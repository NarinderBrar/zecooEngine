#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_CS_DrawRainbow_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
layout(std140, binding = 8) uniform GpuCloudConstants
{
	mat4 transformMatrix;
	vec4 yRange;
	vec3 noiseScale;
	float sourceNoiseScaleKm;
	vec2 extinctions;
	float stepLength;
	float cloudBaseKm;
	uvec3 threadOffset;
	int octaves;
	float time;
	float persistence;
	float humidity;
	float numWorleyOctaves;
	float zPixel;
	int numVolumes;
	float baseLayer;
	float transition;
	float upperDensity;
	float diffusivity;
	float baseMixingRatio;
	float maskThickness;
	vec2 maskCentre;
	float maskRadius;
	float maskFeather;
	vec3 cloudScalesKm;
	float time_step;
	vec3 lightDir;
	float alpha;
	float invBeta;
	int wrap;
	float viscousCoefficient;
	float seaLevelTemperatureK;
	vec3 cloudOriginKm;
	float vorticityConfinement;
	float worleyNoiseStrength;
	float worleyNoiseScale;
	float noisePeriod;
	int numAffectors;
	float localNoiseStrength;
	float localCellNoiseStrength;
	float baseNoiseFactor;
	float max_density_gm3;
	ivec3 gridEdge;
	float edgeSharpness;
	ivec3 idxOffset;
	float cloudLayerThicknessKm;
};


layout(rgba16f, binding = 4) uniform image2DArray outputTexture1;
layout(rgba16f, binding = 5) uniform image2DArray outputTexture3;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t cloudDensity2[24];
	uint64_t rainbowLookup[24];
};
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 75 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_refract_reflect.sl"
float NormalizeLERPPointWithinRange(float x0, float x1, float t)
{
return (t-x0)/(x1-x0);
}
#line 499 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void DrawRainbow(uvec3 p)
{
bool solarLight=true;
vec3 lightDir=normalize(-directionToSun);
const float lowerPrimaryBound=(40.7/180.0*3.1415926536);
const float upperPrimaryBound=(42.4/180.0*3.1415926536);
const float lowerSecondaryBound=(50.4/180.0*3.1415926536);
const float upperSecondaryBound=(53.5/180.0*3.1415926536);
if(lightDir.z>0)
{
lightDir=normalize(-directionToMoon);
solarLight=false;
}

if(lightDir.z>0)return ;
int cubefaceIndex=typed_mod(int(p.z),6);
uvec2 cubefaceSize;
uint arraySize;
ivec3 ivoutputTexture1 = imageSize(outputTexture1);
cubefaceSize.x = ivoutputTexture1.x;cubefaceSize.y = ivoutputTexture1.y;arraySize = ivoutputTexture1.z;;
float ndc_x=2.0*(float(p.x)/float(cubefaceSize.x))-1.0;
float ndc_y=2.0*(float(p.y)/float(cubefaceSize.y))-1.0;
uint negativeFace=typed_mod(uint(cubefaceIndex),2);
vec3 texc=vec3(0.0,0.0,0.0);
vec3 cubefaceDir[6]={vec3(+1.0,0.0,0.0),vec3(-1.0,0.0,0.0),vec3(0.0,+1.0,0.0),vec3(0.0,-1.0,0.0),vec3(0.0,0.0,+1.0),vec3(0.0,0.0,-1.0)};
if(cubefaceIndex==0||cubefaceIndex==1)
{
texc=cubefaceDir[cubefaceIndex]+vec3(0.0,-ndc_y,(negativeFace==1?-1:+1)*-ndc_x);
}

if(cubefaceIndex==2||cubefaceIndex==3)
{
texc=cubefaceDir[cubefaceIndex]+vec3(ndc_x,0.0,(negativeFace==1?-1:+1)*ndc_y);
}

if(cubefaceIndex==4||cubefaceIndex==5)
{
texc=cubefaceDir[cubefaceIndex]+vec3((negativeFace==1?-1:+1)*ndc_x,-ndc_y,0.0);
}

vec3 ntexc=normalize(texc);
float angle=acos(dot(ntexc,lightDir));
if(angle>upperSecondaryBound)return ;
vec4 nearFar=imageLoad(outputTexture3,ivec3(uvec3(p.xy,cubefaceIndex)).xyz);
bool clouds=nearFar.g>0.001;
if(!clouds)return ;
float depth=abs(nearFar.b);
if(depth>rainbowDepthPoint-0.000001)return ;
float moisture=100*abs(nearFar.a);
if(moisture==0.0)return ;
moisture*=(1-depth);
vec3 samplePos=viewPosKm/cloudScalesKm;
float maxRayLength=sqrt(3/2)/2;
int maxNumOfSteps=10;
float totalOcclusion=0.0;
if(allowOccludedRainbows==0)
{
vec3 lightDirTC=vec3(-lightDir.x/2,lightDir.y/2,-lightDir.z/2);
if(lightDirTC.x<0.0)
{
lightDirTC.x+=1.0;
}

if(lightDirTC.y<0.0)
{
lightDirTC.y+=1.0;
}

for(int i=0;i<maxNumOfSteps;i++)
{
totalOcclusion+=(1.0-textureLod(sampler3D(cloudDensity2[1 + 7]),lightDirTC*(i/maxNumOfSteps)+samplePos,0).y);
if(abs(lightDirTC.x)>0.5||abs(lightDirTC.y)>0.5||lightDirTC.z>1.0||length(lightDirTC*(i/maxNumOfSteps))>maxRayLength)break;
if(totalOcclusion>=1.0)return ;
}

}

float rainbow_lookup_tc=NormalizeLERPPointWithinRange(lowerPrimaryBound,upperSecondaryBound,angle);
vec4 rainbowColour=textureLod(sampler2D(rainbowLookup[1 + 9]),vec2(0.5,1.0-rainbow_lookup_tc),0);
float power=rainbowColour.a*(solarLight?5.0:1.0)*moisture;
#line 604 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"

if(power==0.0)power=(solarLight?1.0:0.01)*float(allowLunarRainbows);
#line 609 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"

vec4 current=imageLoad(outputTexture1,ivec3(p).xyz);
if(totalOcclusion<0.2&&textureLod(sampler2D(rainbowLookup[1 + 9]),vec2(0.5,0.9316),0).g>0.0&&angle<(upperPrimaryBound-0.01)&&moisture>0.0)current*=1.1;
vec4 res=vec4(current.r+(1.0-totalOcclusion)*rainbowIntensity*power*rainbowColour.r,current.g+(1.0-totalOcclusion)*rainbowIntensity*power*rainbowColour.g,current.b+(1.0-totalOcclusion)*rainbowIntensity*power*rainbowColour.b,current.a);
imageStore(outputTexture1,ivec3(p),vec4(res));
}
layout(local_size_x=4, local_size_y=4, local_size_z=6) in;
void main()
{
uvec3 p = gl_GlobalInvocationID;
#line 629 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
uvec2 idx=p.xy;
uint Z=typed_mod(p.z,6);
uvec3 pos=uvec3(targetRange[Z].xy+idx*amortizationScale.xy,p.z);
uvec2 offs=uvec2(amortizationOffset.xy);
pos.xy+=offs;
DrawRainbow(pos);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_CS_Edge_NoRain_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 12) uniform CloudStaticConstants
{
	mat4 invViewProj[6];
};
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};

#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
struct RaytracePixelOutput
{
	vec4 colour[2];
	vec4 nearFarDepth;
};













layout(rgba16f, binding = 4) uniform image2DArray outputTexture1;
layout(rgba16f, binding = 5) uniform image2DArray outputTexture3;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t smallWorleyTexture3D[24];
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
	uint64_t noiseTexture3D[24];
	uint64_t godraysTexture[24];
	uint64_t volumeInscatterTexture[24];
	uint64_t skylTexture[24];
	uint64_t inscTexture[24];
	uint64_t lossTexture[24];
	uint64_t depthTexture[24];
	uint64_t illuminationTexture[24];
	uint64_t lightTableTexture[24];
	uint64_t precipitationVolume[24];
	uint64_t updateTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float CalcRayleighBeta(float cos0)
{
return (1.0+cos0*cos0);
}
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float HenyeyGreenstein(float g, float cos0)
{
float g2=g*g;
float u=1.0+g2-2.0*g*cos0;
return (1.0-g2)*pow(u,-1.5)/(4.0*3.1415926536);
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
vec3 PrecalculatedInscatterFunction(vec4 inscatter_factor, float BetaRayleigh, float BetaMie, vec3 mieRayleighRatio)
{
vec3 mr=mieRayleighRatio.xyz;
vec3 BetaTotal=(BetaRayleigh+BetaMie*mr)/(vec3(1.0,1.0,1.0)+mr);
vec3 colour=BetaTotal*inscatter_factor.rgb;
return colour;
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float GetAltTexCoord(float alt_km, float minSunlightAltitudeKm, float fadeAltitudeRangeKm)
{
float diff_km=alt_km-minSunlightAltitudeKm;
float sun_alt_texc=0.5+0.5*saturate(diff_km/fadeAltitudeRangeKm);
sun_alt_texc-=0.5*saturate(-diff_km/(minSunlightAltitudeKm+1.0));
return sun_alt_texc;
}
#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float unshadowedBrightness(float Beta, vec4 lightResponse, vec3 ambientColour)
{
return max(1.0,(Beta+lightResponse.y)+ambientColour.b);
}
#line 34 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColour(uint64_t lossTexture[24], uint64_t inscatterVolumeTexture[24], vec3 volumeTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float Beta, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec3 amb_dir, vec2 fade_texc, out float brightnessFactor, out vec4 inscatter, float fade, float alphaSharpness)
{
float alt_texc=(world_pos.z/fadeAltitudeRangeKm);
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 amb_lookup=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
ambientColour=lightResponse.w*amb_lookup.rgb;
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
vec3 ambient=amb_lookup.rgb*light.w;
vec4 c;
float l=mix(0.75,1.2,density.z);
c.rgb=(light.y*lightResponse.x*(Beta+l)+lightResponse.y*light.x)*combinedLightColour+ambient.rgb;
c.a=density.z*fade;
c.a=saturate(0.3+(1.0+1.0*density.w*alphaSharpness)*(c.a-0.3));

{
vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

inscatter=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),volumeTexCoords,0);
inscatter.rgb*=inscatter.a;
#line 62 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

}

return c;
}
#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColourSimple(uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t lightTableTexture[24], vec4 density, float Beta, float BetaRayleigh, float BetaMie, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, out float brightnessFactor)
{
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
ambientColour=lightResponse.w*textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
vec3 ambient=density.w*ambientColour.rgb;
float opacity=density.z;
vec4 c;
c.rgb=(density.y*Beta+lightResponse.y*density.x)*combinedLightColour+ambient.rgb;
c.a=opacity;
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float earthshadowFactr=saturate((fade_texc.x-nearFarTexc.x)/0.1);
#line 88 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
vec4 insc=textureLod(sampler2D(inscTexture[1 + 5]),fade_texc,0);
vec3 skyl=textureLod(sampler2D(skylTexture[1 + 5]),fade_texc,0).rgb;
vec3 inscatter=earthshadowFactr*PrecalculatedInscatterFunction(insc,BetaRayleigh,BetaMie,mieRayleighRatio);
c.rgb+=inscatter+skyl;
return c;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void calcDensity(uint64_t cloudDensity[24], uint64_t cloudLight[24], vec3 texCoords, vec4 noiseval, vec3 fractalScale, float mip, inout vec4 density, out vec4 light)
{
vec3 pos=texCoords.xyz+fractalScale.xyz*(noiseval.xyz);
density=textureLod(sampler3D(cloudDensity[1 + 7]),pos,mip);
light=textureLod(sampler3D(cloudLight[1 + 7]),texCoords,mip);
}
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 GetPrecipitationAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm, float mip)
{
vec3 rain_texc=cloudWorldOffsetKm;
rain_texc.xy+=rain_texc.z*rainTangent;
rain_texc*=inverseScalesKm;
vec3 pvSize;
ivec3 ivprecipitationVolume = textureSize(sampler3D(precipitationVolume[0]),0);
pvSize.x = ivprecipitationVolume.x;pvSize.y = ivprecipitationVolume.y;pvSize.z = ivprecipitationVolume.z;;
uint z_texel=uint(rain_texc.z*pvSize.z);
rain_texc.z=(float(z_texel)+0.5)/pvSize.z;
return textureLod(sampler3D(precipitationVolume[1 + 7]),rain_texc,mip);
}
#line 120 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float GetRainAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm)
{
vec4 rain_lookup=GetPrecipitationAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm,0.0);
return rain_lookup.x*rain_lookup.w*saturate((20.0*rain_lookup.y-cloudWorldOffsetKm.z)/2.0);
}
#line 146 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void ColourStep(inout vec4 colour[2], inout vec4 insc[2], inout float meanFadeDistance, out float brightness_factor, uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], bool godrays, uint64_t godraysVolumeTexture[24], float godraysScale, vec3 godraysTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float distanceKm, float fadeDistance, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, float cosine, vec3 volumeTexCoords, vec3 amb_dir, float BetaClouds, float BetaRayleigh, float BetaMie, float solidDist_nearFar[2], bool noise, bool do_depth_mix, float distScale, int idx, vec4 noiseval, float fade, float alphaSharpness)
{
density.z*=saturate(distanceKm/0.24);
vec4 clr[2];
vec4 inscatter=vec4(0,0,0,0);
brightness_factor=1.0;
if(noise)clr[2-1]=calcColour(lossTexture,inscatterVolumeTexture,volumeTexCoords,lightTableTexture,density,light,BetaClouds,lightResponse,ambientColour,world_pos,cloudTexCoords,amb_dir,fade_texc,brightness_factor,inscatter,fade,alphaSharpness);else
clr[2-1]=calcColourSimple(lossTexture,inscTexture,skylTexture,lightTableTexture,vec4(light.xyw,density.z),BetaClouds,BetaRayleigh,BetaMie,lightResponse,ambientColour,world_pos,cloudTexCoords,fade_texc,nearFarTexc,brightness_factor);
clr[2-1].a*=cosine*cosine;
meanFadeDistance=mix(min(fadeDistance,meanFadeDistance),meanFadeDistance,(1.0-.4*density.z));
godraysTexCoords.z=distanceKm*godraysScale;
float gr_mult=1.0;
if(godrays)gr_mult=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),godraysTexCoords,0).x;
for(int i=0;i<2;i++)
{
clr[i]=clr[2-1];
if(do_depth_mix)
{
float m=saturate((solidDist_nearFar[i]-fadeDistance)/distScale);
clr[i].a*=m;
}

colour[i].rgb+=(clr[i].rgb)*clr[i].a*(colour[i].a);
insc[i].rgb+=gr_mult*inscatter.rgb*clr[i].a*(colour[i].a);
colour[i].a*=(1.0-clr[i].a);
}

}
#line 239 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColour2(uint64_t lossTexture[24], uint64_t inscatterVolumeTexture[24], vec3 volumeTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float Beta, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec2 fade_texc, out float brightnessFactor, out vec4 inscatter, float opacity, vec3 cloudTintColour)
{
float alt_texc=(world_pos.z/fadeAltitudeRangeKm);
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 amb_lookup=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
ambientColour=lightResponse.w*amb_lookup.rgb;
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
vec3 ambient=amb_lookup.rgb*light.w;
vec4 c;
float l=1;
float combinedLightResponse=(light.y*lightResponse.x*(Beta+l)+lightResponse.y*light.x);
c.rgb=cloudTintColour*(combinedLightResponse*combinedLightColour+ambient.rgb);
c.a=opacity;

{
vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
#line 266 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

inscatter=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),volumeTexCoords,0);
inscatter.rgb*=inscatter.a;
#line 269 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

}

return c;
}
#line 272 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void ColourStep2(inout vec4 colour[2], inout vec4 insc[2], inout float brightness_factor, uint64_t inscatterVolumeTexture[24], uint64_t lossTexture[24], bool godrays, uint64_t godraysVolumeTexture[24], float godraysScale, vec3 godraysTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float distanceKm, float fadeDistance, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec3 volumeTexCoords, float BetaClouds, float solidDist_nearFar[2], bool do_depth_mix, float distScale, uint idx, float opacity, float cosine, vec3 cloudTintColour)
{
vec4 clr[2];
vec4 inscatter=vec4(0,0,0,0);
brightness_factor=1.0;
clr[2-1]=calcColour2(lossTexture,inscatterVolumeTexture,volumeTexCoords,lightTableTexture,density,light,BetaClouds,lightResponse,ambientColour,world_pos,fade_texc,brightness_factor,inscatter,opacity,cloudTintColour);
clr[2-1].a*=cosine*cosine;
godraysTexCoords.z=distanceKm*godraysScale;
float gr_mult=1.0;
if(godrays)gr_mult=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),godraysTexCoords,0).x;
for(int i=0;i<2;i++)
{
clr[i]=clr[2-1];
if(do_depth_mix)
{
float m=saturate((solidDist_nearFar[i]-fadeDistance)/distScale);
clr[i].a*=m;
}

colour[i].rgb+=(clr[i].rgb)*clr[i].a*(colour[i].a);
insc[i].rgb+=gr_mult*inscatter.rgb*clr[i].a*(colour[i].a);
colour[i].a*=(1.0-clr[i].a);
}

}
#line 7 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_raytrace.sl"
RaytracePixelOutput RaytraceCloudsForward(uint64_t cloudDensity[24], uint64_t cloudLight[24], uint64_t precipitationVolume[24], uint64_t noiseTexture3D[24], uint64_t lightTableTexture[24], uint64_t illuminationTexture[24], uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], bool do_depth_mix, vec4 dlookup, vec3 view, vec4 clip_pos, vec3 volumeTexCoordsXyC, bool noise, bool do_rain_effect, bool do_rainbow, vec3 cloudIrRadiance1, vec3 cloudIrRadiance2, int num_interp, bool do_godrays, vec3 cloudTintColour)
{
RaytracePixelOutput res;
vec4 insc[2];
for(int ii=0;ii<num_interp;ii++)
{
res.colour[ii]=vec4(0,0,0,1.0);
insc[ii]=vec4(0,0,0,0);
}

res.nearFarDepth=dlookup;
float s=saturate((directionToSun.z+0.2)/0.01);
vec3 lightDirection=mix(directionToMoon,directionToSun,s);
float cos0=dot(lightDirection.xyz,view.xyz);
float sine=view.z;
float min_z=cornerPosKm.z-(fractalScale.z*1.5)/inverseScalesKm.z;
float max_z=cornerPosKm.z+(1.0+fractalScale.z*1.5)/inverseScalesKm.z;
if(do_rain_effect)min_z=-1.0;else
if(view.z<-0.01&&viewPosKm.z<cornerPosKm.z-fractalScale.z/inverseScalesKm.z)return res;
vec3 godraysTexCoords=vec3(0,0,0);
float lightspaceScale=1.0;
if(do_godrays)
{
vec3 lightspaceView=(mul(worldToScatteringVolumeMatrix,vec4(view,1.0)).xyz);
lightspaceScale=length(lightspaceView);
godraysTexCoords=vec3(fract(atan(lightspaceView.x,lightspaceView.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceView.z/lightspaceScale)*2.0/3.1415926536,0);
}

float solidDist_nearFar[2];
vec2 nfd=(dlookup.yx)+100.0*step(vec2(1.0,1.0),dlookup.yx);
solidDist_nearFar[0]=nfd.x;
solidDist_nearFar[num_interp-1]=nfd.y;
float n=nfd.x;
float f=nfd.y;
for(int l=1;l<num_interp-1;l++)
{
float interp=1.0-float(l)/float(num_interp-1);
solidDist_nearFar[l]=mix(solidDist_nearFar[0],solidDist_nearFar[num_interp-1],1.0-interp);
}

vec2 fade_texc=vec2(0.0,0.5*(1.0-sine));
vec2 illum_texc=vec2(atan(view.x,view.y)/(3.1415926536*2.0),fade_texc.y);
vec4 illum_lookup=texture(sampler2D(illuminationTexture[1 + 3]),illum_texc);
vec2 nearFarTexc=illum_lookup.xy;
float meanFadeDistance=1.0;
float minDistance=1.0;
float maxDistance=0.0;
float BetaClouds=lightResponse.x*HenyeyGreenstein(cloudEccentricity,cos0);
float BetaRayleigh=CalcRayleighBeta(cos0);
float BetaMie=HenyeyGreenstein(hazeEccentricity,cos0);
float moisture=0.0;
vec3 world_pos=viewPosKm;
view.xyz+=vec3(0.00001,0.00001,0.00001);
ivec3 c_offset=ivec3(2.0*step(vec3(0,0,0),view.xyz)-vec3(1,1,1));
ivec3 start_c_offset=-c_offset;
start_c_offset=ivec3(max(start_c_offset.x,0),max(start_c_offset.y,0),max(start_c_offset.z,0));
vec3 viewGridspace=view/scaleOfGridCoordsKm;
viewGridspace=normalize(viewGridspace);
vec3 offset_vec=vec3(0,0,0);

{
float a=1.0/(saturate(view.z)+0.00001);
offset_vec+=max(0.0,min_z-world_pos.z)*vec3(view.x*a,view.y*a,1.0);
}

vec3 halfway=0.5*(lightDirection-view);
world_pos+=offset_vec;
vec3 unitStepKm=viewGridspace*scaleOfGridCoordsKm;
float unitStepLengthKm=length(unitStepKm);
vec3 startOffsetFromOriginKm=viewPosKm-gridOriginPosKm;
vec3 offsetFromOrigin=world_pos-gridOriginPosKm;
vec3 p0=startOffsetFromOriginKm/scaleOfGridCoordsKm;
ivec3 c0=ivec3(floor(p0)+start_c_offset);
vec3 gridScale=scaleOfGridCoordsKm;
vec3 P0=startOffsetFromOriginKm/scaleOfGridCoordsKm/2.0;
ivec3 C0=c0>>1;
float distanceKm=length(offset_vec);
vec3 p_=offsetFromOrigin/scaleOfGridCoordsKm;
ivec3 c=ivec3(floor(p_)+start_c_offset);
int idx=0;
float W=halfClipSize;
const float start=0.866*0.866;
const float ends=1.0;
const float range=ends-start;
float lastFadeDistance=0.0;
ivec2 b=abs(c.xy-C0.xy*2);
vec3 amb_dir=view;
for(int j=0;j<8;j++)
{
if(max(max(b.x,b.y),0)>=W)
{
c0.xy=C0.xy;
c.xy+=start_c_offset.xy;
c.xy-=abs(c.xy&ivec2(1,1));
c.xy=c.xy>>1;
gridScale.xy*=2.0;
if(idx==0)W*=2;
p0.xy=P0.xy;
P0.xy=startOffsetFromOriginKm.xy/gridScale.xy/2.0;
C0.xy+=start_c_offset.xy;
C0.xy-=abs(C0.xy&ivec2(1,1));
C0.xy=C0.xy>>1;
viewGridspace=view/gridScale;
viewGridspace=normalize(viewGridspace);
unitStepKm=viewGridspace*gridScale;
unitStepLengthKm=length(unitStepKm);
idx++;
b=abs(c.xy-C0.xy*2);
}
else
break;
}

float distScale=0.6/maxFadeDistanceKm;
for(int i=0;i<768;i++)
{
world_pos+=0.001*view;
if((view.z<0&&world_pos.z<min_z)||(view.z>0&&world_pos.z>max_z)||distanceKm>maxCloudDistanceKm)break;
offsetFromOrigin=world_pos-gridOriginPosKm;
ivec3 c1=c+c_offset;
vec3 p=offsetFromOrigin/gridScale;
vec3 p1=vec3(c1);
vec3 dp=p1-p;
vec3 D=(dp/viewGridspace);
float e=min(min(D.x,D.y),D.z);
vec3 N=step(D,vec3(e,e,e));
ivec3 c_step=c_offset*ivec3(N);
float stepKm=e*unitStepLengthKm;
distanceKm+=stepKm;
p1=p+e*viewGridspace;
world_pos+=stepKm*view;
vec3 cloudWorldOffsetKm=world_pos-cornerPosKm;
vec3 cloudTexCoords=cloudWorldOffsetKm*inverseScalesKm;
c+=c_step;
ivec2 intermediate=abs(c.xy&ivec2(1,1));
float is_inter=dot(N.xy,vec2(intermediate));
vec3 pw=abs(p1-p0);
float fade_inter=saturate((length(pw.xy)/(float(W)*(3.0-2.0*is_inter)-1.0)-start)/range);
float fade=(1.0-fade_inter);
float fadeDistance=saturate(distanceKm/maxFadeDistanceKm);
maxDistance=max(fadeDistance,maxDistance);
b=abs(c.xy-C0.xy*2);
#line 227 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_raytrace.sl"

if(fade>0.0)
{
float mip=0.0;
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),cloudTexCoords,0.0);

{
vec3 noise_texc=world_pos.xyz*noise3DTexcoordScale+noise3DTexcoordOffset;
vec4 noiseval=vec4(0,0,0,0);
float cosine=dot(N,abs(view));
if(noise)noiseval=density.x*textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc,1.0*(fadeDistance+1.0-abs(cosine)));
vec4 light=vec4(1,1,1,1);
calcDensity(cloudDensity,cloudLight,cloudTexCoords,noiseval,fractalScale,mip,density,light);
if(do_rain_effect)
{
float dm=rainEffect*fade*GetRainAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm);
dm*=saturate(0.6+textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc+vec3(0,0,rainVerticalTexcoord),0.0).z);
moisture+=0.01*dm*light.x;
density.z=max(density.z,dm);
}

if(density.z>0)
{
density.z=saturate(0.3+(1.0+5.0*density.y)*(density.z-0.3));
minDistance=min(max(0,fadeDistance-density.z*stepKm/maxFadeDistanceKm),minDistance);
vec3 worley_texc=(world_pos.xyz+windOffsetKm.xyz)*worleyTexcoordScale+worleyOffsetKm;
vec4 worley=textureLod(sampler3D(smallWorleyTexture3D[1 + 6]),worley_texc,0);
float wo=4*density.y*(worley.w-0.6)*saturate(1.0/(12.0*fadeDistance));
density.z=mix(density.z,density.z*saturate(0.3+((density.z+wo)-0.3-saturate(0.6-density.z))),density.y);
amb_dir=mix(amb_dir,worley.xyz,0.1*density.z);
float brightness_factor;
fade_texc.x=sqrt(fadeDistance);
vec3 volumeTexCoords=vec3(volumeTexCoordsXyC.xy,fade_texc.x);
ColourStep(res.colour,insc,meanFadeDistance,brightness_factor,lossTexture,inscTexture,skylTexture,inscatterVolumeTexture,do_godrays,godraysVolumeTexture,lightspaceScale,godraysTexCoords,lightTableTexture,density,light,distanceKm,fadeDistance,world_pos,cloudTexCoords,fade_texc,nearFarTexc,cosine,volumeTexCoords,amb_dir,BetaClouds,BetaRayleigh,BetaMie,solidDist_nearFar,noise,do_depth_mix,distScale,idx,noiseval,fade,alphaSharpness);
if(res.colour[0].a*brightness_factor<0.003)
{
for(int o=0;o<num_interp;o++)res.colour[o].a=0.0;
meanFadeDistance=fadeDistance;
break;
}

}

lastFadeDistance=mix(lastFadeDistance,fadeDistance-density.z*stepKm/maxFadeDistanceKm,res.colour[num_interp-1].a);
}

}

if(max(max(b.x,b.y),0)>=W)
{
c0.xy=C0.xy;
c.xy+=start_c_offset.xy;
c.xy-=abs(c.xy&ivec2(1,1));
c.xy=c.xy>>1;
gridScale.xy*=2.0;
if(idx==0)W*=2;
p0.xy=P0.xy;
P0.xy=startOffsetFromOriginKm.xy/gridScale.xy/2.0;
C0.xy+=start_c_offset.xy;
C0.xy-=abs(C0.xy&ivec2(1,1));
C0.xy=C0.xy>>1;
viewGridspace=view/gridScale;
viewGridspace=normalize(viewGridspace);
unitStepKm=viewGridspace*gridScale;
unitStepLengthKm=length(unitStepKm);
idx++;
}

}

res.nearFarDepth.zw=vec2(meanFadeDistance,moisture);
for(int k=0;k<num_interp;k++)
{
res.colour[k].rgb+=insc[k].rgb;
}

return res;
}
#line 79 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
vec3 WorldToVolumePos(vec3 world_pos_km, vec3 centreVolumePos, vec3 vol_km)
{
vec3 vp=world_pos_km/vol_km;
return vp+centreVolumePos;
}
#line 96 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
vec3 GridToWorldPos(vec3 grid_pos, vec3 grid_km, vec3 centreVolumePosKm)
{
vec3 wp=grid_pos*grid_km-centreVolumePosKm;
return wp;
}
#line 114 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
ivec3 FloatToIntGrid(vec3 grid_pos)
{
return ivec3(floor(grid_pos));
}
#line 127 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
vec3 WorldToGridPos(vec3 world_pos_km, vec3 gridKm, vec3 centreGridPos)
{
return world_pos_km/gridKm+centreGridPos;
}
#line 132 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
RaytracePixelOutput RaytraceCloudsExperimental(uint64_t cloudDensity[24], uint64_t cloudLight[24], uint64_t precipitationVolume[24], uint64_t noiseTexture3D[24], uint64_t lightTableTexture[24], uint64_t illuminationTexture[24], uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], bool do_depth_mix, vec4 dlookup, vec3 view, vec4 clip_pos, vec3 volumeTexCoordsXyC, bool noise, bool do_rain_effect, bool do_rainbow, vec3 cloudIrRadiance1, vec3 cloudIrRadiance2, int num_interp, bool do_godrays, vec3 cloudTintColour, uint seed)
{
RaytracePixelOutput res;
vec4 insc[2];
for(int ii=0;ii<num_interp;ii++)
{
res.colour[ii]=vec4(0,0,0,1.0);
insc[ii]=vec4(0,0,0,0);
}

res.nearFarDepth=dlookup;
float s=saturate((directionToSun.z+0.2)/0.01);
vec3 lightDirection=mix(directionToMoon,directionToSun,s);
float cos0=dot(lightDirection.xyz,view.xyz);
float min_z=cornerPosKm.z-(fractalScale.z*1.5)/inverseScalesKm.z;
float max_z=cornerPosKm.z+(1.0+fractalScale.z*1.5)/inverseScalesKm.z;
if(do_rain_effect)min_z=-1.0;
vec3 godraysTexCoords=vec3(0,0,0);
float lightspaceScale=1.0;
if(do_godrays)
{
vec3 lightspaceView=(mul(worldToScatteringVolumeMatrix,vec4(view,1.0)).xyz);
lightspaceScale=length(lightspaceView);
godraysTexCoords=vec3(fract(atan(lightspaceView.x,lightspaceView.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceView.z/lightspaceScale)*2.0/3.1415926536,0);
}

float solidDist_nearFar[2];
vec2 nfd=(dlookup.yx)+100.0*step(vec2(1.0,1.0),dlookup.yx);
solidDist_nearFar[0]=nfd.x;
solidDist_nearFar[num_interp-1]=nfd.y;
for(int l=1;l<num_interp-1;l++)
{
float interp=1.0-float(l)/float(num_interp-1);
solidDist_nearFar[l]=mix(solidDist_nearFar[0],solidDist_nearFar[num_interp-1],1.0-interp);
}

float sine=view.z;
vec2 fade_texc=vec2(0.0,0.5*(1.0-sine));
vec2 illum_texc=vec2(atan(view.x,view.y)/(3.1415926536*2.0),fade_texc.y);
vec4 illum_lookup=texture(sampler2D(illuminationTexture[1 + 3]),illum_texc);
vec2 nearFarTexc=illum_lookup.xy;
float meanFadeDistance=1.0;
float BetaClouds=HenyeyGreenstein(cloudEccentricity,cos0);
float BetaRayleigh=CalcRayleighBeta(cos0);
float BetaMie=HenyeyGreenstein(hazeEccentricity,cos0);
float moisture=0.0;
vec3 world_pos_km=viewPosKm;
world_pos_km.xy-=windOffsetKm.xy;
uint mip=uint(maxMip);
uint mipscale=uint(1)<<mip;
uvec3 mip_grid=uvec3(windowGrid)/mipscale;
vec3 windowGridf=vec3(mip_grid);
vec3 centreVolumePos=vec3((typed_mod((gridCentreTexel.xy+ivec2(windowGrid.xy/2)),ivec2(windowGrid.xy))-ivec2(windowGrid.xy/2))/float(windowGrid.x),0);
vec3 gridKm=VolumeScaleKm/windowGridf;
vec3 centreVolumePosKm=VolumeScaleKm*centreVolumePos;
vec3 centreGridPos=windowGridf*centreVolumePos;
vec3 grid_pos=WorldToGridPos(world_pos_km,gridKm,centreGridPos);
vec3 grid_dir=normalize(WorldToGridPos(world_pos_km+view,gridKm,centreGridPos)-grid_pos);
ivec3 c_offset=ivec3(2.0*step(vec3(0,0,0),view.xyz)-vec3(1,1,1));
ivec3 c_next=FloatToIntGrid(grid_pos);
uint idx=0;
int count_detail=0;
vec3 amb_dir=view;
float distScale=0.6/maxFadeDistanceKm;
int i=0;
uint use_mip=0;
int steps_at_mip=0;
vec3 last_grid_pos=grid_pos;
ivec3 c_offset_x=ivec3(step(vec3(0,0,0),grid_dir.xyz));
c_offset=2*c_offset_x-ivec3(1,1,1);
float distanceLimitKm=0.f;
for(i=0;i<768;i++)
{
if((view.z<0&&world_pos_km.z<min_z)||(view.z>0&&world_pos_km.z>max_z)||distanceLimitKm>maxCloudDistanceKm)break;
vec3 prev_world_pos_km=world_pos_km;
ivec3 c=c_next;
if(mip>use_mip)
{
vec4 lookup=vec4(0,0,0,0);
ivec4 lookup_index=ivec4(typed_mod((c.xy+mip_grid.xy),mip_grid.xy),c.z,mip);
if(c.z<mip_grid.z&&c.z>=0)lookup=texelFetch(sampler3D(cloudDensity[0]),ivec3(lookup_index).xyz,int(lookup_index.w));
if(do_rain_effect)lookup.z+=rainEffect*GetPrecipitationAtOffsetKm(precipitationVolume,(world_pos_km-cornerPosKm),inverseScalesKm,float(mip)).w;
if(lookup.z!=0)
{
mip--;
mipscale=uint(1)<<mip;
mip_grid=ivec3(windowGrid)/mipscale;
windowGridf=vec3(mip_grid);
gridKm=VolumeScaleKm/windowGridf;
centreVolumePosKm=VolumeScaleKm*centreVolumePos;
centreGridPos=windowGridf*centreVolumePos;
grid_pos=WorldToGridPos(world_pos_km,gridKm,centreGridPos);
c_next=FloatToIntGrid(grid_pos);
continue;
}

ivec3 c1=c+c_offset_x;
vec3 grid_pos_1=c1;
vec3 dp=grid_pos_1-grid_pos;
vec3 D=dp/grid_dir;
float e=min(min(D.x,D.y),D.z);
vec3 N=step(D,vec3(e,e,e));
ivec3 c_step=c_offset*ivec3(N);
grid_pos+=e*grid_dir;
c_next=c+c_step;
world_pos_km=GridToWorldPos(grid_pos,gridKm,centreVolumePosKm);
vec3 step_km=world_pos_km-prev_world_pos_km;
float stepKm=length(step_km);
distanceLimitKm=length(world_pos_km-viewPosKm);
continue;
}

ivec3 c1=c+c_offset_x;
vec3 grid_pos_1=c1;
vec3 dp=grid_pos_1-grid_pos;
vec3 D=dp/grid_dir;
float e=min(min(D.x,D.y),D.z);
vec3 N=step(D,vec3(e,e,e));
ivec3 c_step=c_offset*ivec3(N);
grid_pos+=e*grid_dir;
c_next=c+c_step;
world_pos_km=GridToWorldPos(grid_pos,gridKm,centreVolumePosKm);
vec3 step_km=world_pos_km-prev_world_pos_km;
float stepKm=length(step_km);
idx=uint(mip);
vec3 sample_pos_km=world_pos_km;
vec3 cloud_tex_coords=WorldToVolumePos(sample_pos_km,centreVolumePos,VolumeScaleKm);

{
vec4 light=textureLod(sampler3D(cloudLight[1 + 7]),cloud_tex_coords,0);
vec3 noise_texc=(sample_pos_km.xyz+windOffsetKm.xyz)*noise3DTexcoordScale+noise3DTexcoordOffset;
vec4 noiseval=vec4(0,0,0,0);
if(noise)
{
vec4 noiseval1=textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc,0.0);
noiseval=light.z*noiseval1;
}

vec3 noise_adjusted_texc=cloud_tex_coords.xyz+fractalScale.xyz*(noiseval.xyz);
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),noise_adjusted_texc,use_mip);
if(do_rain_effect)
{
float dm=rainEffect*GetRainAtOffsetKm(precipitationVolume,(sample_pos_km-cornerPosKm)+((fractalScale.xyz*noiseval.xyz)/inverseScalesKm),inverseScalesKm);
dm*=saturate(0.6+textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc+vec3(0,0,rainVerticalTexcoord),0.0).z);
moisture+=0.01*dm*light.x;
density.z=max(density.z,dm);
}

if(density.z>0)
{
float distanceKm=length(world_pos_km-viewPosKm);
float fadeDistance=saturate(distanceKm/maxFadeDistanceKm);
density.z*=saturate(distanceKm/0.24);
density.z=mix(1.0/(1.0+exp(-20.0*(density.z-0.3))),density.z,density.y);
vec3 worley_texc=(sample_pos_km.xyz+windOffsetKm.xyz)*worleyTexcoordScale+worleyOffsetKm;
vec4 worley=textureLod(sampler3D(smallWorleyTexture3D[1 + 6]),worley_texc,0);
float wo=4*light.w*mix(1.0,worley.w,saturate(1.0/(12.0*fadeDistance)));
density.z=mix(density.z,density.z*saturate(0.3+((density.z+wo)-0.3-saturate(0.6-density.z))),density.y);
float brightness_factor;
fade_texc.x=sqrt(fadeDistance);
vec3 volumeTexCoords=vec3(volumeTexCoordsXyC.xy,fade_texc.x);
float opacity=density.z;
opacity=saturate(0.3+(1.0+1.0*density.w*alphaSharpness)*(opacity-0.3));
float cosine=dot(N,abs(view));
ColourStep2(res.colour,insc,brightness_factor,inscatterVolumeTexture,lossTexture,do_godrays,godraysVolumeTexture,lightspaceScale,godraysTexCoords,lightTableTexture,density,light,distanceKm,fadeDistance,world_pos_km,cloud_tex_coords,fade_texc,volumeTexCoords,BetaClouds,solidDist_nearFar,do_depth_mix,distScale,idx,opacity,cosine,cloudTintColour);
meanFadeDistance=mix(min(fadeDistance,meanFadeDistance),meanFadeDistance,(1.0-.4*density.z));
if(res.colour[0].a*brightness_factor<0.03)
{
for(int o=0;o<num_interp;o++)
{
res.colour[o].a=0.0;
}

meanFadeDistance=fadeDistance;
break;
}

continue;
}

count_detail++;
if(count_detail>2)
{
mip=maxMip;
mipscale=int(1)<<mip;
mip_grid=ivec3(windowGrid)/mipscale;
windowGridf=vec3(mip_grid);
gridKm=VolumeScaleKm/windowGridf;
centreGridPos=windowGridf*centreVolumePos;
grid_pos=WorldToGridPos(world_pos_km,gridKm,centreGridPos);
c_next=FloatToIntGrid(grid_pos);
count_detail=0;
}

}

}

res.nearFarDepth.zw=vec2(meanFadeDistance,moisture);
float grey=float(1)/100.0;
for(int k=0;k<num_interp;k++)
{
res.colour[k].rgb+=insc[k].rgb;
}

return res;
}
#line 769 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void Raytrace(uvec3 pos, bool include_rain, bool depth, int num_interp, bool do_godrays, bool experimental, bool blend)
{
vec2 texCoords=(vec2(pos.xy)+vec2(0.5,0.5))/vec2(targetTextureSize);
vec4 clip_pos=vec4(-1.0,1.0,1.0,1.0);
clip_pos.x+=2.0*texCoords.x;
clip_pos.y-=2.0*texCoords.y;
vec3 view=normalize(mul(invViewProj[pos.z],clip_pos).xyz);
vec4 dlookup=vec4(1.0,1.0,0.000001,1.0);
if(depth)
{
dlookup=textureLod(samplerCube(depthTexture[1 + 6]),view,0);
}

uint seed=0;
vec3 worldspaceVolumeTexCoordsXyC=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(view.z)/3.1415926536),0);
RaytracePixelOutput f;
if(experimental)f=RaytraceCloudsExperimental(cloudDensity,cloudDensity2,precipitationVolume,noiseTexture3D,lightTableTexture,illuminationTexture,lossTexture,inscTexture,skylTexture,volumeInscatterTexture,godraysTexture,true,dlookup,view,clip_pos,worldspaceVolumeTexCoordsXyC,true,include_rain,false,cloudIrRadiance1,cloudIrRadiance2,num_interp,do_godrays,cloudTintColour,seed);else
f=RaytraceCloudsForward(cloudDensity,cloudDensity2,precipitationVolume,noiseTexture3D,lightTableTexture,illuminationTexture,lossTexture,inscTexture,skylTexture,volumeInscatterTexture,godraysTexture,true,dlookup,view,clip_pos,worldspaceVolumeTexCoordsXyC,true,include_rain,false,cloudIrRadiance1,cloudIrRadiance2,num_interp,do_godrays,cloudTintColour);
vec4 resn=f.colour[2-1];
if(blend)
{

}

imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*(2-1))),vec4(resn));
float n=float(dlookup.y>=1.0);
for(int u=0;u<2-1;u++)
{
vec4 res=f.colour[u];
if(blend)
{

}

imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*u)),vec4(res));
}

imageStore(outputTexture3,ivec3(pos),vec4(f.nearFarDepth));
#line 860 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"

}
#line 1046 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void Edge(uvec3 g, uvec3 t, bool rain, bool depth, bool godrays, bool experimental)
{
uvec2 idx=uvec2(g.xy*4+t.xy);
uint Z=cubemapFaceIndex[g.z+t.z].x;
uvec3 pos=uvec3(targetRange[Z].xy+idx,Z);
if(pos.x>=targetRange[Z].z||pos.y>=targetRange[Z].w)return ;
vec4 u=texelFetch(sampler2DArray(updateTexture[0]),ivec3(pos).xyz,0);
if(u.g<1.0&&u.b>0.0)
{
Raytrace(pos,rain,depth,2,godrays,experimental,false);
}

}
layout(local_size_x=4, local_size_y=4, local_size_z=1) in;
void main()
{
uvec3 g = gl_WorkGroupID;
uvec3 t = gl_LocalInvocationID;
#line 1063 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
Edge(g,t,false,true,true,false);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_CS_Edge_Rain_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 12) uniform CloudStaticConstants
{
	mat4 invViewProj[6];
};
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};

#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
struct RaytracePixelOutput
{
	vec4 colour[2];
	vec4 nearFarDepth;
};













layout(rgba16f, binding = 4) uniform image2DArray outputTexture1;
layout(rgba16f, binding = 5) uniform image2DArray outputTexture3;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t smallWorleyTexture3D[24];
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
	uint64_t noiseTexture3D[24];
	uint64_t godraysTexture[24];
	uint64_t volumeInscatterTexture[24];
	uint64_t skylTexture[24];
	uint64_t inscTexture[24];
	uint64_t lossTexture[24];
	uint64_t depthTexture[24];
	uint64_t illuminationTexture[24];
	uint64_t lightTableTexture[24];
	uint64_t precipitationVolume[24];
	uint64_t updateTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float CalcRayleighBeta(float cos0)
{
return (1.0+cos0*cos0);
}
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float HenyeyGreenstein(float g, float cos0)
{
float g2=g*g;
float u=1.0+g2-2.0*g*cos0;
return (1.0-g2)*pow(u,-1.5)/(4.0*3.1415926536);
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
vec3 PrecalculatedInscatterFunction(vec4 inscatter_factor, float BetaRayleigh, float BetaMie, vec3 mieRayleighRatio)
{
vec3 mr=mieRayleighRatio.xyz;
vec3 BetaTotal=(BetaRayleigh+BetaMie*mr)/(vec3(1.0,1.0,1.0)+mr);
vec3 colour=BetaTotal*inscatter_factor.rgb;
return colour;
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float GetAltTexCoord(float alt_km, float minSunlightAltitudeKm, float fadeAltitudeRangeKm)
{
float diff_km=alt_km-minSunlightAltitudeKm;
float sun_alt_texc=0.5+0.5*saturate(diff_km/fadeAltitudeRangeKm);
sun_alt_texc-=0.5*saturate(-diff_km/(minSunlightAltitudeKm+1.0));
return sun_alt_texc;
}
#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float unshadowedBrightness(float Beta, vec4 lightResponse, vec3 ambientColour)
{
return max(1.0,(Beta+lightResponse.y)+ambientColour.b);
}
#line 34 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColour(uint64_t lossTexture[24], uint64_t inscatterVolumeTexture[24], vec3 volumeTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float Beta, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec3 amb_dir, vec2 fade_texc, out float brightnessFactor, out vec4 inscatter, float fade, float alphaSharpness)
{
float alt_texc=(world_pos.z/fadeAltitudeRangeKm);
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 amb_lookup=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
ambientColour=lightResponse.w*amb_lookup.rgb;
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
vec3 ambient=amb_lookup.rgb*light.w;
vec4 c;
float l=mix(0.75,1.2,density.z);
c.rgb=(light.y*lightResponse.x*(Beta+l)+lightResponse.y*light.x)*combinedLightColour+ambient.rgb;
c.a=density.z*fade;
c.a=saturate(0.3+(1.0+1.0*density.w*alphaSharpness)*(c.a-0.3));

{
vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

inscatter=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),volumeTexCoords,0);
inscatter.rgb*=inscatter.a;
#line 62 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

}

return c;
}
#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColourSimple(uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t lightTableTexture[24], vec4 density, float Beta, float BetaRayleigh, float BetaMie, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, out float brightnessFactor)
{
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
ambientColour=lightResponse.w*textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
vec3 ambient=density.w*ambientColour.rgb;
float opacity=density.z;
vec4 c;
c.rgb=(density.y*Beta+lightResponse.y*density.x)*combinedLightColour+ambient.rgb;
c.a=opacity;
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float earthshadowFactr=saturate((fade_texc.x-nearFarTexc.x)/0.1);
#line 88 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
vec4 insc=textureLod(sampler2D(inscTexture[1 + 5]),fade_texc,0);
vec3 skyl=textureLod(sampler2D(skylTexture[1 + 5]),fade_texc,0).rgb;
vec3 inscatter=earthshadowFactr*PrecalculatedInscatterFunction(insc,BetaRayleigh,BetaMie,mieRayleighRatio);
c.rgb+=inscatter+skyl;
return c;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void calcDensity(uint64_t cloudDensity[24], uint64_t cloudLight[24], vec3 texCoords, vec4 noiseval, vec3 fractalScale, float mip, inout vec4 density, out vec4 light)
{
vec3 pos=texCoords.xyz+fractalScale.xyz*(noiseval.xyz);
density=textureLod(sampler3D(cloudDensity[1 + 7]),pos,mip);
light=textureLod(sampler3D(cloudLight[1 + 7]),texCoords,mip);
}
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 GetPrecipitationAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm, float mip)
{
vec3 rain_texc=cloudWorldOffsetKm;
rain_texc.xy+=rain_texc.z*rainTangent;
rain_texc*=inverseScalesKm;
vec3 pvSize;
ivec3 ivprecipitationVolume = textureSize(sampler3D(precipitationVolume[0]),0);
pvSize.x = ivprecipitationVolume.x;pvSize.y = ivprecipitationVolume.y;pvSize.z = ivprecipitationVolume.z;;
uint z_texel=uint(rain_texc.z*pvSize.z);
rain_texc.z=(float(z_texel)+0.5)/pvSize.z;
return textureLod(sampler3D(precipitationVolume[1 + 7]),rain_texc,mip);
}
#line 120 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float GetRainAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm)
{
vec4 rain_lookup=GetPrecipitationAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm,0.0);
return rain_lookup.x*rain_lookup.w*saturate((20.0*rain_lookup.y-cloudWorldOffsetKm.z)/2.0);
}
#line 146 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void ColourStep(inout vec4 colour[2], inout vec4 insc[2], inout float meanFadeDistance, out float brightness_factor, uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], bool godrays, uint64_t godraysVolumeTexture[24], float godraysScale, vec3 godraysTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float distanceKm, float fadeDistance, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, float cosine, vec3 volumeTexCoords, vec3 amb_dir, float BetaClouds, float BetaRayleigh, float BetaMie, float solidDist_nearFar[2], bool noise, bool do_depth_mix, float distScale, int idx, vec4 noiseval, float fade, float alphaSharpness)
{
density.z*=saturate(distanceKm/0.24);
vec4 clr[2];
vec4 inscatter=vec4(0,0,0,0);
brightness_factor=1.0;
if(noise)clr[2-1]=calcColour(lossTexture,inscatterVolumeTexture,volumeTexCoords,lightTableTexture,density,light,BetaClouds,lightResponse,ambientColour,world_pos,cloudTexCoords,amb_dir,fade_texc,brightness_factor,inscatter,fade,alphaSharpness);else
clr[2-1]=calcColourSimple(lossTexture,inscTexture,skylTexture,lightTableTexture,vec4(light.xyw,density.z),BetaClouds,BetaRayleigh,BetaMie,lightResponse,ambientColour,world_pos,cloudTexCoords,fade_texc,nearFarTexc,brightness_factor);
clr[2-1].a*=cosine*cosine;
meanFadeDistance=mix(min(fadeDistance,meanFadeDistance),meanFadeDistance,(1.0-.4*density.z));
godraysTexCoords.z=distanceKm*godraysScale;
float gr_mult=1.0;
if(godrays)gr_mult=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),godraysTexCoords,0).x;
for(int i=0;i<2;i++)
{
clr[i]=clr[2-1];
if(do_depth_mix)
{
float m=saturate((solidDist_nearFar[i]-fadeDistance)/distScale);
clr[i].a*=m;
}

colour[i].rgb+=(clr[i].rgb)*clr[i].a*(colour[i].a);
insc[i].rgb+=gr_mult*inscatter.rgb*clr[i].a*(colour[i].a);
colour[i].a*=(1.0-clr[i].a);
}

}
#line 239 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColour2(uint64_t lossTexture[24], uint64_t inscatterVolumeTexture[24], vec3 volumeTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float Beta, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec2 fade_texc, out float brightnessFactor, out vec4 inscatter, float opacity, vec3 cloudTintColour)
{
float alt_texc=(world_pos.z/fadeAltitudeRangeKm);
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 amb_lookup=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
ambientColour=lightResponse.w*amb_lookup.rgb;
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
vec3 ambient=amb_lookup.rgb*light.w;
vec4 c;
float l=1;
float combinedLightResponse=(light.y*lightResponse.x*(Beta+l)+lightResponse.y*light.x);
c.rgb=cloudTintColour*(combinedLightResponse*combinedLightColour+ambient.rgb);
c.a=opacity;

{
vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
#line 266 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

inscatter=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),volumeTexCoords,0);
inscatter.rgb*=inscatter.a;
#line 269 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

}

return c;
}
#line 272 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void ColourStep2(inout vec4 colour[2], inout vec4 insc[2], inout float brightness_factor, uint64_t inscatterVolumeTexture[24], uint64_t lossTexture[24], bool godrays, uint64_t godraysVolumeTexture[24], float godraysScale, vec3 godraysTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float distanceKm, float fadeDistance, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec3 volumeTexCoords, float BetaClouds, float solidDist_nearFar[2], bool do_depth_mix, float distScale, uint idx, float opacity, float cosine, vec3 cloudTintColour)
{
vec4 clr[2];
vec4 inscatter=vec4(0,0,0,0);
brightness_factor=1.0;
clr[2-1]=calcColour2(lossTexture,inscatterVolumeTexture,volumeTexCoords,lightTableTexture,density,light,BetaClouds,lightResponse,ambientColour,world_pos,fade_texc,brightness_factor,inscatter,opacity,cloudTintColour);
clr[2-1].a*=cosine*cosine;
godraysTexCoords.z=distanceKm*godraysScale;
float gr_mult=1.0;
if(godrays)gr_mult=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),godraysTexCoords,0).x;
for(int i=0;i<2;i++)
{
clr[i]=clr[2-1];
if(do_depth_mix)
{
float m=saturate((solidDist_nearFar[i]-fadeDistance)/distScale);
clr[i].a*=m;
}

colour[i].rgb+=(clr[i].rgb)*clr[i].a*(colour[i].a);
insc[i].rgb+=gr_mult*inscatter.rgb*clr[i].a*(colour[i].a);
colour[i].a*=(1.0-clr[i].a);
}

}
#line 7 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_raytrace.sl"
RaytracePixelOutput RaytraceCloudsForward(uint64_t cloudDensity[24], uint64_t cloudLight[24], uint64_t precipitationVolume[24], uint64_t noiseTexture3D[24], uint64_t lightTableTexture[24], uint64_t illuminationTexture[24], uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], bool do_depth_mix, vec4 dlookup, vec3 view, vec4 clip_pos, vec3 volumeTexCoordsXyC, bool noise, bool do_rain_effect, bool do_rainbow, vec3 cloudIrRadiance1, vec3 cloudIrRadiance2, int num_interp, bool do_godrays, vec3 cloudTintColour)
{
RaytracePixelOutput res;
vec4 insc[2];
for(int ii=0;ii<num_interp;ii++)
{
res.colour[ii]=vec4(0,0,0,1.0);
insc[ii]=vec4(0,0,0,0);
}

res.nearFarDepth=dlookup;
float s=saturate((directionToSun.z+0.2)/0.01);
vec3 lightDirection=mix(directionToMoon,directionToSun,s);
float cos0=dot(lightDirection.xyz,view.xyz);
float sine=view.z;
float min_z=cornerPosKm.z-(fractalScale.z*1.5)/inverseScalesKm.z;
float max_z=cornerPosKm.z+(1.0+fractalScale.z*1.5)/inverseScalesKm.z;
if(do_rain_effect)min_z=-1.0;else
if(view.z<-0.01&&viewPosKm.z<cornerPosKm.z-fractalScale.z/inverseScalesKm.z)return res;
vec3 godraysTexCoords=vec3(0,0,0);
float lightspaceScale=1.0;
if(do_godrays)
{
vec3 lightspaceView=(mul(worldToScatteringVolumeMatrix,vec4(view,1.0)).xyz);
lightspaceScale=length(lightspaceView);
godraysTexCoords=vec3(fract(atan(lightspaceView.x,lightspaceView.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceView.z/lightspaceScale)*2.0/3.1415926536,0);
}

float solidDist_nearFar[2];
vec2 nfd=(dlookup.yx)+100.0*step(vec2(1.0,1.0),dlookup.yx);
solidDist_nearFar[0]=nfd.x;
solidDist_nearFar[num_interp-1]=nfd.y;
float n=nfd.x;
float f=nfd.y;
for(int l=1;l<num_interp-1;l++)
{
float interp=1.0-float(l)/float(num_interp-1);
solidDist_nearFar[l]=mix(solidDist_nearFar[0],solidDist_nearFar[num_interp-1],1.0-interp);
}

vec2 fade_texc=vec2(0.0,0.5*(1.0-sine));
vec2 illum_texc=vec2(atan(view.x,view.y)/(3.1415926536*2.0),fade_texc.y);
vec4 illum_lookup=texture(sampler2D(illuminationTexture[1 + 3]),illum_texc);
vec2 nearFarTexc=illum_lookup.xy;
float meanFadeDistance=1.0;
float minDistance=1.0;
float maxDistance=0.0;
float BetaClouds=lightResponse.x*HenyeyGreenstein(cloudEccentricity,cos0);
float BetaRayleigh=CalcRayleighBeta(cos0);
float BetaMie=HenyeyGreenstein(hazeEccentricity,cos0);
float moisture=0.0;
vec3 world_pos=viewPosKm;
view.xyz+=vec3(0.00001,0.00001,0.00001);
ivec3 c_offset=ivec3(2.0*step(vec3(0,0,0),view.xyz)-vec3(1,1,1));
ivec3 start_c_offset=-c_offset;
start_c_offset=ivec3(max(start_c_offset.x,0),max(start_c_offset.y,0),max(start_c_offset.z,0));
vec3 viewGridspace=view/scaleOfGridCoordsKm;
viewGridspace=normalize(viewGridspace);
vec3 offset_vec=vec3(0,0,0);

{
float a=1.0/(saturate(view.z)+0.00001);
offset_vec+=max(0.0,min_z-world_pos.z)*vec3(view.x*a,view.y*a,1.0);
}

vec3 halfway=0.5*(lightDirection-view);
world_pos+=offset_vec;
vec3 unitStepKm=viewGridspace*scaleOfGridCoordsKm;
float unitStepLengthKm=length(unitStepKm);
vec3 startOffsetFromOriginKm=viewPosKm-gridOriginPosKm;
vec3 offsetFromOrigin=world_pos-gridOriginPosKm;
vec3 p0=startOffsetFromOriginKm/scaleOfGridCoordsKm;
ivec3 c0=ivec3(floor(p0)+start_c_offset);
vec3 gridScale=scaleOfGridCoordsKm;
vec3 P0=startOffsetFromOriginKm/scaleOfGridCoordsKm/2.0;
ivec3 C0=c0>>1;
float distanceKm=length(offset_vec);
vec3 p_=offsetFromOrigin/scaleOfGridCoordsKm;
ivec3 c=ivec3(floor(p_)+start_c_offset);
int idx=0;
float W=halfClipSize;
const float start=0.866*0.866;
const float ends=1.0;
const float range=ends-start;
float lastFadeDistance=0.0;
ivec2 b=abs(c.xy-C0.xy*2);
vec3 amb_dir=view;
for(int j=0;j<8;j++)
{
if(max(max(b.x,b.y),0)>=W)
{
c0.xy=C0.xy;
c.xy+=start_c_offset.xy;
c.xy-=abs(c.xy&ivec2(1,1));
c.xy=c.xy>>1;
gridScale.xy*=2.0;
if(idx==0)W*=2;
p0.xy=P0.xy;
P0.xy=startOffsetFromOriginKm.xy/gridScale.xy/2.0;
C0.xy+=start_c_offset.xy;
C0.xy-=abs(C0.xy&ivec2(1,1));
C0.xy=C0.xy>>1;
viewGridspace=view/gridScale;
viewGridspace=normalize(viewGridspace);
unitStepKm=viewGridspace*gridScale;
unitStepLengthKm=length(unitStepKm);
idx++;
b=abs(c.xy-C0.xy*2);
}
else
break;
}

float distScale=0.6/maxFadeDistanceKm;
for(int i=0;i<768;i++)
{
world_pos+=0.001*view;
if((view.z<0&&world_pos.z<min_z)||(view.z>0&&world_pos.z>max_z)||distanceKm>maxCloudDistanceKm)break;
offsetFromOrigin=world_pos-gridOriginPosKm;
ivec3 c1=c+c_offset;
vec3 p=offsetFromOrigin/gridScale;
vec3 p1=vec3(c1);
vec3 dp=p1-p;
vec3 D=(dp/viewGridspace);
float e=min(min(D.x,D.y),D.z);
vec3 N=step(D,vec3(e,e,e));
ivec3 c_step=c_offset*ivec3(N);
float stepKm=e*unitStepLengthKm;
distanceKm+=stepKm;
p1=p+e*viewGridspace;
world_pos+=stepKm*view;
vec3 cloudWorldOffsetKm=world_pos-cornerPosKm;
vec3 cloudTexCoords=cloudWorldOffsetKm*inverseScalesKm;
c+=c_step;
ivec2 intermediate=abs(c.xy&ivec2(1,1));
float is_inter=dot(N.xy,vec2(intermediate));
vec3 pw=abs(p1-p0);
float fade_inter=saturate((length(pw.xy)/(float(W)*(3.0-2.0*is_inter)-1.0)-start)/range);
float fade=(1.0-fade_inter);
float fadeDistance=saturate(distanceKm/maxFadeDistanceKm);
maxDistance=max(fadeDistance,maxDistance);
b=abs(c.xy-C0.xy*2);
#line 227 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_raytrace.sl"

if(fade>0.0)
{
float mip=0.0;
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),cloudTexCoords,0.0);

{
vec3 noise_texc=world_pos.xyz*noise3DTexcoordScale+noise3DTexcoordOffset;
vec4 noiseval=vec4(0,0,0,0);
float cosine=dot(N,abs(view));
if(noise)noiseval=density.x*textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc,1.0*(fadeDistance+1.0-abs(cosine)));
vec4 light=vec4(1,1,1,1);
calcDensity(cloudDensity,cloudLight,cloudTexCoords,noiseval,fractalScale,mip,density,light);
if(do_rain_effect)
{
float dm=rainEffect*fade*GetRainAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm);
dm*=saturate(0.6+textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc+vec3(0,0,rainVerticalTexcoord),0.0).z);
moisture+=0.01*dm*light.x;
density.z=max(density.z,dm);
}

if(density.z>0)
{
density.z=saturate(0.3+(1.0+5.0*density.y)*(density.z-0.3));
minDistance=min(max(0,fadeDistance-density.z*stepKm/maxFadeDistanceKm),minDistance);
vec3 worley_texc=(world_pos.xyz+windOffsetKm.xyz)*worleyTexcoordScale+worleyOffsetKm;
vec4 worley=textureLod(sampler3D(smallWorleyTexture3D[1 + 6]),worley_texc,0);
float wo=4*density.y*(worley.w-0.6)*saturate(1.0/(12.0*fadeDistance));
density.z=mix(density.z,density.z*saturate(0.3+((density.z+wo)-0.3-saturate(0.6-density.z))),density.y);
amb_dir=mix(amb_dir,worley.xyz,0.1*density.z);
float brightness_factor;
fade_texc.x=sqrt(fadeDistance);
vec3 volumeTexCoords=vec3(volumeTexCoordsXyC.xy,fade_texc.x);
ColourStep(res.colour,insc,meanFadeDistance,brightness_factor,lossTexture,inscTexture,skylTexture,inscatterVolumeTexture,do_godrays,godraysVolumeTexture,lightspaceScale,godraysTexCoords,lightTableTexture,density,light,distanceKm,fadeDistance,world_pos,cloudTexCoords,fade_texc,nearFarTexc,cosine,volumeTexCoords,amb_dir,BetaClouds,BetaRayleigh,BetaMie,solidDist_nearFar,noise,do_depth_mix,distScale,idx,noiseval,fade,alphaSharpness);
if(res.colour[0].a*brightness_factor<0.003)
{
for(int o=0;o<num_interp;o++)res.colour[o].a=0.0;
meanFadeDistance=fadeDistance;
break;
}

}

lastFadeDistance=mix(lastFadeDistance,fadeDistance-density.z*stepKm/maxFadeDistanceKm,res.colour[num_interp-1].a);
}

}

if(max(max(b.x,b.y),0)>=W)
{
c0.xy=C0.xy;
c.xy+=start_c_offset.xy;
c.xy-=abs(c.xy&ivec2(1,1));
c.xy=c.xy>>1;
gridScale.xy*=2.0;
if(idx==0)W*=2;
p0.xy=P0.xy;
P0.xy=startOffsetFromOriginKm.xy/gridScale.xy/2.0;
C0.xy+=start_c_offset.xy;
C0.xy-=abs(C0.xy&ivec2(1,1));
C0.xy=C0.xy>>1;
viewGridspace=view/gridScale;
viewGridspace=normalize(viewGridspace);
unitStepKm=viewGridspace*gridScale;
unitStepLengthKm=length(unitStepKm);
idx++;
}

}

res.nearFarDepth.zw=vec2(meanFadeDistance,moisture);
for(int k=0;k<num_interp;k++)
{
res.colour[k].rgb+=insc[k].rgb;
}

return res;
}
#line 79 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
vec3 WorldToVolumePos(vec3 world_pos_km, vec3 centreVolumePos, vec3 vol_km)
{
vec3 vp=world_pos_km/vol_km;
return vp+centreVolumePos;
}
#line 96 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
vec3 GridToWorldPos(vec3 grid_pos, vec3 grid_km, vec3 centreVolumePosKm)
{
vec3 wp=grid_pos*grid_km-centreVolumePosKm;
return wp;
}
#line 114 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
ivec3 FloatToIntGrid(vec3 grid_pos)
{
return ivec3(floor(grid_pos));
}
#line 127 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
vec3 WorldToGridPos(vec3 world_pos_km, vec3 gridKm, vec3 centreGridPos)
{
return world_pos_km/gridKm+centreGridPos;
}
#line 132 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
RaytracePixelOutput RaytraceCloudsExperimental(uint64_t cloudDensity[24], uint64_t cloudLight[24], uint64_t precipitationVolume[24], uint64_t noiseTexture3D[24], uint64_t lightTableTexture[24], uint64_t illuminationTexture[24], uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], bool do_depth_mix, vec4 dlookup, vec3 view, vec4 clip_pos, vec3 volumeTexCoordsXyC, bool noise, bool do_rain_effect, bool do_rainbow, vec3 cloudIrRadiance1, vec3 cloudIrRadiance2, int num_interp, bool do_godrays, vec3 cloudTintColour, uint seed)
{
RaytracePixelOutput res;
vec4 insc[2];
for(int ii=0;ii<num_interp;ii++)
{
res.colour[ii]=vec4(0,0,0,1.0);
insc[ii]=vec4(0,0,0,0);
}

res.nearFarDepth=dlookup;
float s=saturate((directionToSun.z+0.2)/0.01);
vec3 lightDirection=mix(directionToMoon,directionToSun,s);
float cos0=dot(lightDirection.xyz,view.xyz);
float min_z=cornerPosKm.z-(fractalScale.z*1.5)/inverseScalesKm.z;
float max_z=cornerPosKm.z+(1.0+fractalScale.z*1.5)/inverseScalesKm.z;
if(do_rain_effect)min_z=-1.0;
vec3 godraysTexCoords=vec3(0,0,0);
float lightspaceScale=1.0;
if(do_godrays)
{
vec3 lightspaceView=(mul(worldToScatteringVolumeMatrix,vec4(view,1.0)).xyz);
lightspaceScale=length(lightspaceView);
godraysTexCoords=vec3(fract(atan(lightspaceView.x,lightspaceView.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceView.z/lightspaceScale)*2.0/3.1415926536,0);
}

float solidDist_nearFar[2];
vec2 nfd=(dlookup.yx)+100.0*step(vec2(1.0,1.0),dlookup.yx);
solidDist_nearFar[0]=nfd.x;
solidDist_nearFar[num_interp-1]=nfd.y;
for(int l=1;l<num_interp-1;l++)
{
float interp=1.0-float(l)/float(num_interp-1);
solidDist_nearFar[l]=mix(solidDist_nearFar[0],solidDist_nearFar[num_interp-1],1.0-interp);
}

float sine=view.z;
vec2 fade_texc=vec2(0.0,0.5*(1.0-sine));
vec2 illum_texc=vec2(atan(view.x,view.y)/(3.1415926536*2.0),fade_texc.y);
vec4 illum_lookup=texture(sampler2D(illuminationTexture[1 + 3]),illum_texc);
vec2 nearFarTexc=illum_lookup.xy;
float meanFadeDistance=1.0;
float BetaClouds=HenyeyGreenstein(cloudEccentricity,cos0);
float BetaRayleigh=CalcRayleighBeta(cos0);
float BetaMie=HenyeyGreenstein(hazeEccentricity,cos0);
float moisture=0.0;
vec3 world_pos_km=viewPosKm;
world_pos_km.xy-=windOffsetKm.xy;
uint mip=uint(maxMip);
uint mipscale=uint(1)<<mip;
uvec3 mip_grid=uvec3(windowGrid)/mipscale;
vec3 windowGridf=vec3(mip_grid);
vec3 centreVolumePos=vec3((typed_mod((gridCentreTexel.xy+ivec2(windowGrid.xy/2)),ivec2(windowGrid.xy))-ivec2(windowGrid.xy/2))/float(windowGrid.x),0);
vec3 gridKm=VolumeScaleKm/windowGridf;
vec3 centreVolumePosKm=VolumeScaleKm*centreVolumePos;
vec3 centreGridPos=windowGridf*centreVolumePos;
vec3 grid_pos=WorldToGridPos(world_pos_km,gridKm,centreGridPos);
vec3 grid_dir=normalize(WorldToGridPos(world_pos_km+view,gridKm,centreGridPos)-grid_pos);
ivec3 c_offset=ivec3(2.0*step(vec3(0,0,0),view.xyz)-vec3(1,1,1));
ivec3 c_next=FloatToIntGrid(grid_pos);
uint idx=0;
int count_detail=0;
vec3 amb_dir=view;
float distScale=0.6/maxFadeDistanceKm;
int i=0;
uint use_mip=0;
int steps_at_mip=0;
vec3 last_grid_pos=grid_pos;
ivec3 c_offset_x=ivec3(step(vec3(0,0,0),grid_dir.xyz));
c_offset=2*c_offset_x-ivec3(1,1,1);
float distanceLimitKm=0.f;
for(i=0;i<768;i++)
{
if((view.z<0&&world_pos_km.z<min_z)||(view.z>0&&world_pos_km.z>max_z)||distanceLimitKm>maxCloudDistanceKm)break;
vec3 prev_world_pos_km=world_pos_km;
ivec3 c=c_next;
if(mip>use_mip)
{
vec4 lookup=vec4(0,0,0,0);
ivec4 lookup_index=ivec4(typed_mod((c.xy+mip_grid.xy),mip_grid.xy),c.z,mip);
if(c.z<mip_grid.z&&c.z>=0)lookup=texelFetch(sampler3D(cloudDensity[0]),ivec3(lookup_index).xyz,int(lookup_index.w));
if(do_rain_effect)lookup.z+=rainEffect*GetPrecipitationAtOffsetKm(precipitationVolume,(world_pos_km-cornerPosKm),inverseScalesKm,float(mip)).w;
if(lookup.z!=0)
{
mip--;
mipscale=uint(1)<<mip;
mip_grid=ivec3(windowGrid)/mipscale;
windowGridf=vec3(mip_grid);
gridKm=VolumeScaleKm/windowGridf;
centreVolumePosKm=VolumeScaleKm*centreVolumePos;
centreGridPos=windowGridf*centreVolumePos;
grid_pos=WorldToGridPos(world_pos_km,gridKm,centreGridPos);
c_next=FloatToIntGrid(grid_pos);
continue;
}

ivec3 c1=c+c_offset_x;
vec3 grid_pos_1=c1;
vec3 dp=grid_pos_1-grid_pos;
vec3 D=dp/grid_dir;
float e=min(min(D.x,D.y),D.z);
vec3 N=step(D,vec3(e,e,e));
ivec3 c_step=c_offset*ivec3(N);
grid_pos+=e*grid_dir;
c_next=c+c_step;
world_pos_km=GridToWorldPos(grid_pos,gridKm,centreVolumePosKm);
vec3 step_km=world_pos_km-prev_world_pos_km;
float stepKm=length(step_km);
distanceLimitKm=length(world_pos_km-viewPosKm);
continue;
}

ivec3 c1=c+c_offset_x;
vec3 grid_pos_1=c1;
vec3 dp=grid_pos_1-grid_pos;
vec3 D=dp/grid_dir;
float e=min(min(D.x,D.y),D.z);
vec3 N=step(D,vec3(e,e,e));
ivec3 c_step=c_offset*ivec3(N);
grid_pos+=e*grid_dir;
c_next=c+c_step;
world_pos_km=GridToWorldPos(grid_pos,gridKm,centreVolumePosKm);
vec3 step_km=world_pos_km-prev_world_pos_km;
float stepKm=length(step_km);
idx=uint(mip);
vec3 sample_pos_km=world_pos_km;
vec3 cloud_tex_coords=WorldToVolumePos(sample_pos_km,centreVolumePos,VolumeScaleKm);

{
vec4 light=textureLod(sampler3D(cloudLight[1 + 7]),cloud_tex_coords,0);
vec3 noise_texc=(sample_pos_km.xyz+windOffsetKm.xyz)*noise3DTexcoordScale+noise3DTexcoordOffset;
vec4 noiseval=vec4(0,0,0,0);
if(noise)
{
vec4 noiseval1=textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc,0.0);
noiseval=light.z*noiseval1;
}

vec3 noise_adjusted_texc=cloud_tex_coords.xyz+fractalScale.xyz*(noiseval.xyz);
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),noise_adjusted_texc,use_mip);
if(do_rain_effect)
{
float dm=rainEffect*GetRainAtOffsetKm(precipitationVolume,(sample_pos_km-cornerPosKm)+((fractalScale.xyz*noiseval.xyz)/inverseScalesKm),inverseScalesKm);
dm*=saturate(0.6+textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc+vec3(0,0,rainVerticalTexcoord),0.0).z);
moisture+=0.01*dm*light.x;
density.z=max(density.z,dm);
}

if(density.z>0)
{
float distanceKm=length(world_pos_km-viewPosKm);
float fadeDistance=saturate(distanceKm/maxFadeDistanceKm);
density.z*=saturate(distanceKm/0.24);
density.z=mix(1.0/(1.0+exp(-20.0*(density.z-0.3))),density.z,density.y);
vec3 worley_texc=(sample_pos_km.xyz+windOffsetKm.xyz)*worleyTexcoordScale+worleyOffsetKm;
vec4 worley=textureLod(sampler3D(smallWorleyTexture3D[1 + 6]),worley_texc,0);
float wo=4*light.w*mix(1.0,worley.w,saturate(1.0/(12.0*fadeDistance)));
density.z=mix(density.z,density.z*saturate(0.3+((density.z+wo)-0.3-saturate(0.6-density.z))),density.y);
float brightness_factor;
fade_texc.x=sqrt(fadeDistance);
vec3 volumeTexCoords=vec3(volumeTexCoordsXyC.xy,fade_texc.x);
float opacity=density.z;
opacity=saturate(0.3+(1.0+1.0*density.w*alphaSharpness)*(opacity-0.3));
float cosine=dot(N,abs(view));
ColourStep2(res.colour,insc,brightness_factor,inscatterVolumeTexture,lossTexture,do_godrays,godraysVolumeTexture,lightspaceScale,godraysTexCoords,lightTableTexture,density,light,distanceKm,fadeDistance,world_pos_km,cloud_tex_coords,fade_texc,volumeTexCoords,BetaClouds,solidDist_nearFar,do_depth_mix,distScale,idx,opacity,cosine,cloudTintColour);
meanFadeDistance=mix(min(fadeDistance,meanFadeDistance),meanFadeDistance,(1.0-.4*density.z));
if(res.colour[0].a*brightness_factor<0.03)
{
for(int o=0;o<num_interp;o++)
{
res.colour[o].a=0.0;
}

meanFadeDistance=fadeDistance;
break;
}

continue;
}

count_detail++;
if(count_detail>2)
{
mip=maxMip;
mipscale=int(1)<<mip;
mip_grid=ivec3(windowGrid)/mipscale;
windowGridf=vec3(mip_grid);
gridKm=VolumeScaleKm/windowGridf;
centreGridPos=windowGridf*centreVolumePos;
grid_pos=WorldToGridPos(world_pos_km,gridKm,centreGridPos);
c_next=FloatToIntGrid(grid_pos);
count_detail=0;
}

}

}

res.nearFarDepth.zw=vec2(meanFadeDistance,moisture);
float grey=float(1)/100.0;
for(int k=0;k<num_interp;k++)
{
res.colour[k].rgb+=insc[k].rgb;
}

return res;
}
#line 769 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void Raytrace(uvec3 pos, bool include_rain, bool depth, int num_interp, bool do_godrays, bool experimental, bool blend)
{
vec2 texCoords=(vec2(pos.xy)+vec2(0.5,0.5))/vec2(targetTextureSize);
vec4 clip_pos=vec4(-1.0,1.0,1.0,1.0);
clip_pos.x+=2.0*texCoords.x;
clip_pos.y-=2.0*texCoords.y;
vec3 view=normalize(mul(invViewProj[pos.z],clip_pos).xyz);
vec4 dlookup=vec4(1.0,1.0,0.000001,1.0);
if(depth)
{
dlookup=textureLod(samplerCube(depthTexture[1 + 6]),view,0);
}

uint seed=0;
vec3 worldspaceVolumeTexCoordsXyC=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(view.z)/3.1415926536),0);
RaytracePixelOutput f;
if(experimental)f=RaytraceCloudsExperimental(cloudDensity,cloudDensity2,precipitationVolume,noiseTexture3D,lightTableTexture,illuminationTexture,lossTexture,inscTexture,skylTexture,volumeInscatterTexture,godraysTexture,true,dlookup,view,clip_pos,worldspaceVolumeTexCoordsXyC,true,include_rain,false,cloudIrRadiance1,cloudIrRadiance2,num_interp,do_godrays,cloudTintColour,seed);else
f=RaytraceCloudsForward(cloudDensity,cloudDensity2,precipitationVolume,noiseTexture3D,lightTableTexture,illuminationTexture,lossTexture,inscTexture,skylTexture,volumeInscatterTexture,godraysTexture,true,dlookup,view,clip_pos,worldspaceVolumeTexCoordsXyC,true,include_rain,false,cloudIrRadiance1,cloudIrRadiance2,num_interp,do_godrays,cloudTintColour);
vec4 resn=f.colour[2-1];
if(blend)
{

}

imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*(2-1))),vec4(resn));
float n=float(dlookup.y>=1.0);
for(int u=0;u<2-1;u++)
{
vec4 res=f.colour[u];
if(blend)
{

}

imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*u)),vec4(res));
}

imageStore(outputTexture3,ivec3(pos),vec4(f.nearFarDepth));
#line 860 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"

}
#line 1046 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void Edge(uvec3 g, uvec3 t, bool rain, bool depth, bool godrays, bool experimental)
{
uvec2 idx=uvec2(g.xy*4+t.xy);
uint Z=cubemapFaceIndex[g.z+t.z].x;
uvec3 pos=uvec3(targetRange[Z].xy+idx,Z);
if(pos.x>=targetRange[Z].z||pos.y>=targetRange[Z].w)return ;
vec4 u=texelFetch(sampler2DArray(updateTexture[0]),ivec3(pos).xyz,0);
if(u.g<1.0&&u.b>0.0)
{
Raytrace(pos,rain,depth,2,godrays,experimental,false);
}

}
layout(local_size_x=4, local_size_y=4, local_size_z=1) in;
void main()
{
uvec3 g = gl_WorkGroupID;
uvec3 t = gl_LocalInvocationID;
#line 1069 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
Edge(g,t,true,true,true,false);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_CS_Experimental_Edge_NoRain_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 12) uniform CloudStaticConstants
{
	mat4 invViewProj[6];
};
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};

#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
struct RaytracePixelOutput
{
	vec4 colour[2];
	vec4 nearFarDepth;
};













layout(rgba16f, binding = 4) uniform image2DArray outputTexture1;
layout(rgba16f, binding = 5) uniform image2DArray outputTexture3;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t smallWorleyTexture3D[24];
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
	uint64_t noiseTexture3D[24];
	uint64_t godraysTexture[24];
	uint64_t volumeInscatterTexture[24];
	uint64_t skylTexture[24];
	uint64_t inscTexture[24];
	uint64_t lossTexture[24];
	uint64_t depthTexture[24];
	uint64_t illuminationTexture[24];
	uint64_t lightTableTexture[24];
	uint64_t precipitationVolume[24];
	uint64_t updateTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float CalcRayleighBeta(float cos0)
{
return (1.0+cos0*cos0);
}
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float HenyeyGreenstein(float g, float cos0)
{
float g2=g*g;
float u=1.0+g2-2.0*g*cos0;
return (1.0-g2)*pow(u,-1.5)/(4.0*3.1415926536);
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
vec3 PrecalculatedInscatterFunction(vec4 inscatter_factor, float BetaRayleigh, float BetaMie, vec3 mieRayleighRatio)
{
vec3 mr=mieRayleighRatio.xyz;
vec3 BetaTotal=(BetaRayleigh+BetaMie*mr)/(vec3(1.0,1.0,1.0)+mr);
vec3 colour=BetaTotal*inscatter_factor.rgb;
return colour;
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float GetAltTexCoord(float alt_km, float minSunlightAltitudeKm, float fadeAltitudeRangeKm)
{
float diff_km=alt_km-minSunlightAltitudeKm;
float sun_alt_texc=0.5+0.5*saturate(diff_km/fadeAltitudeRangeKm);
sun_alt_texc-=0.5*saturate(-diff_km/(minSunlightAltitudeKm+1.0));
return sun_alt_texc;
}
#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float unshadowedBrightness(float Beta, vec4 lightResponse, vec3 ambientColour)
{
return max(1.0,(Beta+lightResponse.y)+ambientColour.b);
}
#line 34 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColour(uint64_t lossTexture[24], uint64_t inscatterVolumeTexture[24], vec3 volumeTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float Beta, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec3 amb_dir, vec2 fade_texc, out float brightnessFactor, out vec4 inscatter, float fade, float alphaSharpness)
{
float alt_texc=(world_pos.z/fadeAltitudeRangeKm);
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 amb_lookup=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
ambientColour=lightResponse.w*amb_lookup.rgb;
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
vec3 ambient=amb_lookup.rgb*light.w;
vec4 c;
float l=mix(0.75,1.2,density.z);
c.rgb=(light.y*lightResponse.x*(Beta+l)+lightResponse.y*light.x)*combinedLightColour+ambient.rgb;
c.a=density.z*fade;
c.a=saturate(0.3+(1.0+1.0*density.w*alphaSharpness)*(c.a-0.3));

{
vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

inscatter=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),volumeTexCoords,0);
inscatter.rgb*=inscatter.a;
#line 62 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

}

return c;
}
#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColourSimple(uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t lightTableTexture[24], vec4 density, float Beta, float BetaRayleigh, float BetaMie, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, out float brightnessFactor)
{
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
ambientColour=lightResponse.w*textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
vec3 ambient=density.w*ambientColour.rgb;
float opacity=density.z;
vec4 c;
c.rgb=(density.y*Beta+lightResponse.y*density.x)*combinedLightColour+ambient.rgb;
c.a=opacity;
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float earthshadowFactr=saturate((fade_texc.x-nearFarTexc.x)/0.1);
#line 88 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
vec4 insc=textureLod(sampler2D(inscTexture[1 + 5]),fade_texc,0);
vec3 skyl=textureLod(sampler2D(skylTexture[1 + 5]),fade_texc,0).rgb;
vec3 inscatter=earthshadowFactr*PrecalculatedInscatterFunction(insc,BetaRayleigh,BetaMie,mieRayleighRatio);
c.rgb+=inscatter+skyl;
return c;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void calcDensity(uint64_t cloudDensity[24], uint64_t cloudLight[24], vec3 texCoords, vec4 noiseval, vec3 fractalScale, float mip, inout vec4 density, out vec4 light)
{
vec3 pos=texCoords.xyz+fractalScale.xyz*(noiseval.xyz);
density=textureLod(sampler3D(cloudDensity[1 + 7]),pos,mip);
light=textureLod(sampler3D(cloudLight[1 + 7]),texCoords,mip);
}
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 GetPrecipitationAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm, float mip)
{
vec3 rain_texc=cloudWorldOffsetKm;
rain_texc.xy+=rain_texc.z*rainTangent;
rain_texc*=inverseScalesKm;
vec3 pvSize;
ivec3 ivprecipitationVolume = textureSize(sampler3D(precipitationVolume[0]),0);
pvSize.x = ivprecipitationVolume.x;pvSize.y = ivprecipitationVolume.y;pvSize.z = ivprecipitationVolume.z;;
uint z_texel=uint(rain_texc.z*pvSize.z);
rain_texc.z=(float(z_texel)+0.5)/pvSize.z;
return textureLod(sampler3D(precipitationVolume[1 + 7]),rain_texc,mip);
}
#line 120 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float GetRainAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm)
{
vec4 rain_lookup=GetPrecipitationAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm,0.0);
return rain_lookup.x*rain_lookup.w*saturate((20.0*rain_lookup.y-cloudWorldOffsetKm.z)/2.0);
}
#line 146 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void ColourStep(inout vec4 colour[2], inout vec4 insc[2], inout float meanFadeDistance, out float brightness_factor, uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], bool godrays, uint64_t godraysVolumeTexture[24], float godraysScale, vec3 godraysTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float distanceKm, float fadeDistance, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, float cosine, vec3 volumeTexCoords, vec3 amb_dir, float BetaClouds, float BetaRayleigh, float BetaMie, float solidDist_nearFar[2], bool noise, bool do_depth_mix, float distScale, int idx, vec4 noiseval, float fade, float alphaSharpness)
{
density.z*=saturate(distanceKm/0.24);
vec4 clr[2];
vec4 inscatter=vec4(0,0,0,0);
brightness_factor=1.0;
if(noise)clr[2-1]=calcColour(lossTexture,inscatterVolumeTexture,volumeTexCoords,lightTableTexture,density,light,BetaClouds,lightResponse,ambientColour,world_pos,cloudTexCoords,amb_dir,fade_texc,brightness_factor,inscatter,fade,alphaSharpness);else
clr[2-1]=calcColourSimple(lossTexture,inscTexture,skylTexture,lightTableTexture,vec4(light.xyw,density.z),BetaClouds,BetaRayleigh,BetaMie,lightResponse,ambientColour,world_pos,cloudTexCoords,fade_texc,nearFarTexc,brightness_factor);
clr[2-1].a*=cosine*cosine;
meanFadeDistance=mix(min(fadeDistance,meanFadeDistance),meanFadeDistance,(1.0-.4*density.z));
godraysTexCoords.z=distanceKm*godraysScale;
float gr_mult=1.0;
if(godrays)gr_mult=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),godraysTexCoords,0).x;
for(int i=0;i<2;i++)
{
clr[i]=clr[2-1];
if(do_depth_mix)
{
float m=saturate((solidDist_nearFar[i]-fadeDistance)/distScale);
clr[i].a*=m;
}

colour[i].rgb+=(clr[i].rgb)*clr[i].a*(colour[i].a);
insc[i].rgb+=gr_mult*inscatter.rgb*clr[i].a*(colour[i].a);
colour[i].a*=(1.0-clr[i].a);
}

}
#line 239 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColour2(uint64_t lossTexture[24], uint64_t inscatterVolumeTexture[24], vec3 volumeTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float Beta, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec2 fade_texc, out float brightnessFactor, out vec4 inscatter, float opacity, vec3 cloudTintColour)
{
float alt_texc=(world_pos.z/fadeAltitudeRangeKm);
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 amb_lookup=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
ambientColour=lightResponse.w*amb_lookup.rgb;
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
vec3 ambient=amb_lookup.rgb*light.w;
vec4 c;
float l=1;
float combinedLightResponse=(light.y*lightResponse.x*(Beta+l)+lightResponse.y*light.x);
c.rgb=cloudTintColour*(combinedLightResponse*combinedLightColour+ambient.rgb);
c.a=opacity;

{
vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
#line 266 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

inscatter=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),volumeTexCoords,0);
inscatter.rgb*=inscatter.a;
#line 269 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

}

return c;
}
#line 272 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void ColourStep2(inout vec4 colour[2], inout vec4 insc[2], inout float brightness_factor, uint64_t inscatterVolumeTexture[24], uint64_t lossTexture[24], bool godrays, uint64_t godraysVolumeTexture[24], float godraysScale, vec3 godraysTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float distanceKm, float fadeDistance, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec3 volumeTexCoords, float BetaClouds, float solidDist_nearFar[2], bool do_depth_mix, float distScale, uint idx, float opacity, float cosine, vec3 cloudTintColour)
{
vec4 clr[2];
vec4 inscatter=vec4(0,0,0,0);
brightness_factor=1.0;
clr[2-1]=calcColour2(lossTexture,inscatterVolumeTexture,volumeTexCoords,lightTableTexture,density,light,BetaClouds,lightResponse,ambientColour,world_pos,fade_texc,brightness_factor,inscatter,opacity,cloudTintColour);
clr[2-1].a*=cosine*cosine;
godraysTexCoords.z=distanceKm*godraysScale;
float gr_mult=1.0;
if(godrays)gr_mult=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),godraysTexCoords,0).x;
for(int i=0;i<2;i++)
{
clr[i]=clr[2-1];
if(do_depth_mix)
{
float m=saturate((solidDist_nearFar[i]-fadeDistance)/distScale);
clr[i].a*=m;
}

colour[i].rgb+=(clr[i].rgb)*clr[i].a*(colour[i].a);
insc[i].rgb+=gr_mult*inscatter.rgb*clr[i].a*(colour[i].a);
colour[i].a*=(1.0-clr[i].a);
}

}
#line 7 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_raytrace.sl"
RaytracePixelOutput RaytraceCloudsForward(uint64_t cloudDensity[24], uint64_t cloudLight[24], uint64_t precipitationVolume[24], uint64_t noiseTexture3D[24], uint64_t lightTableTexture[24], uint64_t illuminationTexture[24], uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], bool do_depth_mix, vec4 dlookup, vec3 view, vec4 clip_pos, vec3 volumeTexCoordsXyC, bool noise, bool do_rain_effect, bool do_rainbow, vec3 cloudIrRadiance1, vec3 cloudIrRadiance2, int num_interp, bool do_godrays, vec3 cloudTintColour)
{
RaytracePixelOutput res;
vec4 insc[2];
for(int ii=0;ii<num_interp;ii++)
{
res.colour[ii]=vec4(0,0,0,1.0);
insc[ii]=vec4(0,0,0,0);
}

res.nearFarDepth=dlookup;
float s=saturate((directionToSun.z+0.2)/0.01);
vec3 lightDirection=mix(directionToMoon,directionToSun,s);
float cos0=dot(lightDirection.xyz,view.xyz);
float sine=view.z;
float min_z=cornerPosKm.z-(fractalScale.z*1.5)/inverseScalesKm.z;
float max_z=cornerPosKm.z+(1.0+fractalScale.z*1.5)/inverseScalesKm.z;
if(do_rain_effect)min_z=-1.0;else
if(view.z<-0.01&&viewPosKm.z<cornerPosKm.z-fractalScale.z/inverseScalesKm.z)return res;
vec3 godraysTexCoords=vec3(0,0,0);
float lightspaceScale=1.0;
if(do_godrays)
{
vec3 lightspaceView=(mul(worldToScatteringVolumeMatrix,vec4(view,1.0)).xyz);
lightspaceScale=length(lightspaceView);
godraysTexCoords=vec3(fract(atan(lightspaceView.x,lightspaceView.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceView.z/lightspaceScale)*2.0/3.1415926536,0);
}

float solidDist_nearFar[2];
vec2 nfd=(dlookup.yx)+100.0*step(vec2(1.0,1.0),dlookup.yx);
solidDist_nearFar[0]=nfd.x;
solidDist_nearFar[num_interp-1]=nfd.y;
float n=nfd.x;
float f=nfd.y;
for(int l=1;l<num_interp-1;l++)
{
float interp=1.0-float(l)/float(num_interp-1);
solidDist_nearFar[l]=mix(solidDist_nearFar[0],solidDist_nearFar[num_interp-1],1.0-interp);
}

vec2 fade_texc=vec2(0.0,0.5*(1.0-sine));
vec2 illum_texc=vec2(atan(view.x,view.y)/(3.1415926536*2.0),fade_texc.y);
vec4 illum_lookup=texture(sampler2D(illuminationTexture[1 + 3]),illum_texc);
vec2 nearFarTexc=illum_lookup.xy;
float meanFadeDistance=1.0;
float minDistance=1.0;
float maxDistance=0.0;
float BetaClouds=lightResponse.x*HenyeyGreenstein(cloudEccentricity,cos0);
float BetaRayleigh=CalcRayleighBeta(cos0);
float BetaMie=HenyeyGreenstein(hazeEccentricity,cos0);
float moisture=0.0;
vec3 world_pos=viewPosKm;
view.xyz+=vec3(0.00001,0.00001,0.00001);
ivec3 c_offset=ivec3(2.0*step(vec3(0,0,0),view.xyz)-vec3(1,1,1));
ivec3 start_c_offset=-c_offset;
start_c_offset=ivec3(max(start_c_offset.x,0),max(start_c_offset.y,0),max(start_c_offset.z,0));
vec3 viewGridspace=view/scaleOfGridCoordsKm;
viewGridspace=normalize(viewGridspace);
vec3 offset_vec=vec3(0,0,0);

{
float a=1.0/(saturate(view.z)+0.00001);
offset_vec+=max(0.0,min_z-world_pos.z)*vec3(view.x*a,view.y*a,1.0);
}

vec3 halfway=0.5*(lightDirection-view);
world_pos+=offset_vec;
vec3 unitStepKm=viewGridspace*scaleOfGridCoordsKm;
float unitStepLengthKm=length(unitStepKm);
vec3 startOffsetFromOriginKm=viewPosKm-gridOriginPosKm;
vec3 offsetFromOrigin=world_pos-gridOriginPosKm;
vec3 p0=startOffsetFromOriginKm/scaleOfGridCoordsKm;
ivec3 c0=ivec3(floor(p0)+start_c_offset);
vec3 gridScale=scaleOfGridCoordsKm;
vec3 P0=startOffsetFromOriginKm/scaleOfGridCoordsKm/2.0;
ivec3 C0=c0>>1;
float distanceKm=length(offset_vec);
vec3 p_=offsetFromOrigin/scaleOfGridCoordsKm;
ivec3 c=ivec3(floor(p_)+start_c_offset);
int idx=0;
float W=halfClipSize;
const float start=0.866*0.866;
const float ends=1.0;
const float range=ends-start;
float lastFadeDistance=0.0;
ivec2 b=abs(c.xy-C0.xy*2);
vec3 amb_dir=view;
for(int j=0;j<8;j++)
{
if(max(max(b.x,b.y),0)>=W)
{
c0.xy=C0.xy;
c.xy+=start_c_offset.xy;
c.xy-=abs(c.xy&ivec2(1,1));
c.xy=c.xy>>1;
gridScale.xy*=2.0;
if(idx==0)W*=2;
p0.xy=P0.xy;
P0.xy=startOffsetFromOriginKm.xy/gridScale.xy/2.0;
C0.xy+=start_c_offset.xy;
C0.xy-=abs(C0.xy&ivec2(1,1));
C0.xy=C0.xy>>1;
viewGridspace=view/gridScale;
viewGridspace=normalize(viewGridspace);
unitStepKm=viewGridspace*gridScale;
unitStepLengthKm=length(unitStepKm);
idx++;
b=abs(c.xy-C0.xy*2);
}
else
break;
}

float distScale=0.6/maxFadeDistanceKm;
for(int i=0;i<768;i++)
{
world_pos+=0.001*view;
if((view.z<0&&world_pos.z<min_z)||(view.z>0&&world_pos.z>max_z)||distanceKm>maxCloudDistanceKm)break;
offsetFromOrigin=world_pos-gridOriginPosKm;
ivec3 c1=c+c_offset;
vec3 p=offsetFromOrigin/gridScale;
vec3 p1=vec3(c1);
vec3 dp=p1-p;
vec3 D=(dp/viewGridspace);
float e=min(min(D.x,D.y),D.z);
vec3 N=step(D,vec3(e,e,e));
ivec3 c_step=c_offset*ivec3(N);
float stepKm=e*unitStepLengthKm;
distanceKm+=stepKm;
p1=p+e*viewGridspace;
world_pos+=stepKm*view;
vec3 cloudWorldOffsetKm=world_pos-cornerPosKm;
vec3 cloudTexCoords=cloudWorldOffsetKm*inverseScalesKm;
c+=c_step;
ivec2 intermediate=abs(c.xy&ivec2(1,1));
float is_inter=dot(N.xy,vec2(intermediate));
vec3 pw=abs(p1-p0);
float fade_inter=saturate((length(pw.xy)/(float(W)*(3.0-2.0*is_inter)-1.0)-start)/range);
float fade=(1.0-fade_inter);
float fadeDistance=saturate(distanceKm/maxFadeDistanceKm);
maxDistance=max(fadeDistance,maxDistance);
b=abs(c.xy-C0.xy*2);
#line 227 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_raytrace.sl"

if(fade>0.0)
{
float mip=0.0;
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),cloudTexCoords,0.0);

{
vec3 noise_texc=world_pos.xyz*noise3DTexcoordScale+noise3DTexcoordOffset;
vec4 noiseval=vec4(0,0,0,0);
float cosine=dot(N,abs(view));
if(noise)noiseval=density.x*textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc,1.0*(fadeDistance+1.0-abs(cosine)));
vec4 light=vec4(1,1,1,1);
calcDensity(cloudDensity,cloudLight,cloudTexCoords,noiseval,fractalScale,mip,density,light);
if(do_rain_effect)
{
float dm=rainEffect*fade*GetRainAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm);
dm*=saturate(0.6+textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc+vec3(0,0,rainVerticalTexcoord),0.0).z);
moisture+=0.01*dm*light.x;
density.z=max(density.z,dm);
}

if(density.z>0)
{
density.z=saturate(0.3+(1.0+5.0*density.y)*(density.z-0.3));
minDistance=min(max(0,fadeDistance-density.z*stepKm/maxFadeDistanceKm),minDistance);
vec3 worley_texc=(world_pos.xyz+windOffsetKm.xyz)*worleyTexcoordScale+worleyOffsetKm;
vec4 worley=textureLod(sampler3D(smallWorleyTexture3D[1 + 6]),worley_texc,0);
float wo=4*density.y*(worley.w-0.6)*saturate(1.0/(12.0*fadeDistance));
density.z=mix(density.z,density.z*saturate(0.3+((density.z+wo)-0.3-saturate(0.6-density.z))),density.y);
amb_dir=mix(amb_dir,worley.xyz,0.1*density.z);
float brightness_factor;
fade_texc.x=sqrt(fadeDistance);
vec3 volumeTexCoords=vec3(volumeTexCoordsXyC.xy,fade_texc.x);
ColourStep(res.colour,insc,meanFadeDistance,brightness_factor,lossTexture,inscTexture,skylTexture,inscatterVolumeTexture,do_godrays,godraysVolumeTexture,lightspaceScale,godraysTexCoords,lightTableTexture,density,light,distanceKm,fadeDistance,world_pos,cloudTexCoords,fade_texc,nearFarTexc,cosine,volumeTexCoords,amb_dir,BetaClouds,BetaRayleigh,BetaMie,solidDist_nearFar,noise,do_depth_mix,distScale,idx,noiseval,fade,alphaSharpness);
if(res.colour[0].a*brightness_factor<0.003)
{
for(int o=0;o<num_interp;o++)res.colour[o].a=0.0;
meanFadeDistance=fadeDistance;
break;
}

}

lastFadeDistance=mix(lastFadeDistance,fadeDistance-density.z*stepKm/maxFadeDistanceKm,res.colour[num_interp-1].a);
}

}

if(max(max(b.x,b.y),0)>=W)
{
c0.xy=C0.xy;
c.xy+=start_c_offset.xy;
c.xy-=abs(c.xy&ivec2(1,1));
c.xy=c.xy>>1;
gridScale.xy*=2.0;
if(idx==0)W*=2;
p0.xy=P0.xy;
P0.xy=startOffsetFromOriginKm.xy/gridScale.xy/2.0;
C0.xy+=start_c_offset.xy;
C0.xy-=abs(C0.xy&ivec2(1,1));
C0.xy=C0.xy>>1;
viewGridspace=view/gridScale;
viewGridspace=normalize(viewGridspace);
unitStepKm=viewGridspace*gridScale;
unitStepLengthKm=length(unitStepKm);
idx++;
}

}

res.nearFarDepth.zw=vec2(meanFadeDistance,moisture);
for(int k=0;k<num_interp;k++)
{
res.colour[k].rgb+=insc[k].rgb;
}

return res;
}
#line 79 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
vec3 WorldToVolumePos(vec3 world_pos_km, vec3 centreVolumePos, vec3 vol_km)
{
vec3 vp=world_pos_km/vol_km;
return vp+centreVolumePos;
}
#line 96 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
vec3 GridToWorldPos(vec3 grid_pos, vec3 grid_km, vec3 centreVolumePosKm)
{
vec3 wp=grid_pos*grid_km-centreVolumePosKm;
return wp;
}
#line 114 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
ivec3 FloatToIntGrid(vec3 grid_pos)
{
return ivec3(floor(grid_pos));
}
#line 127 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
vec3 WorldToGridPos(vec3 world_pos_km, vec3 gridKm, vec3 centreGridPos)
{
return world_pos_km/gridKm+centreGridPos;
}
#line 132 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
RaytracePixelOutput RaytraceCloudsExperimental(uint64_t cloudDensity[24], uint64_t cloudLight[24], uint64_t precipitationVolume[24], uint64_t noiseTexture3D[24], uint64_t lightTableTexture[24], uint64_t illuminationTexture[24], uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], bool do_depth_mix, vec4 dlookup, vec3 view, vec4 clip_pos, vec3 volumeTexCoordsXyC, bool noise, bool do_rain_effect, bool do_rainbow, vec3 cloudIrRadiance1, vec3 cloudIrRadiance2, int num_interp, bool do_godrays, vec3 cloudTintColour, uint seed)
{
RaytracePixelOutput res;
vec4 insc[2];
for(int ii=0;ii<num_interp;ii++)
{
res.colour[ii]=vec4(0,0,0,1.0);
insc[ii]=vec4(0,0,0,0);
}

res.nearFarDepth=dlookup;
float s=saturate((directionToSun.z+0.2)/0.01);
vec3 lightDirection=mix(directionToMoon,directionToSun,s);
float cos0=dot(lightDirection.xyz,view.xyz);
float min_z=cornerPosKm.z-(fractalScale.z*1.5)/inverseScalesKm.z;
float max_z=cornerPosKm.z+(1.0+fractalScale.z*1.5)/inverseScalesKm.z;
if(do_rain_effect)min_z=-1.0;
vec3 godraysTexCoords=vec3(0,0,0);
float lightspaceScale=1.0;
if(do_godrays)
{
vec3 lightspaceView=(mul(worldToScatteringVolumeMatrix,vec4(view,1.0)).xyz);
lightspaceScale=length(lightspaceView);
godraysTexCoords=vec3(fract(atan(lightspaceView.x,lightspaceView.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceView.z/lightspaceScale)*2.0/3.1415926536,0);
}

float solidDist_nearFar[2];
vec2 nfd=(dlookup.yx)+100.0*step(vec2(1.0,1.0),dlookup.yx);
solidDist_nearFar[0]=nfd.x;
solidDist_nearFar[num_interp-1]=nfd.y;
for(int l=1;l<num_interp-1;l++)
{
float interp=1.0-float(l)/float(num_interp-1);
solidDist_nearFar[l]=mix(solidDist_nearFar[0],solidDist_nearFar[num_interp-1],1.0-interp);
}

float sine=view.z;
vec2 fade_texc=vec2(0.0,0.5*(1.0-sine));
vec2 illum_texc=vec2(atan(view.x,view.y)/(3.1415926536*2.0),fade_texc.y);
vec4 illum_lookup=texture(sampler2D(illuminationTexture[1 + 3]),illum_texc);
vec2 nearFarTexc=illum_lookup.xy;
float meanFadeDistance=1.0;
float BetaClouds=HenyeyGreenstein(cloudEccentricity,cos0);
float BetaRayleigh=CalcRayleighBeta(cos0);
float BetaMie=HenyeyGreenstein(hazeEccentricity,cos0);
float moisture=0.0;
vec3 world_pos_km=viewPosKm;
world_pos_km.xy-=windOffsetKm.xy;
uint mip=uint(maxMip);
uint mipscale=uint(1)<<mip;
uvec3 mip_grid=uvec3(windowGrid)/mipscale;
vec3 windowGridf=vec3(mip_grid);
vec3 centreVolumePos=vec3((typed_mod((gridCentreTexel.xy+ivec2(windowGrid.xy/2)),ivec2(windowGrid.xy))-ivec2(windowGrid.xy/2))/float(windowGrid.x),0);
vec3 gridKm=VolumeScaleKm/windowGridf;
vec3 centreVolumePosKm=VolumeScaleKm*centreVolumePos;
vec3 centreGridPos=windowGridf*centreVolumePos;
vec3 grid_pos=WorldToGridPos(world_pos_km,gridKm,centreGridPos);
vec3 grid_dir=normalize(WorldToGridPos(world_pos_km+view,gridKm,centreGridPos)-grid_pos);
ivec3 c_offset=ivec3(2.0*step(vec3(0,0,0),view.xyz)-vec3(1,1,1));
ivec3 c_next=FloatToIntGrid(grid_pos);
uint idx=0;
int count_detail=0;
vec3 amb_dir=view;
float distScale=0.6/maxFadeDistanceKm;
int i=0;
uint use_mip=0;
int steps_at_mip=0;
vec3 last_grid_pos=grid_pos;
ivec3 c_offset_x=ivec3(step(vec3(0,0,0),grid_dir.xyz));
c_offset=2*c_offset_x-ivec3(1,1,1);
float distanceLimitKm=0.f;
for(i=0;i<768;i++)
{
if((view.z<0&&world_pos_km.z<min_z)||(view.z>0&&world_pos_km.z>max_z)||distanceLimitKm>maxCloudDistanceKm)break;
vec3 prev_world_pos_km=world_pos_km;
ivec3 c=c_next;
if(mip>use_mip)
{
vec4 lookup=vec4(0,0,0,0);
ivec4 lookup_index=ivec4(typed_mod((c.xy+mip_grid.xy),mip_grid.xy),c.z,mip);
if(c.z<mip_grid.z&&c.z>=0)lookup=texelFetch(sampler3D(cloudDensity[0]),ivec3(lookup_index).xyz,int(lookup_index.w));
if(do_rain_effect)lookup.z+=rainEffect*GetPrecipitationAtOffsetKm(precipitationVolume,(world_pos_km-cornerPosKm),inverseScalesKm,float(mip)).w;
if(lookup.z!=0)
{
mip--;
mipscale=uint(1)<<mip;
mip_grid=ivec3(windowGrid)/mipscale;
windowGridf=vec3(mip_grid);
gridKm=VolumeScaleKm/windowGridf;
centreVolumePosKm=VolumeScaleKm*centreVolumePos;
centreGridPos=windowGridf*centreVolumePos;
grid_pos=WorldToGridPos(world_pos_km,gridKm,centreGridPos);
c_next=FloatToIntGrid(grid_pos);
continue;
}

ivec3 c1=c+c_offset_x;
vec3 grid_pos_1=c1;
vec3 dp=grid_pos_1-grid_pos;
vec3 D=dp/grid_dir;
float e=min(min(D.x,D.y),D.z);
vec3 N=step(D,vec3(e,e,e));
ivec3 c_step=c_offset*ivec3(N);
grid_pos+=e*grid_dir;
c_next=c+c_step;
world_pos_km=GridToWorldPos(grid_pos,gridKm,centreVolumePosKm);
vec3 step_km=world_pos_km-prev_world_pos_km;
float stepKm=length(step_km);
distanceLimitKm=length(world_pos_km-viewPosKm);
continue;
}

ivec3 c1=c+c_offset_x;
vec3 grid_pos_1=c1;
vec3 dp=grid_pos_1-grid_pos;
vec3 D=dp/grid_dir;
float e=min(min(D.x,D.y),D.z);
vec3 N=step(D,vec3(e,e,e));
ivec3 c_step=c_offset*ivec3(N);
grid_pos+=e*grid_dir;
c_next=c+c_step;
world_pos_km=GridToWorldPos(grid_pos,gridKm,centreVolumePosKm);
vec3 step_km=world_pos_km-prev_world_pos_km;
float stepKm=length(step_km);
idx=uint(mip);
vec3 sample_pos_km=world_pos_km;
vec3 cloud_tex_coords=WorldToVolumePos(sample_pos_km,centreVolumePos,VolumeScaleKm);

{
vec4 light=textureLod(sampler3D(cloudLight[1 + 7]),cloud_tex_coords,0);
vec3 noise_texc=(sample_pos_km.xyz+windOffsetKm.xyz)*noise3DTexcoordScale+noise3DTexcoordOffset;
vec4 noiseval=vec4(0,0,0,0);
if(noise)
{
vec4 noiseval1=textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc,0.0);
noiseval=light.z*noiseval1;
}

vec3 noise_adjusted_texc=cloud_tex_coords.xyz+fractalScale.xyz*(noiseval.xyz);
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),noise_adjusted_texc,use_mip);
if(do_rain_effect)
{
float dm=rainEffect*GetRainAtOffsetKm(precipitationVolume,(sample_pos_km-cornerPosKm)+((fractalScale.xyz*noiseval.xyz)/inverseScalesKm),inverseScalesKm);
dm*=saturate(0.6+textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc+vec3(0,0,rainVerticalTexcoord),0.0).z);
moisture+=0.01*dm*light.x;
density.z=max(density.z,dm);
}

if(density.z>0)
{
float distanceKm=length(world_pos_km-viewPosKm);
float fadeDistance=saturate(distanceKm/maxFadeDistanceKm);
density.z*=saturate(distanceKm/0.24);
density.z=mix(1.0/(1.0+exp(-20.0*(density.z-0.3))),density.z,density.y);
vec3 worley_texc=(sample_pos_km.xyz+windOffsetKm.xyz)*worleyTexcoordScale+worleyOffsetKm;
vec4 worley=textureLod(sampler3D(smallWorleyTexture3D[1 + 6]),worley_texc,0);
float wo=4*light.w*mix(1.0,worley.w,saturate(1.0/(12.0*fadeDistance)));
density.z=mix(density.z,density.z*saturate(0.3+((density.z+wo)-0.3-saturate(0.6-density.z))),density.y);
float brightness_factor;
fade_texc.x=sqrt(fadeDistance);
vec3 volumeTexCoords=vec3(volumeTexCoordsXyC.xy,fade_texc.x);
float opacity=density.z;
opacity=saturate(0.3+(1.0+1.0*density.w*alphaSharpness)*(opacity-0.3));
float cosine=dot(N,abs(view));
ColourStep2(res.colour,insc,brightness_factor,inscatterVolumeTexture,lossTexture,do_godrays,godraysVolumeTexture,lightspaceScale,godraysTexCoords,lightTableTexture,density,light,distanceKm,fadeDistance,world_pos_km,cloud_tex_coords,fade_texc,volumeTexCoords,BetaClouds,solidDist_nearFar,do_depth_mix,distScale,idx,opacity,cosine,cloudTintColour);
meanFadeDistance=mix(min(fadeDistance,meanFadeDistance),meanFadeDistance,(1.0-.4*density.z));
if(res.colour[0].a*brightness_factor<0.03)
{
for(int o=0;o<num_interp;o++)
{
res.colour[o].a=0.0;
}

meanFadeDistance=fadeDistance;
break;
}

continue;
}

count_detail++;
if(count_detail>2)
{
mip=maxMip;
mipscale=int(1)<<mip;
mip_grid=ivec3(windowGrid)/mipscale;
windowGridf=vec3(mip_grid);
gridKm=VolumeScaleKm/windowGridf;
centreGridPos=windowGridf*centreVolumePos;
grid_pos=WorldToGridPos(world_pos_km,gridKm,centreGridPos);
c_next=FloatToIntGrid(grid_pos);
count_detail=0;
}

}

}

res.nearFarDepth.zw=vec2(meanFadeDistance,moisture);
float grey=float(1)/100.0;
for(int k=0;k<num_interp;k++)
{
res.colour[k].rgb+=insc[k].rgb;
}

return res;
}
#line 769 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void Raytrace(uvec3 pos, bool include_rain, bool depth, int num_interp, bool do_godrays, bool experimental, bool blend)
{
vec2 texCoords=(vec2(pos.xy)+vec2(0.5,0.5))/vec2(targetTextureSize);
vec4 clip_pos=vec4(-1.0,1.0,1.0,1.0);
clip_pos.x+=2.0*texCoords.x;
clip_pos.y-=2.0*texCoords.y;
vec3 view=normalize(mul(invViewProj[pos.z],clip_pos).xyz);
vec4 dlookup=vec4(1.0,1.0,0.000001,1.0);
if(depth)
{
dlookup=textureLod(samplerCube(depthTexture[1 + 6]),view,0);
}

uint seed=0;
vec3 worldspaceVolumeTexCoordsXyC=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(view.z)/3.1415926536),0);
RaytracePixelOutput f;
if(experimental)f=RaytraceCloudsExperimental(cloudDensity,cloudDensity2,precipitationVolume,noiseTexture3D,lightTableTexture,illuminationTexture,lossTexture,inscTexture,skylTexture,volumeInscatterTexture,godraysTexture,true,dlookup,view,clip_pos,worldspaceVolumeTexCoordsXyC,true,include_rain,false,cloudIrRadiance1,cloudIrRadiance2,num_interp,do_godrays,cloudTintColour,seed);else
f=RaytraceCloudsForward(cloudDensity,cloudDensity2,precipitationVolume,noiseTexture3D,lightTableTexture,illuminationTexture,lossTexture,inscTexture,skylTexture,volumeInscatterTexture,godraysTexture,true,dlookup,view,clip_pos,worldspaceVolumeTexCoordsXyC,true,include_rain,false,cloudIrRadiance1,cloudIrRadiance2,num_interp,do_godrays,cloudTintColour);
vec4 resn=f.colour[2-1];
if(blend)
{

}

imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*(2-1))),vec4(resn));
float n=float(dlookup.y>=1.0);
for(int u=0;u<2-1;u++)
{
vec4 res=f.colour[u];
if(blend)
{

}

imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*u)),vec4(res));
}

imageStore(outputTexture3,ivec3(pos),vec4(f.nearFarDepth));
#line 860 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"

}
#line 1046 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void Edge(uvec3 g, uvec3 t, bool rain, bool depth, bool godrays, bool experimental)
{
uvec2 idx=uvec2(g.xy*4+t.xy);
uint Z=cubemapFaceIndex[g.z+t.z].x;
uvec3 pos=uvec3(targetRange[Z].xy+idx,Z);
if(pos.x>=targetRange[Z].z||pos.y>=targetRange[Z].w)return ;
vec4 u=texelFetch(sampler2DArray(updateTexture[0]),ivec3(pos).xyz,0);
if(u.g<1.0&&u.b>0.0)
{
Raytrace(pos,rain,depth,2,godrays,experimental,false);
}

}
layout(local_size_x=4, local_size_y=4, local_size_z=1) in;
void main()
{
uvec3 g = gl_WorkGroupID;
uvec3 t = gl_LocalInvocationID;
#line 1139 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
Edge(g,t,false,true,true,true);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_CS_Experimental_Edge_Rain_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 12) uniform CloudStaticConstants
{
	mat4 invViewProj[6];
};
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};

#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
struct RaytracePixelOutput
{
	vec4 colour[2];
	vec4 nearFarDepth;
};













layout(rgba16f, binding = 4) uniform image2DArray outputTexture1;
layout(rgba16f, binding = 5) uniform image2DArray outputTexture3;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t smallWorleyTexture3D[24];
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
	uint64_t noiseTexture3D[24];
	uint64_t godraysTexture[24];
	uint64_t volumeInscatterTexture[24];
	uint64_t skylTexture[24];
	uint64_t inscTexture[24];
	uint64_t lossTexture[24];
	uint64_t depthTexture[24];
	uint64_t illuminationTexture[24];
	uint64_t lightTableTexture[24];
	uint64_t precipitationVolume[24];
	uint64_t updateTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float CalcRayleighBeta(float cos0)
{
return (1.0+cos0*cos0);
}
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float HenyeyGreenstein(float g, float cos0)
{
float g2=g*g;
float u=1.0+g2-2.0*g*cos0;
return (1.0-g2)*pow(u,-1.5)/(4.0*3.1415926536);
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
vec3 PrecalculatedInscatterFunction(vec4 inscatter_factor, float BetaRayleigh, float BetaMie, vec3 mieRayleighRatio)
{
vec3 mr=mieRayleighRatio.xyz;
vec3 BetaTotal=(BetaRayleigh+BetaMie*mr)/(vec3(1.0,1.0,1.0)+mr);
vec3 colour=BetaTotal*inscatter_factor.rgb;
return colour;
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float GetAltTexCoord(float alt_km, float minSunlightAltitudeKm, float fadeAltitudeRangeKm)
{
float diff_km=alt_km-minSunlightAltitudeKm;
float sun_alt_texc=0.5+0.5*saturate(diff_km/fadeAltitudeRangeKm);
sun_alt_texc-=0.5*saturate(-diff_km/(minSunlightAltitudeKm+1.0));
return sun_alt_texc;
}
#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float unshadowedBrightness(float Beta, vec4 lightResponse, vec3 ambientColour)
{
return max(1.0,(Beta+lightResponse.y)+ambientColour.b);
}
#line 34 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColour(uint64_t lossTexture[24], uint64_t inscatterVolumeTexture[24], vec3 volumeTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float Beta, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec3 amb_dir, vec2 fade_texc, out float brightnessFactor, out vec4 inscatter, float fade, float alphaSharpness)
{
float alt_texc=(world_pos.z/fadeAltitudeRangeKm);
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 amb_lookup=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
ambientColour=lightResponse.w*amb_lookup.rgb;
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
vec3 ambient=amb_lookup.rgb*light.w;
vec4 c;
float l=mix(0.75,1.2,density.z);
c.rgb=(light.y*lightResponse.x*(Beta+l)+lightResponse.y*light.x)*combinedLightColour+ambient.rgb;
c.a=density.z*fade;
c.a=saturate(0.3+(1.0+1.0*density.w*alphaSharpness)*(c.a-0.3));

{
vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

inscatter=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),volumeTexCoords,0);
inscatter.rgb*=inscatter.a;
#line 62 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

}

return c;
}
#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColourSimple(uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t lightTableTexture[24], vec4 density, float Beta, float BetaRayleigh, float BetaMie, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, out float brightnessFactor)
{
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
ambientColour=lightResponse.w*textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
vec3 ambient=density.w*ambientColour.rgb;
float opacity=density.z;
vec4 c;
c.rgb=(density.y*Beta+lightResponse.y*density.x)*combinedLightColour+ambient.rgb;
c.a=opacity;
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float earthshadowFactr=saturate((fade_texc.x-nearFarTexc.x)/0.1);
#line 88 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
vec4 insc=textureLod(sampler2D(inscTexture[1 + 5]),fade_texc,0);
vec3 skyl=textureLod(sampler2D(skylTexture[1 + 5]),fade_texc,0).rgb;
vec3 inscatter=earthshadowFactr*PrecalculatedInscatterFunction(insc,BetaRayleigh,BetaMie,mieRayleighRatio);
c.rgb+=inscatter+skyl;
return c;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void calcDensity(uint64_t cloudDensity[24], uint64_t cloudLight[24], vec3 texCoords, vec4 noiseval, vec3 fractalScale, float mip, inout vec4 density, out vec4 light)
{
vec3 pos=texCoords.xyz+fractalScale.xyz*(noiseval.xyz);
density=textureLod(sampler3D(cloudDensity[1 + 7]),pos,mip);
light=textureLod(sampler3D(cloudLight[1 + 7]),texCoords,mip);
}
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 GetPrecipitationAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm, float mip)
{
vec3 rain_texc=cloudWorldOffsetKm;
rain_texc.xy+=rain_texc.z*rainTangent;
rain_texc*=inverseScalesKm;
vec3 pvSize;
ivec3 ivprecipitationVolume = textureSize(sampler3D(precipitationVolume[0]),0);
pvSize.x = ivprecipitationVolume.x;pvSize.y = ivprecipitationVolume.y;pvSize.z = ivprecipitationVolume.z;;
uint z_texel=uint(rain_texc.z*pvSize.z);
rain_texc.z=(float(z_texel)+0.5)/pvSize.z;
return textureLod(sampler3D(precipitationVolume[1 + 7]),rain_texc,mip);
}
#line 120 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float GetRainAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm)
{
vec4 rain_lookup=GetPrecipitationAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm,0.0);
return rain_lookup.x*rain_lookup.w*saturate((20.0*rain_lookup.y-cloudWorldOffsetKm.z)/2.0);
}
#line 146 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void ColourStep(inout vec4 colour[2], inout vec4 insc[2], inout float meanFadeDistance, out float brightness_factor, uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], bool godrays, uint64_t godraysVolumeTexture[24], float godraysScale, vec3 godraysTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float distanceKm, float fadeDistance, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, float cosine, vec3 volumeTexCoords, vec3 amb_dir, float BetaClouds, float BetaRayleigh, float BetaMie, float solidDist_nearFar[2], bool noise, bool do_depth_mix, float distScale, int idx, vec4 noiseval, float fade, float alphaSharpness)
{
density.z*=saturate(distanceKm/0.24);
vec4 clr[2];
vec4 inscatter=vec4(0,0,0,0);
brightness_factor=1.0;
if(noise)clr[2-1]=calcColour(lossTexture,inscatterVolumeTexture,volumeTexCoords,lightTableTexture,density,light,BetaClouds,lightResponse,ambientColour,world_pos,cloudTexCoords,amb_dir,fade_texc,brightness_factor,inscatter,fade,alphaSharpness);else
clr[2-1]=calcColourSimple(lossTexture,inscTexture,skylTexture,lightTableTexture,vec4(light.xyw,density.z),BetaClouds,BetaRayleigh,BetaMie,lightResponse,ambientColour,world_pos,cloudTexCoords,fade_texc,nearFarTexc,brightness_factor);
clr[2-1].a*=cosine*cosine;
meanFadeDistance=mix(min(fadeDistance,meanFadeDistance),meanFadeDistance,(1.0-.4*density.z));
godraysTexCoords.z=distanceKm*godraysScale;
float gr_mult=1.0;
if(godrays)gr_mult=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),godraysTexCoords,0).x;
for(int i=0;i<2;i++)
{
clr[i]=clr[2-1];
if(do_depth_mix)
{
float m=saturate((solidDist_nearFar[i]-fadeDistance)/distScale);
clr[i].a*=m;
}

colour[i].rgb+=(clr[i].rgb)*clr[i].a*(colour[i].a);
insc[i].rgb+=gr_mult*inscatter.rgb*clr[i].a*(colour[i].a);
colour[i].a*=(1.0-clr[i].a);
}

}
#line 239 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColour2(uint64_t lossTexture[24], uint64_t inscatterVolumeTexture[24], vec3 volumeTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float Beta, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec2 fade_texc, out float brightnessFactor, out vec4 inscatter, float opacity, vec3 cloudTintColour)
{
float alt_texc=(world_pos.z/fadeAltitudeRangeKm);
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 amb_lookup=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
ambientColour=lightResponse.w*amb_lookup.rgb;
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
vec3 ambient=amb_lookup.rgb*light.w;
vec4 c;
float l=1;
float combinedLightResponse=(light.y*lightResponse.x*(Beta+l)+lightResponse.y*light.x);
c.rgb=cloudTintColour*(combinedLightResponse*combinedLightColour+ambient.rgb);
c.a=opacity;

{
vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
#line 266 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

inscatter=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),volumeTexCoords,0);
inscatter.rgb*=inscatter.a;
#line 269 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

}

return c;
}
#line 272 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void ColourStep2(inout vec4 colour[2], inout vec4 insc[2], inout float brightness_factor, uint64_t inscatterVolumeTexture[24], uint64_t lossTexture[24], bool godrays, uint64_t godraysVolumeTexture[24], float godraysScale, vec3 godraysTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float distanceKm, float fadeDistance, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec3 volumeTexCoords, float BetaClouds, float solidDist_nearFar[2], bool do_depth_mix, float distScale, uint idx, float opacity, float cosine, vec3 cloudTintColour)
{
vec4 clr[2];
vec4 inscatter=vec4(0,0,0,0);
brightness_factor=1.0;
clr[2-1]=calcColour2(lossTexture,inscatterVolumeTexture,volumeTexCoords,lightTableTexture,density,light,BetaClouds,lightResponse,ambientColour,world_pos,fade_texc,brightness_factor,inscatter,opacity,cloudTintColour);
clr[2-1].a*=cosine*cosine;
godraysTexCoords.z=distanceKm*godraysScale;
float gr_mult=1.0;
if(godrays)gr_mult=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),godraysTexCoords,0).x;
for(int i=0;i<2;i++)
{
clr[i]=clr[2-1];
if(do_depth_mix)
{
float m=saturate((solidDist_nearFar[i]-fadeDistance)/distScale);
clr[i].a*=m;
}

colour[i].rgb+=(clr[i].rgb)*clr[i].a*(colour[i].a);
insc[i].rgb+=gr_mult*inscatter.rgb*clr[i].a*(colour[i].a);
colour[i].a*=(1.0-clr[i].a);
}

}
#line 7 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_raytrace.sl"
RaytracePixelOutput RaytraceCloudsForward(uint64_t cloudDensity[24], uint64_t cloudLight[24], uint64_t precipitationVolume[24], uint64_t noiseTexture3D[24], uint64_t lightTableTexture[24], uint64_t illuminationTexture[24], uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], bool do_depth_mix, vec4 dlookup, vec3 view, vec4 clip_pos, vec3 volumeTexCoordsXyC, bool noise, bool do_rain_effect, bool do_rainbow, vec3 cloudIrRadiance1, vec3 cloudIrRadiance2, int num_interp, bool do_godrays, vec3 cloudTintColour)
{
RaytracePixelOutput res;
vec4 insc[2];
for(int ii=0;ii<num_interp;ii++)
{
res.colour[ii]=vec4(0,0,0,1.0);
insc[ii]=vec4(0,0,0,0);
}

res.nearFarDepth=dlookup;
float s=saturate((directionToSun.z+0.2)/0.01);
vec3 lightDirection=mix(directionToMoon,directionToSun,s);
float cos0=dot(lightDirection.xyz,view.xyz);
float sine=view.z;
float min_z=cornerPosKm.z-(fractalScale.z*1.5)/inverseScalesKm.z;
float max_z=cornerPosKm.z+(1.0+fractalScale.z*1.5)/inverseScalesKm.z;
if(do_rain_effect)min_z=-1.0;else
if(view.z<-0.01&&viewPosKm.z<cornerPosKm.z-fractalScale.z/inverseScalesKm.z)return res;
vec3 godraysTexCoords=vec3(0,0,0);
float lightspaceScale=1.0;
if(do_godrays)
{
vec3 lightspaceView=(mul(worldToScatteringVolumeMatrix,vec4(view,1.0)).xyz);
lightspaceScale=length(lightspaceView);
godraysTexCoords=vec3(fract(atan(lightspaceView.x,lightspaceView.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceView.z/lightspaceScale)*2.0/3.1415926536,0);
}

float solidDist_nearFar[2];
vec2 nfd=(dlookup.yx)+100.0*step(vec2(1.0,1.0),dlookup.yx);
solidDist_nearFar[0]=nfd.x;
solidDist_nearFar[num_interp-1]=nfd.y;
float n=nfd.x;
float f=nfd.y;
for(int l=1;l<num_interp-1;l++)
{
float interp=1.0-float(l)/float(num_interp-1);
solidDist_nearFar[l]=mix(solidDist_nearFar[0],solidDist_nearFar[num_interp-1],1.0-interp);
}

vec2 fade_texc=vec2(0.0,0.5*(1.0-sine));
vec2 illum_texc=vec2(atan(view.x,view.y)/(3.1415926536*2.0),fade_texc.y);
vec4 illum_lookup=texture(sampler2D(illuminationTexture[1 + 3]),illum_texc);
vec2 nearFarTexc=illum_lookup.xy;
float meanFadeDistance=1.0;
float minDistance=1.0;
float maxDistance=0.0;
float BetaClouds=lightResponse.x*HenyeyGreenstein(cloudEccentricity,cos0);
float BetaRayleigh=CalcRayleighBeta(cos0);
float BetaMie=HenyeyGreenstein(hazeEccentricity,cos0);
float moisture=0.0;
vec3 world_pos=viewPosKm;
view.xyz+=vec3(0.00001,0.00001,0.00001);
ivec3 c_offset=ivec3(2.0*step(vec3(0,0,0),view.xyz)-vec3(1,1,1));
ivec3 start_c_offset=-c_offset;
start_c_offset=ivec3(max(start_c_offset.x,0),max(start_c_offset.y,0),max(start_c_offset.z,0));
vec3 viewGridspace=view/scaleOfGridCoordsKm;
viewGridspace=normalize(viewGridspace);
vec3 offset_vec=vec3(0,0,0);

{
float a=1.0/(saturate(view.z)+0.00001);
offset_vec+=max(0.0,min_z-world_pos.z)*vec3(view.x*a,view.y*a,1.0);
}

vec3 halfway=0.5*(lightDirection-view);
world_pos+=offset_vec;
vec3 unitStepKm=viewGridspace*scaleOfGridCoordsKm;
float unitStepLengthKm=length(unitStepKm);
vec3 startOffsetFromOriginKm=viewPosKm-gridOriginPosKm;
vec3 offsetFromOrigin=world_pos-gridOriginPosKm;
vec3 p0=startOffsetFromOriginKm/scaleOfGridCoordsKm;
ivec3 c0=ivec3(floor(p0)+start_c_offset);
vec3 gridScale=scaleOfGridCoordsKm;
vec3 P0=startOffsetFromOriginKm/scaleOfGridCoordsKm/2.0;
ivec3 C0=c0>>1;
float distanceKm=length(offset_vec);
vec3 p_=offsetFromOrigin/scaleOfGridCoordsKm;
ivec3 c=ivec3(floor(p_)+start_c_offset);
int idx=0;
float W=halfClipSize;
const float start=0.866*0.866;
const float ends=1.0;
const float range=ends-start;
float lastFadeDistance=0.0;
ivec2 b=abs(c.xy-C0.xy*2);
vec3 amb_dir=view;
for(int j=0;j<8;j++)
{
if(max(max(b.x,b.y),0)>=W)
{
c0.xy=C0.xy;
c.xy+=start_c_offset.xy;
c.xy-=abs(c.xy&ivec2(1,1));
c.xy=c.xy>>1;
gridScale.xy*=2.0;
if(idx==0)W*=2;
p0.xy=P0.xy;
P0.xy=startOffsetFromOriginKm.xy/gridScale.xy/2.0;
C0.xy+=start_c_offset.xy;
C0.xy-=abs(C0.xy&ivec2(1,1));
C0.xy=C0.xy>>1;
viewGridspace=view/gridScale;
viewGridspace=normalize(viewGridspace);
unitStepKm=viewGridspace*gridScale;
unitStepLengthKm=length(unitStepKm);
idx++;
b=abs(c.xy-C0.xy*2);
}
else
break;
}

float distScale=0.6/maxFadeDistanceKm;
for(int i=0;i<768;i++)
{
world_pos+=0.001*view;
if((view.z<0&&world_pos.z<min_z)||(view.z>0&&world_pos.z>max_z)||distanceKm>maxCloudDistanceKm)break;
offsetFromOrigin=world_pos-gridOriginPosKm;
ivec3 c1=c+c_offset;
vec3 p=offsetFromOrigin/gridScale;
vec3 p1=vec3(c1);
vec3 dp=p1-p;
vec3 D=(dp/viewGridspace);
float e=min(min(D.x,D.y),D.z);
vec3 N=step(D,vec3(e,e,e));
ivec3 c_step=c_offset*ivec3(N);
float stepKm=e*unitStepLengthKm;
distanceKm+=stepKm;
p1=p+e*viewGridspace;
world_pos+=stepKm*view;
vec3 cloudWorldOffsetKm=world_pos-cornerPosKm;
vec3 cloudTexCoords=cloudWorldOffsetKm*inverseScalesKm;
c+=c_step;
ivec2 intermediate=abs(c.xy&ivec2(1,1));
float is_inter=dot(N.xy,vec2(intermediate));
vec3 pw=abs(p1-p0);
float fade_inter=saturate((length(pw.xy)/(float(W)*(3.0-2.0*is_inter)-1.0)-start)/range);
float fade=(1.0-fade_inter);
float fadeDistance=saturate(distanceKm/maxFadeDistanceKm);
maxDistance=max(fadeDistance,maxDistance);
b=abs(c.xy-C0.xy*2);
#line 227 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_raytrace.sl"

if(fade>0.0)
{
float mip=0.0;
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),cloudTexCoords,0.0);

{
vec3 noise_texc=world_pos.xyz*noise3DTexcoordScale+noise3DTexcoordOffset;
vec4 noiseval=vec4(0,0,0,0);
float cosine=dot(N,abs(view));
if(noise)noiseval=density.x*textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc,1.0*(fadeDistance+1.0-abs(cosine)));
vec4 light=vec4(1,1,1,1);
calcDensity(cloudDensity,cloudLight,cloudTexCoords,noiseval,fractalScale,mip,density,light);
if(do_rain_effect)
{
float dm=rainEffect*fade*GetRainAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm);
dm*=saturate(0.6+textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc+vec3(0,0,rainVerticalTexcoord),0.0).z);
moisture+=0.01*dm*light.x;
density.z=max(density.z,dm);
}

if(density.z>0)
{
density.z=saturate(0.3+(1.0+5.0*density.y)*(density.z-0.3));
minDistance=min(max(0,fadeDistance-density.z*stepKm/maxFadeDistanceKm),minDistance);
vec3 worley_texc=(world_pos.xyz+windOffsetKm.xyz)*worleyTexcoordScale+worleyOffsetKm;
vec4 worley=textureLod(sampler3D(smallWorleyTexture3D[1 + 6]),worley_texc,0);
float wo=4*density.y*(worley.w-0.6)*saturate(1.0/(12.0*fadeDistance));
density.z=mix(density.z,density.z*saturate(0.3+((density.z+wo)-0.3-saturate(0.6-density.z))),density.y);
amb_dir=mix(amb_dir,worley.xyz,0.1*density.z);
float brightness_factor;
fade_texc.x=sqrt(fadeDistance);
vec3 volumeTexCoords=vec3(volumeTexCoordsXyC.xy,fade_texc.x);
ColourStep(res.colour,insc,meanFadeDistance,brightness_factor,lossTexture,inscTexture,skylTexture,inscatterVolumeTexture,do_godrays,godraysVolumeTexture,lightspaceScale,godraysTexCoords,lightTableTexture,density,light,distanceKm,fadeDistance,world_pos,cloudTexCoords,fade_texc,nearFarTexc,cosine,volumeTexCoords,amb_dir,BetaClouds,BetaRayleigh,BetaMie,solidDist_nearFar,noise,do_depth_mix,distScale,idx,noiseval,fade,alphaSharpness);
if(res.colour[0].a*brightness_factor<0.003)
{
for(int o=0;o<num_interp;o++)res.colour[o].a=0.0;
meanFadeDistance=fadeDistance;
break;
}

}

lastFadeDistance=mix(lastFadeDistance,fadeDistance-density.z*stepKm/maxFadeDistanceKm,res.colour[num_interp-1].a);
}

}

if(max(max(b.x,b.y),0)>=W)
{
c0.xy=C0.xy;
c.xy+=start_c_offset.xy;
c.xy-=abs(c.xy&ivec2(1,1));
c.xy=c.xy>>1;
gridScale.xy*=2.0;
if(idx==0)W*=2;
p0.xy=P0.xy;
P0.xy=startOffsetFromOriginKm.xy/gridScale.xy/2.0;
C0.xy+=start_c_offset.xy;
C0.xy-=abs(C0.xy&ivec2(1,1));
C0.xy=C0.xy>>1;
viewGridspace=view/gridScale;
viewGridspace=normalize(viewGridspace);
unitStepKm=viewGridspace*gridScale;
unitStepLengthKm=length(unitStepKm);
idx++;
}

}

res.nearFarDepth.zw=vec2(meanFadeDistance,moisture);
for(int k=0;k<num_interp;k++)
{
res.colour[k].rgb+=insc[k].rgb;
}

return res;
}
#line 79 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
vec3 WorldToVolumePos(vec3 world_pos_km, vec3 centreVolumePos, vec3 vol_km)
{
vec3 vp=world_pos_km/vol_km;
return vp+centreVolumePos;
}
#line 96 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
vec3 GridToWorldPos(vec3 grid_pos, vec3 grid_km, vec3 centreVolumePosKm)
{
vec3 wp=grid_pos*grid_km-centreVolumePosKm;
return wp;
}
#line 114 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
ivec3 FloatToIntGrid(vec3 grid_pos)
{
return ivec3(floor(grid_pos));
}
#line 127 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
vec3 WorldToGridPos(vec3 world_pos_km, vec3 gridKm, vec3 centreGridPos)
{
return world_pos_km/gridKm+centreGridPos;
}
#line 132 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
RaytracePixelOutput RaytraceCloudsExperimental(uint64_t cloudDensity[24], uint64_t cloudLight[24], uint64_t precipitationVolume[24], uint64_t noiseTexture3D[24], uint64_t lightTableTexture[24], uint64_t illuminationTexture[24], uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], bool do_depth_mix, vec4 dlookup, vec3 view, vec4 clip_pos, vec3 volumeTexCoordsXyC, bool noise, bool do_rain_effect, bool do_rainbow, vec3 cloudIrRadiance1, vec3 cloudIrRadiance2, int num_interp, bool do_godrays, vec3 cloudTintColour, uint seed)
{
RaytracePixelOutput res;
vec4 insc[2];
for(int ii=0;ii<num_interp;ii++)
{
res.colour[ii]=vec4(0,0,0,1.0);
insc[ii]=vec4(0,0,0,0);
}

res.nearFarDepth=dlookup;
float s=saturate((directionToSun.z+0.2)/0.01);
vec3 lightDirection=mix(directionToMoon,directionToSun,s);
float cos0=dot(lightDirection.xyz,view.xyz);
float min_z=cornerPosKm.z-(fractalScale.z*1.5)/inverseScalesKm.z;
float max_z=cornerPosKm.z+(1.0+fractalScale.z*1.5)/inverseScalesKm.z;
if(do_rain_effect)min_z=-1.0;
vec3 godraysTexCoords=vec3(0,0,0);
float lightspaceScale=1.0;
if(do_godrays)
{
vec3 lightspaceView=(mul(worldToScatteringVolumeMatrix,vec4(view,1.0)).xyz);
lightspaceScale=length(lightspaceView);
godraysTexCoords=vec3(fract(atan(lightspaceView.x,lightspaceView.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceView.z/lightspaceScale)*2.0/3.1415926536,0);
}

float solidDist_nearFar[2];
vec2 nfd=(dlookup.yx)+100.0*step(vec2(1.0,1.0),dlookup.yx);
solidDist_nearFar[0]=nfd.x;
solidDist_nearFar[num_interp-1]=nfd.y;
for(int l=1;l<num_interp-1;l++)
{
float interp=1.0-float(l)/float(num_interp-1);
solidDist_nearFar[l]=mix(solidDist_nearFar[0],solidDist_nearFar[num_interp-1],1.0-interp);
}

float sine=view.z;
vec2 fade_texc=vec2(0.0,0.5*(1.0-sine));
vec2 illum_texc=vec2(atan(view.x,view.y)/(3.1415926536*2.0),fade_texc.y);
vec4 illum_lookup=texture(sampler2D(illuminationTexture[1 + 3]),illum_texc);
vec2 nearFarTexc=illum_lookup.xy;
float meanFadeDistance=1.0;
float BetaClouds=HenyeyGreenstein(cloudEccentricity,cos0);
float BetaRayleigh=CalcRayleighBeta(cos0);
float BetaMie=HenyeyGreenstein(hazeEccentricity,cos0);
float moisture=0.0;
vec3 world_pos_km=viewPosKm;
world_pos_km.xy-=windOffsetKm.xy;
uint mip=uint(maxMip);
uint mipscale=uint(1)<<mip;
uvec3 mip_grid=uvec3(windowGrid)/mipscale;
vec3 windowGridf=vec3(mip_grid);
vec3 centreVolumePos=vec3((typed_mod((gridCentreTexel.xy+ivec2(windowGrid.xy/2)),ivec2(windowGrid.xy))-ivec2(windowGrid.xy/2))/float(windowGrid.x),0);
vec3 gridKm=VolumeScaleKm/windowGridf;
vec3 centreVolumePosKm=VolumeScaleKm*centreVolumePos;
vec3 centreGridPos=windowGridf*centreVolumePos;
vec3 grid_pos=WorldToGridPos(world_pos_km,gridKm,centreGridPos);
vec3 grid_dir=normalize(WorldToGridPos(world_pos_km+view,gridKm,centreGridPos)-grid_pos);
ivec3 c_offset=ivec3(2.0*step(vec3(0,0,0),view.xyz)-vec3(1,1,1));
ivec3 c_next=FloatToIntGrid(grid_pos);
uint idx=0;
int count_detail=0;
vec3 amb_dir=view;
float distScale=0.6/maxFadeDistanceKm;
int i=0;
uint use_mip=0;
int steps_at_mip=0;
vec3 last_grid_pos=grid_pos;
ivec3 c_offset_x=ivec3(step(vec3(0,0,0),grid_dir.xyz));
c_offset=2*c_offset_x-ivec3(1,1,1);
float distanceLimitKm=0.f;
for(i=0;i<768;i++)
{
if((view.z<0&&world_pos_km.z<min_z)||(view.z>0&&world_pos_km.z>max_z)||distanceLimitKm>maxCloudDistanceKm)break;
vec3 prev_world_pos_km=world_pos_km;
ivec3 c=c_next;
if(mip>use_mip)
{
vec4 lookup=vec4(0,0,0,0);
ivec4 lookup_index=ivec4(typed_mod((c.xy+mip_grid.xy),mip_grid.xy),c.z,mip);
if(c.z<mip_grid.z&&c.z>=0)lookup=texelFetch(sampler3D(cloudDensity[0]),ivec3(lookup_index).xyz,int(lookup_index.w));
if(do_rain_effect)lookup.z+=rainEffect*GetPrecipitationAtOffsetKm(precipitationVolume,(world_pos_km-cornerPosKm),inverseScalesKm,float(mip)).w;
if(lookup.z!=0)
{
mip--;
mipscale=uint(1)<<mip;
mip_grid=ivec3(windowGrid)/mipscale;
windowGridf=vec3(mip_grid);
gridKm=VolumeScaleKm/windowGridf;
centreVolumePosKm=VolumeScaleKm*centreVolumePos;
centreGridPos=windowGridf*centreVolumePos;
grid_pos=WorldToGridPos(world_pos_km,gridKm,centreGridPos);
c_next=FloatToIntGrid(grid_pos);
continue;
}

ivec3 c1=c+c_offset_x;
vec3 grid_pos_1=c1;
vec3 dp=grid_pos_1-grid_pos;
vec3 D=dp/grid_dir;
float e=min(min(D.x,D.y),D.z);
vec3 N=step(D,vec3(e,e,e));
ivec3 c_step=c_offset*ivec3(N);
grid_pos+=e*grid_dir;
c_next=c+c_step;
world_pos_km=GridToWorldPos(grid_pos,gridKm,centreVolumePosKm);
vec3 step_km=world_pos_km-prev_world_pos_km;
float stepKm=length(step_km);
distanceLimitKm=length(world_pos_km-viewPosKm);
continue;
}

ivec3 c1=c+c_offset_x;
vec3 grid_pos_1=c1;
vec3 dp=grid_pos_1-grid_pos;
vec3 D=dp/grid_dir;
float e=min(min(D.x,D.y),D.z);
vec3 N=step(D,vec3(e,e,e));
ivec3 c_step=c_offset*ivec3(N);
grid_pos+=e*grid_dir;
c_next=c+c_step;
world_pos_km=GridToWorldPos(grid_pos,gridKm,centreVolumePosKm);
vec3 step_km=world_pos_km-prev_world_pos_km;
float stepKm=length(step_km);
idx=uint(mip);
vec3 sample_pos_km=world_pos_km;
vec3 cloud_tex_coords=WorldToVolumePos(sample_pos_km,centreVolumePos,VolumeScaleKm);

{
vec4 light=textureLod(sampler3D(cloudLight[1 + 7]),cloud_tex_coords,0);
vec3 noise_texc=(sample_pos_km.xyz+windOffsetKm.xyz)*noise3DTexcoordScale+noise3DTexcoordOffset;
vec4 noiseval=vec4(0,0,0,0);
if(noise)
{
vec4 noiseval1=textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc,0.0);
noiseval=light.z*noiseval1;
}

vec3 noise_adjusted_texc=cloud_tex_coords.xyz+fractalScale.xyz*(noiseval.xyz);
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),noise_adjusted_texc,use_mip);
if(do_rain_effect)
{
float dm=rainEffect*GetRainAtOffsetKm(precipitationVolume,(sample_pos_km-cornerPosKm)+((fractalScale.xyz*noiseval.xyz)/inverseScalesKm),inverseScalesKm);
dm*=saturate(0.6+textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc+vec3(0,0,rainVerticalTexcoord),0.0).z);
moisture+=0.01*dm*light.x;
density.z=max(density.z,dm);
}

if(density.z>0)
{
float distanceKm=length(world_pos_km-viewPosKm);
float fadeDistance=saturate(distanceKm/maxFadeDistanceKm);
density.z*=saturate(distanceKm/0.24);
density.z=mix(1.0/(1.0+exp(-20.0*(density.z-0.3))),density.z,density.y);
vec3 worley_texc=(sample_pos_km.xyz+windOffsetKm.xyz)*worleyTexcoordScale+worleyOffsetKm;
vec4 worley=textureLod(sampler3D(smallWorleyTexture3D[1 + 6]),worley_texc,0);
float wo=4*light.w*mix(1.0,worley.w,saturate(1.0/(12.0*fadeDistance)));
density.z=mix(density.z,density.z*saturate(0.3+((density.z+wo)-0.3-saturate(0.6-density.z))),density.y);
float brightness_factor;
fade_texc.x=sqrt(fadeDistance);
vec3 volumeTexCoords=vec3(volumeTexCoordsXyC.xy,fade_texc.x);
float opacity=density.z;
opacity=saturate(0.3+(1.0+1.0*density.w*alphaSharpness)*(opacity-0.3));
float cosine=dot(N,abs(view));
ColourStep2(res.colour,insc,brightness_factor,inscatterVolumeTexture,lossTexture,do_godrays,godraysVolumeTexture,lightspaceScale,godraysTexCoords,lightTableTexture,density,light,distanceKm,fadeDistance,world_pos_km,cloud_tex_coords,fade_texc,volumeTexCoords,BetaClouds,solidDist_nearFar,do_depth_mix,distScale,idx,opacity,cosine,cloudTintColour);
meanFadeDistance=mix(min(fadeDistance,meanFadeDistance),meanFadeDistance,(1.0-.4*density.z));
if(res.colour[0].a*brightness_factor<0.03)
{
for(int o=0;o<num_interp;o++)
{
res.colour[o].a=0.0;
}

meanFadeDistance=fadeDistance;
break;
}

continue;
}

count_detail++;
if(count_detail>2)
{
mip=maxMip;
mipscale=int(1)<<mip;
mip_grid=ivec3(windowGrid)/mipscale;
windowGridf=vec3(mip_grid);
gridKm=VolumeScaleKm/windowGridf;
centreGridPos=windowGridf*centreVolumePos;
grid_pos=WorldToGridPos(world_pos_km,gridKm,centreGridPos);
c_next=FloatToIntGrid(grid_pos);
count_detail=0;
}

}

}

res.nearFarDepth.zw=vec2(meanFadeDistance,moisture);
float grey=float(1)/100.0;
for(int k=0;k<num_interp;k++)
{
res.colour[k].rgb+=insc[k].rgb;
}

return res;
}
#line 769 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void Raytrace(uvec3 pos, bool include_rain, bool depth, int num_interp, bool do_godrays, bool experimental, bool blend)
{
vec2 texCoords=(vec2(pos.xy)+vec2(0.5,0.5))/vec2(targetTextureSize);
vec4 clip_pos=vec4(-1.0,1.0,1.0,1.0);
clip_pos.x+=2.0*texCoords.x;
clip_pos.y-=2.0*texCoords.y;
vec3 view=normalize(mul(invViewProj[pos.z],clip_pos).xyz);
vec4 dlookup=vec4(1.0,1.0,0.000001,1.0);
if(depth)
{
dlookup=textureLod(samplerCube(depthTexture[1 + 6]),view,0);
}

uint seed=0;
vec3 worldspaceVolumeTexCoordsXyC=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(view.z)/3.1415926536),0);
RaytracePixelOutput f;
if(experimental)f=RaytraceCloudsExperimental(cloudDensity,cloudDensity2,precipitationVolume,noiseTexture3D,lightTableTexture,illuminationTexture,lossTexture,inscTexture,skylTexture,volumeInscatterTexture,godraysTexture,true,dlookup,view,clip_pos,worldspaceVolumeTexCoordsXyC,true,include_rain,false,cloudIrRadiance1,cloudIrRadiance2,num_interp,do_godrays,cloudTintColour,seed);else
f=RaytraceCloudsForward(cloudDensity,cloudDensity2,precipitationVolume,noiseTexture3D,lightTableTexture,illuminationTexture,lossTexture,inscTexture,skylTexture,volumeInscatterTexture,godraysTexture,true,dlookup,view,clip_pos,worldspaceVolumeTexCoordsXyC,true,include_rain,false,cloudIrRadiance1,cloudIrRadiance2,num_interp,do_godrays,cloudTintColour);
vec4 resn=f.colour[2-1];
if(blend)
{

}

imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*(2-1))),vec4(resn));
float n=float(dlookup.y>=1.0);
for(int u=0;u<2-1;u++)
{
vec4 res=f.colour[u];
if(blend)
{

}

imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*u)),vec4(res));
}

imageStore(outputTexture3,ivec3(pos),vec4(f.nearFarDepth));
#line 860 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"

}
#line 1046 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void Edge(uvec3 g, uvec3 t, bool rain, bool depth, bool godrays, bool experimental)
{
uvec2 idx=uvec2(g.xy*4+t.xy);
uint Z=cubemapFaceIndex[g.z+t.z].x;
uvec3 pos=uvec3(targetRange[Z].xy+idx,Z);
if(pos.x>=targetRange[Z].z||pos.y>=targetRange[Z].w)return ;
vec4 u=texelFetch(sampler2DArray(updateTexture[0]),ivec3(pos).xyz,0);
if(u.g<1.0&&u.b>0.0)
{
Raytrace(pos,rain,depth,2,godrays,experimental,false);
}

}
layout(local_size_x=4, local_size_y=4, local_size_z=1) in;
void main()
{
uvec3 g = gl_WorkGroupID;
uvec3 t = gl_LocalInvocationID;
#line 1145 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
Edge(g,t,true,true,true,true);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_CS_Experimental_RaytraceNoRain_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 12) uniform CloudStaticConstants
{
	mat4 invViewProj[6];
};
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};

#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
struct RaytracePixelOutput
{
	vec4 colour[2];
	vec4 nearFarDepth;
};













layout(rgba16f, binding = 4) uniform image2DArray outputTexture1;
layout(rgba16f, binding = 5) uniform image2DArray outputTexture3;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t smallWorleyTexture3D[24];
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
	uint64_t noiseTexture3D[24];
	uint64_t godraysTexture[24];
	uint64_t volumeInscatterTexture[24];
	uint64_t skylTexture[24];
	uint64_t inscTexture[24];
	uint64_t lossTexture[24];
	uint64_t depthTexture[24];
	uint64_t illuminationTexture[24];
	uint64_t lightTableTexture[24];
	uint64_t precipitationVolume[24];
	uint64_t updateTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float CalcRayleighBeta(float cos0)
{
return (1.0+cos0*cos0);
}
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float HenyeyGreenstein(float g, float cos0)
{
float g2=g*g;
float u=1.0+g2-2.0*g*cos0;
return (1.0-g2)*pow(u,-1.5)/(4.0*3.1415926536);
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
vec3 PrecalculatedInscatterFunction(vec4 inscatter_factor, float BetaRayleigh, float BetaMie, vec3 mieRayleighRatio)
{
vec3 mr=mieRayleighRatio.xyz;
vec3 BetaTotal=(BetaRayleigh+BetaMie*mr)/(vec3(1.0,1.0,1.0)+mr);
vec3 colour=BetaTotal*inscatter_factor.rgb;
return colour;
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float GetAltTexCoord(float alt_km, float minSunlightAltitudeKm, float fadeAltitudeRangeKm)
{
float diff_km=alt_km-minSunlightAltitudeKm;
float sun_alt_texc=0.5+0.5*saturate(diff_km/fadeAltitudeRangeKm);
sun_alt_texc-=0.5*saturate(-diff_km/(minSunlightAltitudeKm+1.0));
return sun_alt_texc;
}
#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float unshadowedBrightness(float Beta, vec4 lightResponse, vec3 ambientColour)
{
return max(1.0,(Beta+lightResponse.y)+ambientColour.b);
}
#line 34 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColour(uint64_t lossTexture[24], uint64_t inscatterVolumeTexture[24], vec3 volumeTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float Beta, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec3 amb_dir, vec2 fade_texc, out float brightnessFactor, out vec4 inscatter, float fade, float alphaSharpness)
{
float alt_texc=(world_pos.z/fadeAltitudeRangeKm);
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 amb_lookup=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
ambientColour=lightResponse.w*amb_lookup.rgb;
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
vec3 ambient=amb_lookup.rgb*light.w;
vec4 c;
float l=mix(0.75,1.2,density.z);
c.rgb=(light.y*lightResponse.x*(Beta+l)+lightResponse.y*light.x)*combinedLightColour+ambient.rgb;
c.a=density.z*fade;
c.a=saturate(0.3+(1.0+1.0*density.w*alphaSharpness)*(c.a-0.3));

{
vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

inscatter=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),volumeTexCoords,0);
inscatter.rgb*=inscatter.a;
#line 62 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

}

return c;
}
#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColourSimple(uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t lightTableTexture[24], vec4 density, float Beta, float BetaRayleigh, float BetaMie, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, out float brightnessFactor)
{
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
ambientColour=lightResponse.w*textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
vec3 ambient=density.w*ambientColour.rgb;
float opacity=density.z;
vec4 c;
c.rgb=(density.y*Beta+lightResponse.y*density.x)*combinedLightColour+ambient.rgb;
c.a=opacity;
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float earthshadowFactr=saturate((fade_texc.x-nearFarTexc.x)/0.1);
#line 88 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
vec4 insc=textureLod(sampler2D(inscTexture[1 + 5]),fade_texc,0);
vec3 skyl=textureLod(sampler2D(skylTexture[1 + 5]),fade_texc,0).rgb;
vec3 inscatter=earthshadowFactr*PrecalculatedInscatterFunction(insc,BetaRayleigh,BetaMie,mieRayleighRatio);
c.rgb+=inscatter+skyl;
return c;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void calcDensity(uint64_t cloudDensity[24], uint64_t cloudLight[24], vec3 texCoords, vec4 noiseval, vec3 fractalScale, float mip, inout vec4 density, out vec4 light)
{
vec3 pos=texCoords.xyz+fractalScale.xyz*(noiseval.xyz);
density=textureLod(sampler3D(cloudDensity[1 + 7]),pos,mip);
light=textureLod(sampler3D(cloudLight[1 + 7]),texCoords,mip);
}
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 GetPrecipitationAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm, float mip)
{
vec3 rain_texc=cloudWorldOffsetKm;
rain_texc.xy+=rain_texc.z*rainTangent;
rain_texc*=inverseScalesKm;
vec3 pvSize;
ivec3 ivprecipitationVolume = textureSize(sampler3D(precipitationVolume[0]),0);
pvSize.x = ivprecipitationVolume.x;pvSize.y = ivprecipitationVolume.y;pvSize.z = ivprecipitationVolume.z;;
uint z_texel=uint(rain_texc.z*pvSize.z);
rain_texc.z=(float(z_texel)+0.5)/pvSize.z;
return textureLod(sampler3D(precipitationVolume[1 + 7]),rain_texc,mip);
}
#line 120 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float GetRainAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm)
{
vec4 rain_lookup=GetPrecipitationAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm,0.0);
return rain_lookup.x*rain_lookup.w*saturate((20.0*rain_lookup.y-cloudWorldOffsetKm.z)/2.0);
}
#line 146 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void ColourStep(inout vec4 colour[2], inout vec4 insc[2], inout float meanFadeDistance, out float brightness_factor, uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], bool godrays, uint64_t godraysVolumeTexture[24], float godraysScale, vec3 godraysTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float distanceKm, float fadeDistance, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, float cosine, vec3 volumeTexCoords, vec3 amb_dir, float BetaClouds, float BetaRayleigh, float BetaMie, float solidDist_nearFar[2], bool noise, bool do_depth_mix, float distScale, int idx, vec4 noiseval, float fade, float alphaSharpness)
{
density.z*=saturate(distanceKm/0.24);
vec4 clr[2];
vec4 inscatter=vec4(0,0,0,0);
brightness_factor=1.0;
if(noise)clr[2-1]=calcColour(lossTexture,inscatterVolumeTexture,volumeTexCoords,lightTableTexture,density,light,BetaClouds,lightResponse,ambientColour,world_pos,cloudTexCoords,amb_dir,fade_texc,brightness_factor,inscatter,fade,alphaSharpness);else
clr[2-1]=calcColourSimple(lossTexture,inscTexture,skylTexture,lightTableTexture,vec4(light.xyw,density.z),BetaClouds,BetaRayleigh,BetaMie,lightResponse,ambientColour,world_pos,cloudTexCoords,fade_texc,nearFarTexc,brightness_factor);
clr[2-1].a*=cosine*cosine;
meanFadeDistance=mix(min(fadeDistance,meanFadeDistance),meanFadeDistance,(1.0-.4*density.z));
godraysTexCoords.z=distanceKm*godraysScale;
float gr_mult=1.0;
if(godrays)gr_mult=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),godraysTexCoords,0).x;
for(int i=0;i<2;i++)
{
clr[i]=clr[2-1];
if(do_depth_mix)
{
float m=saturate((solidDist_nearFar[i]-fadeDistance)/distScale);
clr[i].a*=m;
}

colour[i].rgb+=(clr[i].rgb)*clr[i].a*(colour[i].a);
insc[i].rgb+=gr_mult*inscatter.rgb*clr[i].a*(colour[i].a);
colour[i].a*=(1.0-clr[i].a);
}

}
#line 239 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColour2(uint64_t lossTexture[24], uint64_t inscatterVolumeTexture[24], vec3 volumeTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float Beta, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec2 fade_texc, out float brightnessFactor, out vec4 inscatter, float opacity, vec3 cloudTintColour)
{
float alt_texc=(world_pos.z/fadeAltitudeRangeKm);
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 amb_lookup=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
ambientColour=lightResponse.w*amb_lookup.rgb;
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
vec3 ambient=amb_lookup.rgb*light.w;
vec4 c;
float l=1;
float combinedLightResponse=(light.y*lightResponse.x*(Beta+l)+lightResponse.y*light.x);
c.rgb=cloudTintColour*(combinedLightResponse*combinedLightColour+ambient.rgb);
c.a=opacity;

{
vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
#line 266 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

inscatter=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),volumeTexCoords,0);
inscatter.rgb*=inscatter.a;
#line 269 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

}

return c;
}
#line 272 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void ColourStep2(inout vec4 colour[2], inout vec4 insc[2], inout float brightness_factor, uint64_t inscatterVolumeTexture[24], uint64_t lossTexture[24], bool godrays, uint64_t godraysVolumeTexture[24], float godraysScale, vec3 godraysTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float distanceKm, float fadeDistance, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec3 volumeTexCoords, float BetaClouds, float solidDist_nearFar[2], bool do_depth_mix, float distScale, uint idx, float opacity, float cosine, vec3 cloudTintColour)
{
vec4 clr[2];
vec4 inscatter=vec4(0,0,0,0);
brightness_factor=1.0;
clr[2-1]=calcColour2(lossTexture,inscatterVolumeTexture,volumeTexCoords,lightTableTexture,density,light,BetaClouds,lightResponse,ambientColour,world_pos,fade_texc,brightness_factor,inscatter,opacity,cloudTintColour);
clr[2-1].a*=cosine*cosine;
godraysTexCoords.z=distanceKm*godraysScale;
float gr_mult=1.0;
if(godrays)gr_mult=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),godraysTexCoords,0).x;
for(int i=0;i<2;i++)
{
clr[i]=clr[2-1];
if(do_depth_mix)
{
float m=saturate((solidDist_nearFar[i]-fadeDistance)/distScale);
clr[i].a*=m;
}

colour[i].rgb+=(clr[i].rgb)*clr[i].a*(colour[i].a);
insc[i].rgb+=gr_mult*inscatter.rgb*clr[i].a*(colour[i].a);
colour[i].a*=(1.0-clr[i].a);
}

}
#line 7 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_raytrace.sl"
RaytracePixelOutput RaytraceCloudsForward(uint64_t cloudDensity[24], uint64_t cloudLight[24], uint64_t precipitationVolume[24], uint64_t noiseTexture3D[24], uint64_t lightTableTexture[24], uint64_t illuminationTexture[24], uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], bool do_depth_mix, vec4 dlookup, vec3 view, vec4 clip_pos, vec3 volumeTexCoordsXyC, bool noise, bool do_rain_effect, bool do_rainbow, vec3 cloudIrRadiance1, vec3 cloudIrRadiance2, int num_interp, bool do_godrays, vec3 cloudTintColour)
{
RaytracePixelOutput res;
vec4 insc[2];
for(int ii=0;ii<num_interp;ii++)
{
res.colour[ii]=vec4(0,0,0,1.0);
insc[ii]=vec4(0,0,0,0);
}

res.nearFarDepth=dlookup;
float s=saturate((directionToSun.z+0.2)/0.01);
vec3 lightDirection=mix(directionToMoon,directionToSun,s);
float cos0=dot(lightDirection.xyz,view.xyz);
float sine=view.z;
float min_z=cornerPosKm.z-(fractalScale.z*1.5)/inverseScalesKm.z;
float max_z=cornerPosKm.z+(1.0+fractalScale.z*1.5)/inverseScalesKm.z;
if(do_rain_effect)min_z=-1.0;else
if(view.z<-0.01&&viewPosKm.z<cornerPosKm.z-fractalScale.z/inverseScalesKm.z)return res;
vec3 godraysTexCoords=vec3(0,0,0);
float lightspaceScale=1.0;
if(do_godrays)
{
vec3 lightspaceView=(mul(worldToScatteringVolumeMatrix,vec4(view,1.0)).xyz);
lightspaceScale=length(lightspaceView);
godraysTexCoords=vec3(fract(atan(lightspaceView.x,lightspaceView.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceView.z/lightspaceScale)*2.0/3.1415926536,0);
}

float solidDist_nearFar[2];
vec2 nfd=(dlookup.yx)+100.0*step(vec2(1.0,1.0),dlookup.yx);
solidDist_nearFar[0]=nfd.x;
solidDist_nearFar[num_interp-1]=nfd.y;
float n=nfd.x;
float f=nfd.y;
for(int l=1;l<num_interp-1;l++)
{
float interp=1.0-float(l)/float(num_interp-1);
solidDist_nearFar[l]=mix(solidDist_nearFar[0],solidDist_nearFar[num_interp-1],1.0-interp);
}

vec2 fade_texc=vec2(0.0,0.5*(1.0-sine));
vec2 illum_texc=vec2(atan(view.x,view.y)/(3.1415926536*2.0),fade_texc.y);
vec4 illum_lookup=texture(sampler2D(illuminationTexture[1 + 3]),illum_texc);
vec2 nearFarTexc=illum_lookup.xy;
float meanFadeDistance=1.0;
float minDistance=1.0;
float maxDistance=0.0;
float BetaClouds=lightResponse.x*HenyeyGreenstein(cloudEccentricity,cos0);
float BetaRayleigh=CalcRayleighBeta(cos0);
float BetaMie=HenyeyGreenstein(hazeEccentricity,cos0);
float moisture=0.0;
vec3 world_pos=viewPosKm;
view.xyz+=vec3(0.00001,0.00001,0.00001);
ivec3 c_offset=ivec3(2.0*step(vec3(0,0,0),view.xyz)-vec3(1,1,1));
ivec3 start_c_offset=-c_offset;
start_c_offset=ivec3(max(start_c_offset.x,0),max(start_c_offset.y,0),max(start_c_offset.z,0));
vec3 viewGridspace=view/scaleOfGridCoordsKm;
viewGridspace=normalize(viewGridspace);
vec3 offset_vec=vec3(0,0,0);

{
float a=1.0/(saturate(view.z)+0.00001);
offset_vec+=max(0.0,min_z-world_pos.z)*vec3(view.x*a,view.y*a,1.0);
}

vec3 halfway=0.5*(lightDirection-view);
world_pos+=offset_vec;
vec3 unitStepKm=viewGridspace*scaleOfGridCoordsKm;
float unitStepLengthKm=length(unitStepKm);
vec3 startOffsetFromOriginKm=viewPosKm-gridOriginPosKm;
vec3 offsetFromOrigin=world_pos-gridOriginPosKm;
vec3 p0=startOffsetFromOriginKm/scaleOfGridCoordsKm;
ivec3 c0=ivec3(floor(p0)+start_c_offset);
vec3 gridScale=scaleOfGridCoordsKm;
vec3 P0=startOffsetFromOriginKm/scaleOfGridCoordsKm/2.0;
ivec3 C0=c0>>1;
float distanceKm=length(offset_vec);
vec3 p_=offsetFromOrigin/scaleOfGridCoordsKm;
ivec3 c=ivec3(floor(p_)+start_c_offset);
int idx=0;
float W=halfClipSize;
const float start=0.866*0.866;
const float ends=1.0;
const float range=ends-start;
float lastFadeDistance=0.0;
ivec2 b=abs(c.xy-C0.xy*2);
vec3 amb_dir=view;
for(int j=0;j<8;j++)
{
if(max(max(b.x,b.y),0)>=W)
{
c0.xy=C0.xy;
c.xy+=start_c_offset.xy;
c.xy-=abs(c.xy&ivec2(1,1));
c.xy=c.xy>>1;
gridScale.xy*=2.0;
if(idx==0)W*=2;
p0.xy=P0.xy;
P0.xy=startOffsetFromOriginKm.xy/gridScale.xy/2.0;
C0.xy+=start_c_offset.xy;
C0.xy-=abs(C0.xy&ivec2(1,1));
C0.xy=C0.xy>>1;
viewGridspace=view/gridScale;
viewGridspace=normalize(viewGridspace);
unitStepKm=viewGridspace*gridScale;
unitStepLengthKm=length(unitStepKm);
idx++;
b=abs(c.xy-C0.xy*2);
}
else
break;
}

float distScale=0.6/maxFadeDistanceKm;
for(int i=0;i<768;i++)
{
world_pos+=0.001*view;
if((view.z<0&&world_pos.z<min_z)||(view.z>0&&world_pos.z>max_z)||distanceKm>maxCloudDistanceKm)break;
offsetFromOrigin=world_pos-gridOriginPosKm;
ivec3 c1=c+c_offset;
vec3 p=offsetFromOrigin/gridScale;
vec3 p1=vec3(c1);
vec3 dp=p1-p;
vec3 D=(dp/viewGridspace);
float e=min(min(D.x,D.y),D.z);
vec3 N=step(D,vec3(e,e,e));
ivec3 c_step=c_offset*ivec3(N);
float stepKm=e*unitStepLengthKm;
distanceKm+=stepKm;
p1=p+e*viewGridspace;
world_pos+=stepKm*view;
vec3 cloudWorldOffsetKm=world_pos-cornerPosKm;
vec3 cloudTexCoords=cloudWorldOffsetKm*inverseScalesKm;
c+=c_step;
ivec2 intermediate=abs(c.xy&ivec2(1,1));
float is_inter=dot(N.xy,vec2(intermediate));
vec3 pw=abs(p1-p0);
float fade_inter=saturate((length(pw.xy)/(float(W)*(3.0-2.0*is_inter)-1.0)-start)/range);
float fade=(1.0-fade_inter);
float fadeDistance=saturate(distanceKm/maxFadeDistanceKm);
maxDistance=max(fadeDistance,maxDistance);
b=abs(c.xy-C0.xy*2);
#line 227 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_raytrace.sl"

if(fade>0.0)
{
float mip=0.0;
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),cloudTexCoords,0.0);

{
vec3 noise_texc=world_pos.xyz*noise3DTexcoordScale+noise3DTexcoordOffset;
vec4 noiseval=vec4(0,0,0,0);
float cosine=dot(N,abs(view));
if(noise)noiseval=density.x*textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc,1.0*(fadeDistance+1.0-abs(cosine)));
vec4 light=vec4(1,1,1,1);
calcDensity(cloudDensity,cloudLight,cloudTexCoords,noiseval,fractalScale,mip,density,light);
if(do_rain_effect)
{
float dm=rainEffect*fade*GetRainAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm);
dm*=saturate(0.6+textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc+vec3(0,0,rainVerticalTexcoord),0.0).z);
moisture+=0.01*dm*light.x;
density.z=max(density.z,dm);
}

if(density.z>0)
{
density.z=saturate(0.3+(1.0+5.0*density.y)*(density.z-0.3));
minDistance=min(max(0,fadeDistance-density.z*stepKm/maxFadeDistanceKm),minDistance);
vec3 worley_texc=(world_pos.xyz+windOffsetKm.xyz)*worleyTexcoordScale+worleyOffsetKm;
vec4 worley=textureLod(sampler3D(smallWorleyTexture3D[1 + 6]),worley_texc,0);
float wo=4*density.y*(worley.w-0.6)*saturate(1.0/(12.0*fadeDistance));
density.z=mix(density.z,density.z*saturate(0.3+((density.z+wo)-0.3-saturate(0.6-density.z))),density.y);
amb_dir=mix(amb_dir,worley.xyz,0.1*density.z);
float brightness_factor;
fade_texc.x=sqrt(fadeDistance);
vec3 volumeTexCoords=vec3(volumeTexCoordsXyC.xy,fade_texc.x);
ColourStep(res.colour,insc,meanFadeDistance,brightness_factor,lossTexture,inscTexture,skylTexture,inscatterVolumeTexture,do_godrays,godraysVolumeTexture,lightspaceScale,godraysTexCoords,lightTableTexture,density,light,distanceKm,fadeDistance,world_pos,cloudTexCoords,fade_texc,nearFarTexc,cosine,volumeTexCoords,amb_dir,BetaClouds,BetaRayleigh,BetaMie,solidDist_nearFar,noise,do_depth_mix,distScale,idx,noiseval,fade,alphaSharpness);
if(res.colour[0].a*brightness_factor<0.003)
{
for(int o=0;o<num_interp;o++)res.colour[o].a=0.0;
meanFadeDistance=fadeDistance;
break;
}

}

lastFadeDistance=mix(lastFadeDistance,fadeDistance-density.z*stepKm/maxFadeDistanceKm,res.colour[num_interp-1].a);
}

}

if(max(max(b.x,b.y),0)>=W)
{
c0.xy=C0.xy;
c.xy+=start_c_offset.xy;
c.xy-=abs(c.xy&ivec2(1,1));
c.xy=c.xy>>1;
gridScale.xy*=2.0;
if(idx==0)W*=2;
p0.xy=P0.xy;
P0.xy=startOffsetFromOriginKm.xy/gridScale.xy/2.0;
C0.xy+=start_c_offset.xy;
C0.xy-=abs(C0.xy&ivec2(1,1));
C0.xy=C0.xy>>1;
viewGridspace=view/gridScale;
viewGridspace=normalize(viewGridspace);
unitStepKm=viewGridspace*gridScale;
unitStepLengthKm=length(unitStepKm);
idx++;
}

}

res.nearFarDepth.zw=vec2(meanFadeDistance,moisture);
for(int k=0;k<num_interp;k++)
{
res.colour[k].rgb+=insc[k].rgb;
}

return res;
}
#line 79 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
vec3 WorldToVolumePos(vec3 world_pos_km, vec3 centreVolumePos, vec3 vol_km)
{
vec3 vp=world_pos_km/vol_km;
return vp+centreVolumePos;
}
#line 96 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
vec3 GridToWorldPos(vec3 grid_pos, vec3 grid_km, vec3 centreVolumePosKm)
{
vec3 wp=grid_pos*grid_km-centreVolumePosKm;
return wp;
}
#line 114 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
ivec3 FloatToIntGrid(vec3 grid_pos)
{
return ivec3(floor(grid_pos));
}
#line 127 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
vec3 WorldToGridPos(vec3 world_pos_km, vec3 gridKm, vec3 centreGridPos)
{
return world_pos_km/gridKm+centreGridPos;
}
#line 132 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
RaytracePixelOutput RaytraceCloudsExperimental(uint64_t cloudDensity[24], uint64_t cloudLight[24], uint64_t precipitationVolume[24], uint64_t noiseTexture3D[24], uint64_t lightTableTexture[24], uint64_t illuminationTexture[24], uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], bool do_depth_mix, vec4 dlookup, vec3 view, vec4 clip_pos, vec3 volumeTexCoordsXyC, bool noise, bool do_rain_effect, bool do_rainbow, vec3 cloudIrRadiance1, vec3 cloudIrRadiance2, int num_interp, bool do_godrays, vec3 cloudTintColour, uint seed)
{
RaytracePixelOutput res;
vec4 insc[2];
for(int ii=0;ii<num_interp;ii++)
{
res.colour[ii]=vec4(0,0,0,1.0);
insc[ii]=vec4(0,0,0,0);
}

res.nearFarDepth=dlookup;
float s=saturate((directionToSun.z+0.2)/0.01);
vec3 lightDirection=mix(directionToMoon,directionToSun,s);
float cos0=dot(lightDirection.xyz,view.xyz);
float min_z=cornerPosKm.z-(fractalScale.z*1.5)/inverseScalesKm.z;
float max_z=cornerPosKm.z+(1.0+fractalScale.z*1.5)/inverseScalesKm.z;
if(do_rain_effect)min_z=-1.0;
vec3 godraysTexCoords=vec3(0,0,0);
float lightspaceScale=1.0;
if(do_godrays)
{
vec3 lightspaceView=(mul(worldToScatteringVolumeMatrix,vec4(view,1.0)).xyz);
lightspaceScale=length(lightspaceView);
godraysTexCoords=vec3(fract(atan(lightspaceView.x,lightspaceView.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceView.z/lightspaceScale)*2.0/3.1415926536,0);
}

float solidDist_nearFar[2];
vec2 nfd=(dlookup.yx)+100.0*step(vec2(1.0,1.0),dlookup.yx);
solidDist_nearFar[0]=nfd.x;
solidDist_nearFar[num_interp-1]=nfd.y;
for(int l=1;l<num_interp-1;l++)
{
float interp=1.0-float(l)/float(num_interp-1);
solidDist_nearFar[l]=mix(solidDist_nearFar[0],solidDist_nearFar[num_interp-1],1.0-interp);
}

float sine=view.z;
vec2 fade_texc=vec2(0.0,0.5*(1.0-sine));
vec2 illum_texc=vec2(atan(view.x,view.y)/(3.1415926536*2.0),fade_texc.y);
vec4 illum_lookup=texture(sampler2D(illuminationTexture[1 + 3]),illum_texc);
vec2 nearFarTexc=illum_lookup.xy;
float meanFadeDistance=1.0;
float BetaClouds=HenyeyGreenstein(cloudEccentricity,cos0);
float BetaRayleigh=CalcRayleighBeta(cos0);
float BetaMie=HenyeyGreenstein(hazeEccentricity,cos0);
float moisture=0.0;
vec3 world_pos_km=viewPosKm;
world_pos_km.xy-=windOffsetKm.xy;
uint mip=uint(maxMip);
uint mipscale=uint(1)<<mip;
uvec3 mip_grid=uvec3(windowGrid)/mipscale;
vec3 windowGridf=vec3(mip_grid);
vec3 centreVolumePos=vec3((typed_mod((gridCentreTexel.xy+ivec2(windowGrid.xy/2)),ivec2(windowGrid.xy))-ivec2(windowGrid.xy/2))/float(windowGrid.x),0);
vec3 gridKm=VolumeScaleKm/windowGridf;
vec3 centreVolumePosKm=VolumeScaleKm*centreVolumePos;
vec3 centreGridPos=windowGridf*centreVolumePos;
vec3 grid_pos=WorldToGridPos(world_pos_km,gridKm,centreGridPos);
vec3 grid_dir=normalize(WorldToGridPos(world_pos_km+view,gridKm,centreGridPos)-grid_pos);
ivec3 c_offset=ivec3(2.0*step(vec3(0,0,0),view.xyz)-vec3(1,1,1));
ivec3 c_next=FloatToIntGrid(grid_pos);
uint idx=0;
int count_detail=0;
vec3 amb_dir=view;
float distScale=0.6/maxFadeDistanceKm;
int i=0;
uint use_mip=0;
int steps_at_mip=0;
vec3 last_grid_pos=grid_pos;
ivec3 c_offset_x=ivec3(step(vec3(0,0,0),grid_dir.xyz));
c_offset=2*c_offset_x-ivec3(1,1,1);
float distanceLimitKm=0.f;
for(i=0;i<768;i++)
{
if((view.z<0&&world_pos_km.z<min_z)||(view.z>0&&world_pos_km.z>max_z)||distanceLimitKm>maxCloudDistanceKm)break;
vec3 prev_world_pos_km=world_pos_km;
ivec3 c=c_next;
if(mip>use_mip)
{
vec4 lookup=vec4(0,0,0,0);
ivec4 lookup_index=ivec4(typed_mod((c.xy+mip_grid.xy),mip_grid.xy),c.z,mip);
if(c.z<mip_grid.z&&c.z>=0)lookup=texelFetch(sampler3D(cloudDensity[0]),ivec3(lookup_index).xyz,int(lookup_index.w));
if(do_rain_effect)lookup.z+=rainEffect*GetPrecipitationAtOffsetKm(precipitationVolume,(world_pos_km-cornerPosKm),inverseScalesKm,float(mip)).w;
if(lookup.z!=0)
{
mip--;
mipscale=uint(1)<<mip;
mip_grid=ivec3(windowGrid)/mipscale;
windowGridf=vec3(mip_grid);
gridKm=VolumeScaleKm/windowGridf;
centreVolumePosKm=VolumeScaleKm*centreVolumePos;
centreGridPos=windowGridf*centreVolumePos;
grid_pos=WorldToGridPos(world_pos_km,gridKm,centreGridPos);
c_next=FloatToIntGrid(grid_pos);
continue;
}

ivec3 c1=c+c_offset_x;
vec3 grid_pos_1=c1;
vec3 dp=grid_pos_1-grid_pos;
vec3 D=dp/grid_dir;
float e=min(min(D.x,D.y),D.z);
vec3 N=step(D,vec3(e,e,e));
ivec3 c_step=c_offset*ivec3(N);
grid_pos+=e*grid_dir;
c_next=c+c_step;
world_pos_km=GridToWorldPos(grid_pos,gridKm,centreVolumePosKm);
vec3 step_km=world_pos_km-prev_world_pos_km;
float stepKm=length(step_km);
distanceLimitKm=length(world_pos_km-viewPosKm);
continue;
}

ivec3 c1=c+c_offset_x;
vec3 grid_pos_1=c1;
vec3 dp=grid_pos_1-grid_pos;
vec3 D=dp/grid_dir;
float e=min(min(D.x,D.y),D.z);
vec3 N=step(D,vec3(e,e,e));
ivec3 c_step=c_offset*ivec3(N);
grid_pos+=e*grid_dir;
c_next=c+c_step;
world_pos_km=GridToWorldPos(grid_pos,gridKm,centreVolumePosKm);
vec3 step_km=world_pos_km-prev_world_pos_km;
float stepKm=length(step_km);
idx=uint(mip);
vec3 sample_pos_km=world_pos_km;
vec3 cloud_tex_coords=WorldToVolumePos(sample_pos_km,centreVolumePos,VolumeScaleKm);

{
vec4 light=textureLod(sampler3D(cloudLight[1 + 7]),cloud_tex_coords,0);
vec3 noise_texc=(sample_pos_km.xyz+windOffsetKm.xyz)*noise3DTexcoordScale+noise3DTexcoordOffset;
vec4 noiseval=vec4(0,0,0,0);
if(noise)
{
vec4 noiseval1=textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc,0.0);
noiseval=light.z*noiseval1;
}

vec3 noise_adjusted_texc=cloud_tex_coords.xyz+fractalScale.xyz*(noiseval.xyz);
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),noise_adjusted_texc,use_mip);
if(do_rain_effect)
{
float dm=rainEffect*GetRainAtOffsetKm(precipitationVolume,(sample_pos_km-cornerPosKm)+((fractalScale.xyz*noiseval.xyz)/inverseScalesKm),inverseScalesKm);
dm*=saturate(0.6+textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc+vec3(0,0,rainVerticalTexcoord),0.0).z);
moisture+=0.01*dm*light.x;
density.z=max(density.z,dm);
}

if(density.z>0)
{
float distanceKm=length(world_pos_km-viewPosKm);
float fadeDistance=saturate(distanceKm/maxFadeDistanceKm);
density.z*=saturate(distanceKm/0.24);
density.z=mix(1.0/(1.0+exp(-20.0*(density.z-0.3))),density.z,density.y);
vec3 worley_texc=(sample_pos_km.xyz+windOffsetKm.xyz)*worleyTexcoordScale+worleyOffsetKm;
vec4 worley=textureLod(sampler3D(smallWorleyTexture3D[1 + 6]),worley_texc,0);
float wo=4*light.w*mix(1.0,worley.w,saturate(1.0/(12.0*fadeDistance)));
density.z=mix(density.z,density.z*saturate(0.3+((density.z+wo)-0.3-saturate(0.6-density.z))),density.y);
float brightness_factor;
fade_texc.x=sqrt(fadeDistance);
vec3 volumeTexCoords=vec3(volumeTexCoordsXyC.xy,fade_texc.x);
float opacity=density.z;
opacity=saturate(0.3+(1.0+1.0*density.w*alphaSharpness)*(opacity-0.3));
float cosine=dot(N,abs(view));
ColourStep2(res.colour,insc,brightness_factor,inscatterVolumeTexture,lossTexture,do_godrays,godraysVolumeTexture,lightspaceScale,godraysTexCoords,lightTableTexture,density,light,distanceKm,fadeDistance,world_pos_km,cloud_tex_coords,fade_texc,volumeTexCoords,BetaClouds,solidDist_nearFar,do_depth_mix,distScale,idx,opacity,cosine,cloudTintColour);
meanFadeDistance=mix(min(fadeDistance,meanFadeDistance),meanFadeDistance,(1.0-.4*density.z));
if(res.colour[0].a*brightness_factor<0.03)
{
for(int o=0;o<num_interp;o++)
{
res.colour[o].a=0.0;
}

meanFadeDistance=fadeDistance;
break;
}

continue;
}

count_detail++;
if(count_detail>2)
{
mip=maxMip;
mipscale=int(1)<<mip;
mip_grid=ivec3(windowGrid)/mipscale;
windowGridf=vec3(mip_grid);
gridKm=VolumeScaleKm/windowGridf;
centreGridPos=windowGridf*centreVolumePos;
grid_pos=WorldToGridPos(world_pos_km,gridKm,centreGridPos);
c_next=FloatToIntGrid(grid_pos);
count_detail=0;
}

}

}

res.nearFarDepth.zw=vec2(meanFadeDistance,moisture);
float grey=float(1)/100.0;
for(int k=0;k<num_interp;k++)
{
res.colour[k].rgb+=insc[k].rgb;
}

return res;
}
#line 769 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void Raytrace(uvec3 pos, bool include_rain, bool depth, int num_interp, bool do_godrays, bool experimental, bool blend)
{
vec2 texCoords=(vec2(pos.xy)+vec2(0.5,0.5))/vec2(targetTextureSize);
vec4 clip_pos=vec4(-1.0,1.0,1.0,1.0);
clip_pos.x+=2.0*texCoords.x;
clip_pos.y-=2.0*texCoords.y;
vec3 view=normalize(mul(invViewProj[pos.z],clip_pos).xyz);
vec4 dlookup=vec4(1.0,1.0,0.000001,1.0);
if(depth)
{
dlookup=textureLod(samplerCube(depthTexture[1 + 6]),view,0);
}

uint seed=0;
vec3 worldspaceVolumeTexCoordsXyC=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(view.z)/3.1415926536),0);
RaytracePixelOutput f;
if(experimental)f=RaytraceCloudsExperimental(cloudDensity,cloudDensity2,precipitationVolume,noiseTexture3D,lightTableTexture,illuminationTexture,lossTexture,inscTexture,skylTexture,volumeInscatterTexture,godraysTexture,true,dlookup,view,clip_pos,worldspaceVolumeTexCoordsXyC,true,include_rain,false,cloudIrRadiance1,cloudIrRadiance2,num_interp,do_godrays,cloudTintColour,seed);else
f=RaytraceCloudsForward(cloudDensity,cloudDensity2,precipitationVolume,noiseTexture3D,lightTableTexture,illuminationTexture,lossTexture,inscTexture,skylTexture,volumeInscatterTexture,godraysTexture,true,dlookup,view,clip_pos,worldspaceVolumeTexCoordsXyC,true,include_rain,false,cloudIrRadiance1,cloudIrRadiance2,num_interp,do_godrays,cloudTintColour);
vec4 resn=f.colour[2-1];
if(blend)
{

}

imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*(2-1))),vec4(resn));
float n=float(dlookup.y>=1.0);
for(int u=0;u<2-1;u++)
{
vec4 res=f.colour[u];
if(blend)
{

}

imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*u)),vec4(res));
}

imageStore(outputTexture3,ivec3(pos),vec4(f.nearFarDepth));
#line 860 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"

}
#line 901 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void CS_Raytrace(uvec3 g, uvec3 t, bool include_rain, bool depth, bool godrays, bool experimental)
{
uvec2 idx=uvec2(g.xy*4+t.xy);
uint Z=cubemapFaceIndex[g.z+t.z].x;
uvec3 pos=uvec3(targetRange[Z].xy+idx*amortizationScale.xy,Z);
uvec2 offs=amortizationOffset.xy;
pos.xy+=offs;
if(pos.x>=edge.x||pos.y>=edge.y)return ;
if(pos.x>=targetRange[Z].z||pos.y>=targetRange[Z].w)return ;
if(texelFetch(sampler2DArray(updateTexture[0]),ivec3(pos).xyz,0).b==0.0)return ;
Raytrace(pos,include_rain,depth,2,godrays,experimental,true);
}
layout(local_size_x=4, local_size_y=4, local_size_z=1) in;
void main()
{
uvec3 g = gl_WorkGroupID;
uvec3 t = gl_LocalInvocationID;
#line 1133 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
CS_Raytrace(g,t,false,true,true,true);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_CS_Experimental_RaytraceRain_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 12) uniform CloudStaticConstants
{
	mat4 invViewProj[6];
};
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};

#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
struct RaytracePixelOutput
{
	vec4 colour[2];
	vec4 nearFarDepth;
};













layout(rgba16f, binding = 4) uniform image2DArray outputTexture1;
layout(rgba16f, binding = 5) uniform image2DArray outputTexture3;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t smallWorleyTexture3D[24];
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
	uint64_t noiseTexture3D[24];
	uint64_t godraysTexture[24];
	uint64_t volumeInscatterTexture[24];
	uint64_t skylTexture[24];
	uint64_t inscTexture[24];
	uint64_t lossTexture[24];
	uint64_t depthTexture[24];
	uint64_t illuminationTexture[24];
	uint64_t lightTableTexture[24];
	uint64_t precipitationVolume[24];
	uint64_t updateTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float CalcRayleighBeta(float cos0)
{
return (1.0+cos0*cos0);
}
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float HenyeyGreenstein(float g, float cos0)
{
float g2=g*g;
float u=1.0+g2-2.0*g*cos0;
return (1.0-g2)*pow(u,-1.5)/(4.0*3.1415926536);
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
vec3 PrecalculatedInscatterFunction(vec4 inscatter_factor, float BetaRayleigh, float BetaMie, vec3 mieRayleighRatio)
{
vec3 mr=mieRayleighRatio.xyz;
vec3 BetaTotal=(BetaRayleigh+BetaMie*mr)/(vec3(1.0,1.0,1.0)+mr);
vec3 colour=BetaTotal*inscatter_factor.rgb;
return colour;
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float GetAltTexCoord(float alt_km, float minSunlightAltitudeKm, float fadeAltitudeRangeKm)
{
float diff_km=alt_km-minSunlightAltitudeKm;
float sun_alt_texc=0.5+0.5*saturate(diff_km/fadeAltitudeRangeKm);
sun_alt_texc-=0.5*saturate(-diff_km/(minSunlightAltitudeKm+1.0));
return sun_alt_texc;
}
#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float unshadowedBrightness(float Beta, vec4 lightResponse, vec3 ambientColour)
{
return max(1.0,(Beta+lightResponse.y)+ambientColour.b);
}
#line 34 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColour(uint64_t lossTexture[24], uint64_t inscatterVolumeTexture[24], vec3 volumeTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float Beta, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec3 amb_dir, vec2 fade_texc, out float brightnessFactor, out vec4 inscatter, float fade, float alphaSharpness)
{
float alt_texc=(world_pos.z/fadeAltitudeRangeKm);
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 amb_lookup=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
ambientColour=lightResponse.w*amb_lookup.rgb;
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
vec3 ambient=amb_lookup.rgb*light.w;
vec4 c;
float l=mix(0.75,1.2,density.z);
c.rgb=(light.y*lightResponse.x*(Beta+l)+lightResponse.y*light.x)*combinedLightColour+ambient.rgb;
c.a=density.z*fade;
c.a=saturate(0.3+(1.0+1.0*density.w*alphaSharpness)*(c.a-0.3));

{
vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

inscatter=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),volumeTexCoords,0);
inscatter.rgb*=inscatter.a;
#line 62 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

}

return c;
}
#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColourSimple(uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t lightTableTexture[24], vec4 density, float Beta, float BetaRayleigh, float BetaMie, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, out float brightnessFactor)
{
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
ambientColour=lightResponse.w*textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
vec3 ambient=density.w*ambientColour.rgb;
float opacity=density.z;
vec4 c;
c.rgb=(density.y*Beta+lightResponse.y*density.x)*combinedLightColour+ambient.rgb;
c.a=opacity;
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float earthshadowFactr=saturate((fade_texc.x-nearFarTexc.x)/0.1);
#line 88 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
vec4 insc=textureLod(sampler2D(inscTexture[1 + 5]),fade_texc,0);
vec3 skyl=textureLod(sampler2D(skylTexture[1 + 5]),fade_texc,0).rgb;
vec3 inscatter=earthshadowFactr*PrecalculatedInscatterFunction(insc,BetaRayleigh,BetaMie,mieRayleighRatio);
c.rgb+=inscatter+skyl;
return c;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void calcDensity(uint64_t cloudDensity[24], uint64_t cloudLight[24], vec3 texCoords, vec4 noiseval, vec3 fractalScale, float mip, inout vec4 density, out vec4 light)
{
vec3 pos=texCoords.xyz+fractalScale.xyz*(noiseval.xyz);
density=textureLod(sampler3D(cloudDensity[1 + 7]),pos,mip);
light=textureLod(sampler3D(cloudLight[1 + 7]),texCoords,mip);
}
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 GetPrecipitationAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm, float mip)
{
vec3 rain_texc=cloudWorldOffsetKm;
rain_texc.xy+=rain_texc.z*rainTangent;
rain_texc*=inverseScalesKm;
vec3 pvSize;
ivec3 ivprecipitationVolume = textureSize(sampler3D(precipitationVolume[0]),0);
pvSize.x = ivprecipitationVolume.x;pvSize.y = ivprecipitationVolume.y;pvSize.z = ivprecipitationVolume.z;;
uint z_texel=uint(rain_texc.z*pvSize.z);
rain_texc.z=(float(z_texel)+0.5)/pvSize.z;
return textureLod(sampler3D(precipitationVolume[1 + 7]),rain_texc,mip);
}
#line 120 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float GetRainAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm)
{
vec4 rain_lookup=GetPrecipitationAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm,0.0);
return rain_lookup.x*rain_lookup.w*saturate((20.0*rain_lookup.y-cloudWorldOffsetKm.z)/2.0);
}
#line 146 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void ColourStep(inout vec4 colour[2], inout vec4 insc[2], inout float meanFadeDistance, out float brightness_factor, uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], bool godrays, uint64_t godraysVolumeTexture[24], float godraysScale, vec3 godraysTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float distanceKm, float fadeDistance, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, float cosine, vec3 volumeTexCoords, vec3 amb_dir, float BetaClouds, float BetaRayleigh, float BetaMie, float solidDist_nearFar[2], bool noise, bool do_depth_mix, float distScale, int idx, vec4 noiseval, float fade, float alphaSharpness)
{
density.z*=saturate(distanceKm/0.24);
vec4 clr[2];
vec4 inscatter=vec4(0,0,0,0);
brightness_factor=1.0;
if(noise)clr[2-1]=calcColour(lossTexture,inscatterVolumeTexture,volumeTexCoords,lightTableTexture,density,light,BetaClouds,lightResponse,ambientColour,world_pos,cloudTexCoords,amb_dir,fade_texc,brightness_factor,inscatter,fade,alphaSharpness);else
clr[2-1]=calcColourSimple(lossTexture,inscTexture,skylTexture,lightTableTexture,vec4(light.xyw,density.z),BetaClouds,BetaRayleigh,BetaMie,lightResponse,ambientColour,world_pos,cloudTexCoords,fade_texc,nearFarTexc,brightness_factor);
clr[2-1].a*=cosine*cosine;
meanFadeDistance=mix(min(fadeDistance,meanFadeDistance),meanFadeDistance,(1.0-.4*density.z));
godraysTexCoords.z=distanceKm*godraysScale;
float gr_mult=1.0;
if(godrays)gr_mult=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),godraysTexCoords,0).x;
for(int i=0;i<2;i++)
{
clr[i]=clr[2-1];
if(do_depth_mix)
{
float m=saturate((solidDist_nearFar[i]-fadeDistance)/distScale);
clr[i].a*=m;
}

colour[i].rgb+=(clr[i].rgb)*clr[i].a*(colour[i].a);
insc[i].rgb+=gr_mult*inscatter.rgb*clr[i].a*(colour[i].a);
colour[i].a*=(1.0-clr[i].a);
}

}
#line 239 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColour2(uint64_t lossTexture[24], uint64_t inscatterVolumeTexture[24], vec3 volumeTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float Beta, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec2 fade_texc, out float brightnessFactor, out vec4 inscatter, float opacity, vec3 cloudTintColour)
{
float alt_texc=(world_pos.z/fadeAltitudeRangeKm);
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 amb_lookup=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
ambientColour=lightResponse.w*amb_lookup.rgb;
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
vec3 ambient=amb_lookup.rgb*light.w;
vec4 c;
float l=1;
float combinedLightResponse=(light.y*lightResponse.x*(Beta+l)+lightResponse.y*light.x);
c.rgb=cloudTintColour*(combinedLightResponse*combinedLightColour+ambient.rgb);
c.a=opacity;

{
vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
#line 266 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

inscatter=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),volumeTexCoords,0);
inscatter.rgb*=inscatter.a;
#line 269 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

}

return c;
}
#line 272 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void ColourStep2(inout vec4 colour[2], inout vec4 insc[2], inout float brightness_factor, uint64_t inscatterVolumeTexture[24], uint64_t lossTexture[24], bool godrays, uint64_t godraysVolumeTexture[24], float godraysScale, vec3 godraysTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float distanceKm, float fadeDistance, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec3 volumeTexCoords, float BetaClouds, float solidDist_nearFar[2], bool do_depth_mix, float distScale, uint idx, float opacity, float cosine, vec3 cloudTintColour)
{
vec4 clr[2];
vec4 inscatter=vec4(0,0,0,0);
brightness_factor=1.0;
clr[2-1]=calcColour2(lossTexture,inscatterVolumeTexture,volumeTexCoords,lightTableTexture,density,light,BetaClouds,lightResponse,ambientColour,world_pos,fade_texc,brightness_factor,inscatter,opacity,cloudTintColour);
clr[2-1].a*=cosine*cosine;
godraysTexCoords.z=distanceKm*godraysScale;
float gr_mult=1.0;
if(godrays)gr_mult=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),godraysTexCoords,0).x;
for(int i=0;i<2;i++)
{
clr[i]=clr[2-1];
if(do_depth_mix)
{
float m=saturate((solidDist_nearFar[i]-fadeDistance)/distScale);
clr[i].a*=m;
}

colour[i].rgb+=(clr[i].rgb)*clr[i].a*(colour[i].a);
insc[i].rgb+=gr_mult*inscatter.rgb*clr[i].a*(colour[i].a);
colour[i].a*=(1.0-clr[i].a);
}

}
#line 7 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_raytrace.sl"
RaytracePixelOutput RaytraceCloudsForward(uint64_t cloudDensity[24], uint64_t cloudLight[24], uint64_t precipitationVolume[24], uint64_t noiseTexture3D[24], uint64_t lightTableTexture[24], uint64_t illuminationTexture[24], uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], bool do_depth_mix, vec4 dlookup, vec3 view, vec4 clip_pos, vec3 volumeTexCoordsXyC, bool noise, bool do_rain_effect, bool do_rainbow, vec3 cloudIrRadiance1, vec3 cloudIrRadiance2, int num_interp, bool do_godrays, vec3 cloudTintColour)
{
RaytracePixelOutput res;
vec4 insc[2];
for(int ii=0;ii<num_interp;ii++)
{
res.colour[ii]=vec4(0,0,0,1.0);
insc[ii]=vec4(0,0,0,0);
}

res.nearFarDepth=dlookup;
float s=saturate((directionToSun.z+0.2)/0.01);
vec3 lightDirection=mix(directionToMoon,directionToSun,s);
float cos0=dot(lightDirection.xyz,view.xyz);
float sine=view.z;
float min_z=cornerPosKm.z-(fractalScale.z*1.5)/inverseScalesKm.z;
float max_z=cornerPosKm.z+(1.0+fractalScale.z*1.5)/inverseScalesKm.z;
if(do_rain_effect)min_z=-1.0;else
if(view.z<-0.01&&viewPosKm.z<cornerPosKm.z-fractalScale.z/inverseScalesKm.z)return res;
vec3 godraysTexCoords=vec3(0,0,0);
float lightspaceScale=1.0;
if(do_godrays)
{
vec3 lightspaceView=(mul(worldToScatteringVolumeMatrix,vec4(view,1.0)).xyz);
lightspaceScale=length(lightspaceView);
godraysTexCoords=vec3(fract(atan(lightspaceView.x,lightspaceView.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceView.z/lightspaceScale)*2.0/3.1415926536,0);
}

float solidDist_nearFar[2];
vec2 nfd=(dlookup.yx)+100.0*step(vec2(1.0,1.0),dlookup.yx);
solidDist_nearFar[0]=nfd.x;
solidDist_nearFar[num_interp-1]=nfd.y;
float n=nfd.x;
float f=nfd.y;
for(int l=1;l<num_interp-1;l++)
{
float interp=1.0-float(l)/float(num_interp-1);
solidDist_nearFar[l]=mix(solidDist_nearFar[0],solidDist_nearFar[num_interp-1],1.0-interp);
}

vec2 fade_texc=vec2(0.0,0.5*(1.0-sine));
vec2 illum_texc=vec2(atan(view.x,view.y)/(3.1415926536*2.0),fade_texc.y);
vec4 illum_lookup=texture(sampler2D(illuminationTexture[1 + 3]),illum_texc);
vec2 nearFarTexc=illum_lookup.xy;
float meanFadeDistance=1.0;
float minDistance=1.0;
float maxDistance=0.0;
float BetaClouds=lightResponse.x*HenyeyGreenstein(cloudEccentricity,cos0);
float BetaRayleigh=CalcRayleighBeta(cos0);
float BetaMie=HenyeyGreenstein(hazeEccentricity,cos0);
float moisture=0.0;
vec3 world_pos=viewPosKm;
view.xyz+=vec3(0.00001,0.00001,0.00001);
ivec3 c_offset=ivec3(2.0*step(vec3(0,0,0),view.xyz)-vec3(1,1,1));
ivec3 start_c_offset=-c_offset;
start_c_offset=ivec3(max(start_c_offset.x,0),max(start_c_offset.y,0),max(start_c_offset.z,0));
vec3 viewGridspace=view/scaleOfGridCoordsKm;
viewGridspace=normalize(viewGridspace);
vec3 offset_vec=vec3(0,0,0);

{
float a=1.0/(saturate(view.z)+0.00001);
offset_vec+=max(0.0,min_z-world_pos.z)*vec3(view.x*a,view.y*a,1.0);
}

vec3 halfway=0.5*(lightDirection-view);
world_pos+=offset_vec;
vec3 unitStepKm=viewGridspace*scaleOfGridCoordsKm;
float unitStepLengthKm=length(unitStepKm);
vec3 startOffsetFromOriginKm=viewPosKm-gridOriginPosKm;
vec3 offsetFromOrigin=world_pos-gridOriginPosKm;
vec3 p0=startOffsetFromOriginKm/scaleOfGridCoordsKm;
ivec3 c0=ivec3(floor(p0)+start_c_offset);
vec3 gridScale=scaleOfGridCoordsKm;
vec3 P0=startOffsetFromOriginKm/scaleOfGridCoordsKm/2.0;
ivec3 C0=c0>>1;
float distanceKm=length(offset_vec);
vec3 p_=offsetFromOrigin/scaleOfGridCoordsKm;
ivec3 c=ivec3(floor(p_)+start_c_offset);
int idx=0;
float W=halfClipSize;
const float start=0.866*0.866;
const float ends=1.0;
const float range=ends-start;
float lastFadeDistance=0.0;
ivec2 b=abs(c.xy-C0.xy*2);
vec3 amb_dir=view;
for(int j=0;j<8;j++)
{
if(max(max(b.x,b.y),0)>=W)
{
c0.xy=C0.xy;
c.xy+=start_c_offset.xy;
c.xy-=abs(c.xy&ivec2(1,1));
c.xy=c.xy>>1;
gridScale.xy*=2.0;
if(idx==0)W*=2;
p0.xy=P0.xy;
P0.xy=startOffsetFromOriginKm.xy/gridScale.xy/2.0;
C0.xy+=start_c_offset.xy;
C0.xy-=abs(C0.xy&ivec2(1,1));
C0.xy=C0.xy>>1;
viewGridspace=view/gridScale;
viewGridspace=normalize(viewGridspace);
unitStepKm=viewGridspace*gridScale;
unitStepLengthKm=length(unitStepKm);
idx++;
b=abs(c.xy-C0.xy*2);
}
else
break;
}

float distScale=0.6/maxFadeDistanceKm;
for(int i=0;i<768;i++)
{
world_pos+=0.001*view;
if((view.z<0&&world_pos.z<min_z)||(view.z>0&&world_pos.z>max_z)||distanceKm>maxCloudDistanceKm)break;
offsetFromOrigin=world_pos-gridOriginPosKm;
ivec3 c1=c+c_offset;
vec3 p=offsetFromOrigin/gridScale;
vec3 p1=vec3(c1);
vec3 dp=p1-p;
vec3 D=(dp/viewGridspace);
float e=min(min(D.x,D.y),D.z);
vec3 N=step(D,vec3(e,e,e));
ivec3 c_step=c_offset*ivec3(N);
float stepKm=e*unitStepLengthKm;
distanceKm+=stepKm;
p1=p+e*viewGridspace;
world_pos+=stepKm*view;
vec3 cloudWorldOffsetKm=world_pos-cornerPosKm;
vec3 cloudTexCoords=cloudWorldOffsetKm*inverseScalesKm;
c+=c_step;
ivec2 intermediate=abs(c.xy&ivec2(1,1));
float is_inter=dot(N.xy,vec2(intermediate));
vec3 pw=abs(p1-p0);
float fade_inter=saturate((length(pw.xy)/(float(W)*(3.0-2.0*is_inter)-1.0)-start)/range);
float fade=(1.0-fade_inter);
float fadeDistance=saturate(distanceKm/maxFadeDistanceKm);
maxDistance=max(fadeDistance,maxDistance);
b=abs(c.xy-C0.xy*2);
#line 227 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_raytrace.sl"

if(fade>0.0)
{
float mip=0.0;
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),cloudTexCoords,0.0);

{
vec3 noise_texc=world_pos.xyz*noise3DTexcoordScale+noise3DTexcoordOffset;
vec4 noiseval=vec4(0,0,0,0);
float cosine=dot(N,abs(view));
if(noise)noiseval=density.x*textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc,1.0*(fadeDistance+1.0-abs(cosine)));
vec4 light=vec4(1,1,1,1);
calcDensity(cloudDensity,cloudLight,cloudTexCoords,noiseval,fractalScale,mip,density,light);
if(do_rain_effect)
{
float dm=rainEffect*fade*GetRainAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm);
dm*=saturate(0.6+textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc+vec3(0,0,rainVerticalTexcoord),0.0).z);
moisture+=0.01*dm*light.x;
density.z=max(density.z,dm);
}

if(density.z>0)
{
density.z=saturate(0.3+(1.0+5.0*density.y)*(density.z-0.3));
minDistance=min(max(0,fadeDistance-density.z*stepKm/maxFadeDistanceKm),minDistance);
vec3 worley_texc=(world_pos.xyz+windOffsetKm.xyz)*worleyTexcoordScale+worleyOffsetKm;
vec4 worley=textureLod(sampler3D(smallWorleyTexture3D[1 + 6]),worley_texc,0);
float wo=4*density.y*(worley.w-0.6)*saturate(1.0/(12.0*fadeDistance));
density.z=mix(density.z,density.z*saturate(0.3+((density.z+wo)-0.3-saturate(0.6-density.z))),density.y);
amb_dir=mix(amb_dir,worley.xyz,0.1*density.z);
float brightness_factor;
fade_texc.x=sqrt(fadeDistance);
vec3 volumeTexCoords=vec3(volumeTexCoordsXyC.xy,fade_texc.x);
ColourStep(res.colour,insc,meanFadeDistance,brightness_factor,lossTexture,inscTexture,skylTexture,inscatterVolumeTexture,do_godrays,godraysVolumeTexture,lightspaceScale,godraysTexCoords,lightTableTexture,density,light,distanceKm,fadeDistance,world_pos,cloudTexCoords,fade_texc,nearFarTexc,cosine,volumeTexCoords,amb_dir,BetaClouds,BetaRayleigh,BetaMie,solidDist_nearFar,noise,do_depth_mix,distScale,idx,noiseval,fade,alphaSharpness);
if(res.colour[0].a*brightness_factor<0.003)
{
for(int o=0;o<num_interp;o++)res.colour[o].a=0.0;
meanFadeDistance=fadeDistance;
break;
}

}

lastFadeDistance=mix(lastFadeDistance,fadeDistance-density.z*stepKm/maxFadeDistanceKm,res.colour[num_interp-1].a);
}

}

if(max(max(b.x,b.y),0)>=W)
{
c0.xy=C0.xy;
c.xy+=start_c_offset.xy;
c.xy-=abs(c.xy&ivec2(1,1));
c.xy=c.xy>>1;
gridScale.xy*=2.0;
if(idx==0)W*=2;
p0.xy=P0.xy;
P0.xy=startOffsetFromOriginKm.xy/gridScale.xy/2.0;
C0.xy+=start_c_offset.xy;
C0.xy-=abs(C0.xy&ivec2(1,1));
C0.xy=C0.xy>>1;
viewGridspace=view/gridScale;
viewGridspace=normalize(viewGridspace);
unitStepKm=viewGridspace*gridScale;
unitStepLengthKm=length(unitStepKm);
idx++;
}

}

res.nearFarDepth.zw=vec2(meanFadeDistance,moisture);
for(int k=0;k<num_interp;k++)
{
res.colour[k].rgb+=insc[k].rgb;
}

return res;
}
#line 79 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
vec3 WorldToVolumePos(vec3 world_pos_km, vec3 centreVolumePos, vec3 vol_km)
{
vec3 vp=world_pos_km/vol_km;
return vp+centreVolumePos;
}
#line 96 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
vec3 GridToWorldPos(vec3 grid_pos, vec3 grid_km, vec3 centreVolumePosKm)
{
vec3 wp=grid_pos*grid_km-centreVolumePosKm;
return wp;
}
#line 114 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
ivec3 FloatToIntGrid(vec3 grid_pos)
{
return ivec3(floor(grid_pos));
}
#line 127 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
vec3 WorldToGridPos(vec3 world_pos_km, vec3 gridKm, vec3 centreGridPos)
{
return world_pos_km/gridKm+centreGridPos;
}
#line 132 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
RaytracePixelOutput RaytraceCloudsExperimental(uint64_t cloudDensity[24], uint64_t cloudLight[24], uint64_t precipitationVolume[24], uint64_t noiseTexture3D[24], uint64_t lightTableTexture[24], uint64_t illuminationTexture[24], uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], bool do_depth_mix, vec4 dlookup, vec3 view, vec4 clip_pos, vec3 volumeTexCoordsXyC, bool noise, bool do_rain_effect, bool do_rainbow, vec3 cloudIrRadiance1, vec3 cloudIrRadiance2, int num_interp, bool do_godrays, vec3 cloudTintColour, uint seed)
{
RaytracePixelOutput res;
vec4 insc[2];
for(int ii=0;ii<num_interp;ii++)
{
res.colour[ii]=vec4(0,0,0,1.0);
insc[ii]=vec4(0,0,0,0);
}

res.nearFarDepth=dlookup;
float s=saturate((directionToSun.z+0.2)/0.01);
vec3 lightDirection=mix(directionToMoon,directionToSun,s);
float cos0=dot(lightDirection.xyz,view.xyz);
float min_z=cornerPosKm.z-(fractalScale.z*1.5)/inverseScalesKm.z;
float max_z=cornerPosKm.z+(1.0+fractalScale.z*1.5)/inverseScalesKm.z;
if(do_rain_effect)min_z=-1.0;
vec3 godraysTexCoords=vec3(0,0,0);
float lightspaceScale=1.0;
if(do_godrays)
{
vec3 lightspaceView=(mul(worldToScatteringVolumeMatrix,vec4(view,1.0)).xyz);
lightspaceScale=length(lightspaceView);
godraysTexCoords=vec3(fract(atan(lightspaceView.x,lightspaceView.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceView.z/lightspaceScale)*2.0/3.1415926536,0);
}

float solidDist_nearFar[2];
vec2 nfd=(dlookup.yx)+100.0*step(vec2(1.0,1.0),dlookup.yx);
solidDist_nearFar[0]=nfd.x;
solidDist_nearFar[num_interp-1]=nfd.y;
for(int l=1;l<num_interp-1;l++)
{
float interp=1.0-float(l)/float(num_interp-1);
solidDist_nearFar[l]=mix(solidDist_nearFar[0],solidDist_nearFar[num_interp-1],1.0-interp);
}

float sine=view.z;
vec2 fade_texc=vec2(0.0,0.5*(1.0-sine));
vec2 illum_texc=vec2(atan(view.x,view.y)/(3.1415926536*2.0),fade_texc.y);
vec4 illum_lookup=texture(sampler2D(illuminationTexture[1 + 3]),illum_texc);
vec2 nearFarTexc=illum_lookup.xy;
float meanFadeDistance=1.0;
float BetaClouds=HenyeyGreenstein(cloudEccentricity,cos0);
float BetaRayleigh=CalcRayleighBeta(cos0);
float BetaMie=HenyeyGreenstein(hazeEccentricity,cos0);
float moisture=0.0;
vec3 world_pos_km=viewPosKm;
world_pos_km.xy-=windOffsetKm.xy;
uint mip=uint(maxMip);
uint mipscale=uint(1)<<mip;
uvec3 mip_grid=uvec3(windowGrid)/mipscale;
vec3 windowGridf=vec3(mip_grid);
vec3 centreVolumePos=vec3((typed_mod((gridCentreTexel.xy+ivec2(windowGrid.xy/2)),ivec2(windowGrid.xy))-ivec2(windowGrid.xy/2))/float(windowGrid.x),0);
vec3 gridKm=VolumeScaleKm/windowGridf;
vec3 centreVolumePosKm=VolumeScaleKm*centreVolumePos;
vec3 centreGridPos=windowGridf*centreVolumePos;
vec3 grid_pos=WorldToGridPos(world_pos_km,gridKm,centreGridPos);
vec3 grid_dir=normalize(WorldToGridPos(world_pos_km+view,gridKm,centreGridPos)-grid_pos);
ivec3 c_offset=ivec3(2.0*step(vec3(0,0,0),view.xyz)-vec3(1,1,1));
ivec3 c_next=FloatToIntGrid(grid_pos);
uint idx=0;
int count_detail=0;
vec3 amb_dir=view;
float distScale=0.6/maxFadeDistanceKm;
int i=0;
uint use_mip=0;
int steps_at_mip=0;
vec3 last_grid_pos=grid_pos;
ivec3 c_offset_x=ivec3(step(vec3(0,0,0),grid_dir.xyz));
c_offset=2*c_offset_x-ivec3(1,1,1);
float distanceLimitKm=0.f;
for(i=0;i<768;i++)
{
if((view.z<0&&world_pos_km.z<min_z)||(view.z>0&&world_pos_km.z>max_z)||distanceLimitKm>maxCloudDistanceKm)break;
vec3 prev_world_pos_km=world_pos_km;
ivec3 c=c_next;
if(mip>use_mip)
{
vec4 lookup=vec4(0,0,0,0);
ivec4 lookup_index=ivec4(typed_mod((c.xy+mip_grid.xy),mip_grid.xy),c.z,mip);
if(c.z<mip_grid.z&&c.z>=0)lookup=texelFetch(sampler3D(cloudDensity[0]),ivec3(lookup_index).xyz,int(lookup_index.w));
if(do_rain_effect)lookup.z+=rainEffect*GetPrecipitationAtOffsetKm(precipitationVolume,(world_pos_km-cornerPosKm),inverseScalesKm,float(mip)).w;
if(lookup.z!=0)
{
mip--;
mipscale=uint(1)<<mip;
mip_grid=ivec3(windowGrid)/mipscale;
windowGridf=vec3(mip_grid);
gridKm=VolumeScaleKm/windowGridf;
centreVolumePosKm=VolumeScaleKm*centreVolumePos;
centreGridPos=windowGridf*centreVolumePos;
grid_pos=WorldToGridPos(world_pos_km,gridKm,centreGridPos);
c_next=FloatToIntGrid(grid_pos);
continue;
}

ivec3 c1=c+c_offset_x;
vec3 grid_pos_1=c1;
vec3 dp=grid_pos_1-grid_pos;
vec3 D=dp/grid_dir;
float e=min(min(D.x,D.y),D.z);
vec3 N=step(D,vec3(e,e,e));
ivec3 c_step=c_offset*ivec3(N);
grid_pos+=e*grid_dir;
c_next=c+c_step;
world_pos_km=GridToWorldPos(grid_pos,gridKm,centreVolumePosKm);
vec3 step_km=world_pos_km-prev_world_pos_km;
float stepKm=length(step_km);
distanceLimitKm=length(world_pos_km-viewPosKm);
continue;
}

ivec3 c1=c+c_offset_x;
vec3 grid_pos_1=c1;
vec3 dp=grid_pos_1-grid_pos;
vec3 D=dp/grid_dir;
float e=min(min(D.x,D.y),D.z);
vec3 N=step(D,vec3(e,e,e));
ivec3 c_step=c_offset*ivec3(N);
grid_pos+=e*grid_dir;
c_next=c+c_step;
world_pos_km=GridToWorldPos(grid_pos,gridKm,centreVolumePosKm);
vec3 step_km=world_pos_km-prev_world_pos_km;
float stepKm=length(step_km);
idx=uint(mip);
vec3 sample_pos_km=world_pos_km;
vec3 cloud_tex_coords=WorldToVolumePos(sample_pos_km,centreVolumePos,VolumeScaleKm);

{
vec4 light=textureLod(sampler3D(cloudLight[1 + 7]),cloud_tex_coords,0);
vec3 noise_texc=(sample_pos_km.xyz+windOffsetKm.xyz)*noise3DTexcoordScale+noise3DTexcoordOffset;
vec4 noiseval=vec4(0,0,0,0);
if(noise)
{
vec4 noiseval1=textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc,0.0);
noiseval=light.z*noiseval1;
}

vec3 noise_adjusted_texc=cloud_tex_coords.xyz+fractalScale.xyz*(noiseval.xyz);
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),noise_adjusted_texc,use_mip);
if(do_rain_effect)
{
float dm=rainEffect*GetRainAtOffsetKm(precipitationVolume,(sample_pos_km-cornerPosKm)+((fractalScale.xyz*noiseval.xyz)/inverseScalesKm),inverseScalesKm);
dm*=saturate(0.6+textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc+vec3(0,0,rainVerticalTexcoord),0.0).z);
moisture+=0.01*dm*light.x;
density.z=max(density.z,dm);
}

if(density.z>0)
{
float distanceKm=length(world_pos_km-viewPosKm);
float fadeDistance=saturate(distanceKm/maxFadeDistanceKm);
density.z*=saturate(distanceKm/0.24);
density.z=mix(1.0/(1.0+exp(-20.0*(density.z-0.3))),density.z,density.y);
vec3 worley_texc=(sample_pos_km.xyz+windOffsetKm.xyz)*worleyTexcoordScale+worleyOffsetKm;
vec4 worley=textureLod(sampler3D(smallWorleyTexture3D[1 + 6]),worley_texc,0);
float wo=4*light.w*mix(1.0,worley.w,saturate(1.0/(12.0*fadeDistance)));
density.z=mix(density.z,density.z*saturate(0.3+((density.z+wo)-0.3-saturate(0.6-density.z))),density.y);
float brightness_factor;
fade_texc.x=sqrt(fadeDistance);
vec3 volumeTexCoords=vec3(volumeTexCoordsXyC.xy,fade_texc.x);
float opacity=density.z;
opacity=saturate(0.3+(1.0+1.0*density.w*alphaSharpness)*(opacity-0.3));
float cosine=dot(N,abs(view));
ColourStep2(res.colour,insc,brightness_factor,inscatterVolumeTexture,lossTexture,do_godrays,godraysVolumeTexture,lightspaceScale,godraysTexCoords,lightTableTexture,density,light,distanceKm,fadeDistance,world_pos_km,cloud_tex_coords,fade_texc,volumeTexCoords,BetaClouds,solidDist_nearFar,do_depth_mix,distScale,idx,opacity,cosine,cloudTintColour);
meanFadeDistance=mix(min(fadeDistance,meanFadeDistance),meanFadeDistance,(1.0-.4*density.z));
if(res.colour[0].a*brightness_factor<0.03)
{
for(int o=0;o<num_interp;o++)
{
res.colour[o].a=0.0;
}

meanFadeDistance=fadeDistance;
break;
}

continue;
}

count_detail++;
if(count_detail>2)
{
mip=maxMip;
mipscale=int(1)<<mip;
mip_grid=ivec3(windowGrid)/mipscale;
windowGridf=vec3(mip_grid);
gridKm=VolumeScaleKm/windowGridf;
centreGridPos=windowGridf*centreVolumePos;
grid_pos=WorldToGridPos(world_pos_km,gridKm,centreGridPos);
c_next=FloatToIntGrid(grid_pos);
count_detail=0;
}

}

}

res.nearFarDepth.zw=vec2(meanFadeDistance,moisture);
float grey=float(1)/100.0;
for(int k=0;k<num_interp;k++)
{
res.colour[k].rgb+=insc[k].rgb;
}

return res;
}
#line 769 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void Raytrace(uvec3 pos, bool include_rain, bool depth, int num_interp, bool do_godrays, bool experimental, bool blend)
{
vec2 texCoords=(vec2(pos.xy)+vec2(0.5,0.5))/vec2(targetTextureSize);
vec4 clip_pos=vec4(-1.0,1.0,1.0,1.0);
clip_pos.x+=2.0*texCoords.x;
clip_pos.y-=2.0*texCoords.y;
vec3 view=normalize(mul(invViewProj[pos.z],clip_pos).xyz);
vec4 dlookup=vec4(1.0,1.0,0.000001,1.0);
if(depth)
{
dlookup=textureLod(samplerCube(depthTexture[1 + 6]),view,0);
}

uint seed=0;
vec3 worldspaceVolumeTexCoordsXyC=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(view.z)/3.1415926536),0);
RaytracePixelOutput f;
if(experimental)f=RaytraceCloudsExperimental(cloudDensity,cloudDensity2,precipitationVolume,noiseTexture3D,lightTableTexture,illuminationTexture,lossTexture,inscTexture,skylTexture,volumeInscatterTexture,godraysTexture,true,dlookup,view,clip_pos,worldspaceVolumeTexCoordsXyC,true,include_rain,false,cloudIrRadiance1,cloudIrRadiance2,num_interp,do_godrays,cloudTintColour,seed);else
f=RaytraceCloudsForward(cloudDensity,cloudDensity2,precipitationVolume,noiseTexture3D,lightTableTexture,illuminationTexture,lossTexture,inscTexture,skylTexture,volumeInscatterTexture,godraysTexture,true,dlookup,view,clip_pos,worldspaceVolumeTexCoordsXyC,true,include_rain,false,cloudIrRadiance1,cloudIrRadiance2,num_interp,do_godrays,cloudTintColour);
vec4 resn=f.colour[2-1];
if(blend)
{

}

imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*(2-1))),vec4(resn));
float n=float(dlookup.y>=1.0);
for(int u=0;u<2-1;u++)
{
vec4 res=f.colour[u];
if(blend)
{

}

imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*u)),vec4(res));
}

imageStore(outputTexture3,ivec3(pos),vec4(f.nearFarDepth));
#line 860 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"

}
#line 901 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void CS_Raytrace(uvec3 g, uvec3 t, bool include_rain, bool depth, bool godrays, bool experimental)
{
uvec2 idx=uvec2(g.xy*4+t.xy);
uint Z=cubemapFaceIndex[g.z+t.z].x;
uvec3 pos=uvec3(targetRange[Z].xy+idx*amortizationScale.xy,Z);
uvec2 offs=amortizationOffset.xy;
pos.xy+=offs;
if(pos.x>=edge.x||pos.y>=edge.y)return ;
if(pos.x>=targetRange[Z].z||pos.y>=targetRange[Z].w)return ;
if(texelFetch(sampler2DArray(updateTexture[0]),ivec3(pos).xyz,0).b==0.0)return ;
Raytrace(pos,include_rain,depth,2,godrays,experimental,true);
}
layout(local_size_x=4, local_size_y=4, local_size_z=1) in;
void main()
{
uvec3 g = gl_WorkGroupID;
uvec3 t = gl_LocalInvocationID;
#line 1127 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
CS_Raytrace(g,t,true,true,true,true);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_CS_Interp_NoRain_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};

layout(rgba16f, binding = 4) uniform image2DArray outputTexture1;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t updateTexture[24];
};
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 921 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void Interp(uvec3 g, uvec3 t, bool include_rain, bool depth, bool godrays)
{
uvec2 idx=uvec2(g.xy*4+t.xy);
uint Z=cubemapFaceIndex[g.z+t.z].x;
uvec3 pos=uvec3(targetRange[Z].xy+idx*amortizationScale.xy,Z);
uvec2 offs=(amortizationOffset.xy);
pos.xy+=offs;
if(pos.x>=edge.x||pos.y>=edge.y)return ;
if(pos.x>=targetRange[Z].z||pos.y>=targetRange[Z].w)return ;
vec4 v=texelFetch(sampler2DArray(updateTexture[0]),ivec3(pos).xyz,0);
if(v.b==0.0)return ;
int xi,yi;
for(int u=0;u<2;u++)
{
vec4 c00=imageLoad(outputTexture1,ivec3(pos+uvec3(0,0,6*u)).xyz);
vec4 c20=imageLoad(outputTexture1,ivec3(pos+uvec3(3,0,6*u)).xyz);
vec4 c02=imageLoad(outputTexture1,ivec3(pos+uvec3(0,3,6*u)).xyz);
vec4 c22=imageLoad(outputTexture1,ivec3(pos+uvec3(3,3,6*u)).xyz);
for(xi=0;xi<3;xi++)
{
float xf=float(xi)/float(3);
for(yi=0;yi<3;yi++)
{
if(xi==0&&yi==0)continue;
uvec3 posu=pos+uvec3(xi,yi,0);
vec4 ui=texelFetch(sampler2DArray(updateTexture[0]),ivec3(posu).xyz,0);
if(ui.b==0.0)continue;
float yf=float(yi)/float(3);
vec4 cx0=mix(c00,c20,xf);
vec4 cx2=mix(c02,c22,xf);
vec4 cii=mix(cx0,cx2,yf);
uvec3 post=pos+uvec3(xi,yi,6*u);
float r=(typed_mod(post.x,3))/float(3);
float g=(typed_mod(post.y,3))/float(3);
imageStore(outputTexture1,ivec3(post),vec4(cii));
}

}

}

}
layout(local_size_x=4, local_size_y=4, local_size_z=1) in;
void main()
{
uvec3 g = gl_WorkGroupID;
uvec3 t = gl_LocalInvocationID;
#line 1076 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
Interp(g,t,false,true,true);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_CS_Interp_Rain_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};

layout(rgba16f, binding = 4) uniform image2DArray outputTexture1;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t updateTexture[24];
};
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 921 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void Interp(uvec3 g, uvec3 t, bool include_rain, bool depth, bool godrays)
{
uvec2 idx=uvec2(g.xy*4+t.xy);
uint Z=cubemapFaceIndex[g.z+t.z].x;
uvec3 pos=uvec3(targetRange[Z].xy+idx*amortizationScale.xy,Z);
uvec2 offs=(amortizationOffset.xy);
pos.xy+=offs;
if(pos.x>=edge.x||pos.y>=edge.y)return ;
if(pos.x>=targetRange[Z].z||pos.y>=targetRange[Z].w)return ;
vec4 v=texelFetch(sampler2DArray(updateTexture[0]),ivec3(pos).xyz,0);
if(v.b==0.0)return ;
int xi,yi;
for(int u=0;u<2;u++)
{
vec4 c00=imageLoad(outputTexture1,ivec3(pos+uvec3(0,0,6*u)).xyz);
vec4 c20=imageLoad(outputTexture1,ivec3(pos+uvec3(3,0,6*u)).xyz);
vec4 c02=imageLoad(outputTexture1,ivec3(pos+uvec3(0,3,6*u)).xyz);
vec4 c22=imageLoad(outputTexture1,ivec3(pos+uvec3(3,3,6*u)).xyz);
for(xi=0;xi<3;xi++)
{
float xf=float(xi)/float(3);
for(yi=0;yi<3;yi++)
{
if(xi==0&&yi==0)continue;
uvec3 posu=pos+uvec3(xi,yi,0);
vec4 ui=texelFetch(sampler2DArray(updateTexture[0]),ivec3(posu).xyz,0);
if(ui.b==0.0)continue;
float yf=float(yi)/float(3);
vec4 cx0=mix(c00,c20,xf);
vec4 cx2=mix(c02,c22,xf);
vec4 cii=mix(cx0,cx2,yf);
uvec3 post=pos+uvec3(xi,yi,6*u);
float r=(typed_mod(post.x,3))/float(3);
float g=(typed_mod(post.y,3))/float(3);
imageStore(outputTexture1,ivec3(post),vec4(cii));
}

}

}

}
layout(local_size_x=4, local_size_y=4, local_size_z=1) in;
void main()
{
uvec3 g = gl_WorkGroupID;
uvec3 t = gl_LocalInvocationID;
#line 1082 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
Interp(g,t,true,true,true);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_CS_Lightpass_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 12) uniform CloudStaticConstants
{
	mat4 invViewProj[6];
};
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};
#line 184 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 10) uniform CloudLightpassConstants
{
	vec3 sourcePosKm;
	float sourceRadiusKm;
	vec3 spectralFluxOver1e6;
	float minCosine;
	float irradianceThreshold;
	float maxRadiusKm;
	vec2 padding2;
};
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
struct FarNearPixelOutput
{
	vec4 farColour;
	vec4 nearColour;
};




layout(rgba16f, binding = 4) uniform image2DArray outputTexture1;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t cloudDensity[24];
	uint64_t noiseTexture3D[24];
	uint64_t depthTexture[24];
	uint64_t updateTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 3 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_lightpass.sl"
FarNearPixelOutput Lightpass(uint64_t cloudDensity[24], uint64_t noiseTexture3D[24], vec4 dlookup, vec3 view, vec4 clip_pos, vec3 sourcePosKm_w, float source_radius, vec3 spectralFluxOver1e6, float minCosine, float maxIlluminatedRadius, float threshold)
{
FarNearPixelOutput res;
res.farColour=vec4(0,0,0,1.0);
res.nearColour=vec4(0,0,0,1.0);
float max_spectral_flux=max(max(spectralFluxOver1e6.r,spectralFluxOver1e6.g),spectralFluxOver1e6.b);
vec3 dir_to_source=normalize(sourcePosKm_w-viewPosKm);
float cos0=dot(dir_to_source.xyz,view.xyz);
if(cos0<minCosine)return res;
float sine=view.z;
float min_z=cornerPosKm.z-(fractalScale.z*1.5)/inverseScalesKm.z;
float max_z=cornerPosKm.z+(1.0+fractalScale.z*1.5)/inverseScalesKm.z;
if(view.z<-0.1&&viewPosKm.z<cornerPosKm.z-fractalScale.z/inverseScalesKm.z)return res;
vec2 solidDist_nearFar=(dlookup.yx);
float meanFadeDistance=1.0;
vec3 world_pos=viewPosKm;
ivec3 c_offset=ivec3(sign(view.x),sign(view.y),sign(view.z));
ivec3 start_c_offset=-c_offset;
start_c_offset=ivec3(max(start_c_offset.x,0),max(start_c_offset.y,0),max(start_c_offset.z,0));
vec3 viewScaled=view/scaleOfGridCoordsKm;
viewScaled=normalize(viewScaled);
vec3 offset_vec=vec3(0,0,0);
if(world_pos.z<min_z)
{
float a=1.0/(view.z+0.00001);
offset_vec=(min_z-world_pos.z)*vec3(view.x*a,view.y*a,1.0);
}

if(view.z<0&&world_pos.z>max_z)
{
float a=1.0/(-view.z+0.00001);
offset_vec=(world_pos.z-max_z)*vec3(view.x*a,view.y*a,-1.0);
}

world_pos+=offset_vec;
float viewScale=length(viewScaled*scaleOfGridCoordsKm);
vec3 startOffsetFromOrigin=viewPosKm-gridOriginPosKm;
vec3 offsetFromOrigin=world_pos-gridOriginPosKm;
vec3 p0=startOffsetFromOrigin/scaleOfGridCoordsKm;
ivec3 c0=ivec3(floor(p0)+start_c_offset);
vec3 gridScale=scaleOfGridCoordsKm;
vec3 P0=startOffsetFromOrigin/scaleOfGridCoordsKm/2.0;
ivec3 C0=c0>>1;
float distanceKm=length(offset_vec);
ivec3 c=c0;
int idx=0;
float W=halfClipSize;
const float start=0.866*0.866;
const float ends=1.0;
const float range=ends-start;
vec4 colour=vec4(0.0,0.0,0.0,1.0);
vec4 nearColour=vec4(0.0,0.0,0.0,1.0);
float lastFadeDistance=0.0;
ivec3 b=abs(c-C0*2);
for(int j=0;j<8;j++)
{
if(max(max(b.x,b.y),0)>=W)
{
c0=C0;
c+=start_c_offset;
c-=abs(c&ivec3(1,1,1));
c=c>>1;
gridScale*=2.0;
viewScale*=2.0;
if(idx==0)W*=2;
p0=P0;
P0=startOffsetFromOrigin/gridScale/2.0;
C0+=start_c_offset;
C0-=abs(C0&ivec3(1,1,1));
C0=C0>>1;
idx++;
b=abs(c-C0*2);
}
else
break;
}

for(int i=0;i<256;i++)
{
world_pos+=0.001*view;
if((view.z<0&&world_pos.z<min_z)||(view.z>0&&world_pos.z>max_z)||distanceKm>maxCloudDistanceKm)break;
offsetFromOrigin=world_pos-gridOriginPosKm;
ivec3 c1=c+c_offset;
vec3 p=offsetFromOrigin/gridScale;
vec3 p1=c1;
vec3 dp=p1-p;
vec3 D=(dp/viewScaled);
float e=min(min(D.x,D.y),D.z);
vec3 N=step(D,vec3(e,e,e));
ivec3 c_step=c_offset*ivec3(N);
float d=e*viewScale;
distanceKm+=d;
p1=p+e*viewScaled;
world_pos+=d*view;
vec3 cloudWorldOffsetKm=world_pos-cornerPosKm;
vec3 cloudTexCoords=cloudWorldOffsetKm*inverseScalesKm;
c+=c_step;
ivec3 intermediate=abs(c&ivec3(1,1,1));
float is_inter=dot(N,vec3(intermediate));
vec3 pw=abs(p1-p0);
float fade_inter=saturate((length(pw.xy)/(float(W)*(2.0-is_inter)-1.0)-start)/range);
float fade=1.0-fade_inter;
float fadeDistance=saturate(distanceKm/maxFadeDistanceKm);
b=abs(c-C0*2);
if(fade>0)
{
const float mip=0.0;
vec3 noise_texc=vec3(0.0,0.0,0.0);
vec4 noiseval=vec4(0,0,0,0);
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),cloudTexCoords,mip);
density.z*=fade;
if(density.z>0)
{
float brightness_factor=0.0;
float cloud_density=density.z;
float cosine=dot(N,abs(view));
density.z*=cosine;
density.z*=cosine;
density.z*=saturate(distanceKm/0.24);
vec3 dist=world_pos-sourcePosKm_w;
float radius_km=max(source_radius,length(dist));
noise_texc=world_pos.xyz*noise3DTexcoordScale/2.3+noise3DTexcoordOffset;
noiseval=textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc,3.0*fadeDistance);
float radiance=(0.3+noiseval.x)*(1.0-density.z)*100.0/(4.0*3.14159*radius_km*radius_km);
vec4 clr=vec4(spectralFluxOver1e6.rgb*radiance*density.z,density.z);
brightness_factor=max(1.0,radiance*max_spectral_flux);

{
vec4 clr_n=clr;
clr.a*=saturate((solidDist_nearFar.y-fadeDistance)/0.01);
clr_n.a*=saturate((solidDist_nearFar.x-fadeDistance)/0.01);
nearColour.rgb+=clr_n.rgb*clr_n.a*(nearColour.a);
nearColour.a*=(1.0-clr_n.a);
}

colour.rgb+=clr.rgb*clr.a*(colour.a);
meanFadeDistance=mix(meanFadeDistance,fadeDistance,colour.a*cloud_density);
colour.a*=(1.0-clr.a);
if(nearColour.a*brightness_factor<0.3)
{
colour.a=0.0;
break;
}

}

}

lastFadeDistance=fadeDistance;
if(max(max(b.x,b.y),0)>=W)
{
c0=C0;
c+=start_c_offset;
c-=abs(c&ivec3(1,1,1));
c=c>>1;
gridScale*=2.0;
viewScale*=2.0;
if(idx==0)W*=2;
p0=P0;
P0=startOffsetFromOrigin/gridScale/2.0;
C0+=start_c_offset;
C0-=abs(C0&ivec3(1,1,1));
C0=C0>>1;
idx++;
}

}

float rad_mult=saturate((cos0-minCosine)/(1.0-minCosine));
colour.rgb=max(vec3(0,0,0),(rad_mult*colour.rgb-vec3(threshold,threshold,threshold))/(1.0+threshold));
res.farColour=vec4(exposure*colour.rgb,1.0);
return res;
}
#line 866 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void Lightpass(uvec3 pos, bool depth)
{
vec2 texCoords=(vec2(pos.xy)+vec2(0.5,0.5))/vec2(targetTextureSize);
vec4 clip_pos=vec4(-1.0,1.0,1.0,1.0);
clip_pos.x+=2.0*texCoords.x;
clip_pos.y-=2.0*texCoords.y;
vec3 view=normalize(mul(invViewProj[pos.z],clip_pos).xyz);
vec4 dlookup=vec4(1.0,1.0,1.0,1.0);
if(depth)dlookup=textureLod(samplerCube(depthTexture[1 + 4]),view,0);
;
vec3 lightspaceView=normalize((mul(worldToScatteringVolumeMatrix,vec4(view,1.0))).xyz);
float ls_angle=asin(lightspaceView.z);
vec3 volumeTexCoordsXyC=vec3(atan(lightspaceView.x,lightspaceView.y)/(2.0*3.1415926536),0.5*(1.0+2.0*ls_angle/3.1415926536),max(0.3,cos(ls_angle)));
FarNearPixelOutput f=Lightpass(cloudDensity,noiseTexture3D,dlookup,view,clip_pos,sourcePosKm,sourceRadiusKm,spectralFluxOver1e6,minCosine,maxRadiusKm,irradianceThreshold);
#line 896 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"

imageStore(outputTexture1,ivec3(pos),vec4(f.farColour));
imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6)),vec4(f.nearColour));
}
layout(local_size_x=4, local_size_y=4, local_size_z=1) in;
void main()
{
uvec3 g = gl_WorkGroupID;
uvec3 t = gl_LocalInvocationID;
#line 1004 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
uvec2 idx=uvec2(g.xy*4+t.xy);
uvec3 pos=uvec3(targetRange[cubemapTargetIndex].xy+idx*amortizationScale.xy,cubemapTargetIndex);
if(pos.x>=edge.x||pos.y>=edge.y)return ;
if(pos.x>=targetRange[cubemapTargetIndex].z||pos.y>=targetRange[cubemapTargetIndex].w)return ;
if(texelFetch(sampler2DArray(updateTexture[0]),ivec3(pos).xyz,0).b==0.0)return ;
Lightpass(pos,true);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_CS_LineQueries_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};
#line 210 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
struct LineQueryResult
{
	vec4 pos1_km;
	vec4 pos2_km;
	vec3 padding2;
	flat int valid;
	float density;
	float visibility;
	float optical_thickness_km;
	float first_contact_km;
};

layout(std430, binding = 23) buffer queryInputs_ssbo
{
	vec4 queryInputs[]; 
};
layout(std430, binding = 7) buffer lineQueryResults_ssbo
{
	LineQueryResult lineQueryResults[]; 
};
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t cloudDensity[24];
};
layout(local_size_x=1, local_size_y=1, local_size_z=1) in;
void main()
{
uvec3 sub_pos = gl_GlobalInvocationID;
#line 137 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
vec3 orig=queryInputs[sub_pos.x*2+firstInput].xyz;
vec3 start_pos=orig;
vec3 end_pos=queryInputs[sub_pos.x*2+1+firstInput].xyz;
vec3 diff=end_pos-start_pos;
float total_dist=length(diff);
if(total_dist<=0.0000001)return ;
float max_dist=total_dist;
LineQueryResult res;
res.valid=1;
res.density=0.0;
res.visibility=1.0;
res.optical_thickness_km=0.0;
res.first_contact_km=max_dist;
res.padding2=vec3(0,0,0);
vec3 dir=diff/total_dist;
float dz_plus=max(0.0001,dir.z);
float dz_minus=max(0.0001,-dir.z);
float start_dist=0;
vec3 offsetKm1=start_pos-cornerPosKm;
float under=max(0.0,-offsetKm1.z);
float over=max(0.0,offsetKm1.z-1.0/inverseScalesKm.z);
start_dist=max(over/dz_minus,under/dz_plus);
start_dist=min(start_dist,total_dist);
start_pos+=dir*start_dist;
vec3 offsetKm2=end_pos-cornerPosKm;
float under2=max(0.0,-offsetKm2.z);
float over2=max(0.0,offsetKm2.z-1.0/inverseScalesKm.z);
float end_dist=total_dist+max(over2/dz_minus,under2/dz_plus);
end_dist=min(end_dist,total_dist);
end_dist=max(start_dist,end_dist);
end_pos=start_pos+dir*end_dist;
diff=end_pos-start_pos;
total_dist=length(diff);
res.pos1_km=vec4(start_pos,1);
res.pos2_km=vec4(end_pos,1);
if(start_dist<max_dist)
{
float stepSize=total_dist/32.0;
int i=0;
for(i=0;i<33;i++)
{
vec3 pos=mix(start_pos,end_pos,float(i)/32.0);
vec3 cloudTexCoords=(pos-cornerPosKm)*inverseScalesKm;
vec4 lookup=textureLod(sampler3D(cloudDensity[1 + 7]),cloudTexCoords,0);
if(res.density==0.0&&lookup.z>0)res.first_contact_km=min(res.first_contact_km,length(pos-orig));
res.density+=lookup.z/32.0;
res.visibility*=1.0-lookup.z;
res.optical_thickness_km+=stepSize*lookup.z;
}

}

lineQueryResults[sub_pos.x]=res;
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_CS_PointQueries_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};
#line 198 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
struct VolumeQueryResult
{
	vec4 pos_km;
	flat int valid;
	float density;
	float direct_light;
	float indirect_light;
	float ambient_light;
	float precipitation;
	float rain_to_snow;
	float padding;
};



layout(std430, binding = 23) buffer queryInputs_ssbo
{
	vec4 queryInputs[]; 
};
layout(std430, binding = 6) buffer volumeQueries_ssbo
{
	VolumeQueryResult volumeQueries[]; 
};
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
	uint64_t precipitationVolume[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 GetPrecipitationAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm, float mip)
{
vec3 rain_texc=cloudWorldOffsetKm;
rain_texc.xy+=rain_texc.z*rainTangent;
rain_texc*=inverseScalesKm;
vec3 pvSize;
ivec3 ivprecipitationVolume = textureSize(sampler3D(precipitationVolume[0]),0);
pvSize.x = ivprecipitationVolume.x;pvSize.y = ivprecipitationVolume.y;pvSize.z = ivprecipitationVolume.z;;
uint z_texel=uint(rain_texc.z*pvSize.z);
rain_texc.z=(float(z_texel)+0.5)/pvSize.z;
return textureLod(sampler3D(precipitationVolume[1 + 7]),rain_texc,mip);
}
#line 120 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float GetRainAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm)
{
vec4 rain_lookup=GetPrecipitationAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm,0.0);
return rain_lookup.x*rain_lookup.w*saturate((20.0*rain_lookup.y-cloudWorldOffsetKm.z)/2.0);
}
#line 126 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float GetRainToSnowAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm)
{
vec4 rain_lookup=GetPrecipitationAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm,0.0);
return rain_lookup.z;
}
layout(local_size_x=1, local_size_y=1, local_size_z=1) in;
void main()
{
uvec3 sub_pos = gl_GlobalInvocationID;
#line 112 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
uint num=0;
uint byteStride=0;
VolumeQueryResult res;
res.pos_km=queryInputs[sub_pos.x+firstInput];
res.valid=1;
vec3 cloudWorldOffsetKm=res.pos_km.xyz-cornerPosKm;
vec3 cloudTexCoords=cloudWorldOffsetKm*inverseScalesKm;
vec4 lookup=textureLod(sampler3D(cloudDensity[1 + 7]),cloudTexCoords,0);
res.density=lookup.z;
vec4 light_lookup=textureLod(sampler3D(cloudDensity2[1 + 7]),cloudTexCoords,0);
res.direct_light=light_lookup.y;
res.indirect_light=light_lookup.x;
res.ambient_light=light_lookup.w;
res.precipitation=GetRainAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm);
res.rain_to_snow=GetRainToSnowAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm);
res.padding=0.0;
volumeQueries[sub_pos.x]=res;
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_CS_PrecipitationVolume_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};
#line 226 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
struct PrecipitationLayerInfo
{
	float precipitation;
	float rainToSnow;
	float cloudBaseKm;
	float cloudLayerThicknessKm;
	float precipitationBaseKm;
	float rainRadiusKm;
	vec2 rainCentreKm;
	vec3 mapScale;
	flat uint cloudMaskTextureIndex;
	vec3 mapOffset;
	float azimuth;
};

layout(std430, binding = 14) buffer precipitationLayerInfos_ssbo
{
	PrecipitationLayerInfo precipitationLayerInfos[]; 
};




layout(rgba8, binding = 0) uniform image3D precipitationVolumeRW;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t cloudDensity[24];
	uint64_t precipitationMaskTextures0[24];
	uint64_t precipitationMaskTextures1[24];
	uint64_t precipitationMaskTextures2[24];
	uint64_t precipitationMaskTextures3[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 267 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void PrecipitationVolume(uvec3 p, bool init)
{
ivec3 idx=ivec3(p)*ivec3(amortizationScale)+ivec3(amortizationOffset.xyz);
if(idx.x>=exclusionRange.x&&idx.y>=exclusionRange.y&&idx.x<exclusionRange.z&&idx.y<exclusionRange.w)return ;
idx.xy+=gridCentreTexel;
idx.xy+=ivec2(precipitationGrid.xy+precipitationGrid.xy/2);
idx.xy=typed_mod(idx.xy,ivec2(precipitationGrid.xy));
vec3 texc=vec3(idx)/vec3(precipitationGrid);
float zPixel1=1.0/float(precipitationGrid.z);
float layer_saturate=saturate(texc.z/zPixel1-0.5)*saturate((1.0-0.5*zPixel1-texc.z)/zPixel1);
if(init)
{
float total_cloud=0.0;
float max_tex_z=0.0;
float thickness=0.0;
int current_height_km=int(texc.z*20.0);
for(int i=14*2;i>current_height_km;i--)
{
float tex_z=float(i)/(20.0*2);
vec3 texc1=vec3(texc.xy,tex_z);
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),texc1,0);
total_cloud+=0.125*density.z;
thickness+=1.0*density.z;
max_tex_z=max(max_tex_z,step(1.0,thickness)*tex_z);
}

total_cloud=saturate((total_cloud-0)/0.1);
vec4 res=vec4(0.0,max_tex_z,0.0,total_cloud);
imageStore(precipitationVolumeRW,ivec3(idx),vec4(res));
;
return ;
}

float precipitation=0.0;
float rainToSnow=0.0;
float activeLayers=0.0;
for(uint i=0;i<4;i++)
{
PrecipitationLayerInfo precipitationLayerInfo=precipitationLayerInfos[i];
float precipitationMask=0.0;
vec2 rainCentreTC[4];
rainCentreTC[0]=precipitationLayerInfo.rainCentreKm*inverseScalesKm.xy+vec2(0,0);
rainCentreTC[1]=precipitationLayerInfo.rainCentreKm*inverseScalesKm.xy+vec2(0,1);
rainCentreTC[2]=precipitationLayerInfo.rainCentreKm*inverseScalesKm.xy+vec2(1,0);
rainCentreTC[3]=precipitationLayerInfo.rainCentreKm*inverseScalesKm.xy+vec2(1,1);
float rainRadiusTC=precipitationLayerInfo.rainRadiusKm*inverseScalesKm.x;
for(int i=0;i<4;i++)
{
if(length(texc.xy-rainCentreTC[i])<rainRadiusTC)
{
precipitationMask=1.0;
break;
}

}

float map_lookup=0.0;
if(precipitationLayerInfo.cloudMaskTextureIndex!=0xFFFFFFFF)
{
vec2 map_texc=vec3(idx).xy/vec3(precipitationGrid).xy;
map_texc.y=1.0-map_texc.y;
map_texc.xy+=vec2(0.5,0.5);
if(map_texc.x>1.0)
{
map_texc.x-=1.0;
}

if(map_texc.y>1.0)
{
map_texc.y-=1.0;
}

map_texc.xy-=vec2(0.5,0.5);
map_texc=map_texc*mapScale.xy+mapOffset.xy;
float sine=sin(azimuth);
float cosine=cos(azimuth);
map_texc.xy=vec2(map_texc.x*cosine-map_texc.y*sine,map_texc.y*cosine+map_texc.x*sine);
map_texc.xy+=vec2(0.5,0.5);
if(map_texc.x>=0.0&&map_texc.y>=0.0&&map_texc.x<=1.0&&map_texc.y<=1.0)
{
if(precipitationLayerInfo.cloudMaskTextureIndex==0)map_lookup=textureLod(sampler2D(precipitationMaskTextures0[1 + 9]),map_texc.xy,0).x;else
if(precipitationLayerInfo.cloudMaskTextureIndex==1)map_lookup=textureLod(sampler2D(precipitationMaskTextures1[1 + 9]),map_texc.xy,0).x;else
if(precipitationLayerInfo.cloudMaskTextureIndex==2)map_lookup=textureLod(sampler2D(precipitationMaskTextures2[1 + 9]),map_texc.xy,0).x;else
if(precipitationLayerInfo.cloudMaskTextureIndex==3)map_lookup=textureLod(sampler2D(precipitationMaskTextures3[1 + 9]),map_texc.xy,0).x;else
map_lookup=1.0;
}

}
else
map_lookup=1.0;
float base=(precipitationLayerInfo.precipitationBaseKm/20.0);
float top=((precipitationLayerInfo.cloudBaseKm)/20.0);
if(map_lookup==0.0||precipitationMask==0.0||float(idx.z)*zPixel1>top||float(idx.z)*zPixel1<base)continue;else

{
precipitation+=precipitationLayerInfo.precipitation*map_lookup*precipitationMask;
rainToSnow+=precipitationLayerInfo.rainToSnow*map_lookup*precipitationMask;
activeLayers+=1.0;
}

}

if(activeLayers==0.0)return ;
precipitation/=activeLayers;
rainToSnow/=activeLayers;
vec4 current=imageLoad(precipitationVolumeRW,ivec3(idx).xyz);
if(current.g==0.0||current.a==0.0)return ;
vec4 res=vec4(precipitation,current.g,rainToSnow,current.a);
imageStore(precipitationVolumeRW,ivec3(idx),vec4(res));
;
}
layout(local_size_x=4, local_size_y=4, local_size_z=4) in;
void main()
{
uvec3 p = gl_GlobalInvocationID;
#line 408 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
PrecipitationVolume(p,false);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_CS_PrecipitationVolumeInit_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};
#line 226 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
struct PrecipitationLayerInfo
{
	float precipitation;
	float rainToSnow;
	float cloudBaseKm;
	float cloudLayerThicknessKm;
	float precipitationBaseKm;
	float rainRadiusKm;
	vec2 rainCentreKm;
	vec3 mapScale;
	flat uint cloudMaskTextureIndex;
	vec3 mapOffset;
	float azimuth;
};

layout(std430, binding = 14) buffer precipitationLayerInfos_ssbo
{
	PrecipitationLayerInfo precipitationLayerInfos[]; 
};




layout(rgba8, binding = 0) uniform image3D precipitationVolumeRW;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t cloudDensity[24];
	uint64_t precipitationMaskTextures0[24];
	uint64_t precipitationMaskTextures1[24];
	uint64_t precipitationMaskTextures2[24];
	uint64_t precipitationMaskTextures3[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 267 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void PrecipitationVolume(uvec3 p, bool init)
{
ivec3 idx=ivec3(p)*ivec3(amortizationScale)+ivec3(amortizationOffset.xyz);
if(idx.x>=exclusionRange.x&&idx.y>=exclusionRange.y&&idx.x<exclusionRange.z&&idx.y<exclusionRange.w)return ;
idx.xy+=gridCentreTexel;
idx.xy+=ivec2(precipitationGrid.xy+precipitationGrid.xy/2);
idx.xy=typed_mod(idx.xy,ivec2(precipitationGrid.xy));
vec3 texc=vec3(idx)/vec3(precipitationGrid);
float zPixel1=1.0/float(precipitationGrid.z);
float layer_saturate=saturate(texc.z/zPixel1-0.5)*saturate((1.0-0.5*zPixel1-texc.z)/zPixel1);
if(init)
{
float total_cloud=0.0;
float max_tex_z=0.0;
float thickness=0.0;
int current_height_km=int(texc.z*20.0);
for(int i=14*2;i>current_height_km;i--)
{
float tex_z=float(i)/(20.0*2);
vec3 texc1=vec3(texc.xy,tex_z);
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),texc1,0);
total_cloud+=0.125*density.z;
thickness+=1.0*density.z;
max_tex_z=max(max_tex_z,step(1.0,thickness)*tex_z);
}

total_cloud=saturate((total_cloud-0)/0.1);
vec4 res=vec4(0.0,max_tex_z,0.0,total_cloud);
imageStore(precipitationVolumeRW,ivec3(idx),vec4(res));
;
return ;
}

float precipitation=0.0;
float rainToSnow=0.0;
float activeLayers=0.0;
for(uint i=0;i<4;i++)
{
PrecipitationLayerInfo precipitationLayerInfo=precipitationLayerInfos[i];
float precipitationMask=0.0;
vec2 rainCentreTC[4];
rainCentreTC[0]=precipitationLayerInfo.rainCentreKm*inverseScalesKm.xy+vec2(0,0);
rainCentreTC[1]=precipitationLayerInfo.rainCentreKm*inverseScalesKm.xy+vec2(0,1);
rainCentreTC[2]=precipitationLayerInfo.rainCentreKm*inverseScalesKm.xy+vec2(1,0);
rainCentreTC[3]=precipitationLayerInfo.rainCentreKm*inverseScalesKm.xy+vec2(1,1);
float rainRadiusTC=precipitationLayerInfo.rainRadiusKm*inverseScalesKm.x;
for(int i=0;i<4;i++)
{
if(length(texc.xy-rainCentreTC[i])<rainRadiusTC)
{
precipitationMask=1.0;
break;
}

}

float map_lookup=0.0;
if(precipitationLayerInfo.cloudMaskTextureIndex!=0xFFFFFFFF)
{
vec2 map_texc=vec3(idx).xy/vec3(precipitationGrid).xy;
map_texc.y=1.0-map_texc.y;
map_texc.xy+=vec2(0.5,0.5);
if(map_texc.x>1.0)
{
map_texc.x-=1.0;
}

if(map_texc.y>1.0)
{
map_texc.y-=1.0;
}

map_texc.xy-=vec2(0.5,0.5);
map_texc=map_texc*mapScale.xy+mapOffset.xy;
float sine=sin(azimuth);
float cosine=cos(azimuth);
map_texc.xy=vec2(map_texc.x*cosine-map_texc.y*sine,map_texc.y*cosine+map_texc.x*sine);
map_texc.xy+=vec2(0.5,0.5);
if(map_texc.x>=0.0&&map_texc.y>=0.0&&map_texc.x<=1.0&&map_texc.y<=1.0)
{
if(precipitationLayerInfo.cloudMaskTextureIndex==0)map_lookup=textureLod(sampler2D(precipitationMaskTextures0[1 + 9]),map_texc.xy,0).x;else
if(precipitationLayerInfo.cloudMaskTextureIndex==1)map_lookup=textureLod(sampler2D(precipitationMaskTextures1[1 + 9]),map_texc.xy,0).x;else
if(precipitationLayerInfo.cloudMaskTextureIndex==2)map_lookup=textureLod(sampler2D(precipitationMaskTextures2[1 + 9]),map_texc.xy,0).x;else
if(precipitationLayerInfo.cloudMaskTextureIndex==3)map_lookup=textureLod(sampler2D(precipitationMaskTextures3[1 + 9]),map_texc.xy,0).x;else
map_lookup=1.0;
}

}
else
map_lookup=1.0;
float base=(precipitationLayerInfo.precipitationBaseKm/20.0);
float top=((precipitationLayerInfo.cloudBaseKm)/20.0);
if(map_lookup==0.0||precipitationMask==0.0||float(idx.z)*zPixel1>top||float(idx.z)*zPixel1<base)continue;else

{
precipitation+=precipitationLayerInfo.precipitation*map_lookup*precipitationMask;
rainToSnow+=precipitationLayerInfo.rainToSnow*map_lookup*precipitationMask;
activeLayers+=1.0;
}

}

if(activeLayers==0.0)return ;
precipitation/=activeLayers;
rainToSnow/=activeLayers;
vec4 current=imageLoad(precipitationVolumeRW,ivec3(idx).xyz);
if(current.g==0.0||current.a==0.0)return ;
vec4 res=vec4(precipitation,current.g,rainToSnow,current.a);
imageStore(precipitationVolumeRW,ivec3(idx),vec4(res));
;
}
layout(local_size_x=4, local_size_y=4, local_size_z=4) in;
void main()
{
uvec3 p = gl_GlobalInvocationID;
#line 413 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
PrecipitationVolume(p,true);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_CS_RaytraceHighDetailCubemap_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 12) uniform CloudStaticConstants
{
	mat4 invViewProj[6];
};
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};

#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
struct RaytracePixelOutput
{
	vec4 colour[2];
	vec4 nearFarDepth;
};












layout(rgba16f, binding = 4) uniform image2DArray outputTexture1;
layout(rgba16f, binding = 5) uniform image2DArray outputTexture3;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t smallWorleyTexture3D[24];
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
	uint64_t noiseTexture3D[24];
	uint64_t godraysTexture[24];
	uint64_t volumeInscatterTexture[24];
	uint64_t skylTexture[24];
	uint64_t inscTexture[24];
	uint64_t lossTexture[24];
	uint64_t depthTexture[24];
	uint64_t illuminationTexture[24];
	uint64_t lightTableTexture[24];
	uint64_t precipitationVolume[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float CalcRayleighBeta(float cos0)
{
return (1.0+cos0*cos0);
}
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float HenyeyGreenstein(float g, float cos0)
{
float g2=g*g;
float u=1.0+g2-2.0*g*cos0;
return (1.0-g2)*pow(u,-1.5)/(4.0*3.1415926536);
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
vec3 PrecalculatedInscatterFunction(vec4 inscatter_factor, float BetaRayleigh, float BetaMie, vec3 mieRayleighRatio)
{
vec3 mr=mieRayleighRatio.xyz;
vec3 BetaTotal=(BetaRayleigh+BetaMie*mr)/(vec3(1.0,1.0,1.0)+mr);
vec3 colour=BetaTotal*inscatter_factor.rgb;
return colour;
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float GetAltTexCoord(float alt_km, float minSunlightAltitudeKm, float fadeAltitudeRangeKm)
{
float diff_km=alt_km-minSunlightAltitudeKm;
float sun_alt_texc=0.5+0.5*saturate(diff_km/fadeAltitudeRangeKm);
sun_alt_texc-=0.5*saturate(-diff_km/(minSunlightAltitudeKm+1.0));
return sun_alt_texc;
}
#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float unshadowedBrightness(float Beta, vec4 lightResponse, vec3 ambientColour)
{
return max(1.0,(Beta+lightResponse.y)+ambientColour.b);
}
#line 34 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColour(uint64_t lossTexture[24], uint64_t inscatterVolumeTexture[24], vec3 volumeTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float Beta, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec3 amb_dir, vec2 fade_texc, out float brightnessFactor, out vec4 inscatter, float fade, float alphaSharpness)
{
float alt_texc=(world_pos.z/fadeAltitudeRangeKm);
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 amb_lookup=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
ambientColour=lightResponse.w*amb_lookup.rgb;
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
vec3 ambient=amb_lookup.rgb*light.w;
vec4 c;
float l=mix(0.75,1.2,density.z);
c.rgb=(light.y*lightResponse.x*(Beta+l)+lightResponse.y*light.x)*combinedLightColour+ambient.rgb;
c.a=density.z*fade;
c.a=saturate(0.3+(1.0+1.0*density.w*alphaSharpness)*(c.a-0.3));

{
vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

inscatter=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),volumeTexCoords,0);
inscatter.rgb*=inscatter.a;
#line 62 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

}

return c;
}
#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColourSimple(uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t lightTableTexture[24], vec4 density, float Beta, float BetaRayleigh, float BetaMie, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, out float brightnessFactor)
{
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
ambientColour=lightResponse.w*textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
vec3 ambient=density.w*ambientColour.rgb;
float opacity=density.z;
vec4 c;
c.rgb=(density.y*Beta+lightResponse.y*density.x)*combinedLightColour+ambient.rgb;
c.a=opacity;
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float earthshadowFactr=saturate((fade_texc.x-nearFarTexc.x)/0.1);
#line 88 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
vec4 insc=textureLod(sampler2D(inscTexture[1 + 5]),fade_texc,0);
vec3 skyl=textureLod(sampler2D(skylTexture[1 + 5]),fade_texc,0).rgb;
vec3 inscatter=earthshadowFactr*PrecalculatedInscatterFunction(insc,BetaRayleigh,BetaMie,mieRayleighRatio);
c.rgb+=inscatter+skyl;
return c;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void calcDensity(uint64_t cloudDensity[24], uint64_t cloudLight[24], vec3 texCoords, vec4 noiseval, vec3 fractalScale, float mip, inout vec4 density, out vec4 light)
{
vec3 pos=texCoords.xyz+fractalScale.xyz*(noiseval.xyz);
density=textureLod(sampler3D(cloudDensity[1 + 7]),pos,mip);
light=textureLod(sampler3D(cloudLight[1 + 7]),texCoords,mip);
}
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 GetPrecipitationAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm, float mip)
{
vec3 rain_texc=cloudWorldOffsetKm;
rain_texc.xy+=rain_texc.z*rainTangent;
rain_texc*=inverseScalesKm;
vec3 pvSize;
ivec3 ivprecipitationVolume = textureSize(sampler3D(precipitationVolume[0]),0);
pvSize.x = ivprecipitationVolume.x;pvSize.y = ivprecipitationVolume.y;pvSize.z = ivprecipitationVolume.z;;
uint z_texel=uint(rain_texc.z*pvSize.z);
rain_texc.z=(float(z_texel)+0.5)/pvSize.z;
return textureLod(sampler3D(precipitationVolume[1 + 7]),rain_texc,mip);
}
#line 120 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float GetRainAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm)
{
vec4 rain_lookup=GetPrecipitationAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm,0.0);
return rain_lookup.x*rain_lookup.w*saturate((20.0*rain_lookup.y-cloudWorldOffsetKm.z)/2.0);
}
#line 146 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void ColourStep(inout vec4 colour[2], inout vec4 insc[2], inout float meanFadeDistance, out float brightness_factor, uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], bool godrays, uint64_t godraysVolumeTexture[24], float godraysScale, vec3 godraysTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float distanceKm, float fadeDistance, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, float cosine, vec3 volumeTexCoords, vec3 amb_dir, float BetaClouds, float BetaRayleigh, float BetaMie, float solidDist_nearFar[2], bool noise, bool do_depth_mix, float distScale, int idx, vec4 noiseval, float fade, float alphaSharpness)
{
density.z*=saturate(distanceKm/0.24);
vec4 clr[2];
vec4 inscatter=vec4(0,0,0,0);
brightness_factor=1.0;
if(noise)clr[2-1]=calcColour(lossTexture,inscatterVolumeTexture,volumeTexCoords,lightTableTexture,density,light,BetaClouds,lightResponse,ambientColour,world_pos,cloudTexCoords,amb_dir,fade_texc,brightness_factor,inscatter,fade,alphaSharpness);else
clr[2-1]=calcColourSimple(lossTexture,inscTexture,skylTexture,lightTableTexture,vec4(light.xyw,density.z),BetaClouds,BetaRayleigh,BetaMie,lightResponse,ambientColour,world_pos,cloudTexCoords,fade_texc,nearFarTexc,brightness_factor);
clr[2-1].a*=cosine*cosine;
meanFadeDistance=mix(min(fadeDistance,meanFadeDistance),meanFadeDistance,(1.0-.4*density.z));
godraysTexCoords.z=distanceKm*godraysScale;
float gr_mult=1.0;
if(godrays)gr_mult=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),godraysTexCoords,0).x;
for(int i=0;i<2;i++)
{
clr[i]=clr[2-1];
if(do_depth_mix)
{
float m=saturate((solidDist_nearFar[i]-fadeDistance)/distScale);
clr[i].a*=m;
}

colour[i].rgb+=(clr[i].rgb)*clr[i].a*(colour[i].a);
insc[i].rgb+=gr_mult*inscatter.rgb*clr[i].a*(colour[i].a);
colour[i].a*=(1.0-clr[i].a);
}

}
#line 239 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColour2(uint64_t lossTexture[24], uint64_t inscatterVolumeTexture[24], vec3 volumeTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float Beta, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec2 fade_texc, out float brightnessFactor, out vec4 inscatter, float opacity, vec3 cloudTintColour)
{
float alt_texc=(world_pos.z/fadeAltitudeRangeKm);
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 amb_lookup=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
ambientColour=lightResponse.w*amb_lookup.rgb;
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
vec3 ambient=amb_lookup.rgb*light.w;
vec4 c;
float l=1;
float combinedLightResponse=(light.y*lightResponse.x*(Beta+l)+lightResponse.y*light.x);
c.rgb=cloudTintColour*(combinedLightResponse*combinedLightColour+ambient.rgb);
c.a=opacity;

{
vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
#line 266 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

inscatter=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),volumeTexCoords,0);
inscatter.rgb*=inscatter.a;
#line 269 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

}

return c;
}
#line 272 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void ColourStep2(inout vec4 colour[2], inout vec4 insc[2], inout float brightness_factor, uint64_t inscatterVolumeTexture[24], uint64_t lossTexture[24], bool godrays, uint64_t godraysVolumeTexture[24], float godraysScale, vec3 godraysTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float distanceKm, float fadeDistance, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec3 volumeTexCoords, float BetaClouds, float solidDist_nearFar[2], bool do_depth_mix, float distScale, uint idx, float opacity, float cosine, vec3 cloudTintColour)
{
vec4 clr[2];
vec4 inscatter=vec4(0,0,0,0);
brightness_factor=1.0;
clr[2-1]=calcColour2(lossTexture,inscatterVolumeTexture,volumeTexCoords,lightTableTexture,density,light,BetaClouds,lightResponse,ambientColour,world_pos,fade_texc,brightness_factor,inscatter,opacity,cloudTintColour);
clr[2-1].a*=cosine*cosine;
godraysTexCoords.z=distanceKm*godraysScale;
float gr_mult=1.0;
if(godrays)gr_mult=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),godraysTexCoords,0).x;
for(int i=0;i<2;i++)
{
clr[i]=clr[2-1];
if(do_depth_mix)
{
float m=saturate((solidDist_nearFar[i]-fadeDistance)/distScale);
clr[i].a*=m;
}

colour[i].rgb+=(clr[i].rgb)*clr[i].a*(colour[i].a);
insc[i].rgb+=gr_mult*inscatter.rgb*clr[i].a*(colour[i].a);
colour[i].a*=(1.0-clr[i].a);
}

}
#line 7 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_raytrace.sl"
RaytracePixelOutput RaytraceCloudsForward(uint64_t cloudDensity[24], uint64_t cloudLight[24], uint64_t precipitationVolume[24], uint64_t noiseTexture3D[24], uint64_t lightTableTexture[24], uint64_t illuminationTexture[24], uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], bool do_depth_mix, vec4 dlookup, vec3 view, vec4 clip_pos, vec3 volumeTexCoordsXyC, bool noise, bool do_rain_effect, bool do_rainbow, vec3 cloudIrRadiance1, vec3 cloudIrRadiance2, int num_interp, bool do_godrays, vec3 cloudTintColour)
{
RaytracePixelOutput res;
vec4 insc[2];
for(int ii=0;ii<num_interp;ii++)
{
res.colour[ii]=vec4(0,0,0,1.0);
insc[ii]=vec4(0,0,0,0);
}

res.nearFarDepth=dlookup;
float s=saturate((directionToSun.z+0.2)/0.01);
vec3 lightDirection=mix(directionToMoon,directionToSun,s);
float cos0=dot(lightDirection.xyz,view.xyz);
float sine=view.z;
float min_z=cornerPosKm.z-(fractalScale.z*1.5)/inverseScalesKm.z;
float max_z=cornerPosKm.z+(1.0+fractalScale.z*1.5)/inverseScalesKm.z;
if(do_rain_effect)min_z=-1.0;else
if(view.z<-0.01&&viewPosKm.z<cornerPosKm.z-fractalScale.z/inverseScalesKm.z)return res;
vec3 godraysTexCoords=vec3(0,0,0);
float lightspaceScale=1.0;
if(do_godrays)
{
vec3 lightspaceView=(mul(worldToScatteringVolumeMatrix,vec4(view,1.0)).xyz);
lightspaceScale=length(lightspaceView);
godraysTexCoords=vec3(fract(atan(lightspaceView.x,lightspaceView.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceView.z/lightspaceScale)*2.0/3.1415926536,0);
}

float solidDist_nearFar[2];
vec2 nfd=(dlookup.yx)+100.0*step(vec2(1.0,1.0),dlookup.yx);
solidDist_nearFar[0]=nfd.x;
solidDist_nearFar[num_interp-1]=nfd.y;
float n=nfd.x;
float f=nfd.y;
for(int l=1;l<num_interp-1;l++)
{
float interp=1.0-float(l)/float(num_interp-1);
solidDist_nearFar[l]=mix(solidDist_nearFar[0],solidDist_nearFar[num_interp-1],1.0-interp);
}

vec2 fade_texc=vec2(0.0,0.5*(1.0-sine));
vec2 illum_texc=vec2(atan(view.x,view.y)/(3.1415926536*2.0),fade_texc.y);
vec4 illum_lookup=texture(sampler2D(illuminationTexture[1 + 3]),illum_texc);
vec2 nearFarTexc=illum_lookup.xy;
float meanFadeDistance=1.0;
float minDistance=1.0;
float maxDistance=0.0;
float BetaClouds=lightResponse.x*HenyeyGreenstein(cloudEccentricity,cos0);
float BetaRayleigh=CalcRayleighBeta(cos0);
float BetaMie=HenyeyGreenstein(hazeEccentricity,cos0);
float moisture=0.0;
vec3 world_pos=viewPosKm;
view.xyz+=vec3(0.00001,0.00001,0.00001);
ivec3 c_offset=ivec3(2.0*step(vec3(0,0,0),view.xyz)-vec3(1,1,1));
ivec3 start_c_offset=-c_offset;
start_c_offset=ivec3(max(start_c_offset.x,0),max(start_c_offset.y,0),max(start_c_offset.z,0));
vec3 viewGridspace=view/scaleOfGridCoordsKm;
viewGridspace=normalize(viewGridspace);
vec3 offset_vec=vec3(0,0,0);

{
float a=1.0/(saturate(view.z)+0.00001);
offset_vec+=max(0.0,min_z-world_pos.z)*vec3(view.x*a,view.y*a,1.0);
}

vec3 halfway=0.5*(lightDirection-view);
world_pos+=offset_vec;
vec3 unitStepKm=viewGridspace*scaleOfGridCoordsKm;
float unitStepLengthKm=length(unitStepKm);
vec3 startOffsetFromOriginKm=viewPosKm-gridOriginPosKm;
vec3 offsetFromOrigin=world_pos-gridOriginPosKm;
vec3 p0=startOffsetFromOriginKm/scaleOfGridCoordsKm;
ivec3 c0=ivec3(floor(p0)+start_c_offset);
vec3 gridScale=scaleOfGridCoordsKm;
vec3 P0=startOffsetFromOriginKm/scaleOfGridCoordsKm/2.0;
ivec3 C0=c0>>1;
float distanceKm=length(offset_vec);
vec3 p_=offsetFromOrigin/scaleOfGridCoordsKm;
ivec3 c=ivec3(floor(p_)+start_c_offset);
int idx=0;
float W=halfClipSize;
const float start=0.866*0.866;
const float ends=1.0;
const float range=ends-start;
float lastFadeDistance=0.0;
ivec2 b=abs(c.xy-C0.xy*2);
vec3 amb_dir=view;
for(int j=0;j<8;j++)
{
if(max(max(b.x,b.y),0)>=W)
{
c0.xy=C0.xy;
c.xy+=start_c_offset.xy;
c.xy-=abs(c.xy&ivec2(1,1));
c.xy=c.xy>>1;
gridScale.xy*=2.0;
if(idx==0)W*=2;
p0.xy=P0.xy;
P0.xy=startOffsetFromOriginKm.xy/gridScale.xy/2.0;
C0.xy+=start_c_offset.xy;
C0.xy-=abs(C0.xy&ivec2(1,1));
C0.xy=C0.xy>>1;
viewGridspace=view/gridScale;
viewGridspace=normalize(viewGridspace);
unitStepKm=viewGridspace*gridScale;
unitStepLengthKm=length(unitStepKm);
idx++;
b=abs(c.xy-C0.xy*2);
}
else
break;
}

float distScale=0.6/maxFadeDistanceKm;
for(int i=0;i<768;i++)
{
world_pos+=0.001*view;
if((view.z<0&&world_pos.z<min_z)||(view.z>0&&world_pos.z>max_z)||distanceKm>maxCloudDistanceKm)break;
offsetFromOrigin=world_pos-gridOriginPosKm;
ivec3 c1=c+c_offset;
vec3 p=offsetFromOrigin/gridScale;
vec3 p1=vec3(c1);
vec3 dp=p1-p;
vec3 D=(dp/viewGridspace);
float e=min(min(D.x,D.y),D.z);
vec3 N=step(D,vec3(e,e,e));
ivec3 c_step=c_offset*ivec3(N);
float stepKm=e*unitStepLengthKm;
distanceKm+=stepKm;
p1=p+e*viewGridspace;
world_pos+=stepKm*view;
vec3 cloudWorldOffsetKm=world_pos-cornerPosKm;
vec3 cloudTexCoords=cloudWorldOffsetKm*inverseScalesKm;
c+=c_step;
ivec2 intermediate=abs(c.xy&ivec2(1,1));
float is_inter=dot(N.xy,vec2(intermediate));
vec3 pw=abs(p1-p0);
float fade_inter=saturate((length(pw.xy)/(float(W)*(3.0-2.0*is_inter)-1.0)-start)/range);
float fade=(1.0-fade_inter);
float fadeDistance=saturate(distanceKm/maxFadeDistanceKm);
maxDistance=max(fadeDistance,maxDistance);
b=abs(c.xy-C0.xy*2);
#line 227 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_raytrace.sl"

if(fade>0.0)
{
float mip=0.0;
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),cloudTexCoords,0.0);

{
vec3 noise_texc=world_pos.xyz*noise3DTexcoordScale+noise3DTexcoordOffset;
vec4 noiseval=vec4(0,0,0,0);
float cosine=dot(N,abs(view));
if(noise)noiseval=density.x*textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc,1.0*(fadeDistance+1.0-abs(cosine)));
vec4 light=vec4(1,1,1,1);
calcDensity(cloudDensity,cloudLight,cloudTexCoords,noiseval,fractalScale,mip,density,light);
if(do_rain_effect)
{
float dm=rainEffect*fade*GetRainAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm);
dm*=saturate(0.6+textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc+vec3(0,0,rainVerticalTexcoord),0.0).z);
moisture+=0.01*dm*light.x;
density.z=max(density.z,dm);
}

if(density.z>0)
{
density.z=saturate(0.3+(1.0+5.0*density.y)*(density.z-0.3));
minDistance=min(max(0,fadeDistance-density.z*stepKm/maxFadeDistanceKm),minDistance);
vec3 worley_texc=(world_pos.xyz+windOffsetKm.xyz)*worleyTexcoordScale+worleyOffsetKm;
vec4 worley=textureLod(sampler3D(smallWorleyTexture3D[1 + 6]),worley_texc,0);
float wo=4*density.y*(worley.w-0.6)*saturate(1.0/(12.0*fadeDistance));
density.z=mix(density.z,density.z*saturate(0.3+((density.z+wo)-0.3-saturate(0.6-density.z))),density.y);
amb_dir=mix(amb_dir,worley.xyz,0.1*density.z);
float brightness_factor;
fade_texc.x=sqrt(fadeDistance);
vec3 volumeTexCoords=vec3(volumeTexCoordsXyC.xy,fade_texc.x);
ColourStep(res.colour,insc,meanFadeDistance,brightness_factor,lossTexture,inscTexture,skylTexture,inscatterVolumeTexture,do_godrays,godraysVolumeTexture,lightspaceScale,godraysTexCoords,lightTableTexture,density,light,distanceKm,fadeDistance,world_pos,cloudTexCoords,fade_texc,nearFarTexc,cosine,volumeTexCoords,amb_dir,BetaClouds,BetaRayleigh,BetaMie,solidDist_nearFar,noise,do_depth_mix,distScale,idx,noiseval,fade,alphaSharpness);
if(res.colour[0].a*brightness_factor<0.003)
{
for(int o=0;o<num_interp;o++)res.colour[o].a=0.0;
meanFadeDistance=fadeDistance;
break;
}

}

lastFadeDistance=mix(lastFadeDistance,fadeDistance-density.z*stepKm/maxFadeDistanceKm,res.colour[num_interp-1].a);
}

}

if(max(max(b.x,b.y),0)>=W)
{
c0.xy=C0.xy;
c.xy+=start_c_offset.xy;
c.xy-=abs(c.xy&ivec2(1,1));
c.xy=c.xy>>1;
gridScale.xy*=2.0;
if(idx==0)W*=2;
p0.xy=P0.xy;
P0.xy=startOffsetFromOriginKm.xy/gridScale.xy/2.0;
C0.xy+=start_c_offset.xy;
C0.xy-=abs(C0.xy&ivec2(1,1));
C0.xy=C0.xy>>1;
viewGridspace=view/gridScale;
viewGridspace=normalize(viewGridspace);
unitStepKm=viewGridspace*gridScale;
unitStepLengthKm=length(unitStepKm);
idx++;
}

}

res.nearFarDepth.zw=vec2(meanFadeDistance,moisture);
for(int k=0;k<num_interp;k++)
{
res.colour[k].rgb+=insc[k].rgb;
}

return res;
}
#line 79 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
vec3 WorldToVolumePos(vec3 world_pos_km, vec3 centreVolumePos, vec3 vol_km)
{
vec3 vp=world_pos_km/vol_km;
return vp+centreVolumePos;
}
#line 96 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
vec3 GridToWorldPos(vec3 grid_pos, vec3 grid_km, vec3 centreVolumePosKm)
{
vec3 wp=grid_pos*grid_km-centreVolumePosKm;
return wp;
}
#line 114 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
ivec3 FloatToIntGrid(vec3 grid_pos)
{
return ivec3(floor(grid_pos));
}
#line 127 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
vec3 WorldToGridPos(vec3 world_pos_km, vec3 gridKm, vec3 centreGridPos)
{
return world_pos_km/gridKm+centreGridPos;
}
#line 132 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
RaytracePixelOutput RaytraceCloudsExperimental(uint64_t cloudDensity[24], uint64_t cloudLight[24], uint64_t precipitationVolume[24], uint64_t noiseTexture3D[24], uint64_t lightTableTexture[24], uint64_t illuminationTexture[24], uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], bool do_depth_mix, vec4 dlookup, vec3 view, vec4 clip_pos, vec3 volumeTexCoordsXyC, bool noise, bool do_rain_effect, bool do_rainbow, vec3 cloudIrRadiance1, vec3 cloudIrRadiance2, int num_interp, bool do_godrays, vec3 cloudTintColour, uint seed)
{
RaytracePixelOutput res;
vec4 insc[2];
for(int ii=0;ii<num_interp;ii++)
{
res.colour[ii]=vec4(0,0,0,1.0);
insc[ii]=vec4(0,0,0,0);
}

res.nearFarDepth=dlookup;
float s=saturate((directionToSun.z+0.2)/0.01);
vec3 lightDirection=mix(directionToMoon,directionToSun,s);
float cos0=dot(lightDirection.xyz,view.xyz);
float min_z=cornerPosKm.z-(fractalScale.z*1.5)/inverseScalesKm.z;
float max_z=cornerPosKm.z+(1.0+fractalScale.z*1.5)/inverseScalesKm.z;
if(do_rain_effect)min_z=-1.0;
vec3 godraysTexCoords=vec3(0,0,0);
float lightspaceScale=1.0;
if(do_godrays)
{
vec3 lightspaceView=(mul(worldToScatteringVolumeMatrix,vec4(view,1.0)).xyz);
lightspaceScale=length(lightspaceView);
godraysTexCoords=vec3(fract(atan(lightspaceView.x,lightspaceView.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceView.z/lightspaceScale)*2.0/3.1415926536,0);
}

float solidDist_nearFar[2];
vec2 nfd=(dlookup.yx)+100.0*step(vec2(1.0,1.0),dlookup.yx);
solidDist_nearFar[0]=nfd.x;
solidDist_nearFar[num_interp-1]=nfd.y;
for(int l=1;l<num_interp-1;l++)
{
float interp=1.0-float(l)/float(num_interp-1);
solidDist_nearFar[l]=mix(solidDist_nearFar[0],solidDist_nearFar[num_interp-1],1.0-interp);
}

float sine=view.z;
vec2 fade_texc=vec2(0.0,0.5*(1.0-sine));
vec2 illum_texc=vec2(atan(view.x,view.y)/(3.1415926536*2.0),fade_texc.y);
vec4 illum_lookup=texture(sampler2D(illuminationTexture[1 + 3]),illum_texc);
vec2 nearFarTexc=illum_lookup.xy;
float meanFadeDistance=1.0;
float BetaClouds=HenyeyGreenstein(cloudEccentricity,cos0);
float BetaRayleigh=CalcRayleighBeta(cos0);
float BetaMie=HenyeyGreenstein(hazeEccentricity,cos0);
float moisture=0.0;
vec3 world_pos_km=viewPosKm;
world_pos_km.xy-=windOffsetKm.xy;
uint mip=uint(maxMip);
uint mipscale=uint(1)<<mip;
uvec3 mip_grid=uvec3(windowGrid)/mipscale;
vec3 windowGridf=vec3(mip_grid);
vec3 centreVolumePos=vec3((typed_mod((gridCentreTexel.xy+ivec2(windowGrid.xy/2)),ivec2(windowGrid.xy))-ivec2(windowGrid.xy/2))/float(windowGrid.x),0);
vec3 gridKm=VolumeScaleKm/windowGridf;
vec3 centreVolumePosKm=VolumeScaleKm*centreVolumePos;
vec3 centreGridPos=windowGridf*centreVolumePos;
vec3 grid_pos=WorldToGridPos(world_pos_km,gridKm,centreGridPos);
vec3 grid_dir=normalize(WorldToGridPos(world_pos_km+view,gridKm,centreGridPos)-grid_pos);
ivec3 c_offset=ivec3(2.0*step(vec3(0,0,0),view.xyz)-vec3(1,1,1));
ivec3 c_next=FloatToIntGrid(grid_pos);
uint idx=0;
int count_detail=0;
vec3 amb_dir=view;
float distScale=0.6/maxFadeDistanceKm;
int i=0;
uint use_mip=0;
int steps_at_mip=0;
vec3 last_grid_pos=grid_pos;
ivec3 c_offset_x=ivec3(step(vec3(0,0,0),grid_dir.xyz));
c_offset=2*c_offset_x-ivec3(1,1,1);
float distanceLimitKm=0.f;
for(i=0;i<768;i++)
{
if((view.z<0&&world_pos_km.z<min_z)||(view.z>0&&world_pos_km.z>max_z)||distanceLimitKm>maxCloudDistanceKm)break;
vec3 prev_world_pos_km=world_pos_km;
ivec3 c=c_next;
if(mip>use_mip)
{
vec4 lookup=vec4(0,0,0,0);
ivec4 lookup_index=ivec4(typed_mod((c.xy+mip_grid.xy),mip_grid.xy),c.z,mip);
if(c.z<mip_grid.z&&c.z>=0)lookup=texelFetch(sampler3D(cloudDensity[0]),ivec3(lookup_index).xyz,int(lookup_index.w));
if(do_rain_effect)lookup.z+=rainEffect*GetPrecipitationAtOffsetKm(precipitationVolume,(world_pos_km-cornerPosKm),inverseScalesKm,float(mip)).w;
if(lookup.z!=0)
{
mip--;
mipscale=uint(1)<<mip;
mip_grid=ivec3(windowGrid)/mipscale;
windowGridf=vec3(mip_grid);
gridKm=VolumeScaleKm/windowGridf;
centreVolumePosKm=VolumeScaleKm*centreVolumePos;
centreGridPos=windowGridf*centreVolumePos;
grid_pos=WorldToGridPos(world_pos_km,gridKm,centreGridPos);
c_next=FloatToIntGrid(grid_pos);
continue;
}

ivec3 c1=c+c_offset_x;
vec3 grid_pos_1=c1;
vec3 dp=grid_pos_1-grid_pos;
vec3 D=dp/grid_dir;
float e=min(min(D.x,D.y),D.z);
vec3 N=step(D,vec3(e,e,e));
ivec3 c_step=c_offset*ivec3(N);
grid_pos+=e*grid_dir;
c_next=c+c_step;
world_pos_km=GridToWorldPos(grid_pos,gridKm,centreVolumePosKm);
vec3 step_km=world_pos_km-prev_world_pos_km;
float stepKm=length(step_km);
distanceLimitKm=length(world_pos_km-viewPosKm);
continue;
}

ivec3 c1=c+c_offset_x;
vec3 grid_pos_1=c1;
vec3 dp=grid_pos_1-grid_pos;
vec3 D=dp/grid_dir;
float e=min(min(D.x,D.y),D.z);
vec3 N=step(D,vec3(e,e,e));
ivec3 c_step=c_offset*ivec3(N);
grid_pos+=e*grid_dir;
c_next=c+c_step;
world_pos_km=GridToWorldPos(grid_pos,gridKm,centreVolumePosKm);
vec3 step_km=world_pos_km-prev_world_pos_km;
float stepKm=length(step_km);
idx=uint(mip);
vec3 sample_pos_km=world_pos_km;
vec3 cloud_tex_coords=WorldToVolumePos(sample_pos_km,centreVolumePos,VolumeScaleKm);

{
vec4 light=textureLod(sampler3D(cloudLight[1 + 7]),cloud_tex_coords,0);
vec3 noise_texc=(sample_pos_km.xyz+windOffsetKm.xyz)*noise3DTexcoordScale+noise3DTexcoordOffset;
vec4 noiseval=vec4(0,0,0,0);
if(noise)
{
vec4 noiseval1=textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc,0.0);
noiseval=light.z*noiseval1;
}

vec3 noise_adjusted_texc=cloud_tex_coords.xyz+fractalScale.xyz*(noiseval.xyz);
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),noise_adjusted_texc,use_mip);
if(do_rain_effect)
{
float dm=rainEffect*GetRainAtOffsetKm(precipitationVolume,(sample_pos_km-cornerPosKm)+((fractalScale.xyz*noiseval.xyz)/inverseScalesKm),inverseScalesKm);
dm*=saturate(0.6+textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc+vec3(0,0,rainVerticalTexcoord),0.0).z);
moisture+=0.01*dm*light.x;
density.z=max(density.z,dm);
}

if(density.z>0)
{
float distanceKm=length(world_pos_km-viewPosKm);
float fadeDistance=saturate(distanceKm/maxFadeDistanceKm);
density.z*=saturate(distanceKm/0.24);
density.z=mix(1.0/(1.0+exp(-20.0*(density.z-0.3))),density.z,density.y);
vec3 worley_texc=(sample_pos_km.xyz+windOffsetKm.xyz)*worleyTexcoordScale+worleyOffsetKm;
vec4 worley=textureLod(sampler3D(smallWorleyTexture3D[1 + 6]),worley_texc,0);
float wo=4*light.w*mix(1.0,worley.w,saturate(1.0/(12.0*fadeDistance)));
density.z=mix(density.z,density.z*saturate(0.3+((density.z+wo)-0.3-saturate(0.6-density.z))),density.y);
float brightness_factor;
fade_texc.x=sqrt(fadeDistance);
vec3 volumeTexCoords=vec3(volumeTexCoordsXyC.xy,fade_texc.x);
float opacity=density.z;
opacity=saturate(0.3+(1.0+1.0*density.w*alphaSharpness)*(opacity-0.3));
float cosine=dot(N,abs(view));
ColourStep2(res.colour,insc,brightness_factor,inscatterVolumeTexture,lossTexture,do_godrays,godraysVolumeTexture,lightspaceScale,godraysTexCoords,lightTableTexture,density,light,distanceKm,fadeDistance,world_pos_km,cloud_tex_coords,fade_texc,volumeTexCoords,BetaClouds,solidDist_nearFar,do_depth_mix,distScale,idx,opacity,cosine,cloudTintColour);
meanFadeDistance=mix(min(fadeDistance,meanFadeDistance),meanFadeDistance,(1.0-.4*density.z));
if(res.colour[0].a*brightness_factor<0.03)
{
for(int o=0;o<num_interp;o++)
{
res.colour[o].a=0.0;
}

meanFadeDistance=fadeDistance;
break;
}

continue;
}

count_detail++;
if(count_detail>2)
{
mip=maxMip;
mipscale=int(1)<<mip;
mip_grid=ivec3(windowGrid)/mipscale;
windowGridf=vec3(mip_grid);
gridKm=VolumeScaleKm/windowGridf;
centreGridPos=windowGridf*centreVolumePos;
grid_pos=WorldToGridPos(world_pos_km,gridKm,centreGridPos);
c_next=FloatToIntGrid(grid_pos);
count_detail=0;
}

}

}

res.nearFarDepth.zw=vec2(meanFadeDistance,moisture);
float grey=float(1)/100.0;
for(int k=0;k<num_interp;k++)
{
res.colour[k].rgb+=insc[k].rgb;
}

return res;
}
#line 769 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void Raytrace(uvec3 pos, bool include_rain, bool depth, int num_interp, bool do_godrays, bool experimental, bool blend)
{
vec2 texCoords=(vec2(pos.xy)+vec2(0.5,0.5))/vec2(targetTextureSize);
vec4 clip_pos=vec4(-1.0,1.0,1.0,1.0);
clip_pos.x+=2.0*texCoords.x;
clip_pos.y-=2.0*texCoords.y;
vec3 view=normalize(mul(invViewProj[pos.z],clip_pos).xyz);
vec4 dlookup=vec4(1.0,1.0,0.000001,1.0);
if(depth)
{
dlookup=textureLod(samplerCube(depthTexture[1 + 6]),view,0);
}

uint seed=0;
vec3 worldspaceVolumeTexCoordsXyC=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(view.z)/3.1415926536),0);
RaytracePixelOutput f;
if(experimental)f=RaytraceCloudsExperimental(cloudDensity,cloudDensity2,precipitationVolume,noiseTexture3D,lightTableTexture,illuminationTexture,lossTexture,inscTexture,skylTexture,volumeInscatterTexture,godraysTexture,true,dlookup,view,clip_pos,worldspaceVolumeTexCoordsXyC,true,include_rain,false,cloudIrRadiance1,cloudIrRadiance2,num_interp,do_godrays,cloudTintColour,seed);else
f=RaytraceCloudsForward(cloudDensity,cloudDensity2,precipitationVolume,noiseTexture3D,lightTableTexture,illuminationTexture,lossTexture,inscTexture,skylTexture,volumeInscatterTexture,godraysTexture,true,dlookup,view,clip_pos,worldspaceVolumeTexCoordsXyC,true,include_rain,false,cloudIrRadiance1,cloudIrRadiance2,num_interp,do_godrays,cloudTintColour);
vec4 resn=f.colour[2-1];
if(blend)
{

}

imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*(2-1))),vec4(resn));
float n=float(dlookup.y>=1.0);
for(int u=0;u<2-1;u++)
{
vec4 res=f.colour[u];
if(blend)
{

}

imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*u)),vec4(res));
}

imageStore(outputTexture3,ivec3(pos),vec4(f.nearFarDepth));
#line 860 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"

}
layout(local_size_x=4, local_size_y=4, local_size_z=1) in;
void main()
{
uvec3 g = gl_WorkGroupID;
uvec3 t = gl_LocalInvocationID;
#line 1098 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
uvec2 idx=uvec2(g.xy*4+t.xy);
uint Z=cubemapFaceIndex[g.z+t.z].x;
uvec3 pos=uvec3(targetRange[Z].xy+idx*amortizationScale.xy,Z);
uvec2 offset=typed_mod((amortizationOffset.xy+(idx.xy+idx.yx)),amortizationScale.xy);
pos.xy+=offset;
if(pos.x>=edge.x||pos.y>=edge.y)return ;
if(pos.x>=targetRange[Z].z||pos.y>=targetRange[Z].w)return ;
Raytrace(pos,false,false,2,true,false,false);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_CS_RaytraceNoRain_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 12) uniform CloudStaticConstants
{
	mat4 invViewProj[6];
};
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};

#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
struct RaytracePixelOutput
{
	vec4 colour[2];
	vec4 nearFarDepth;
};













layout(rgba16f, binding = 4) uniform image2DArray outputTexture1;
layout(rgba16f, binding = 5) uniform image2DArray outputTexture3;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t smallWorleyTexture3D[24];
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
	uint64_t noiseTexture3D[24];
	uint64_t godraysTexture[24];
	uint64_t volumeInscatterTexture[24];
	uint64_t skylTexture[24];
	uint64_t inscTexture[24];
	uint64_t lossTexture[24];
	uint64_t depthTexture[24];
	uint64_t illuminationTexture[24];
	uint64_t lightTableTexture[24];
	uint64_t precipitationVolume[24];
	uint64_t updateTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float CalcRayleighBeta(float cos0)
{
return (1.0+cos0*cos0);
}
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float HenyeyGreenstein(float g, float cos0)
{
float g2=g*g;
float u=1.0+g2-2.0*g*cos0;
return (1.0-g2)*pow(u,-1.5)/(4.0*3.1415926536);
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
vec3 PrecalculatedInscatterFunction(vec4 inscatter_factor, float BetaRayleigh, float BetaMie, vec3 mieRayleighRatio)
{
vec3 mr=mieRayleighRatio.xyz;
vec3 BetaTotal=(BetaRayleigh+BetaMie*mr)/(vec3(1.0,1.0,1.0)+mr);
vec3 colour=BetaTotal*inscatter_factor.rgb;
return colour;
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float GetAltTexCoord(float alt_km, float minSunlightAltitudeKm, float fadeAltitudeRangeKm)
{
float diff_km=alt_km-minSunlightAltitudeKm;
float sun_alt_texc=0.5+0.5*saturate(diff_km/fadeAltitudeRangeKm);
sun_alt_texc-=0.5*saturate(-diff_km/(minSunlightAltitudeKm+1.0));
return sun_alt_texc;
}
#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float unshadowedBrightness(float Beta, vec4 lightResponse, vec3 ambientColour)
{
return max(1.0,(Beta+lightResponse.y)+ambientColour.b);
}
#line 34 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColour(uint64_t lossTexture[24], uint64_t inscatterVolumeTexture[24], vec3 volumeTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float Beta, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec3 amb_dir, vec2 fade_texc, out float brightnessFactor, out vec4 inscatter, float fade, float alphaSharpness)
{
float alt_texc=(world_pos.z/fadeAltitudeRangeKm);
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 amb_lookup=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
ambientColour=lightResponse.w*amb_lookup.rgb;
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
vec3 ambient=amb_lookup.rgb*light.w;
vec4 c;
float l=mix(0.75,1.2,density.z);
c.rgb=(light.y*lightResponse.x*(Beta+l)+lightResponse.y*light.x)*combinedLightColour+ambient.rgb;
c.a=density.z*fade;
c.a=saturate(0.3+(1.0+1.0*density.w*alphaSharpness)*(c.a-0.3));

{
vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

inscatter=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),volumeTexCoords,0);
inscatter.rgb*=inscatter.a;
#line 62 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

}

return c;
}
#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColourSimple(uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t lightTableTexture[24], vec4 density, float Beta, float BetaRayleigh, float BetaMie, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, out float brightnessFactor)
{
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
ambientColour=lightResponse.w*textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
vec3 ambient=density.w*ambientColour.rgb;
float opacity=density.z;
vec4 c;
c.rgb=(density.y*Beta+lightResponse.y*density.x)*combinedLightColour+ambient.rgb;
c.a=opacity;
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float earthshadowFactr=saturate((fade_texc.x-nearFarTexc.x)/0.1);
#line 88 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
vec4 insc=textureLod(sampler2D(inscTexture[1 + 5]),fade_texc,0);
vec3 skyl=textureLod(sampler2D(skylTexture[1 + 5]),fade_texc,0).rgb;
vec3 inscatter=earthshadowFactr*PrecalculatedInscatterFunction(insc,BetaRayleigh,BetaMie,mieRayleighRatio);
c.rgb+=inscatter+skyl;
return c;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void calcDensity(uint64_t cloudDensity[24], uint64_t cloudLight[24], vec3 texCoords, vec4 noiseval, vec3 fractalScale, float mip, inout vec4 density, out vec4 light)
{
vec3 pos=texCoords.xyz+fractalScale.xyz*(noiseval.xyz);
density=textureLod(sampler3D(cloudDensity[1 + 7]),pos,mip);
light=textureLod(sampler3D(cloudLight[1 + 7]),texCoords,mip);
}
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 GetPrecipitationAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm, float mip)
{
vec3 rain_texc=cloudWorldOffsetKm;
rain_texc.xy+=rain_texc.z*rainTangent;
rain_texc*=inverseScalesKm;
vec3 pvSize;
ivec3 ivprecipitationVolume = textureSize(sampler3D(precipitationVolume[0]),0);
pvSize.x = ivprecipitationVolume.x;pvSize.y = ivprecipitationVolume.y;pvSize.z = ivprecipitationVolume.z;;
uint z_texel=uint(rain_texc.z*pvSize.z);
rain_texc.z=(float(z_texel)+0.5)/pvSize.z;
return textureLod(sampler3D(precipitationVolume[1 + 7]),rain_texc,mip);
}
#line 120 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float GetRainAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm)
{
vec4 rain_lookup=GetPrecipitationAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm,0.0);
return rain_lookup.x*rain_lookup.w*saturate((20.0*rain_lookup.y-cloudWorldOffsetKm.z)/2.0);
}
#line 146 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void ColourStep(inout vec4 colour[2], inout vec4 insc[2], inout float meanFadeDistance, out float brightness_factor, uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], bool godrays, uint64_t godraysVolumeTexture[24], float godraysScale, vec3 godraysTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float distanceKm, float fadeDistance, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, float cosine, vec3 volumeTexCoords, vec3 amb_dir, float BetaClouds, float BetaRayleigh, float BetaMie, float solidDist_nearFar[2], bool noise, bool do_depth_mix, float distScale, int idx, vec4 noiseval, float fade, float alphaSharpness)
{
density.z*=saturate(distanceKm/0.24);
vec4 clr[2];
vec4 inscatter=vec4(0,0,0,0);
brightness_factor=1.0;
if(noise)clr[2-1]=calcColour(lossTexture,inscatterVolumeTexture,volumeTexCoords,lightTableTexture,density,light,BetaClouds,lightResponse,ambientColour,world_pos,cloudTexCoords,amb_dir,fade_texc,brightness_factor,inscatter,fade,alphaSharpness);else
clr[2-1]=calcColourSimple(lossTexture,inscTexture,skylTexture,lightTableTexture,vec4(light.xyw,density.z),BetaClouds,BetaRayleigh,BetaMie,lightResponse,ambientColour,world_pos,cloudTexCoords,fade_texc,nearFarTexc,brightness_factor);
clr[2-1].a*=cosine*cosine;
meanFadeDistance=mix(min(fadeDistance,meanFadeDistance),meanFadeDistance,(1.0-.4*density.z));
godraysTexCoords.z=distanceKm*godraysScale;
float gr_mult=1.0;
if(godrays)gr_mult=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),godraysTexCoords,0).x;
for(int i=0;i<2;i++)
{
clr[i]=clr[2-1];
if(do_depth_mix)
{
float m=saturate((solidDist_nearFar[i]-fadeDistance)/distScale);
clr[i].a*=m;
}

colour[i].rgb+=(clr[i].rgb)*clr[i].a*(colour[i].a);
insc[i].rgb+=gr_mult*inscatter.rgb*clr[i].a*(colour[i].a);
colour[i].a*=(1.0-clr[i].a);
}

}
#line 239 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColour2(uint64_t lossTexture[24], uint64_t inscatterVolumeTexture[24], vec3 volumeTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float Beta, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec2 fade_texc, out float brightnessFactor, out vec4 inscatter, float opacity, vec3 cloudTintColour)
{
float alt_texc=(world_pos.z/fadeAltitudeRangeKm);
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 amb_lookup=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
ambientColour=lightResponse.w*amb_lookup.rgb;
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
vec3 ambient=amb_lookup.rgb*light.w;
vec4 c;
float l=1;
float combinedLightResponse=(light.y*lightResponse.x*(Beta+l)+lightResponse.y*light.x);
c.rgb=cloudTintColour*(combinedLightResponse*combinedLightColour+ambient.rgb);
c.a=opacity;

{
vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
#line 266 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

inscatter=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),volumeTexCoords,0);
inscatter.rgb*=inscatter.a;
#line 269 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

}

return c;
}
#line 272 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void ColourStep2(inout vec4 colour[2], inout vec4 insc[2], inout float brightness_factor, uint64_t inscatterVolumeTexture[24], uint64_t lossTexture[24], bool godrays, uint64_t godraysVolumeTexture[24], float godraysScale, vec3 godraysTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float distanceKm, float fadeDistance, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec3 volumeTexCoords, float BetaClouds, float solidDist_nearFar[2], bool do_depth_mix, float distScale, uint idx, float opacity, float cosine, vec3 cloudTintColour)
{
vec4 clr[2];
vec4 inscatter=vec4(0,0,0,0);
brightness_factor=1.0;
clr[2-1]=calcColour2(lossTexture,inscatterVolumeTexture,volumeTexCoords,lightTableTexture,density,light,BetaClouds,lightResponse,ambientColour,world_pos,fade_texc,brightness_factor,inscatter,opacity,cloudTintColour);
clr[2-1].a*=cosine*cosine;
godraysTexCoords.z=distanceKm*godraysScale;
float gr_mult=1.0;
if(godrays)gr_mult=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),godraysTexCoords,0).x;
for(int i=0;i<2;i++)
{
clr[i]=clr[2-1];
if(do_depth_mix)
{
float m=saturate((solidDist_nearFar[i]-fadeDistance)/distScale);
clr[i].a*=m;
}

colour[i].rgb+=(clr[i].rgb)*clr[i].a*(colour[i].a);
insc[i].rgb+=gr_mult*inscatter.rgb*clr[i].a*(colour[i].a);
colour[i].a*=(1.0-clr[i].a);
}

}
#line 7 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_raytrace.sl"
RaytracePixelOutput RaytraceCloudsForward(uint64_t cloudDensity[24], uint64_t cloudLight[24], uint64_t precipitationVolume[24], uint64_t noiseTexture3D[24], uint64_t lightTableTexture[24], uint64_t illuminationTexture[24], uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], bool do_depth_mix, vec4 dlookup, vec3 view, vec4 clip_pos, vec3 volumeTexCoordsXyC, bool noise, bool do_rain_effect, bool do_rainbow, vec3 cloudIrRadiance1, vec3 cloudIrRadiance2, int num_interp, bool do_godrays, vec3 cloudTintColour)
{
RaytracePixelOutput res;
vec4 insc[2];
for(int ii=0;ii<num_interp;ii++)
{
res.colour[ii]=vec4(0,0,0,1.0);
insc[ii]=vec4(0,0,0,0);
}

res.nearFarDepth=dlookup;
float s=saturate((directionToSun.z+0.2)/0.01);
vec3 lightDirection=mix(directionToMoon,directionToSun,s);
float cos0=dot(lightDirection.xyz,view.xyz);
float sine=view.z;
float min_z=cornerPosKm.z-(fractalScale.z*1.5)/inverseScalesKm.z;
float max_z=cornerPosKm.z+(1.0+fractalScale.z*1.5)/inverseScalesKm.z;
if(do_rain_effect)min_z=-1.0;else
if(view.z<-0.01&&viewPosKm.z<cornerPosKm.z-fractalScale.z/inverseScalesKm.z)return res;
vec3 godraysTexCoords=vec3(0,0,0);
float lightspaceScale=1.0;
if(do_godrays)
{
vec3 lightspaceView=(mul(worldToScatteringVolumeMatrix,vec4(view,1.0)).xyz);
lightspaceScale=length(lightspaceView);
godraysTexCoords=vec3(fract(atan(lightspaceView.x,lightspaceView.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceView.z/lightspaceScale)*2.0/3.1415926536,0);
}

float solidDist_nearFar[2];
vec2 nfd=(dlookup.yx)+100.0*step(vec2(1.0,1.0),dlookup.yx);
solidDist_nearFar[0]=nfd.x;
solidDist_nearFar[num_interp-1]=nfd.y;
float n=nfd.x;
float f=nfd.y;
for(int l=1;l<num_interp-1;l++)
{
float interp=1.0-float(l)/float(num_interp-1);
solidDist_nearFar[l]=mix(solidDist_nearFar[0],solidDist_nearFar[num_interp-1],1.0-interp);
}

vec2 fade_texc=vec2(0.0,0.5*(1.0-sine));
vec2 illum_texc=vec2(atan(view.x,view.y)/(3.1415926536*2.0),fade_texc.y);
vec4 illum_lookup=texture(sampler2D(illuminationTexture[1 + 3]),illum_texc);
vec2 nearFarTexc=illum_lookup.xy;
float meanFadeDistance=1.0;
float minDistance=1.0;
float maxDistance=0.0;
float BetaClouds=lightResponse.x*HenyeyGreenstein(cloudEccentricity,cos0);
float BetaRayleigh=CalcRayleighBeta(cos0);
float BetaMie=HenyeyGreenstein(hazeEccentricity,cos0);
float moisture=0.0;
vec3 world_pos=viewPosKm;
view.xyz+=vec3(0.00001,0.00001,0.00001);
ivec3 c_offset=ivec3(2.0*step(vec3(0,0,0),view.xyz)-vec3(1,1,1));
ivec3 start_c_offset=-c_offset;
start_c_offset=ivec3(max(start_c_offset.x,0),max(start_c_offset.y,0),max(start_c_offset.z,0));
vec3 viewGridspace=view/scaleOfGridCoordsKm;
viewGridspace=normalize(viewGridspace);
vec3 offset_vec=vec3(0,0,0);

{
float a=1.0/(saturate(view.z)+0.00001);
offset_vec+=max(0.0,min_z-world_pos.z)*vec3(view.x*a,view.y*a,1.0);
}

vec3 halfway=0.5*(lightDirection-view);
world_pos+=offset_vec;
vec3 unitStepKm=viewGridspace*scaleOfGridCoordsKm;
float unitStepLengthKm=length(unitStepKm);
vec3 startOffsetFromOriginKm=viewPosKm-gridOriginPosKm;
vec3 offsetFromOrigin=world_pos-gridOriginPosKm;
vec3 p0=startOffsetFromOriginKm/scaleOfGridCoordsKm;
ivec3 c0=ivec3(floor(p0)+start_c_offset);
vec3 gridScale=scaleOfGridCoordsKm;
vec3 P0=startOffsetFromOriginKm/scaleOfGridCoordsKm/2.0;
ivec3 C0=c0>>1;
float distanceKm=length(offset_vec);
vec3 p_=offsetFromOrigin/scaleOfGridCoordsKm;
ivec3 c=ivec3(floor(p_)+start_c_offset);
int idx=0;
float W=halfClipSize;
const float start=0.866*0.866;
const float ends=1.0;
const float range=ends-start;
float lastFadeDistance=0.0;
ivec2 b=abs(c.xy-C0.xy*2);
vec3 amb_dir=view;
for(int j=0;j<8;j++)
{
if(max(max(b.x,b.y),0)>=W)
{
c0.xy=C0.xy;
c.xy+=start_c_offset.xy;
c.xy-=abs(c.xy&ivec2(1,1));
c.xy=c.xy>>1;
gridScale.xy*=2.0;
if(idx==0)W*=2;
p0.xy=P0.xy;
P0.xy=startOffsetFromOriginKm.xy/gridScale.xy/2.0;
C0.xy+=start_c_offset.xy;
C0.xy-=abs(C0.xy&ivec2(1,1));
C0.xy=C0.xy>>1;
viewGridspace=view/gridScale;
viewGridspace=normalize(viewGridspace);
unitStepKm=viewGridspace*gridScale;
unitStepLengthKm=length(unitStepKm);
idx++;
b=abs(c.xy-C0.xy*2);
}
else
break;
}

float distScale=0.6/maxFadeDistanceKm;
for(int i=0;i<768;i++)
{
world_pos+=0.001*view;
if((view.z<0&&world_pos.z<min_z)||(view.z>0&&world_pos.z>max_z)||distanceKm>maxCloudDistanceKm)break;
offsetFromOrigin=world_pos-gridOriginPosKm;
ivec3 c1=c+c_offset;
vec3 p=offsetFromOrigin/gridScale;
vec3 p1=vec3(c1);
vec3 dp=p1-p;
vec3 D=(dp/viewGridspace);
float e=min(min(D.x,D.y),D.z);
vec3 N=step(D,vec3(e,e,e));
ivec3 c_step=c_offset*ivec3(N);
float stepKm=e*unitStepLengthKm;
distanceKm+=stepKm;
p1=p+e*viewGridspace;
world_pos+=stepKm*view;
vec3 cloudWorldOffsetKm=world_pos-cornerPosKm;
vec3 cloudTexCoords=cloudWorldOffsetKm*inverseScalesKm;
c+=c_step;
ivec2 intermediate=abs(c.xy&ivec2(1,1));
float is_inter=dot(N.xy,vec2(intermediate));
vec3 pw=abs(p1-p0);
float fade_inter=saturate((length(pw.xy)/(float(W)*(3.0-2.0*is_inter)-1.0)-start)/range);
float fade=(1.0-fade_inter);
float fadeDistance=saturate(distanceKm/maxFadeDistanceKm);
maxDistance=max(fadeDistance,maxDistance);
b=abs(c.xy-C0.xy*2);
#line 227 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_raytrace.sl"

if(fade>0.0)
{
float mip=0.0;
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),cloudTexCoords,0.0);

{
vec3 noise_texc=world_pos.xyz*noise3DTexcoordScale+noise3DTexcoordOffset;
vec4 noiseval=vec4(0,0,0,0);
float cosine=dot(N,abs(view));
if(noise)noiseval=density.x*textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc,1.0*(fadeDistance+1.0-abs(cosine)));
vec4 light=vec4(1,1,1,1);
calcDensity(cloudDensity,cloudLight,cloudTexCoords,noiseval,fractalScale,mip,density,light);
if(do_rain_effect)
{
float dm=rainEffect*fade*GetRainAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm);
dm*=saturate(0.6+textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc+vec3(0,0,rainVerticalTexcoord),0.0).z);
moisture+=0.01*dm*light.x;
density.z=max(density.z,dm);
}

if(density.z>0)
{
density.z=saturate(0.3+(1.0+5.0*density.y)*(density.z-0.3));
minDistance=min(max(0,fadeDistance-density.z*stepKm/maxFadeDistanceKm),minDistance);
vec3 worley_texc=(world_pos.xyz+windOffsetKm.xyz)*worleyTexcoordScale+worleyOffsetKm;
vec4 worley=textureLod(sampler3D(smallWorleyTexture3D[1 + 6]),worley_texc,0);
float wo=4*density.y*(worley.w-0.6)*saturate(1.0/(12.0*fadeDistance));
density.z=mix(density.z,density.z*saturate(0.3+((density.z+wo)-0.3-saturate(0.6-density.z))),density.y);
amb_dir=mix(amb_dir,worley.xyz,0.1*density.z);
float brightness_factor;
fade_texc.x=sqrt(fadeDistance);
vec3 volumeTexCoords=vec3(volumeTexCoordsXyC.xy,fade_texc.x);
ColourStep(res.colour,insc,meanFadeDistance,brightness_factor,lossTexture,inscTexture,skylTexture,inscatterVolumeTexture,do_godrays,godraysVolumeTexture,lightspaceScale,godraysTexCoords,lightTableTexture,density,light,distanceKm,fadeDistance,world_pos,cloudTexCoords,fade_texc,nearFarTexc,cosine,volumeTexCoords,amb_dir,BetaClouds,BetaRayleigh,BetaMie,solidDist_nearFar,noise,do_depth_mix,distScale,idx,noiseval,fade,alphaSharpness);
if(res.colour[0].a*brightness_factor<0.003)
{
for(int o=0;o<num_interp;o++)res.colour[o].a=0.0;
meanFadeDistance=fadeDistance;
break;
}

}

lastFadeDistance=mix(lastFadeDistance,fadeDistance-density.z*stepKm/maxFadeDistanceKm,res.colour[num_interp-1].a);
}

}

if(max(max(b.x,b.y),0)>=W)
{
c0.xy=C0.xy;
c.xy+=start_c_offset.xy;
c.xy-=abs(c.xy&ivec2(1,1));
c.xy=c.xy>>1;
gridScale.xy*=2.0;
if(idx==0)W*=2;
p0.xy=P0.xy;
P0.xy=startOffsetFromOriginKm.xy/gridScale.xy/2.0;
C0.xy+=start_c_offset.xy;
C0.xy-=abs(C0.xy&ivec2(1,1));
C0.xy=C0.xy>>1;
viewGridspace=view/gridScale;
viewGridspace=normalize(viewGridspace);
unitStepKm=viewGridspace*gridScale;
unitStepLengthKm=length(unitStepKm);
idx++;
}

}

res.nearFarDepth.zw=vec2(meanFadeDistance,moisture);
for(int k=0;k<num_interp;k++)
{
res.colour[k].rgb+=insc[k].rgb;
}

return res;
}
#line 79 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
vec3 WorldToVolumePos(vec3 world_pos_km, vec3 centreVolumePos, vec3 vol_km)
{
vec3 vp=world_pos_km/vol_km;
return vp+centreVolumePos;
}
#line 96 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
vec3 GridToWorldPos(vec3 grid_pos, vec3 grid_km, vec3 centreVolumePosKm)
{
vec3 wp=grid_pos*grid_km-centreVolumePosKm;
return wp;
}
#line 114 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
ivec3 FloatToIntGrid(vec3 grid_pos)
{
return ivec3(floor(grid_pos));
}
#line 127 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
vec3 WorldToGridPos(vec3 world_pos_km, vec3 gridKm, vec3 centreGridPos)
{
return world_pos_km/gridKm+centreGridPos;
}
#line 132 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
RaytracePixelOutput RaytraceCloudsExperimental(uint64_t cloudDensity[24], uint64_t cloudLight[24], uint64_t precipitationVolume[24], uint64_t noiseTexture3D[24], uint64_t lightTableTexture[24], uint64_t illuminationTexture[24], uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], bool do_depth_mix, vec4 dlookup, vec3 view, vec4 clip_pos, vec3 volumeTexCoordsXyC, bool noise, bool do_rain_effect, bool do_rainbow, vec3 cloudIrRadiance1, vec3 cloudIrRadiance2, int num_interp, bool do_godrays, vec3 cloudTintColour, uint seed)
{
RaytracePixelOutput res;
vec4 insc[2];
for(int ii=0;ii<num_interp;ii++)
{
res.colour[ii]=vec4(0,0,0,1.0);
insc[ii]=vec4(0,0,0,0);
}

res.nearFarDepth=dlookup;
float s=saturate((directionToSun.z+0.2)/0.01);
vec3 lightDirection=mix(directionToMoon,directionToSun,s);
float cos0=dot(lightDirection.xyz,view.xyz);
float min_z=cornerPosKm.z-(fractalScale.z*1.5)/inverseScalesKm.z;
float max_z=cornerPosKm.z+(1.0+fractalScale.z*1.5)/inverseScalesKm.z;
if(do_rain_effect)min_z=-1.0;
vec3 godraysTexCoords=vec3(0,0,0);
float lightspaceScale=1.0;
if(do_godrays)
{
vec3 lightspaceView=(mul(worldToScatteringVolumeMatrix,vec4(view,1.0)).xyz);
lightspaceScale=length(lightspaceView);
godraysTexCoords=vec3(fract(atan(lightspaceView.x,lightspaceView.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceView.z/lightspaceScale)*2.0/3.1415926536,0);
}

float solidDist_nearFar[2];
vec2 nfd=(dlookup.yx)+100.0*step(vec2(1.0,1.0),dlookup.yx);
solidDist_nearFar[0]=nfd.x;
solidDist_nearFar[num_interp-1]=nfd.y;
for(int l=1;l<num_interp-1;l++)
{
float interp=1.0-float(l)/float(num_interp-1);
solidDist_nearFar[l]=mix(solidDist_nearFar[0],solidDist_nearFar[num_interp-1],1.0-interp);
}

float sine=view.z;
vec2 fade_texc=vec2(0.0,0.5*(1.0-sine));
vec2 illum_texc=vec2(atan(view.x,view.y)/(3.1415926536*2.0),fade_texc.y);
vec4 illum_lookup=texture(sampler2D(illuminationTexture[1 + 3]),illum_texc);
vec2 nearFarTexc=illum_lookup.xy;
float meanFadeDistance=1.0;
float BetaClouds=HenyeyGreenstein(cloudEccentricity,cos0);
float BetaRayleigh=CalcRayleighBeta(cos0);
float BetaMie=HenyeyGreenstein(hazeEccentricity,cos0);
float moisture=0.0;
vec3 world_pos_km=viewPosKm;
world_pos_km.xy-=windOffsetKm.xy;
uint mip=uint(maxMip);
uint mipscale=uint(1)<<mip;
uvec3 mip_grid=uvec3(windowGrid)/mipscale;
vec3 windowGridf=vec3(mip_grid);
vec3 centreVolumePos=vec3((typed_mod((gridCentreTexel.xy+ivec2(windowGrid.xy/2)),ivec2(windowGrid.xy))-ivec2(windowGrid.xy/2))/float(windowGrid.x),0);
vec3 gridKm=VolumeScaleKm/windowGridf;
vec3 centreVolumePosKm=VolumeScaleKm*centreVolumePos;
vec3 centreGridPos=windowGridf*centreVolumePos;
vec3 grid_pos=WorldToGridPos(world_pos_km,gridKm,centreGridPos);
vec3 grid_dir=normalize(WorldToGridPos(world_pos_km+view,gridKm,centreGridPos)-grid_pos);
ivec3 c_offset=ivec3(2.0*step(vec3(0,0,0),view.xyz)-vec3(1,1,1));
ivec3 c_next=FloatToIntGrid(grid_pos);
uint idx=0;
int count_detail=0;
vec3 amb_dir=view;
float distScale=0.6/maxFadeDistanceKm;
int i=0;
uint use_mip=0;
int steps_at_mip=0;
vec3 last_grid_pos=grid_pos;
ivec3 c_offset_x=ivec3(step(vec3(0,0,0),grid_dir.xyz));
c_offset=2*c_offset_x-ivec3(1,1,1);
float distanceLimitKm=0.f;
for(i=0;i<768;i++)
{
if((view.z<0&&world_pos_km.z<min_z)||(view.z>0&&world_pos_km.z>max_z)||distanceLimitKm>maxCloudDistanceKm)break;
vec3 prev_world_pos_km=world_pos_km;
ivec3 c=c_next;
if(mip>use_mip)
{
vec4 lookup=vec4(0,0,0,0);
ivec4 lookup_index=ivec4(typed_mod((c.xy+mip_grid.xy),mip_grid.xy),c.z,mip);
if(c.z<mip_grid.z&&c.z>=0)lookup=texelFetch(sampler3D(cloudDensity[0]),ivec3(lookup_index).xyz,int(lookup_index.w));
if(do_rain_effect)lookup.z+=rainEffect*GetPrecipitationAtOffsetKm(precipitationVolume,(world_pos_km-cornerPosKm),inverseScalesKm,float(mip)).w;
if(lookup.z!=0)
{
mip--;
mipscale=uint(1)<<mip;
mip_grid=ivec3(windowGrid)/mipscale;
windowGridf=vec3(mip_grid);
gridKm=VolumeScaleKm/windowGridf;
centreVolumePosKm=VolumeScaleKm*centreVolumePos;
centreGridPos=windowGridf*centreVolumePos;
grid_pos=WorldToGridPos(world_pos_km,gridKm,centreGridPos);
c_next=FloatToIntGrid(grid_pos);
continue;
}

ivec3 c1=c+c_offset_x;
vec3 grid_pos_1=c1;
vec3 dp=grid_pos_1-grid_pos;
vec3 D=dp/grid_dir;
float e=min(min(D.x,D.y),D.z);
vec3 N=step(D,vec3(e,e,e));
ivec3 c_step=c_offset*ivec3(N);
grid_pos+=e*grid_dir;
c_next=c+c_step;
world_pos_km=GridToWorldPos(grid_pos,gridKm,centreVolumePosKm);
vec3 step_km=world_pos_km-prev_world_pos_km;
float stepKm=length(step_km);
distanceLimitKm=length(world_pos_km-viewPosKm);
continue;
}

ivec3 c1=c+c_offset_x;
vec3 grid_pos_1=c1;
vec3 dp=grid_pos_1-grid_pos;
vec3 D=dp/grid_dir;
float e=min(min(D.x,D.y),D.z);
vec3 N=step(D,vec3(e,e,e));
ivec3 c_step=c_offset*ivec3(N);
grid_pos+=e*grid_dir;
c_next=c+c_step;
world_pos_km=GridToWorldPos(grid_pos,gridKm,centreVolumePosKm);
vec3 step_km=world_pos_km-prev_world_pos_km;
float stepKm=length(step_km);
idx=uint(mip);
vec3 sample_pos_km=world_pos_km;
vec3 cloud_tex_coords=WorldToVolumePos(sample_pos_km,centreVolumePos,VolumeScaleKm);

{
vec4 light=textureLod(sampler3D(cloudLight[1 + 7]),cloud_tex_coords,0);
vec3 noise_texc=(sample_pos_km.xyz+windOffsetKm.xyz)*noise3DTexcoordScale+noise3DTexcoordOffset;
vec4 noiseval=vec4(0,0,0,0);
if(noise)
{
vec4 noiseval1=textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc,0.0);
noiseval=light.z*noiseval1;
}

vec3 noise_adjusted_texc=cloud_tex_coords.xyz+fractalScale.xyz*(noiseval.xyz);
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),noise_adjusted_texc,use_mip);
if(do_rain_effect)
{
float dm=rainEffect*GetRainAtOffsetKm(precipitationVolume,(sample_pos_km-cornerPosKm)+((fractalScale.xyz*noiseval.xyz)/inverseScalesKm),inverseScalesKm);
dm*=saturate(0.6+textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc+vec3(0,0,rainVerticalTexcoord),0.0).z);
moisture+=0.01*dm*light.x;
density.z=max(density.z,dm);
}

if(density.z>0)
{
float distanceKm=length(world_pos_km-viewPosKm);
float fadeDistance=saturate(distanceKm/maxFadeDistanceKm);
density.z*=saturate(distanceKm/0.24);
density.z=mix(1.0/(1.0+exp(-20.0*(density.z-0.3))),density.z,density.y);
vec3 worley_texc=(sample_pos_km.xyz+windOffsetKm.xyz)*worleyTexcoordScale+worleyOffsetKm;
vec4 worley=textureLod(sampler3D(smallWorleyTexture3D[1 + 6]),worley_texc,0);
float wo=4*light.w*mix(1.0,worley.w,saturate(1.0/(12.0*fadeDistance)));
density.z=mix(density.z,density.z*saturate(0.3+((density.z+wo)-0.3-saturate(0.6-density.z))),density.y);
float brightness_factor;
fade_texc.x=sqrt(fadeDistance);
vec3 volumeTexCoords=vec3(volumeTexCoordsXyC.xy,fade_texc.x);
float opacity=density.z;
opacity=saturate(0.3+(1.0+1.0*density.w*alphaSharpness)*(opacity-0.3));
float cosine=dot(N,abs(view));
ColourStep2(res.colour,insc,brightness_factor,inscatterVolumeTexture,lossTexture,do_godrays,godraysVolumeTexture,lightspaceScale,godraysTexCoords,lightTableTexture,density,light,distanceKm,fadeDistance,world_pos_km,cloud_tex_coords,fade_texc,volumeTexCoords,BetaClouds,solidDist_nearFar,do_depth_mix,distScale,idx,opacity,cosine,cloudTintColour);
meanFadeDistance=mix(min(fadeDistance,meanFadeDistance),meanFadeDistance,(1.0-.4*density.z));
if(res.colour[0].a*brightness_factor<0.03)
{
for(int o=0;o<num_interp;o++)
{
res.colour[o].a=0.0;
}

meanFadeDistance=fadeDistance;
break;
}

continue;
}

count_detail++;
if(count_detail>2)
{
mip=maxMip;
mipscale=int(1)<<mip;
mip_grid=ivec3(windowGrid)/mipscale;
windowGridf=vec3(mip_grid);
gridKm=VolumeScaleKm/windowGridf;
centreGridPos=windowGridf*centreVolumePos;
grid_pos=WorldToGridPos(world_pos_km,gridKm,centreGridPos);
c_next=FloatToIntGrid(grid_pos);
count_detail=0;
}

}

}

res.nearFarDepth.zw=vec2(meanFadeDistance,moisture);
float grey=float(1)/100.0;
for(int k=0;k<num_interp;k++)
{
res.colour[k].rgb+=insc[k].rgb;
}

return res;
}
#line 769 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void Raytrace(uvec3 pos, bool include_rain, bool depth, int num_interp, bool do_godrays, bool experimental, bool blend)
{
vec2 texCoords=(vec2(pos.xy)+vec2(0.5,0.5))/vec2(targetTextureSize);
vec4 clip_pos=vec4(-1.0,1.0,1.0,1.0);
clip_pos.x+=2.0*texCoords.x;
clip_pos.y-=2.0*texCoords.y;
vec3 view=normalize(mul(invViewProj[pos.z],clip_pos).xyz);
vec4 dlookup=vec4(1.0,1.0,0.000001,1.0);
if(depth)
{
dlookup=textureLod(samplerCube(depthTexture[1 + 6]),view,0);
}

uint seed=0;
vec3 worldspaceVolumeTexCoordsXyC=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(view.z)/3.1415926536),0);
RaytracePixelOutput f;
if(experimental)f=RaytraceCloudsExperimental(cloudDensity,cloudDensity2,precipitationVolume,noiseTexture3D,lightTableTexture,illuminationTexture,lossTexture,inscTexture,skylTexture,volumeInscatterTexture,godraysTexture,true,dlookup,view,clip_pos,worldspaceVolumeTexCoordsXyC,true,include_rain,false,cloudIrRadiance1,cloudIrRadiance2,num_interp,do_godrays,cloudTintColour,seed);else
f=RaytraceCloudsForward(cloudDensity,cloudDensity2,precipitationVolume,noiseTexture3D,lightTableTexture,illuminationTexture,lossTexture,inscTexture,skylTexture,volumeInscatterTexture,godraysTexture,true,dlookup,view,clip_pos,worldspaceVolumeTexCoordsXyC,true,include_rain,false,cloudIrRadiance1,cloudIrRadiance2,num_interp,do_godrays,cloudTintColour);
vec4 resn=f.colour[2-1];
if(blend)
{

}

imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*(2-1))),vec4(resn));
float n=float(dlookup.y>=1.0);
for(int u=0;u<2-1;u++)
{
vec4 res=f.colour[u];
if(blend)
{

}

imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*u)),vec4(res));
}

imageStore(outputTexture3,ivec3(pos),vec4(f.nearFarDepth));
#line 860 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"

}
#line 901 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void CS_Raytrace(uvec3 g, uvec3 t, bool include_rain, bool depth, bool godrays, bool experimental)
{
uvec2 idx=uvec2(g.xy*4+t.xy);
uint Z=cubemapFaceIndex[g.z+t.z].x;
uvec3 pos=uvec3(targetRange[Z].xy+idx*amortizationScale.xy,Z);
uvec2 offs=amortizationOffset.xy;
pos.xy+=offs;
if(pos.x>=edge.x||pos.y>=edge.y)return ;
if(pos.x>=targetRange[Z].z||pos.y>=targetRange[Z].w)return ;
if(texelFetch(sampler2DArray(updateTexture[0]),ivec3(pos).xyz,0).b==0.0)return ;
Raytrace(pos,include_rain,depth,2,godrays,experimental,true);
}
layout(local_size_x=4, local_size_y=4, local_size_z=1) in;
void main()
{
uvec3 g = gl_WorkGroupID;
uvec3 t = gl_LocalInvocationID;
#line 1121 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
CS_Raytrace(g,t,false,true,true,false);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_CS_RaytraceRain_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 12) uniform CloudStaticConstants
{
	mat4 invViewProj[6];
};
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};

#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
struct RaytracePixelOutput
{
	vec4 colour[2];
	vec4 nearFarDepth;
};













layout(rgba16f, binding = 4) uniform image2DArray outputTexture1;
layout(rgba16f, binding = 5) uniform image2DArray outputTexture3;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t smallWorleyTexture3D[24];
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
	uint64_t noiseTexture3D[24];
	uint64_t godraysTexture[24];
	uint64_t volumeInscatterTexture[24];
	uint64_t skylTexture[24];
	uint64_t inscTexture[24];
	uint64_t lossTexture[24];
	uint64_t depthTexture[24];
	uint64_t illuminationTexture[24];
	uint64_t lightTableTexture[24];
	uint64_t precipitationVolume[24];
	uint64_t updateTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float CalcRayleighBeta(float cos0)
{
return (1.0+cos0*cos0);
}
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float HenyeyGreenstein(float g, float cos0)
{
float g2=g*g;
float u=1.0+g2-2.0*g*cos0;
return (1.0-g2)*pow(u,-1.5)/(4.0*3.1415926536);
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
vec3 PrecalculatedInscatterFunction(vec4 inscatter_factor, float BetaRayleigh, float BetaMie, vec3 mieRayleighRatio)
{
vec3 mr=mieRayleighRatio.xyz;
vec3 BetaTotal=(BetaRayleigh+BetaMie*mr)/(vec3(1.0,1.0,1.0)+mr);
vec3 colour=BetaTotal*inscatter_factor.rgb;
return colour;
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float GetAltTexCoord(float alt_km, float minSunlightAltitudeKm, float fadeAltitudeRangeKm)
{
float diff_km=alt_km-minSunlightAltitudeKm;
float sun_alt_texc=0.5+0.5*saturate(diff_km/fadeAltitudeRangeKm);
sun_alt_texc-=0.5*saturate(-diff_km/(minSunlightAltitudeKm+1.0));
return sun_alt_texc;
}
#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float unshadowedBrightness(float Beta, vec4 lightResponse, vec3 ambientColour)
{
return max(1.0,(Beta+lightResponse.y)+ambientColour.b);
}
#line 34 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColour(uint64_t lossTexture[24], uint64_t inscatterVolumeTexture[24], vec3 volumeTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float Beta, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec3 amb_dir, vec2 fade_texc, out float brightnessFactor, out vec4 inscatter, float fade, float alphaSharpness)
{
float alt_texc=(world_pos.z/fadeAltitudeRangeKm);
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 amb_lookup=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
ambientColour=lightResponse.w*amb_lookup.rgb;
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
vec3 ambient=amb_lookup.rgb*light.w;
vec4 c;
float l=mix(0.75,1.2,density.z);
c.rgb=(light.y*lightResponse.x*(Beta+l)+lightResponse.y*light.x)*combinedLightColour+ambient.rgb;
c.a=density.z*fade;
c.a=saturate(0.3+(1.0+1.0*density.w*alphaSharpness)*(c.a-0.3));

{
vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

inscatter=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),volumeTexCoords,0);
inscatter.rgb*=inscatter.a;
#line 62 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

}

return c;
}
#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColourSimple(uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t lightTableTexture[24], vec4 density, float Beta, float BetaRayleigh, float BetaMie, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, out float brightnessFactor)
{
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
ambientColour=lightResponse.w*textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
vec3 ambient=density.w*ambientColour.rgb;
float opacity=density.z;
vec4 c;
c.rgb=(density.y*Beta+lightResponse.y*density.x)*combinedLightColour+ambient.rgb;
c.a=opacity;
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float earthshadowFactr=saturate((fade_texc.x-nearFarTexc.x)/0.1);
#line 88 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
vec4 insc=textureLod(sampler2D(inscTexture[1 + 5]),fade_texc,0);
vec3 skyl=textureLod(sampler2D(skylTexture[1 + 5]),fade_texc,0).rgb;
vec3 inscatter=earthshadowFactr*PrecalculatedInscatterFunction(insc,BetaRayleigh,BetaMie,mieRayleighRatio);
c.rgb+=inscatter+skyl;
return c;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void calcDensity(uint64_t cloudDensity[24], uint64_t cloudLight[24], vec3 texCoords, vec4 noiseval, vec3 fractalScale, float mip, inout vec4 density, out vec4 light)
{
vec3 pos=texCoords.xyz+fractalScale.xyz*(noiseval.xyz);
density=textureLod(sampler3D(cloudDensity[1 + 7]),pos,mip);
light=textureLod(sampler3D(cloudLight[1 + 7]),texCoords,mip);
}
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 GetPrecipitationAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm, float mip)
{
vec3 rain_texc=cloudWorldOffsetKm;
rain_texc.xy+=rain_texc.z*rainTangent;
rain_texc*=inverseScalesKm;
vec3 pvSize;
ivec3 ivprecipitationVolume = textureSize(sampler3D(precipitationVolume[0]),0);
pvSize.x = ivprecipitationVolume.x;pvSize.y = ivprecipitationVolume.y;pvSize.z = ivprecipitationVolume.z;;
uint z_texel=uint(rain_texc.z*pvSize.z);
rain_texc.z=(float(z_texel)+0.5)/pvSize.z;
return textureLod(sampler3D(precipitationVolume[1 + 7]),rain_texc,mip);
}
#line 120 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float GetRainAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm)
{
vec4 rain_lookup=GetPrecipitationAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm,0.0);
return rain_lookup.x*rain_lookup.w*saturate((20.0*rain_lookup.y-cloudWorldOffsetKm.z)/2.0);
}
#line 146 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void ColourStep(inout vec4 colour[2], inout vec4 insc[2], inout float meanFadeDistance, out float brightness_factor, uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], bool godrays, uint64_t godraysVolumeTexture[24], float godraysScale, vec3 godraysTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float distanceKm, float fadeDistance, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, float cosine, vec3 volumeTexCoords, vec3 amb_dir, float BetaClouds, float BetaRayleigh, float BetaMie, float solidDist_nearFar[2], bool noise, bool do_depth_mix, float distScale, int idx, vec4 noiseval, float fade, float alphaSharpness)
{
density.z*=saturate(distanceKm/0.24);
vec4 clr[2];
vec4 inscatter=vec4(0,0,0,0);
brightness_factor=1.0;
if(noise)clr[2-1]=calcColour(lossTexture,inscatterVolumeTexture,volumeTexCoords,lightTableTexture,density,light,BetaClouds,lightResponse,ambientColour,world_pos,cloudTexCoords,amb_dir,fade_texc,brightness_factor,inscatter,fade,alphaSharpness);else
clr[2-1]=calcColourSimple(lossTexture,inscTexture,skylTexture,lightTableTexture,vec4(light.xyw,density.z),BetaClouds,BetaRayleigh,BetaMie,lightResponse,ambientColour,world_pos,cloudTexCoords,fade_texc,nearFarTexc,brightness_factor);
clr[2-1].a*=cosine*cosine;
meanFadeDistance=mix(min(fadeDistance,meanFadeDistance),meanFadeDistance,(1.0-.4*density.z));
godraysTexCoords.z=distanceKm*godraysScale;
float gr_mult=1.0;
if(godrays)gr_mult=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),godraysTexCoords,0).x;
for(int i=0;i<2;i++)
{
clr[i]=clr[2-1];
if(do_depth_mix)
{
float m=saturate((solidDist_nearFar[i]-fadeDistance)/distScale);
clr[i].a*=m;
}

colour[i].rgb+=(clr[i].rgb)*clr[i].a*(colour[i].a);
insc[i].rgb+=gr_mult*inscatter.rgb*clr[i].a*(colour[i].a);
colour[i].a*=(1.0-clr[i].a);
}

}
#line 239 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColour2(uint64_t lossTexture[24], uint64_t inscatterVolumeTexture[24], vec3 volumeTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float Beta, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec2 fade_texc, out float brightnessFactor, out vec4 inscatter, float opacity, vec3 cloudTintColour)
{
float alt_texc=(world_pos.z/fadeAltitudeRangeKm);
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 amb_lookup=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
ambientColour=lightResponse.w*amb_lookup.rgb;
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
vec3 ambient=amb_lookup.rgb*light.w;
vec4 c;
float l=1;
float combinedLightResponse=(light.y*lightResponse.x*(Beta+l)+lightResponse.y*light.x);
c.rgb=cloudTintColour*(combinedLightResponse*combinedLightColour+ambient.rgb);
c.a=opacity;

{
vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
#line 266 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

inscatter=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),volumeTexCoords,0);
inscatter.rgb*=inscatter.a;
#line 269 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

}

return c;
}
#line 272 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void ColourStep2(inout vec4 colour[2], inout vec4 insc[2], inout float brightness_factor, uint64_t inscatterVolumeTexture[24], uint64_t lossTexture[24], bool godrays, uint64_t godraysVolumeTexture[24], float godraysScale, vec3 godraysTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float distanceKm, float fadeDistance, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec3 volumeTexCoords, float BetaClouds, float solidDist_nearFar[2], bool do_depth_mix, float distScale, uint idx, float opacity, float cosine, vec3 cloudTintColour)
{
vec4 clr[2];
vec4 inscatter=vec4(0,0,0,0);
brightness_factor=1.0;
clr[2-1]=calcColour2(lossTexture,inscatterVolumeTexture,volumeTexCoords,lightTableTexture,density,light,BetaClouds,lightResponse,ambientColour,world_pos,fade_texc,brightness_factor,inscatter,opacity,cloudTintColour);
clr[2-1].a*=cosine*cosine;
godraysTexCoords.z=distanceKm*godraysScale;
float gr_mult=1.0;
if(godrays)gr_mult=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),godraysTexCoords,0).x;
for(int i=0;i<2;i++)
{
clr[i]=clr[2-1];
if(do_depth_mix)
{
float m=saturate((solidDist_nearFar[i]-fadeDistance)/distScale);
clr[i].a*=m;
}

colour[i].rgb+=(clr[i].rgb)*clr[i].a*(colour[i].a);
insc[i].rgb+=gr_mult*inscatter.rgb*clr[i].a*(colour[i].a);
colour[i].a*=(1.0-clr[i].a);
}

}
#line 7 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_raytrace.sl"
RaytracePixelOutput RaytraceCloudsForward(uint64_t cloudDensity[24], uint64_t cloudLight[24], uint64_t precipitationVolume[24], uint64_t noiseTexture3D[24], uint64_t lightTableTexture[24], uint64_t illuminationTexture[24], uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], bool do_depth_mix, vec4 dlookup, vec3 view, vec4 clip_pos, vec3 volumeTexCoordsXyC, bool noise, bool do_rain_effect, bool do_rainbow, vec3 cloudIrRadiance1, vec3 cloudIrRadiance2, int num_interp, bool do_godrays, vec3 cloudTintColour)
{
RaytracePixelOutput res;
vec4 insc[2];
for(int ii=0;ii<num_interp;ii++)
{
res.colour[ii]=vec4(0,0,0,1.0);
insc[ii]=vec4(0,0,0,0);
}

res.nearFarDepth=dlookup;
float s=saturate((directionToSun.z+0.2)/0.01);
vec3 lightDirection=mix(directionToMoon,directionToSun,s);
float cos0=dot(lightDirection.xyz,view.xyz);
float sine=view.z;
float min_z=cornerPosKm.z-(fractalScale.z*1.5)/inverseScalesKm.z;
float max_z=cornerPosKm.z+(1.0+fractalScale.z*1.5)/inverseScalesKm.z;
if(do_rain_effect)min_z=-1.0;else
if(view.z<-0.01&&viewPosKm.z<cornerPosKm.z-fractalScale.z/inverseScalesKm.z)return res;
vec3 godraysTexCoords=vec3(0,0,0);
float lightspaceScale=1.0;
if(do_godrays)
{
vec3 lightspaceView=(mul(worldToScatteringVolumeMatrix,vec4(view,1.0)).xyz);
lightspaceScale=length(lightspaceView);
godraysTexCoords=vec3(fract(atan(lightspaceView.x,lightspaceView.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceView.z/lightspaceScale)*2.0/3.1415926536,0);
}

float solidDist_nearFar[2];
vec2 nfd=(dlookup.yx)+100.0*step(vec2(1.0,1.0),dlookup.yx);
solidDist_nearFar[0]=nfd.x;
solidDist_nearFar[num_interp-1]=nfd.y;
float n=nfd.x;
float f=nfd.y;
for(int l=1;l<num_interp-1;l++)
{
float interp=1.0-float(l)/float(num_interp-1);
solidDist_nearFar[l]=mix(solidDist_nearFar[0],solidDist_nearFar[num_interp-1],1.0-interp);
}

vec2 fade_texc=vec2(0.0,0.5*(1.0-sine));
vec2 illum_texc=vec2(atan(view.x,view.y)/(3.1415926536*2.0),fade_texc.y);
vec4 illum_lookup=texture(sampler2D(illuminationTexture[1 + 3]),illum_texc);
vec2 nearFarTexc=illum_lookup.xy;
float meanFadeDistance=1.0;
float minDistance=1.0;
float maxDistance=0.0;
float BetaClouds=lightResponse.x*HenyeyGreenstein(cloudEccentricity,cos0);
float BetaRayleigh=CalcRayleighBeta(cos0);
float BetaMie=HenyeyGreenstein(hazeEccentricity,cos0);
float moisture=0.0;
vec3 world_pos=viewPosKm;
view.xyz+=vec3(0.00001,0.00001,0.00001);
ivec3 c_offset=ivec3(2.0*step(vec3(0,0,0),view.xyz)-vec3(1,1,1));
ivec3 start_c_offset=-c_offset;
start_c_offset=ivec3(max(start_c_offset.x,0),max(start_c_offset.y,0),max(start_c_offset.z,0));
vec3 viewGridspace=view/scaleOfGridCoordsKm;
viewGridspace=normalize(viewGridspace);
vec3 offset_vec=vec3(0,0,0);

{
float a=1.0/(saturate(view.z)+0.00001);
offset_vec+=max(0.0,min_z-world_pos.z)*vec3(view.x*a,view.y*a,1.0);
}

vec3 halfway=0.5*(lightDirection-view);
world_pos+=offset_vec;
vec3 unitStepKm=viewGridspace*scaleOfGridCoordsKm;
float unitStepLengthKm=length(unitStepKm);
vec3 startOffsetFromOriginKm=viewPosKm-gridOriginPosKm;
vec3 offsetFromOrigin=world_pos-gridOriginPosKm;
vec3 p0=startOffsetFromOriginKm/scaleOfGridCoordsKm;
ivec3 c0=ivec3(floor(p0)+start_c_offset);
vec3 gridScale=scaleOfGridCoordsKm;
vec3 P0=startOffsetFromOriginKm/scaleOfGridCoordsKm/2.0;
ivec3 C0=c0>>1;
float distanceKm=length(offset_vec);
vec3 p_=offsetFromOrigin/scaleOfGridCoordsKm;
ivec3 c=ivec3(floor(p_)+start_c_offset);
int idx=0;
float W=halfClipSize;
const float start=0.866*0.866;
const float ends=1.0;
const float range=ends-start;
float lastFadeDistance=0.0;
ivec2 b=abs(c.xy-C0.xy*2);
vec3 amb_dir=view;
for(int j=0;j<8;j++)
{
if(max(max(b.x,b.y),0)>=W)
{
c0.xy=C0.xy;
c.xy+=start_c_offset.xy;
c.xy-=abs(c.xy&ivec2(1,1));
c.xy=c.xy>>1;
gridScale.xy*=2.0;
if(idx==0)W*=2;
p0.xy=P0.xy;
P0.xy=startOffsetFromOriginKm.xy/gridScale.xy/2.0;
C0.xy+=start_c_offset.xy;
C0.xy-=abs(C0.xy&ivec2(1,1));
C0.xy=C0.xy>>1;
viewGridspace=view/gridScale;
viewGridspace=normalize(viewGridspace);
unitStepKm=viewGridspace*gridScale;
unitStepLengthKm=length(unitStepKm);
idx++;
b=abs(c.xy-C0.xy*2);
}
else
break;
}

float distScale=0.6/maxFadeDistanceKm;
for(int i=0;i<768;i++)
{
world_pos+=0.001*view;
if((view.z<0&&world_pos.z<min_z)||(view.z>0&&world_pos.z>max_z)||distanceKm>maxCloudDistanceKm)break;
offsetFromOrigin=world_pos-gridOriginPosKm;
ivec3 c1=c+c_offset;
vec3 p=offsetFromOrigin/gridScale;
vec3 p1=vec3(c1);
vec3 dp=p1-p;
vec3 D=(dp/viewGridspace);
float e=min(min(D.x,D.y),D.z);
vec3 N=step(D,vec3(e,e,e));
ivec3 c_step=c_offset*ivec3(N);
float stepKm=e*unitStepLengthKm;
distanceKm+=stepKm;
p1=p+e*viewGridspace;
world_pos+=stepKm*view;
vec3 cloudWorldOffsetKm=world_pos-cornerPosKm;
vec3 cloudTexCoords=cloudWorldOffsetKm*inverseScalesKm;
c+=c_step;
ivec2 intermediate=abs(c.xy&ivec2(1,1));
float is_inter=dot(N.xy,vec2(intermediate));
vec3 pw=abs(p1-p0);
float fade_inter=saturate((length(pw.xy)/(float(W)*(3.0-2.0*is_inter)-1.0)-start)/range);
float fade=(1.0-fade_inter);
float fadeDistance=saturate(distanceKm/maxFadeDistanceKm);
maxDistance=max(fadeDistance,maxDistance);
b=abs(c.xy-C0.xy*2);
#line 227 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_raytrace.sl"

if(fade>0.0)
{
float mip=0.0;
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),cloudTexCoords,0.0);

{
vec3 noise_texc=world_pos.xyz*noise3DTexcoordScale+noise3DTexcoordOffset;
vec4 noiseval=vec4(0,0,0,0);
float cosine=dot(N,abs(view));
if(noise)noiseval=density.x*textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc,1.0*(fadeDistance+1.0-abs(cosine)));
vec4 light=vec4(1,1,1,1);
calcDensity(cloudDensity,cloudLight,cloudTexCoords,noiseval,fractalScale,mip,density,light);
if(do_rain_effect)
{
float dm=rainEffect*fade*GetRainAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm);
dm*=saturate(0.6+textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc+vec3(0,0,rainVerticalTexcoord),0.0).z);
moisture+=0.01*dm*light.x;
density.z=max(density.z,dm);
}

if(density.z>0)
{
density.z=saturate(0.3+(1.0+5.0*density.y)*(density.z-0.3));
minDistance=min(max(0,fadeDistance-density.z*stepKm/maxFadeDistanceKm),minDistance);
vec3 worley_texc=(world_pos.xyz+windOffsetKm.xyz)*worleyTexcoordScale+worleyOffsetKm;
vec4 worley=textureLod(sampler3D(smallWorleyTexture3D[1 + 6]),worley_texc,0);
float wo=4*density.y*(worley.w-0.6)*saturate(1.0/(12.0*fadeDistance));
density.z=mix(density.z,density.z*saturate(0.3+((density.z+wo)-0.3-saturate(0.6-density.z))),density.y);
amb_dir=mix(amb_dir,worley.xyz,0.1*density.z);
float brightness_factor;
fade_texc.x=sqrt(fadeDistance);
vec3 volumeTexCoords=vec3(volumeTexCoordsXyC.xy,fade_texc.x);
ColourStep(res.colour,insc,meanFadeDistance,brightness_factor,lossTexture,inscTexture,skylTexture,inscatterVolumeTexture,do_godrays,godraysVolumeTexture,lightspaceScale,godraysTexCoords,lightTableTexture,density,light,distanceKm,fadeDistance,world_pos,cloudTexCoords,fade_texc,nearFarTexc,cosine,volumeTexCoords,amb_dir,BetaClouds,BetaRayleigh,BetaMie,solidDist_nearFar,noise,do_depth_mix,distScale,idx,noiseval,fade,alphaSharpness);
if(res.colour[0].a*brightness_factor<0.003)
{
for(int o=0;o<num_interp;o++)res.colour[o].a=0.0;
meanFadeDistance=fadeDistance;
break;
}

}

lastFadeDistance=mix(lastFadeDistance,fadeDistance-density.z*stepKm/maxFadeDistanceKm,res.colour[num_interp-1].a);
}

}

if(max(max(b.x,b.y),0)>=W)
{
c0.xy=C0.xy;
c.xy+=start_c_offset.xy;
c.xy-=abs(c.xy&ivec2(1,1));
c.xy=c.xy>>1;
gridScale.xy*=2.0;
if(idx==0)W*=2;
p0.xy=P0.xy;
P0.xy=startOffsetFromOriginKm.xy/gridScale.xy/2.0;
C0.xy+=start_c_offset.xy;
C0.xy-=abs(C0.xy&ivec2(1,1));
C0.xy=C0.xy>>1;
viewGridspace=view/gridScale;
viewGridspace=normalize(viewGridspace);
unitStepKm=viewGridspace*gridScale;
unitStepLengthKm=length(unitStepKm);
idx++;
}

}

res.nearFarDepth.zw=vec2(meanFadeDistance,moisture);
for(int k=0;k<num_interp;k++)
{
res.colour[k].rgb+=insc[k].rgb;
}

return res;
}
#line 79 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
vec3 WorldToVolumePos(vec3 world_pos_km, vec3 centreVolumePos, vec3 vol_km)
{
vec3 vp=world_pos_km/vol_km;
return vp+centreVolumePos;
}
#line 96 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
vec3 GridToWorldPos(vec3 grid_pos, vec3 grid_km, vec3 centreVolumePosKm)
{
vec3 wp=grid_pos*grid_km-centreVolumePosKm;
return wp;
}
#line 114 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
ivec3 FloatToIntGrid(vec3 grid_pos)
{
return ivec3(floor(grid_pos));
}
#line 127 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
vec3 WorldToGridPos(vec3 world_pos_km, vec3 gridKm, vec3 centreGridPos)
{
return world_pos_km/gridKm+centreGridPos;
}
#line 132 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_experimental.sl"
RaytracePixelOutput RaytraceCloudsExperimental(uint64_t cloudDensity[24], uint64_t cloudLight[24], uint64_t precipitationVolume[24], uint64_t noiseTexture3D[24], uint64_t lightTableTexture[24], uint64_t illuminationTexture[24], uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], bool do_depth_mix, vec4 dlookup, vec3 view, vec4 clip_pos, vec3 volumeTexCoordsXyC, bool noise, bool do_rain_effect, bool do_rainbow, vec3 cloudIrRadiance1, vec3 cloudIrRadiance2, int num_interp, bool do_godrays, vec3 cloudTintColour, uint seed)
{
RaytracePixelOutput res;
vec4 insc[2];
for(int ii=0;ii<num_interp;ii++)
{
res.colour[ii]=vec4(0,0,0,1.0);
insc[ii]=vec4(0,0,0,0);
}

res.nearFarDepth=dlookup;
float s=saturate((directionToSun.z+0.2)/0.01);
vec3 lightDirection=mix(directionToMoon,directionToSun,s);
float cos0=dot(lightDirection.xyz,view.xyz);
float min_z=cornerPosKm.z-(fractalScale.z*1.5)/inverseScalesKm.z;
float max_z=cornerPosKm.z+(1.0+fractalScale.z*1.5)/inverseScalesKm.z;
if(do_rain_effect)min_z=-1.0;
vec3 godraysTexCoords=vec3(0,0,0);
float lightspaceScale=1.0;
if(do_godrays)
{
vec3 lightspaceView=(mul(worldToScatteringVolumeMatrix,vec4(view,1.0)).xyz);
lightspaceScale=length(lightspaceView);
godraysTexCoords=vec3(fract(atan(lightspaceView.x,lightspaceView.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceView.z/lightspaceScale)*2.0/3.1415926536,0);
}

float solidDist_nearFar[2];
vec2 nfd=(dlookup.yx)+100.0*step(vec2(1.0,1.0),dlookup.yx);
solidDist_nearFar[0]=nfd.x;
solidDist_nearFar[num_interp-1]=nfd.y;
for(int l=1;l<num_interp-1;l++)
{
float interp=1.0-float(l)/float(num_interp-1);
solidDist_nearFar[l]=mix(solidDist_nearFar[0],solidDist_nearFar[num_interp-1],1.0-interp);
}

float sine=view.z;
vec2 fade_texc=vec2(0.0,0.5*(1.0-sine));
vec2 illum_texc=vec2(atan(view.x,view.y)/(3.1415926536*2.0),fade_texc.y);
vec4 illum_lookup=texture(sampler2D(illuminationTexture[1 + 3]),illum_texc);
vec2 nearFarTexc=illum_lookup.xy;
float meanFadeDistance=1.0;
float BetaClouds=HenyeyGreenstein(cloudEccentricity,cos0);
float BetaRayleigh=CalcRayleighBeta(cos0);
float BetaMie=HenyeyGreenstein(hazeEccentricity,cos0);
float moisture=0.0;
vec3 world_pos_km=viewPosKm;
world_pos_km.xy-=windOffsetKm.xy;
uint mip=uint(maxMip);
uint mipscale=uint(1)<<mip;
uvec3 mip_grid=uvec3(windowGrid)/mipscale;
vec3 windowGridf=vec3(mip_grid);
vec3 centreVolumePos=vec3((typed_mod((gridCentreTexel.xy+ivec2(windowGrid.xy/2)),ivec2(windowGrid.xy))-ivec2(windowGrid.xy/2))/float(windowGrid.x),0);
vec3 gridKm=VolumeScaleKm/windowGridf;
vec3 centreVolumePosKm=VolumeScaleKm*centreVolumePos;
vec3 centreGridPos=windowGridf*centreVolumePos;
vec3 grid_pos=WorldToGridPos(world_pos_km,gridKm,centreGridPos);
vec3 grid_dir=normalize(WorldToGridPos(world_pos_km+view,gridKm,centreGridPos)-grid_pos);
ivec3 c_offset=ivec3(2.0*step(vec3(0,0,0),view.xyz)-vec3(1,1,1));
ivec3 c_next=FloatToIntGrid(grid_pos);
uint idx=0;
int count_detail=0;
vec3 amb_dir=view;
float distScale=0.6/maxFadeDistanceKm;
int i=0;
uint use_mip=0;
int steps_at_mip=0;
vec3 last_grid_pos=grid_pos;
ivec3 c_offset_x=ivec3(step(vec3(0,0,0),grid_dir.xyz));
c_offset=2*c_offset_x-ivec3(1,1,1);
float distanceLimitKm=0.f;
for(i=0;i<768;i++)
{
if((view.z<0&&world_pos_km.z<min_z)||(view.z>0&&world_pos_km.z>max_z)||distanceLimitKm>maxCloudDistanceKm)break;
vec3 prev_world_pos_km=world_pos_km;
ivec3 c=c_next;
if(mip>use_mip)
{
vec4 lookup=vec4(0,0,0,0);
ivec4 lookup_index=ivec4(typed_mod((c.xy+mip_grid.xy),mip_grid.xy),c.z,mip);
if(c.z<mip_grid.z&&c.z>=0)lookup=texelFetch(sampler3D(cloudDensity[0]),ivec3(lookup_index).xyz,int(lookup_index.w));
if(do_rain_effect)lookup.z+=rainEffect*GetPrecipitationAtOffsetKm(precipitationVolume,(world_pos_km-cornerPosKm),inverseScalesKm,float(mip)).w;
if(lookup.z!=0)
{
mip--;
mipscale=uint(1)<<mip;
mip_grid=ivec3(windowGrid)/mipscale;
windowGridf=vec3(mip_grid);
gridKm=VolumeScaleKm/windowGridf;
centreVolumePosKm=VolumeScaleKm*centreVolumePos;
centreGridPos=windowGridf*centreVolumePos;
grid_pos=WorldToGridPos(world_pos_km,gridKm,centreGridPos);
c_next=FloatToIntGrid(grid_pos);
continue;
}

ivec3 c1=c+c_offset_x;
vec3 grid_pos_1=c1;
vec3 dp=grid_pos_1-grid_pos;
vec3 D=dp/grid_dir;
float e=min(min(D.x,D.y),D.z);
vec3 N=step(D,vec3(e,e,e));
ivec3 c_step=c_offset*ivec3(N);
grid_pos+=e*grid_dir;
c_next=c+c_step;
world_pos_km=GridToWorldPos(grid_pos,gridKm,centreVolumePosKm);
vec3 step_km=world_pos_km-prev_world_pos_km;
float stepKm=length(step_km);
distanceLimitKm=length(world_pos_km-viewPosKm);
continue;
}

ivec3 c1=c+c_offset_x;
vec3 grid_pos_1=c1;
vec3 dp=grid_pos_1-grid_pos;
vec3 D=dp/grid_dir;
float e=min(min(D.x,D.y),D.z);
vec3 N=step(D,vec3(e,e,e));
ivec3 c_step=c_offset*ivec3(N);
grid_pos+=e*grid_dir;
c_next=c+c_step;
world_pos_km=GridToWorldPos(grid_pos,gridKm,centreVolumePosKm);
vec3 step_km=world_pos_km-prev_world_pos_km;
float stepKm=length(step_km);
idx=uint(mip);
vec3 sample_pos_km=world_pos_km;
vec3 cloud_tex_coords=WorldToVolumePos(sample_pos_km,centreVolumePos,VolumeScaleKm);

{
vec4 light=textureLod(sampler3D(cloudLight[1 + 7]),cloud_tex_coords,0);
vec3 noise_texc=(sample_pos_km.xyz+windOffsetKm.xyz)*noise3DTexcoordScale+noise3DTexcoordOffset;
vec4 noiseval=vec4(0,0,0,0);
if(noise)
{
vec4 noiseval1=textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc,0.0);
noiseval=light.z*noiseval1;
}

vec3 noise_adjusted_texc=cloud_tex_coords.xyz+fractalScale.xyz*(noiseval.xyz);
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),noise_adjusted_texc,use_mip);
if(do_rain_effect)
{
float dm=rainEffect*GetRainAtOffsetKm(precipitationVolume,(sample_pos_km-cornerPosKm)+((fractalScale.xyz*noiseval.xyz)/inverseScalesKm),inverseScalesKm);
dm*=saturate(0.6+textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc+vec3(0,0,rainVerticalTexcoord),0.0).z);
moisture+=0.01*dm*light.x;
density.z=max(density.z,dm);
}

if(density.z>0)
{
float distanceKm=length(world_pos_km-viewPosKm);
float fadeDistance=saturate(distanceKm/maxFadeDistanceKm);
density.z*=saturate(distanceKm/0.24);
density.z=mix(1.0/(1.0+exp(-20.0*(density.z-0.3))),density.z,density.y);
vec3 worley_texc=(sample_pos_km.xyz+windOffsetKm.xyz)*worleyTexcoordScale+worleyOffsetKm;
vec4 worley=textureLod(sampler3D(smallWorleyTexture3D[1 + 6]),worley_texc,0);
float wo=4*light.w*mix(1.0,worley.w,saturate(1.0/(12.0*fadeDistance)));
density.z=mix(density.z,density.z*saturate(0.3+((density.z+wo)-0.3-saturate(0.6-density.z))),density.y);
float brightness_factor;
fade_texc.x=sqrt(fadeDistance);
vec3 volumeTexCoords=vec3(volumeTexCoordsXyC.xy,fade_texc.x);
float opacity=density.z;
opacity=saturate(0.3+(1.0+1.0*density.w*alphaSharpness)*(opacity-0.3));
float cosine=dot(N,abs(view));
ColourStep2(res.colour,insc,brightness_factor,inscatterVolumeTexture,lossTexture,do_godrays,godraysVolumeTexture,lightspaceScale,godraysTexCoords,lightTableTexture,density,light,distanceKm,fadeDistance,world_pos_km,cloud_tex_coords,fade_texc,volumeTexCoords,BetaClouds,solidDist_nearFar,do_depth_mix,distScale,idx,opacity,cosine,cloudTintColour);
meanFadeDistance=mix(min(fadeDistance,meanFadeDistance),meanFadeDistance,(1.0-.4*density.z));
if(res.colour[0].a*brightness_factor<0.03)
{
for(int o=0;o<num_interp;o++)
{
res.colour[o].a=0.0;
}

meanFadeDistance=fadeDistance;
break;
}

continue;
}

count_detail++;
if(count_detail>2)
{
mip=maxMip;
mipscale=int(1)<<mip;
mip_grid=ivec3(windowGrid)/mipscale;
windowGridf=vec3(mip_grid);
gridKm=VolumeScaleKm/windowGridf;
centreGridPos=windowGridf*centreVolumePos;
grid_pos=WorldToGridPos(world_pos_km,gridKm,centreGridPos);
c_next=FloatToIntGrid(grid_pos);
count_detail=0;
}

}

}

res.nearFarDepth.zw=vec2(meanFadeDistance,moisture);
float grey=float(1)/100.0;
for(int k=0;k<num_interp;k++)
{
res.colour[k].rgb+=insc[k].rgb;
}

return res;
}
#line 769 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void Raytrace(uvec3 pos, bool include_rain, bool depth, int num_interp, bool do_godrays, bool experimental, bool blend)
{
vec2 texCoords=(vec2(pos.xy)+vec2(0.5,0.5))/vec2(targetTextureSize);
vec4 clip_pos=vec4(-1.0,1.0,1.0,1.0);
clip_pos.x+=2.0*texCoords.x;
clip_pos.y-=2.0*texCoords.y;
vec3 view=normalize(mul(invViewProj[pos.z],clip_pos).xyz);
vec4 dlookup=vec4(1.0,1.0,0.000001,1.0);
if(depth)
{
dlookup=textureLod(samplerCube(depthTexture[1 + 6]),view,0);
}

uint seed=0;
vec3 worldspaceVolumeTexCoordsXyC=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(view.z)/3.1415926536),0);
RaytracePixelOutput f;
if(experimental)f=RaytraceCloudsExperimental(cloudDensity,cloudDensity2,precipitationVolume,noiseTexture3D,lightTableTexture,illuminationTexture,lossTexture,inscTexture,skylTexture,volumeInscatterTexture,godraysTexture,true,dlookup,view,clip_pos,worldspaceVolumeTexCoordsXyC,true,include_rain,false,cloudIrRadiance1,cloudIrRadiance2,num_interp,do_godrays,cloudTintColour,seed);else
f=RaytraceCloudsForward(cloudDensity,cloudDensity2,precipitationVolume,noiseTexture3D,lightTableTexture,illuminationTexture,lossTexture,inscTexture,skylTexture,volumeInscatterTexture,godraysTexture,true,dlookup,view,clip_pos,worldspaceVolumeTexCoordsXyC,true,include_rain,false,cloudIrRadiance1,cloudIrRadiance2,num_interp,do_godrays,cloudTintColour);
vec4 resn=f.colour[2-1];
if(blend)
{

}

imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*(2-1))),vec4(resn));
float n=float(dlookup.y>=1.0);
for(int u=0;u<2-1;u++)
{
vec4 res=f.colour[u];
if(blend)
{

}

imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*u)),vec4(res));
}

imageStore(outputTexture3,ivec3(pos),vec4(f.nearFarDepth));
#line 860 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"

}
#line 901 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void CS_Raytrace(uvec3 g, uvec3 t, bool include_rain, bool depth, bool godrays, bool experimental)
{
uvec2 idx=uvec2(g.xy*4+t.xy);
uint Z=cubemapFaceIndex[g.z+t.z].x;
uvec3 pos=uvec3(targetRange[Z].xy+idx*amortizationScale.xy,Z);
uvec2 offs=amortizationOffset.xy;
pos.xy+=offs;
if(pos.x>=edge.x||pos.y>=edge.y)return ;
if(pos.x>=targetRange[Z].z||pos.y>=targetRange[Z].w)return ;
if(texelFetch(sampler2DArray(updateTexture[0]),ivec3(pos).xyz,0).b==0.0)return ;
Raytrace(pos,include_rain,depth,2,godrays,experimental,true);
}
layout(local_size_x=4, local_size_y=4, local_size_z=1) in;
void main()
{
uvec3 g = gl_WorkGroupID;
uvec3 t = gl_LocalInvocationID;
#line 1114 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
CS_Raytrace(g,t,true,true,true,false);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_CS_RaytraceSimple_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 12) uniform CloudStaticConstants
{
	mat4 invViewProj[6];
};
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};

#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
struct RaytracePixelOutput
{
	vec4 colour[2];
	vec4 nearFarDepth;
};












layout(rgba16f, binding = 4) uniform image2DArray outputTexture1;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t smallWorleyTexture3D[24];
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
	uint64_t noiseTexture3D[24];
	uint64_t godraysTexture[24];
	uint64_t volumeInscatterTexture[24];
	uint64_t skylTexture[24];
	uint64_t inscTexture[24];
	uint64_t lossTexture[24];
	uint64_t depthTexture[24];
	uint64_t illuminationTexture[24];
	uint64_t lightTableTexture[24];
	uint64_t precipitationVolume[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float CalcRayleighBeta(float cos0)
{
return (1.0+cos0*cos0);
}
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float HenyeyGreenstein(float g, float cos0)
{
float g2=g*g;
float u=1.0+g2-2.0*g*cos0;
return (1.0-g2)*pow(u,-1.5)/(4.0*3.1415926536);
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
vec3 PrecalculatedInscatterFunction(vec4 inscatter_factor, float BetaRayleigh, float BetaMie, vec3 mieRayleighRatio)
{
vec3 mr=mieRayleighRatio.xyz;
vec3 BetaTotal=(BetaRayleigh+BetaMie*mr)/(vec3(1.0,1.0,1.0)+mr);
vec3 colour=BetaTotal*inscatter_factor.rgb;
return colour;
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float GetAltTexCoord(float alt_km, float minSunlightAltitudeKm, float fadeAltitudeRangeKm)
{
float diff_km=alt_km-minSunlightAltitudeKm;
float sun_alt_texc=0.5+0.5*saturate(diff_km/fadeAltitudeRangeKm);
sun_alt_texc-=0.5*saturate(-diff_km/(minSunlightAltitudeKm+1.0));
return sun_alt_texc;
}
#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float unshadowedBrightness(float Beta, vec4 lightResponse, vec3 ambientColour)
{
return max(1.0,(Beta+lightResponse.y)+ambientColour.b);
}
#line 34 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColour(uint64_t lossTexture[24], uint64_t inscatterVolumeTexture[24], vec3 volumeTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float Beta, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec3 amb_dir, vec2 fade_texc, out float brightnessFactor, out vec4 inscatter, float fade, float alphaSharpness)
{
float alt_texc=(world_pos.z/fadeAltitudeRangeKm);
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 amb_lookup=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
ambientColour=lightResponse.w*amb_lookup.rgb;
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
vec3 ambient=amb_lookup.rgb*light.w;
vec4 c;
float l=mix(0.75,1.2,density.z);
c.rgb=(light.y*lightResponse.x*(Beta+l)+lightResponse.y*light.x)*combinedLightColour+ambient.rgb;
c.a=density.z*fade;
c.a=saturate(0.3+(1.0+1.0*density.w*alphaSharpness)*(c.a-0.3));

{
vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

inscatter=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),volumeTexCoords,0);
inscatter.rgb*=inscatter.a;
#line 62 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

}

return c;
}
#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColourSimple(uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t lightTableTexture[24], vec4 density, float Beta, float BetaRayleigh, float BetaMie, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, out float brightnessFactor)
{
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
ambientColour=lightResponse.w*textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
vec3 ambient=density.w*ambientColour.rgb;
float opacity=density.z;
vec4 c;
c.rgb=(density.y*Beta+lightResponse.y*density.x)*combinedLightColour+ambient.rgb;
c.a=opacity;
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float earthshadowFactr=saturate((fade_texc.x-nearFarTexc.x)/0.1);
#line 88 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
vec4 insc=textureLod(sampler2D(inscTexture[1 + 5]),fade_texc,0);
vec3 skyl=textureLod(sampler2D(skylTexture[1 + 5]),fade_texc,0).rgb;
vec3 inscatter=earthshadowFactr*PrecalculatedInscatterFunction(insc,BetaRayleigh,BetaMie,mieRayleighRatio);
c.rgb+=inscatter+skyl;
return c;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void calcDensity(uint64_t cloudDensity[24], uint64_t cloudLight[24], vec3 texCoords, vec4 noiseval, vec3 fractalScale, float mip, inout vec4 density, out vec4 light)
{
vec3 pos=texCoords.xyz+fractalScale.xyz*(noiseval.xyz);
density=textureLod(sampler3D(cloudDensity[1 + 7]),pos,mip);
light=textureLod(sampler3D(cloudLight[1 + 7]),texCoords,mip);
}
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 GetPrecipitationAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm, float mip)
{
vec3 rain_texc=cloudWorldOffsetKm;
rain_texc.xy+=rain_texc.z*rainTangent;
rain_texc*=inverseScalesKm;
vec3 pvSize;
ivec3 ivprecipitationVolume = textureSize(sampler3D(precipitationVolume[0]),0);
pvSize.x = ivprecipitationVolume.x;pvSize.y = ivprecipitationVolume.y;pvSize.z = ivprecipitationVolume.z;;
uint z_texel=uint(rain_texc.z*pvSize.z);
rain_texc.z=(float(z_texel)+0.5)/pvSize.z;
return textureLod(sampler3D(precipitationVolume[1 + 7]),rain_texc,mip);
}
#line 120 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float GetRainAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm)
{
vec4 rain_lookup=GetPrecipitationAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm,0.0);
return rain_lookup.x*rain_lookup.w*saturate((20.0*rain_lookup.y-cloudWorldOffsetKm.z)/2.0);
}
#line 146 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void ColourStep(inout vec4 colour[2], inout vec4 insc[2], inout float meanFadeDistance, out float brightness_factor, uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], bool godrays, uint64_t godraysVolumeTexture[24], float godraysScale, vec3 godraysTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float distanceKm, float fadeDistance, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, float cosine, vec3 volumeTexCoords, vec3 amb_dir, float BetaClouds, float BetaRayleigh, float BetaMie, float solidDist_nearFar[2], bool noise, bool do_depth_mix, float distScale, int idx, vec4 noiseval, float fade, float alphaSharpness)
{
density.z*=saturate(distanceKm/0.24);
vec4 clr[2];
vec4 inscatter=vec4(0,0,0,0);
brightness_factor=1.0;
if(noise)clr[2-1]=calcColour(lossTexture,inscatterVolumeTexture,volumeTexCoords,lightTableTexture,density,light,BetaClouds,lightResponse,ambientColour,world_pos,cloudTexCoords,amb_dir,fade_texc,brightness_factor,inscatter,fade,alphaSharpness);else
clr[2-1]=calcColourSimple(lossTexture,inscTexture,skylTexture,lightTableTexture,vec4(light.xyw,density.z),BetaClouds,BetaRayleigh,BetaMie,lightResponse,ambientColour,world_pos,cloudTexCoords,fade_texc,nearFarTexc,brightness_factor);
clr[2-1].a*=cosine*cosine;
meanFadeDistance=mix(min(fadeDistance,meanFadeDistance),meanFadeDistance,(1.0-.4*density.z));
godraysTexCoords.z=distanceKm*godraysScale;
float gr_mult=1.0;
if(godrays)gr_mult=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),godraysTexCoords,0).x;
for(int i=0;i<2;i++)
{
clr[i]=clr[2-1];
if(do_depth_mix)
{
float m=saturate((solidDist_nearFar[i]-fadeDistance)/distScale);
clr[i].a*=m;
}

colour[i].rgb+=(clr[i].rgb)*clr[i].a*(colour[i].a);
insc[i].rgb+=gr_mult*inscatter.rgb*clr[i].a*(colour[i].a);
colour[i].a*=(1.0-clr[i].a);
}

}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_simple.sl"
RaytracePixelOutput RaytraceCloudsStatic(uint64_t cloudDensity[24], uint64_t cloudLight[24], uint64_t precipitationVolume[24], uint64_t noiseTexture3D[24], uint64_t lightTableTexture[24], uint64_t illuminationTexture[24], uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], bool do_depth_mix, vec4 dlookup, vec3 view, vec4 clip_pos, vec3 volumeTexCoordsXyC, bool noise, bool do_rain_effect, bool do_rainbow, vec3 cloudIrRadiance1, vec3 cloudIrRadiance2, int numSteps, int num_interp, bool do_godrays, bool consistent_steps)
{
RaytracePixelOutput res;
vec4 insc[2];
for(int ii=0;ii<num_interp;ii++)
{
res.colour[ii]=vec4(0,0,0,1.0);
insc[ii]=vec4(0,0,0,0);
}

res.nearFarDepth=dlookup;
float s=saturate((directionToSun.z+0.2)/0.01);
vec3 lightDirection=mix(directionToMoon,directionToSun,s);
float cos0=dot(lightDirection.xyz,view.xyz);
float sine=view.z;
float min_z=cornerPosKm.z-(fractalScale.z*1.5)/inverseScalesKm.z;
float max_z=cornerPosKm.z+(1.0+fractalScale.z*1.5)/inverseScalesKm.z;
vec3 godraysTexCoords=vec3(0,0,0);
float lightspaceScale=1.0;
if(do_godrays)
{
vec3 lightspaceView=(mul(worldToScatteringVolumeMatrix,vec4(view,1.0)).xyz);
lightspaceScale=length(lightspaceView);
godraysTexCoords=vec3(fract(atan(lightspaceView.x,lightspaceView.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceView.z/lightspaceScale)*2.0/3.1415926536,0);
}

float solidDist_nearFar[2];
vec2 nfd=(dlookup.yx)+100.0*step(vec2(1.0,1.0),dlookup.yx);
float n=nfd.x;
float f=nfd.y;
solidDist_nearFar[0]=n;
solidDist_nearFar[num_interp-1]=f;
for(int l=1;l<num_interp-1;l++)
{
float interp=float(l)/float(num_interp-1);
solidDist_nearFar[l]=mix(n,f,interp);
}

vec2 fade_texc=vec2(0.0,0.5*(1.0-sine));
vec2 illum_texc=vec2(atan(view.x,view.y)/(3.1415926536*2.0),fade_texc.y);
vec4 illum_lookup=textureLod(sampler2D(illuminationTexture[1 + 3]),illum_texc,0);
vec2 nearFarTexc=vec2(0,1.0);
float meanFadeDistance=1.0;
float minDistance=1.0;
float maxDistance=0.0;
float BetaClouds=lightResponse.x*HenyeyGreenstein(cloudEccentricity,cos0);
float BetaRayleigh=CalcRayleighBeta(cos0);
float BetaMie=HenyeyGreenstein(hazeEccentricity,cos0);
float moisture=0.0;
vec3 world_pos=viewPosKm;
view.xyz+=vec3(0.00001,0.00001,0.00001);
ivec3 c_offset=ivec3(2.0*step(vec3(0,0,0),view.xyz)-vec3(1,1,1));
ivec3 start_c_offset=-c_offset;
start_c_offset=ivec3(max(start_c_offset.x,0),max(start_c_offset.y,0),max(start_c_offset.z,0));
vec3 viewScaled=view/scaleOfGridCoordsKm;
viewScaled=normalize(viewScaled);
vec3 offset_vec=vec3(0,0,0);
float maxDistKm=maxCloudDistanceKm;
float K=log(maxDistKm);
float step_ratio=1.0+K/float(numSteps);

{
float a=1.0/(saturate(view.z)+0.00001);
offset_vec+=max(0.0,min_z-world_pos.z)*vec3(view.x*a,view.y*a,1.0);
}


{
float a=1.0/(saturate(-view.z)+0.00001);
offset_vec+=max(0.0,world_pos.z-max_z)*vec3(view.x*a,view.y*a,-1.0);
}

vec3 halfway=0.5*(lightDirection-view);
world_pos+=offset_vec;
float distanceKm=length(offset_vec);
float distScale=0.6/maxFadeDistanceKm;
bool found=false;
float stepKm=K*(1.2+distanceKm)/float(numSteps);
vec3 amb_dir=view;
uint steps=initialSteps-uint((1&stepPos)!=0);
uint in_step=0,c=0;
float rangeKm=initialSteps*stepKm;
float oddRangeKm=(0.5*stepKm*initialSteps);
for(int i=0;i<768;i++)
{
if((view.z<0&&world_pos.z<min_z)||(view.z>0&&world_pos.z>max_z)||distanceKm>maxCloudDistanceKm)break;
distanceKm+=stepKm;
float fade=1.0;
if(consistent_steps)
{
uint odd=typed_mod((steps-in_step),2);
float fade_up=saturate((rangeKm-distanceKm)/oddRangeKm);
fade=(odd!=0)?fade_up:1.0;
if(in_step++==steps)
{
stepKm*=2.0;
c++;
uint u=(1<<c);
steps=initialSteps-uint((u&stepPos)!=0);
in_step=0;
rangeKm=distanceKm+initialSteps*stepKm;
oddRangeKm=(0.5*stepKm*initialSteps);
}

}

world_pos+=stepKm*view;
if(!consistent_steps)stepKm*=step_ratio;
vec3 cloudWorldOffsetKm=world_pos-cornerPosKm;
vec3 cloudTexCoords=cloudWorldOffsetKm*inverseScalesKm;
float fadeDistance=saturate(distanceKm/maxFadeDistanceKm);
maxDistance=max(fadeDistance,maxDistance);
if(fade>0)
{
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),cloudTexCoords,fadeDistance*0.0);

{

}


{
vec3 noise_texc=world_pos.xyz*noise3DTexcoordScale+noise3DTexcoordOffset;
vec3 noise_texc2=world_pos.xyz*noise3DTexcoordScale2+noise3DTexcoordOffset2;
vec4 noiseval=vec4(0,0,0,0);
if(noise)
{
vec4 noiseval1=density.x*textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc,1.0*fadeDistance);
vec4 noiseval2=density.x*textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc2,1.0*fadeDistance);
noiseval=noiseval1*cos(.2*3.14159*noiseval2.x)+noiseval1.wzxy*sin(.2*3.14159*noiseval2.y);
}

vec4 light=vec4(1,1,1,1);
calcDensity(cloudDensity,cloudLight,cloudTexCoords,noiseval,fractalScale,0,density,light);
density.z*=fade;
if(do_rain_effect)
{
float dm=rainEffect*fade*GetRainAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm);
moisture+=0.01*dm*light.x;
density.z=saturate(density.z+dm);
}

if(density.z>0)
{
if(noise)
{
vec3 worley_texc=(world_pos.xyz+worleyOffsetKm)*worleyTexcoordScale;
minDistance=min(max(0,fadeDistance-density.z*stepKm/maxFadeDistanceKm),minDistance);
vec4 worley=textureLod(sampler3D(smallWorleyTexture3D[1 + 6]),worley_texc,0);
float wo=4*density.y*(worley.w-0.6)*saturate(1.0/(12.0*fadeDistance));
density.z*=mix(1.0,worley.w,saturate(1.0/(12.0*fadeDistance)));
amb_dir=mix(amb_dir,worley.xyz,0.1*density.z);
}

float brightness_factor;
fade_texc.x=sqrt(fadeDistance);
vec3 volumeTexCoords=vec3(volumeTexCoordsXyC.xy,fade_texc.x);
ColourStep(res.colour,insc,meanFadeDistance,brightness_factor,lossTexture,inscTexture,skylTexture,inscatterVolumeTexture,do_godrays,godraysVolumeTexture,lightspaceScale,godraysTexCoords,lightTableTexture,density,light,distanceKm,fadeDistance,world_pos,cloudTexCoords,fade_texc,nearFarTexc,1.0,volumeTexCoords,amb_dir,BetaClouds,BetaRayleigh,BetaMie,solidDist_nearFar,noise,do_depth_mix,distScale,0,noiseval,1.0,alphaSharpness);
if(res.colour[0].a*brightness_factor<0.003)
{
for(int o=0;o<num_interp;o++)res.colour[o].a=0.0;
meanFadeDistance=fadeDistance;
break;
}

}

}

}

}

res.nearFarDepth.zw=vec2(meanFadeDistance,moisture);
#line 261 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_simple.sl"

for(int j=0;j<num_interp;j++)res.colour[j].rgb+=insc[j].rgb;
return res;
}
#line 646 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void SimpleRaytrace(uvec3 pos, bool include_rain, bool depth, int numSteps, int num_interp, bool consistent_steps)
{
vec2 texCoords=(vec2(pos.xy)+vec2(0.5,0.5))/vec2(targetTextureSize);
vec4 clip_pos=vec4(-1.0,1.0,1.0,1.0);
clip_pos.x+=2.0*texCoords.x;
clip_pos.y-=2.0*texCoords.y;
vec3 view=normalize(mul(invViewProj[pos.z],clip_pos).xyz);
vec4 dlookup=vec4(1.0,1.0,0.000001,1.0);
if(depth)
{
dlookup=textureLod(samplerCube(depthTexture[1 + 6]),view,0);
}

vec3 worldspaceVolumeTexCoordsXyC=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(view.z)/3.1415926536),0);
RaytracePixelOutput f=RaytraceCloudsStatic(cloudDensity,cloudDensity2,precipitationVolume,noiseTexture3D,lightTableTexture,illuminationTexture,lossTexture,inscTexture,skylTexture,volumeInscatterTexture,godraysTexture,depth,dlookup,view,clip_pos,worldspaceVolumeTexCoordsXyC,false,include_rain,false,cloudIrRadiance1,cloudIrRadiance2,numSteps,num_interp,false,consistent_steps);
vec4 t2d=vec4(0,0,0,1.0);
vec4 c=t2d;
c.rgb*=f.colour[num_interp-1].a;
c.rgb+=f.colour[num_interp-1].rgb;
c.a=t2d.a*f.colour[num_interp-1].a;
imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*(num_interp-1))),vec4(c));
float n=float(dlookup.y>=1.0);
for(int u=0;u<num_interp-1;u++)
{
vec4 cn=t2d;
cn.rgb*=f.colour[u].a*n;
cn.a=1.0-n*(1.0-t2d.a);
cn.rgb+=f.colour[u].rgb;
cn.a*=f.colour[u].a;
imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*u)),vec4(cn));
}

}
layout(local_size_x=4, local_size_y=4, local_size_z=1) in;
void main()
{
uvec3 g = gl_WorkGroupID;
uvec3 t = gl_LocalInvocationID;
#line 1088 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
uvec2 idx=uvec2(g.xy*4+t.xy);
uint Z=cubemapFaceIndex[g.z+t.z].x;
uvec3 pos=uvec3(targetRange[t.z].xy+idx*amortizationScale.xy+amortizationOffset.xy,Z);
SimpleRaytrace(pos,false,false,128,1,false);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_CS_RaytraceStaticEdgeNoRain_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 12) uniform CloudStaticConstants
{
	mat4 invViewProj[6];
};
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};

#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
struct RaytracePixelOutput
{
	vec4 colour[2];
	vec4 nearFarDepth;
};













layout(rgba16f, binding = 4) uniform image2DArray outputTexture1;
layout(rgba16f, binding = 5) uniform image2DArray outputTexture3;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t smallWorleyTexture3D[24];
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
	uint64_t noiseTexture3D[24];
	uint64_t godraysTexture[24];
	uint64_t volumeInscatterTexture[24];
	uint64_t skylTexture[24];
	uint64_t inscTexture[24];
	uint64_t lossTexture[24];
	uint64_t depthTexture[24];
	uint64_t illuminationTexture[24];
	uint64_t lightTableTexture[24];
	uint64_t precipitationVolume[24];
	uint64_t updateTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float CalcRayleighBeta(float cos0)
{
return (1.0+cos0*cos0);
}
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float HenyeyGreenstein(float g, float cos0)
{
float g2=g*g;
float u=1.0+g2-2.0*g*cos0;
return (1.0-g2)*pow(u,-1.5)/(4.0*3.1415926536);
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
vec3 PrecalculatedInscatterFunction(vec4 inscatter_factor, float BetaRayleigh, float BetaMie, vec3 mieRayleighRatio)
{
vec3 mr=mieRayleighRatio.xyz;
vec3 BetaTotal=(BetaRayleigh+BetaMie*mr)/(vec3(1.0,1.0,1.0)+mr);
vec3 colour=BetaTotal*inscatter_factor.rgb;
return colour;
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float GetAltTexCoord(float alt_km, float minSunlightAltitudeKm, float fadeAltitudeRangeKm)
{
float diff_km=alt_km-minSunlightAltitudeKm;
float sun_alt_texc=0.5+0.5*saturate(diff_km/fadeAltitudeRangeKm);
sun_alt_texc-=0.5*saturate(-diff_km/(minSunlightAltitudeKm+1.0));
return sun_alt_texc;
}
#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float unshadowedBrightness(float Beta, vec4 lightResponse, vec3 ambientColour)
{
return max(1.0,(Beta+lightResponse.y)+ambientColour.b);
}
#line 34 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColour(uint64_t lossTexture[24], uint64_t inscatterVolumeTexture[24], vec3 volumeTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float Beta, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec3 amb_dir, vec2 fade_texc, out float brightnessFactor, out vec4 inscatter, float fade, float alphaSharpness)
{
float alt_texc=(world_pos.z/fadeAltitudeRangeKm);
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 amb_lookup=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
ambientColour=lightResponse.w*amb_lookup.rgb;
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
vec3 ambient=amb_lookup.rgb*light.w;
vec4 c;
float l=mix(0.75,1.2,density.z);
c.rgb=(light.y*lightResponse.x*(Beta+l)+lightResponse.y*light.x)*combinedLightColour+ambient.rgb;
c.a=density.z*fade;
c.a=saturate(0.3+(1.0+1.0*density.w*alphaSharpness)*(c.a-0.3));

{
vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

inscatter=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),volumeTexCoords,0);
inscatter.rgb*=inscatter.a;
#line 62 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

}

return c;
}
#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColourSimple(uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t lightTableTexture[24], vec4 density, float Beta, float BetaRayleigh, float BetaMie, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, out float brightnessFactor)
{
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
ambientColour=lightResponse.w*textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
vec3 ambient=density.w*ambientColour.rgb;
float opacity=density.z;
vec4 c;
c.rgb=(density.y*Beta+lightResponse.y*density.x)*combinedLightColour+ambient.rgb;
c.a=opacity;
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float earthshadowFactr=saturate((fade_texc.x-nearFarTexc.x)/0.1);
#line 88 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
vec4 insc=textureLod(sampler2D(inscTexture[1 + 5]),fade_texc,0);
vec3 skyl=textureLod(sampler2D(skylTexture[1 + 5]),fade_texc,0).rgb;
vec3 inscatter=earthshadowFactr*PrecalculatedInscatterFunction(insc,BetaRayleigh,BetaMie,mieRayleighRatio);
c.rgb+=inscatter+skyl;
return c;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void calcDensity(uint64_t cloudDensity[24], uint64_t cloudLight[24], vec3 texCoords, vec4 noiseval, vec3 fractalScale, float mip, inout vec4 density, out vec4 light)
{
vec3 pos=texCoords.xyz+fractalScale.xyz*(noiseval.xyz);
density=textureLod(sampler3D(cloudDensity[1 + 7]),pos,mip);
light=textureLod(sampler3D(cloudLight[1 + 7]),texCoords,mip);
}
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 GetPrecipitationAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm, float mip)
{
vec3 rain_texc=cloudWorldOffsetKm;
rain_texc.xy+=rain_texc.z*rainTangent;
rain_texc*=inverseScalesKm;
vec3 pvSize;
ivec3 ivprecipitationVolume = textureSize(sampler3D(precipitationVolume[0]),0);
pvSize.x = ivprecipitationVolume.x;pvSize.y = ivprecipitationVolume.y;pvSize.z = ivprecipitationVolume.z;;
uint z_texel=uint(rain_texc.z*pvSize.z);
rain_texc.z=(float(z_texel)+0.5)/pvSize.z;
return textureLod(sampler3D(precipitationVolume[1 + 7]),rain_texc,mip);
}
#line 120 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float GetRainAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm)
{
vec4 rain_lookup=GetPrecipitationAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm,0.0);
return rain_lookup.x*rain_lookup.w*saturate((20.0*rain_lookup.y-cloudWorldOffsetKm.z)/2.0);
}
#line 146 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void ColourStep(inout vec4 colour[2], inout vec4 insc[2], inout float meanFadeDistance, out float brightness_factor, uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], bool godrays, uint64_t godraysVolumeTexture[24], float godraysScale, vec3 godraysTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float distanceKm, float fadeDistance, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, float cosine, vec3 volumeTexCoords, vec3 amb_dir, float BetaClouds, float BetaRayleigh, float BetaMie, float solidDist_nearFar[2], bool noise, bool do_depth_mix, float distScale, int idx, vec4 noiseval, float fade, float alphaSharpness)
{
density.z*=saturate(distanceKm/0.24);
vec4 clr[2];
vec4 inscatter=vec4(0,0,0,0);
brightness_factor=1.0;
if(noise)clr[2-1]=calcColour(lossTexture,inscatterVolumeTexture,volumeTexCoords,lightTableTexture,density,light,BetaClouds,lightResponse,ambientColour,world_pos,cloudTexCoords,amb_dir,fade_texc,brightness_factor,inscatter,fade,alphaSharpness);else
clr[2-1]=calcColourSimple(lossTexture,inscTexture,skylTexture,lightTableTexture,vec4(light.xyw,density.z),BetaClouds,BetaRayleigh,BetaMie,lightResponse,ambientColour,world_pos,cloudTexCoords,fade_texc,nearFarTexc,brightness_factor);
clr[2-1].a*=cosine*cosine;
meanFadeDistance=mix(min(fadeDistance,meanFadeDistance),meanFadeDistance,(1.0-.4*density.z));
godraysTexCoords.z=distanceKm*godraysScale;
float gr_mult=1.0;
if(godrays)gr_mult=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),godraysTexCoords,0).x;
for(int i=0;i<2;i++)
{
clr[i]=clr[2-1];
if(do_depth_mix)
{
float m=saturate((solidDist_nearFar[i]-fadeDistance)/distScale);
clr[i].a*=m;
}

colour[i].rgb+=(clr[i].rgb)*clr[i].a*(colour[i].a);
insc[i].rgb+=gr_mult*inscatter.rgb*clr[i].a*(colour[i].a);
colour[i].a*=(1.0-clr[i].a);
}

}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_simple.sl"
RaytracePixelOutput RaytraceCloudsStatic(uint64_t cloudDensity[24], uint64_t cloudLight[24], uint64_t precipitationVolume[24], uint64_t noiseTexture3D[24], uint64_t lightTableTexture[24], uint64_t illuminationTexture[24], uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], bool do_depth_mix, vec4 dlookup, vec3 view, vec4 clip_pos, vec3 volumeTexCoordsXyC, bool noise, bool do_rain_effect, bool do_rainbow, vec3 cloudIrRadiance1, vec3 cloudIrRadiance2, int numSteps, int num_interp, bool do_godrays, bool consistent_steps)
{
RaytracePixelOutput res;
vec4 insc[2];
for(int ii=0;ii<num_interp;ii++)
{
res.colour[ii]=vec4(0,0,0,1.0);
insc[ii]=vec4(0,0,0,0);
}

res.nearFarDepth=dlookup;
float s=saturate((directionToSun.z+0.2)/0.01);
vec3 lightDirection=mix(directionToMoon,directionToSun,s);
float cos0=dot(lightDirection.xyz,view.xyz);
float sine=view.z;
float min_z=cornerPosKm.z-(fractalScale.z*1.5)/inverseScalesKm.z;
float max_z=cornerPosKm.z+(1.0+fractalScale.z*1.5)/inverseScalesKm.z;
vec3 godraysTexCoords=vec3(0,0,0);
float lightspaceScale=1.0;
if(do_godrays)
{
vec3 lightspaceView=(mul(worldToScatteringVolumeMatrix,vec4(view,1.0)).xyz);
lightspaceScale=length(lightspaceView);
godraysTexCoords=vec3(fract(atan(lightspaceView.x,lightspaceView.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceView.z/lightspaceScale)*2.0/3.1415926536,0);
}

float solidDist_nearFar[2];
vec2 nfd=(dlookup.yx)+100.0*step(vec2(1.0,1.0),dlookup.yx);
float n=nfd.x;
float f=nfd.y;
solidDist_nearFar[0]=n;
solidDist_nearFar[num_interp-1]=f;
for(int l=1;l<num_interp-1;l++)
{
float interp=float(l)/float(num_interp-1);
solidDist_nearFar[l]=mix(n,f,interp);
}

vec2 fade_texc=vec2(0.0,0.5*(1.0-sine));
vec2 illum_texc=vec2(atan(view.x,view.y)/(3.1415926536*2.0),fade_texc.y);
vec4 illum_lookup=textureLod(sampler2D(illuminationTexture[1 + 3]),illum_texc,0);
vec2 nearFarTexc=vec2(0,1.0);
float meanFadeDistance=1.0;
float minDistance=1.0;
float maxDistance=0.0;
float BetaClouds=lightResponse.x*HenyeyGreenstein(cloudEccentricity,cos0);
float BetaRayleigh=CalcRayleighBeta(cos0);
float BetaMie=HenyeyGreenstein(hazeEccentricity,cos0);
float moisture=0.0;
vec3 world_pos=viewPosKm;
view.xyz+=vec3(0.00001,0.00001,0.00001);
ivec3 c_offset=ivec3(2.0*step(vec3(0,0,0),view.xyz)-vec3(1,1,1));
ivec3 start_c_offset=-c_offset;
start_c_offset=ivec3(max(start_c_offset.x,0),max(start_c_offset.y,0),max(start_c_offset.z,0));
vec3 viewScaled=view/scaleOfGridCoordsKm;
viewScaled=normalize(viewScaled);
vec3 offset_vec=vec3(0,0,0);
float maxDistKm=maxCloudDistanceKm;
float K=log(maxDistKm);
float step_ratio=1.0+K/float(numSteps);

{
float a=1.0/(saturate(view.z)+0.00001);
offset_vec+=max(0.0,min_z-world_pos.z)*vec3(view.x*a,view.y*a,1.0);
}


{
float a=1.0/(saturate(-view.z)+0.00001);
offset_vec+=max(0.0,world_pos.z-max_z)*vec3(view.x*a,view.y*a,-1.0);
}

vec3 halfway=0.5*(lightDirection-view);
world_pos+=offset_vec;
float distanceKm=length(offset_vec);
float distScale=0.6/maxFadeDistanceKm;
bool found=false;
float stepKm=K*(1.2+distanceKm)/float(numSteps);
vec3 amb_dir=view;
uint steps=initialSteps-uint((1&stepPos)!=0);
uint in_step=0,c=0;
float rangeKm=initialSteps*stepKm;
float oddRangeKm=(0.5*stepKm*initialSteps);
for(int i=0;i<768;i++)
{
if((view.z<0&&world_pos.z<min_z)||(view.z>0&&world_pos.z>max_z)||distanceKm>maxCloudDistanceKm)break;
distanceKm+=stepKm;
float fade=1.0;
if(consistent_steps)
{
uint odd=typed_mod((steps-in_step),2);
float fade_up=saturate((rangeKm-distanceKm)/oddRangeKm);
fade=(odd!=0)?fade_up:1.0;
if(in_step++==steps)
{
stepKm*=2.0;
c++;
uint u=(1<<c);
steps=initialSteps-uint((u&stepPos)!=0);
in_step=0;
rangeKm=distanceKm+initialSteps*stepKm;
oddRangeKm=(0.5*stepKm*initialSteps);
}

}

world_pos+=stepKm*view;
if(!consistent_steps)stepKm*=step_ratio;
vec3 cloudWorldOffsetKm=world_pos-cornerPosKm;
vec3 cloudTexCoords=cloudWorldOffsetKm*inverseScalesKm;
float fadeDistance=saturate(distanceKm/maxFadeDistanceKm);
maxDistance=max(fadeDistance,maxDistance);
if(fade>0)
{
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),cloudTexCoords,fadeDistance*0.0);

{

}


{
vec3 noise_texc=world_pos.xyz*noise3DTexcoordScale+noise3DTexcoordOffset;
vec3 noise_texc2=world_pos.xyz*noise3DTexcoordScale2+noise3DTexcoordOffset2;
vec4 noiseval=vec4(0,0,0,0);
if(noise)
{
vec4 noiseval1=density.x*textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc,1.0*fadeDistance);
vec4 noiseval2=density.x*textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc2,1.0*fadeDistance);
noiseval=noiseval1*cos(.2*3.14159*noiseval2.x)+noiseval1.wzxy*sin(.2*3.14159*noiseval2.y);
}

vec4 light=vec4(1,1,1,1);
calcDensity(cloudDensity,cloudLight,cloudTexCoords,noiseval,fractalScale,0,density,light);
density.z*=fade;
if(do_rain_effect)
{
float dm=rainEffect*fade*GetRainAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm);
moisture+=0.01*dm*light.x;
density.z=saturate(density.z+dm);
}

if(density.z>0)
{
if(noise)
{
vec3 worley_texc=(world_pos.xyz+worleyOffsetKm)*worleyTexcoordScale;
minDistance=min(max(0,fadeDistance-density.z*stepKm/maxFadeDistanceKm),minDistance);
vec4 worley=textureLod(sampler3D(smallWorleyTexture3D[1 + 6]),worley_texc,0);
float wo=4*density.y*(worley.w-0.6)*saturate(1.0/(12.0*fadeDistance));
density.z*=mix(1.0,worley.w,saturate(1.0/(12.0*fadeDistance)));
amb_dir=mix(amb_dir,worley.xyz,0.1*density.z);
}

float brightness_factor;
fade_texc.x=sqrt(fadeDistance);
vec3 volumeTexCoords=vec3(volumeTexCoordsXyC.xy,fade_texc.x);
ColourStep(res.colour,insc,meanFadeDistance,brightness_factor,lossTexture,inscTexture,skylTexture,inscatterVolumeTexture,do_godrays,godraysVolumeTexture,lightspaceScale,godraysTexCoords,lightTableTexture,density,light,distanceKm,fadeDistance,world_pos,cloudTexCoords,fade_texc,nearFarTexc,1.0,volumeTexCoords,amb_dir,BetaClouds,BetaRayleigh,BetaMie,solidDist_nearFar,noise,do_depth_mix,distScale,0,noiseval,1.0,alphaSharpness);
if(res.colour[0].a*brightness_factor<0.003)
{
for(int o=0;o<num_interp;o++)res.colour[o].a=0.0;
meanFadeDistance=fadeDistance;
break;
}

}

}

}

}

res.nearFarDepth.zw=vec2(meanFadeDistance,moisture);
#line 261 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_simple.sl"

for(int j=0;j<num_interp;j++)res.colour[j].rgb+=insc[j].rgb;
return res;
}
#line 706 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void StaticRaytrace(uvec3 pos, bool include_rain, bool depth, bool background2d, int numSteps, int num_interp, bool do_godrays, bool consistent_steps)
{
vec2 texCoords=(vec2(pos.xy)+vec2(0.5,0.5))/vec2(targetTextureSize);
vec4 clip_pos=vec4(-1.0,1.0,1.0,1.0);
clip_pos.x+=2.0*texCoords.x;
clip_pos.y-=2.0*texCoords.y;
vec3 view=normalize(mul(invViewProj[pos.z],clip_pos).xyz);
vec4 dlookup=vec4(1.0,1.0,0.000001,1.0);
if(depth)
{
dlookup=textureLod(samplerCube(depthTexture[1 + 6]),view,0);
}

vec3 worldspaceVolumeTexCoordsXyC=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(view.z)/3.1415926536),0);
RaytracePixelOutput f=RaytraceCloudsStatic(cloudDensity,cloudDensity2,precipitationVolume,noiseTexture3D,lightTableTexture,illuminationTexture,lossTexture,inscTexture,skylTexture,volumeInscatterTexture,godraysTexture,depth,dlookup,view,clip_pos,worldspaceVolumeTexCoordsXyC,background2d,include_rain,false,cloudIrRadiance1,cloudIrRadiance2,numSteps,num_interp,do_godrays,consistent_steps);
vec4 t2d=vec4(0,0,0,1.0);
vec4 c=t2d;
c.rgb*=f.colour[num_interp-1].a;
c.rgb+=f.colour[num_interp-1].rgb;
c.a=t2d.a*f.colour[num_interp-1].a;
imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*(num_interp-1))),vec4(c));
float n=float(dlookup.y>=1.0);
for(int u=0;u<num_interp-1;u++)
{
vec4 cn=t2d;
cn.rgb*=f.colour[u].a*n;
cn.a=1.0-n*(1.0-t2d.a);
cn.rgb+=f.colour[u].rgb;
cn.a*=f.colour[u].a;
imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*u)),vec4(cn));
}

if(background2d)imageStore(outputTexture3,ivec3(pos),vec4(f.nearFarDepth));
}
#line 986 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void CS_RaytraceStaticEdge(uvec3 g, uvec3 t, bool include_rain, bool depth, bool godrays, bool consistent_steps)
{
uvec2 idx=uvec2(g.xy*4+t.xy);
uint Z=cubemapFaceIndex[g.z+t.z].x;
uvec3 pos=uvec3(targetRange[Z].xy+idx,Z);
if(pos.x>=edge.x||pos.y>=edge.y)return ;
if(pos.x>=targetRange[Z].z||pos.y>=targetRange[Z].w)return ;
vec4 u=texelFetch(sampler2DArray(updateTexture[0]),ivec3(pos).xyz,0);
if(u.g<1.0&&u.b>0.0)
{
StaticRaytrace(pos,include_rain,depth,true,raytraceSteps,2,godrays,consistent_steps);
}

}
layout(local_size_x=4, local_size_y=4, local_size_z=1) in;
void main()
{
uvec3 g = gl_WorkGroupID;
uvec3 t = gl_LocalInvocationID;
#line 1190 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
CS_RaytraceStaticEdge(g,t,false,true,true,false);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_CS_RaytraceStaticEdgeNoRain_cons_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 12) uniform CloudStaticConstants
{
	mat4 invViewProj[6];
};
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};

#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
struct RaytracePixelOutput
{
	vec4 colour[2];
	vec4 nearFarDepth;
};













layout(rgba16f, binding = 4) uniform image2DArray outputTexture1;
layout(rgba16f, binding = 5) uniform image2DArray outputTexture3;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t smallWorleyTexture3D[24];
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
	uint64_t noiseTexture3D[24];
	uint64_t godraysTexture[24];
	uint64_t volumeInscatterTexture[24];
	uint64_t skylTexture[24];
	uint64_t inscTexture[24];
	uint64_t lossTexture[24];
	uint64_t depthTexture[24];
	uint64_t illuminationTexture[24];
	uint64_t lightTableTexture[24];
	uint64_t precipitationVolume[24];
	uint64_t updateTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float CalcRayleighBeta(float cos0)
{
return (1.0+cos0*cos0);
}
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float HenyeyGreenstein(float g, float cos0)
{
float g2=g*g;
float u=1.0+g2-2.0*g*cos0;
return (1.0-g2)*pow(u,-1.5)/(4.0*3.1415926536);
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
vec3 PrecalculatedInscatterFunction(vec4 inscatter_factor, float BetaRayleigh, float BetaMie, vec3 mieRayleighRatio)
{
vec3 mr=mieRayleighRatio.xyz;
vec3 BetaTotal=(BetaRayleigh+BetaMie*mr)/(vec3(1.0,1.0,1.0)+mr);
vec3 colour=BetaTotal*inscatter_factor.rgb;
return colour;
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float GetAltTexCoord(float alt_km, float minSunlightAltitudeKm, float fadeAltitudeRangeKm)
{
float diff_km=alt_km-minSunlightAltitudeKm;
float sun_alt_texc=0.5+0.5*saturate(diff_km/fadeAltitudeRangeKm);
sun_alt_texc-=0.5*saturate(-diff_km/(minSunlightAltitudeKm+1.0));
return sun_alt_texc;
}
#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float unshadowedBrightness(float Beta, vec4 lightResponse, vec3 ambientColour)
{
return max(1.0,(Beta+lightResponse.y)+ambientColour.b);
}
#line 34 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColour(uint64_t lossTexture[24], uint64_t inscatterVolumeTexture[24], vec3 volumeTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float Beta, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec3 amb_dir, vec2 fade_texc, out float brightnessFactor, out vec4 inscatter, float fade, float alphaSharpness)
{
float alt_texc=(world_pos.z/fadeAltitudeRangeKm);
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 amb_lookup=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
ambientColour=lightResponse.w*amb_lookup.rgb;
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
vec3 ambient=amb_lookup.rgb*light.w;
vec4 c;
float l=mix(0.75,1.2,density.z);
c.rgb=(light.y*lightResponse.x*(Beta+l)+lightResponse.y*light.x)*combinedLightColour+ambient.rgb;
c.a=density.z*fade;
c.a=saturate(0.3+(1.0+1.0*density.w*alphaSharpness)*(c.a-0.3));

{
vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

inscatter=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),volumeTexCoords,0);
inscatter.rgb*=inscatter.a;
#line 62 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

}

return c;
}
#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColourSimple(uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t lightTableTexture[24], vec4 density, float Beta, float BetaRayleigh, float BetaMie, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, out float brightnessFactor)
{
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
ambientColour=lightResponse.w*textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
vec3 ambient=density.w*ambientColour.rgb;
float opacity=density.z;
vec4 c;
c.rgb=(density.y*Beta+lightResponse.y*density.x)*combinedLightColour+ambient.rgb;
c.a=opacity;
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float earthshadowFactr=saturate((fade_texc.x-nearFarTexc.x)/0.1);
#line 88 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
vec4 insc=textureLod(sampler2D(inscTexture[1 + 5]),fade_texc,0);
vec3 skyl=textureLod(sampler2D(skylTexture[1 + 5]),fade_texc,0).rgb;
vec3 inscatter=earthshadowFactr*PrecalculatedInscatterFunction(insc,BetaRayleigh,BetaMie,mieRayleighRatio);
c.rgb+=inscatter+skyl;
return c;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void calcDensity(uint64_t cloudDensity[24], uint64_t cloudLight[24], vec3 texCoords, vec4 noiseval, vec3 fractalScale, float mip, inout vec4 density, out vec4 light)
{
vec3 pos=texCoords.xyz+fractalScale.xyz*(noiseval.xyz);
density=textureLod(sampler3D(cloudDensity[1 + 7]),pos,mip);
light=textureLod(sampler3D(cloudLight[1 + 7]),texCoords,mip);
}
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 GetPrecipitationAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm, float mip)
{
vec3 rain_texc=cloudWorldOffsetKm;
rain_texc.xy+=rain_texc.z*rainTangent;
rain_texc*=inverseScalesKm;
vec3 pvSize;
ivec3 ivprecipitationVolume = textureSize(sampler3D(precipitationVolume[0]),0);
pvSize.x = ivprecipitationVolume.x;pvSize.y = ivprecipitationVolume.y;pvSize.z = ivprecipitationVolume.z;;
uint z_texel=uint(rain_texc.z*pvSize.z);
rain_texc.z=(float(z_texel)+0.5)/pvSize.z;
return textureLod(sampler3D(precipitationVolume[1 + 7]),rain_texc,mip);
}
#line 120 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float GetRainAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm)
{
vec4 rain_lookup=GetPrecipitationAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm,0.0);
return rain_lookup.x*rain_lookup.w*saturate((20.0*rain_lookup.y-cloudWorldOffsetKm.z)/2.0);
}
#line 146 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void ColourStep(inout vec4 colour[2], inout vec4 insc[2], inout float meanFadeDistance, out float brightness_factor, uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], bool godrays, uint64_t godraysVolumeTexture[24], float godraysScale, vec3 godraysTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float distanceKm, float fadeDistance, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, float cosine, vec3 volumeTexCoords, vec3 amb_dir, float BetaClouds, float BetaRayleigh, float BetaMie, float solidDist_nearFar[2], bool noise, bool do_depth_mix, float distScale, int idx, vec4 noiseval, float fade, float alphaSharpness)
{
density.z*=saturate(distanceKm/0.24);
vec4 clr[2];
vec4 inscatter=vec4(0,0,0,0);
brightness_factor=1.0;
if(noise)clr[2-1]=calcColour(lossTexture,inscatterVolumeTexture,volumeTexCoords,lightTableTexture,density,light,BetaClouds,lightResponse,ambientColour,world_pos,cloudTexCoords,amb_dir,fade_texc,brightness_factor,inscatter,fade,alphaSharpness);else
clr[2-1]=calcColourSimple(lossTexture,inscTexture,skylTexture,lightTableTexture,vec4(light.xyw,density.z),BetaClouds,BetaRayleigh,BetaMie,lightResponse,ambientColour,world_pos,cloudTexCoords,fade_texc,nearFarTexc,brightness_factor);
clr[2-1].a*=cosine*cosine;
meanFadeDistance=mix(min(fadeDistance,meanFadeDistance),meanFadeDistance,(1.0-.4*density.z));
godraysTexCoords.z=distanceKm*godraysScale;
float gr_mult=1.0;
if(godrays)gr_mult=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),godraysTexCoords,0).x;
for(int i=0;i<2;i++)
{
clr[i]=clr[2-1];
if(do_depth_mix)
{
float m=saturate((solidDist_nearFar[i]-fadeDistance)/distScale);
clr[i].a*=m;
}

colour[i].rgb+=(clr[i].rgb)*clr[i].a*(colour[i].a);
insc[i].rgb+=gr_mult*inscatter.rgb*clr[i].a*(colour[i].a);
colour[i].a*=(1.0-clr[i].a);
}

}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_simple.sl"
RaytracePixelOutput RaytraceCloudsStatic(uint64_t cloudDensity[24], uint64_t cloudLight[24], uint64_t precipitationVolume[24], uint64_t noiseTexture3D[24], uint64_t lightTableTexture[24], uint64_t illuminationTexture[24], uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], bool do_depth_mix, vec4 dlookup, vec3 view, vec4 clip_pos, vec3 volumeTexCoordsXyC, bool noise, bool do_rain_effect, bool do_rainbow, vec3 cloudIrRadiance1, vec3 cloudIrRadiance2, int numSteps, int num_interp, bool do_godrays, bool consistent_steps)
{
RaytracePixelOutput res;
vec4 insc[2];
for(int ii=0;ii<num_interp;ii++)
{
res.colour[ii]=vec4(0,0,0,1.0);
insc[ii]=vec4(0,0,0,0);
}

res.nearFarDepth=dlookup;
float s=saturate((directionToSun.z+0.2)/0.01);
vec3 lightDirection=mix(directionToMoon,directionToSun,s);
float cos0=dot(lightDirection.xyz,view.xyz);
float sine=view.z;
float min_z=cornerPosKm.z-(fractalScale.z*1.5)/inverseScalesKm.z;
float max_z=cornerPosKm.z+(1.0+fractalScale.z*1.5)/inverseScalesKm.z;
vec3 godraysTexCoords=vec3(0,0,0);
float lightspaceScale=1.0;
if(do_godrays)
{
vec3 lightspaceView=(mul(worldToScatteringVolumeMatrix,vec4(view,1.0)).xyz);
lightspaceScale=length(lightspaceView);
godraysTexCoords=vec3(fract(atan(lightspaceView.x,lightspaceView.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceView.z/lightspaceScale)*2.0/3.1415926536,0);
}

float solidDist_nearFar[2];
vec2 nfd=(dlookup.yx)+100.0*step(vec2(1.0,1.0),dlookup.yx);
float n=nfd.x;
float f=nfd.y;
solidDist_nearFar[0]=n;
solidDist_nearFar[num_interp-1]=f;
for(int l=1;l<num_interp-1;l++)
{
float interp=float(l)/float(num_interp-1);
solidDist_nearFar[l]=mix(n,f,interp);
}

vec2 fade_texc=vec2(0.0,0.5*(1.0-sine));
vec2 illum_texc=vec2(atan(view.x,view.y)/(3.1415926536*2.0),fade_texc.y);
vec4 illum_lookup=textureLod(sampler2D(illuminationTexture[1 + 3]),illum_texc,0);
vec2 nearFarTexc=vec2(0,1.0);
float meanFadeDistance=1.0;
float minDistance=1.0;
float maxDistance=0.0;
float BetaClouds=lightResponse.x*HenyeyGreenstein(cloudEccentricity,cos0);
float BetaRayleigh=CalcRayleighBeta(cos0);
float BetaMie=HenyeyGreenstein(hazeEccentricity,cos0);
float moisture=0.0;
vec3 world_pos=viewPosKm;
view.xyz+=vec3(0.00001,0.00001,0.00001);
ivec3 c_offset=ivec3(2.0*step(vec3(0,0,0),view.xyz)-vec3(1,1,1));
ivec3 start_c_offset=-c_offset;
start_c_offset=ivec3(max(start_c_offset.x,0),max(start_c_offset.y,0),max(start_c_offset.z,0));
vec3 viewScaled=view/scaleOfGridCoordsKm;
viewScaled=normalize(viewScaled);
vec3 offset_vec=vec3(0,0,0);
float maxDistKm=maxCloudDistanceKm;
float K=log(maxDistKm);
float step_ratio=1.0+K/float(numSteps);

{
float a=1.0/(saturate(view.z)+0.00001);
offset_vec+=max(0.0,min_z-world_pos.z)*vec3(view.x*a,view.y*a,1.0);
}


{
float a=1.0/(saturate(-view.z)+0.00001);
offset_vec+=max(0.0,world_pos.z-max_z)*vec3(view.x*a,view.y*a,-1.0);
}

vec3 halfway=0.5*(lightDirection-view);
world_pos+=offset_vec;
float distanceKm=length(offset_vec);
float distScale=0.6/maxFadeDistanceKm;
bool found=false;
float stepKm=K*(1.2+distanceKm)/float(numSteps);
vec3 amb_dir=view;
uint steps=initialSteps-uint((1&stepPos)!=0);
uint in_step=0,c=0;
float rangeKm=initialSteps*stepKm;
float oddRangeKm=(0.5*stepKm*initialSteps);
for(int i=0;i<768;i++)
{
if((view.z<0&&world_pos.z<min_z)||(view.z>0&&world_pos.z>max_z)||distanceKm>maxCloudDistanceKm)break;
distanceKm+=stepKm;
float fade=1.0;
if(consistent_steps)
{
uint odd=typed_mod((steps-in_step),2);
float fade_up=saturate((rangeKm-distanceKm)/oddRangeKm);
fade=(odd!=0)?fade_up:1.0;
if(in_step++==steps)
{
stepKm*=2.0;
c++;
uint u=(1<<c);
steps=initialSteps-uint((u&stepPos)!=0);
in_step=0;
rangeKm=distanceKm+initialSteps*stepKm;
oddRangeKm=(0.5*stepKm*initialSteps);
}

}

world_pos+=stepKm*view;
if(!consistent_steps)stepKm*=step_ratio;
vec3 cloudWorldOffsetKm=world_pos-cornerPosKm;
vec3 cloudTexCoords=cloudWorldOffsetKm*inverseScalesKm;
float fadeDistance=saturate(distanceKm/maxFadeDistanceKm);
maxDistance=max(fadeDistance,maxDistance);
if(fade>0)
{
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),cloudTexCoords,fadeDistance*0.0);

{

}


{
vec3 noise_texc=world_pos.xyz*noise3DTexcoordScale+noise3DTexcoordOffset;
vec3 noise_texc2=world_pos.xyz*noise3DTexcoordScale2+noise3DTexcoordOffset2;
vec4 noiseval=vec4(0,0,0,0);
if(noise)
{
vec4 noiseval1=density.x*textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc,1.0*fadeDistance);
vec4 noiseval2=density.x*textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc2,1.0*fadeDistance);
noiseval=noiseval1*cos(.2*3.14159*noiseval2.x)+noiseval1.wzxy*sin(.2*3.14159*noiseval2.y);
}

vec4 light=vec4(1,1,1,1);
calcDensity(cloudDensity,cloudLight,cloudTexCoords,noiseval,fractalScale,0,density,light);
density.z*=fade;
if(do_rain_effect)
{
float dm=rainEffect*fade*GetRainAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm);
moisture+=0.01*dm*light.x;
density.z=saturate(density.z+dm);
}

if(density.z>0)
{
if(noise)
{
vec3 worley_texc=(world_pos.xyz+worleyOffsetKm)*worleyTexcoordScale;
minDistance=min(max(0,fadeDistance-density.z*stepKm/maxFadeDistanceKm),minDistance);
vec4 worley=textureLod(sampler3D(smallWorleyTexture3D[1 + 6]),worley_texc,0);
float wo=4*density.y*(worley.w-0.6)*saturate(1.0/(12.0*fadeDistance));
density.z*=mix(1.0,worley.w,saturate(1.0/(12.0*fadeDistance)));
amb_dir=mix(amb_dir,worley.xyz,0.1*density.z);
}

float brightness_factor;
fade_texc.x=sqrt(fadeDistance);
vec3 volumeTexCoords=vec3(volumeTexCoordsXyC.xy,fade_texc.x);
ColourStep(res.colour,insc,meanFadeDistance,brightness_factor,lossTexture,inscTexture,skylTexture,inscatterVolumeTexture,do_godrays,godraysVolumeTexture,lightspaceScale,godraysTexCoords,lightTableTexture,density,light,distanceKm,fadeDistance,world_pos,cloudTexCoords,fade_texc,nearFarTexc,1.0,volumeTexCoords,amb_dir,BetaClouds,BetaRayleigh,BetaMie,solidDist_nearFar,noise,do_depth_mix,distScale,0,noiseval,1.0,alphaSharpness);
if(res.colour[0].a*brightness_factor<0.003)
{
for(int o=0;o<num_interp;o++)res.colour[o].a=0.0;
meanFadeDistance=fadeDistance;
break;
}

}

}

}

}

res.nearFarDepth.zw=vec2(meanFadeDistance,moisture);
#line 261 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_simple.sl"

for(int j=0;j<num_interp;j++)res.colour[j].rgb+=insc[j].rgb;
return res;
}
#line 706 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void StaticRaytrace(uvec3 pos, bool include_rain, bool depth, bool background2d, int numSteps, int num_interp, bool do_godrays, bool consistent_steps)
{
vec2 texCoords=(vec2(pos.xy)+vec2(0.5,0.5))/vec2(targetTextureSize);
vec4 clip_pos=vec4(-1.0,1.0,1.0,1.0);
clip_pos.x+=2.0*texCoords.x;
clip_pos.y-=2.0*texCoords.y;
vec3 view=normalize(mul(invViewProj[pos.z],clip_pos).xyz);
vec4 dlookup=vec4(1.0,1.0,0.000001,1.0);
if(depth)
{
dlookup=textureLod(samplerCube(depthTexture[1 + 6]),view,0);
}

vec3 worldspaceVolumeTexCoordsXyC=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(view.z)/3.1415926536),0);
RaytracePixelOutput f=RaytraceCloudsStatic(cloudDensity,cloudDensity2,precipitationVolume,noiseTexture3D,lightTableTexture,illuminationTexture,lossTexture,inscTexture,skylTexture,volumeInscatterTexture,godraysTexture,depth,dlookup,view,clip_pos,worldspaceVolumeTexCoordsXyC,background2d,include_rain,false,cloudIrRadiance1,cloudIrRadiance2,numSteps,num_interp,do_godrays,consistent_steps);
vec4 t2d=vec4(0,0,0,1.0);
vec4 c=t2d;
c.rgb*=f.colour[num_interp-1].a;
c.rgb+=f.colour[num_interp-1].rgb;
c.a=t2d.a*f.colour[num_interp-1].a;
imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*(num_interp-1))),vec4(c));
float n=float(dlookup.y>=1.0);
for(int u=0;u<num_interp-1;u++)
{
vec4 cn=t2d;
cn.rgb*=f.colour[u].a*n;
cn.a=1.0-n*(1.0-t2d.a);
cn.rgb+=f.colour[u].rgb;
cn.a*=f.colour[u].a;
imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*u)),vec4(cn));
}

if(background2d)imageStore(outputTexture3,ivec3(pos),vec4(f.nearFarDepth));
}
#line 986 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void CS_RaytraceStaticEdge(uvec3 g, uvec3 t, bool include_rain, bool depth, bool godrays, bool consistent_steps)
{
uvec2 idx=uvec2(g.xy*4+t.xy);
uint Z=cubemapFaceIndex[g.z+t.z].x;
uvec3 pos=uvec3(targetRange[Z].xy+idx,Z);
if(pos.x>=edge.x||pos.y>=edge.y)return ;
if(pos.x>=targetRange[Z].z||pos.y>=targetRange[Z].w)return ;
vec4 u=texelFetch(sampler2DArray(updateTexture[0]),ivec3(pos).xyz,0);
if(u.g<1.0&&u.b>0.0)
{
StaticRaytrace(pos,include_rain,depth,true,raytraceSteps,2,godrays,consistent_steps);
}

}
layout(local_size_x=4, local_size_y=4, local_size_z=1) in;
void main()
{
uvec3 g = gl_WorkGroupID;
uvec3 t = gl_LocalInvocationID;
#line 1196 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
CS_RaytraceStaticEdge(g,t,false,true,true,true);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_CS_RaytraceStaticEdgeRain_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 12) uniform CloudStaticConstants
{
	mat4 invViewProj[6];
};
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};

#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
struct RaytracePixelOutput
{
	vec4 colour[2];
	vec4 nearFarDepth;
};













layout(rgba16f, binding = 4) uniform image2DArray outputTexture1;
layout(rgba16f, binding = 5) uniform image2DArray outputTexture3;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t smallWorleyTexture3D[24];
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
	uint64_t noiseTexture3D[24];
	uint64_t godraysTexture[24];
	uint64_t volumeInscatterTexture[24];
	uint64_t skylTexture[24];
	uint64_t inscTexture[24];
	uint64_t lossTexture[24];
	uint64_t depthTexture[24];
	uint64_t illuminationTexture[24];
	uint64_t lightTableTexture[24];
	uint64_t precipitationVolume[24];
	uint64_t updateTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float CalcRayleighBeta(float cos0)
{
return (1.0+cos0*cos0);
}
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float HenyeyGreenstein(float g, float cos0)
{
float g2=g*g;
float u=1.0+g2-2.0*g*cos0;
return (1.0-g2)*pow(u,-1.5)/(4.0*3.1415926536);
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
vec3 PrecalculatedInscatterFunction(vec4 inscatter_factor, float BetaRayleigh, float BetaMie, vec3 mieRayleighRatio)
{
vec3 mr=mieRayleighRatio.xyz;
vec3 BetaTotal=(BetaRayleigh+BetaMie*mr)/(vec3(1.0,1.0,1.0)+mr);
vec3 colour=BetaTotal*inscatter_factor.rgb;
return colour;
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float GetAltTexCoord(float alt_km, float minSunlightAltitudeKm, float fadeAltitudeRangeKm)
{
float diff_km=alt_km-minSunlightAltitudeKm;
float sun_alt_texc=0.5+0.5*saturate(diff_km/fadeAltitudeRangeKm);
sun_alt_texc-=0.5*saturate(-diff_km/(minSunlightAltitudeKm+1.0));
return sun_alt_texc;
}
#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float unshadowedBrightness(float Beta, vec4 lightResponse, vec3 ambientColour)
{
return max(1.0,(Beta+lightResponse.y)+ambientColour.b);
}
#line 34 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColour(uint64_t lossTexture[24], uint64_t inscatterVolumeTexture[24], vec3 volumeTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float Beta, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec3 amb_dir, vec2 fade_texc, out float brightnessFactor, out vec4 inscatter, float fade, float alphaSharpness)
{
float alt_texc=(world_pos.z/fadeAltitudeRangeKm);
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 amb_lookup=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
ambientColour=lightResponse.w*amb_lookup.rgb;
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
vec3 ambient=amb_lookup.rgb*light.w;
vec4 c;
float l=mix(0.75,1.2,density.z);
c.rgb=(light.y*lightResponse.x*(Beta+l)+lightResponse.y*light.x)*combinedLightColour+ambient.rgb;
c.a=density.z*fade;
c.a=saturate(0.3+(1.0+1.0*density.w*alphaSharpness)*(c.a-0.3));

{
vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

inscatter=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),volumeTexCoords,0);
inscatter.rgb*=inscatter.a;
#line 62 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

}

return c;
}
#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColourSimple(uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t lightTableTexture[24], vec4 density, float Beta, float BetaRayleigh, float BetaMie, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, out float brightnessFactor)
{
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
ambientColour=lightResponse.w*textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
vec3 ambient=density.w*ambientColour.rgb;
float opacity=density.z;
vec4 c;
c.rgb=(density.y*Beta+lightResponse.y*density.x)*combinedLightColour+ambient.rgb;
c.a=opacity;
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float earthshadowFactr=saturate((fade_texc.x-nearFarTexc.x)/0.1);
#line 88 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
vec4 insc=textureLod(sampler2D(inscTexture[1 + 5]),fade_texc,0);
vec3 skyl=textureLod(sampler2D(skylTexture[1 + 5]),fade_texc,0).rgb;
vec3 inscatter=earthshadowFactr*PrecalculatedInscatterFunction(insc,BetaRayleigh,BetaMie,mieRayleighRatio);
c.rgb+=inscatter+skyl;
return c;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void calcDensity(uint64_t cloudDensity[24], uint64_t cloudLight[24], vec3 texCoords, vec4 noiseval, vec3 fractalScale, float mip, inout vec4 density, out vec4 light)
{
vec3 pos=texCoords.xyz+fractalScale.xyz*(noiseval.xyz);
density=textureLod(sampler3D(cloudDensity[1 + 7]),pos,mip);
light=textureLod(sampler3D(cloudLight[1 + 7]),texCoords,mip);
}
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 GetPrecipitationAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm, float mip)
{
vec3 rain_texc=cloudWorldOffsetKm;
rain_texc.xy+=rain_texc.z*rainTangent;
rain_texc*=inverseScalesKm;
vec3 pvSize;
ivec3 ivprecipitationVolume = textureSize(sampler3D(precipitationVolume[0]),0);
pvSize.x = ivprecipitationVolume.x;pvSize.y = ivprecipitationVolume.y;pvSize.z = ivprecipitationVolume.z;;
uint z_texel=uint(rain_texc.z*pvSize.z);
rain_texc.z=(float(z_texel)+0.5)/pvSize.z;
return textureLod(sampler3D(precipitationVolume[1 + 7]),rain_texc,mip);
}
#line 120 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float GetRainAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm)
{
vec4 rain_lookup=GetPrecipitationAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm,0.0);
return rain_lookup.x*rain_lookup.w*saturate((20.0*rain_lookup.y-cloudWorldOffsetKm.z)/2.0);
}
#line 146 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void ColourStep(inout vec4 colour[2], inout vec4 insc[2], inout float meanFadeDistance, out float brightness_factor, uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], bool godrays, uint64_t godraysVolumeTexture[24], float godraysScale, vec3 godraysTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float distanceKm, float fadeDistance, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, float cosine, vec3 volumeTexCoords, vec3 amb_dir, float BetaClouds, float BetaRayleigh, float BetaMie, float solidDist_nearFar[2], bool noise, bool do_depth_mix, float distScale, int idx, vec4 noiseval, float fade, float alphaSharpness)
{
density.z*=saturate(distanceKm/0.24);
vec4 clr[2];
vec4 inscatter=vec4(0,0,0,0);
brightness_factor=1.0;
if(noise)clr[2-1]=calcColour(lossTexture,inscatterVolumeTexture,volumeTexCoords,lightTableTexture,density,light,BetaClouds,lightResponse,ambientColour,world_pos,cloudTexCoords,amb_dir,fade_texc,brightness_factor,inscatter,fade,alphaSharpness);else
clr[2-1]=calcColourSimple(lossTexture,inscTexture,skylTexture,lightTableTexture,vec4(light.xyw,density.z),BetaClouds,BetaRayleigh,BetaMie,lightResponse,ambientColour,world_pos,cloudTexCoords,fade_texc,nearFarTexc,brightness_factor);
clr[2-1].a*=cosine*cosine;
meanFadeDistance=mix(min(fadeDistance,meanFadeDistance),meanFadeDistance,(1.0-.4*density.z));
godraysTexCoords.z=distanceKm*godraysScale;
float gr_mult=1.0;
if(godrays)gr_mult=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),godraysTexCoords,0).x;
for(int i=0;i<2;i++)
{
clr[i]=clr[2-1];
if(do_depth_mix)
{
float m=saturate((solidDist_nearFar[i]-fadeDistance)/distScale);
clr[i].a*=m;
}

colour[i].rgb+=(clr[i].rgb)*clr[i].a*(colour[i].a);
insc[i].rgb+=gr_mult*inscatter.rgb*clr[i].a*(colour[i].a);
colour[i].a*=(1.0-clr[i].a);
}

}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_simple.sl"
RaytracePixelOutput RaytraceCloudsStatic(uint64_t cloudDensity[24], uint64_t cloudLight[24], uint64_t precipitationVolume[24], uint64_t noiseTexture3D[24], uint64_t lightTableTexture[24], uint64_t illuminationTexture[24], uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], bool do_depth_mix, vec4 dlookup, vec3 view, vec4 clip_pos, vec3 volumeTexCoordsXyC, bool noise, bool do_rain_effect, bool do_rainbow, vec3 cloudIrRadiance1, vec3 cloudIrRadiance2, int numSteps, int num_interp, bool do_godrays, bool consistent_steps)
{
RaytracePixelOutput res;
vec4 insc[2];
for(int ii=0;ii<num_interp;ii++)
{
res.colour[ii]=vec4(0,0,0,1.0);
insc[ii]=vec4(0,0,0,0);
}

res.nearFarDepth=dlookup;
float s=saturate((directionToSun.z+0.2)/0.01);
vec3 lightDirection=mix(directionToMoon,directionToSun,s);
float cos0=dot(lightDirection.xyz,view.xyz);
float sine=view.z;
float min_z=cornerPosKm.z-(fractalScale.z*1.5)/inverseScalesKm.z;
float max_z=cornerPosKm.z+(1.0+fractalScale.z*1.5)/inverseScalesKm.z;
vec3 godraysTexCoords=vec3(0,0,0);
float lightspaceScale=1.0;
if(do_godrays)
{
vec3 lightspaceView=(mul(worldToScatteringVolumeMatrix,vec4(view,1.0)).xyz);
lightspaceScale=length(lightspaceView);
godraysTexCoords=vec3(fract(atan(lightspaceView.x,lightspaceView.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceView.z/lightspaceScale)*2.0/3.1415926536,0);
}

float solidDist_nearFar[2];
vec2 nfd=(dlookup.yx)+100.0*step(vec2(1.0,1.0),dlookup.yx);
float n=nfd.x;
float f=nfd.y;
solidDist_nearFar[0]=n;
solidDist_nearFar[num_interp-1]=f;
for(int l=1;l<num_interp-1;l++)
{
float interp=float(l)/float(num_interp-1);
solidDist_nearFar[l]=mix(n,f,interp);
}

vec2 fade_texc=vec2(0.0,0.5*(1.0-sine));
vec2 illum_texc=vec2(atan(view.x,view.y)/(3.1415926536*2.0),fade_texc.y);
vec4 illum_lookup=textureLod(sampler2D(illuminationTexture[1 + 3]),illum_texc,0);
vec2 nearFarTexc=vec2(0,1.0);
float meanFadeDistance=1.0;
float minDistance=1.0;
float maxDistance=0.0;
float BetaClouds=lightResponse.x*HenyeyGreenstein(cloudEccentricity,cos0);
float BetaRayleigh=CalcRayleighBeta(cos0);
float BetaMie=HenyeyGreenstein(hazeEccentricity,cos0);
float moisture=0.0;
vec3 world_pos=viewPosKm;
view.xyz+=vec3(0.00001,0.00001,0.00001);
ivec3 c_offset=ivec3(2.0*step(vec3(0,0,0),view.xyz)-vec3(1,1,1));
ivec3 start_c_offset=-c_offset;
start_c_offset=ivec3(max(start_c_offset.x,0),max(start_c_offset.y,0),max(start_c_offset.z,0));
vec3 viewScaled=view/scaleOfGridCoordsKm;
viewScaled=normalize(viewScaled);
vec3 offset_vec=vec3(0,0,0);
float maxDistKm=maxCloudDistanceKm;
float K=log(maxDistKm);
float step_ratio=1.0+K/float(numSteps);

{
float a=1.0/(saturate(view.z)+0.00001);
offset_vec+=max(0.0,min_z-world_pos.z)*vec3(view.x*a,view.y*a,1.0);
}


{
float a=1.0/(saturate(-view.z)+0.00001);
offset_vec+=max(0.0,world_pos.z-max_z)*vec3(view.x*a,view.y*a,-1.0);
}

vec3 halfway=0.5*(lightDirection-view);
world_pos+=offset_vec;
float distanceKm=length(offset_vec);
float distScale=0.6/maxFadeDistanceKm;
bool found=false;
float stepKm=K*(1.2+distanceKm)/float(numSteps);
vec3 amb_dir=view;
uint steps=initialSteps-uint((1&stepPos)!=0);
uint in_step=0,c=0;
float rangeKm=initialSteps*stepKm;
float oddRangeKm=(0.5*stepKm*initialSteps);
for(int i=0;i<768;i++)
{
if((view.z<0&&world_pos.z<min_z)||(view.z>0&&world_pos.z>max_z)||distanceKm>maxCloudDistanceKm)break;
distanceKm+=stepKm;
float fade=1.0;
if(consistent_steps)
{
uint odd=typed_mod((steps-in_step),2);
float fade_up=saturate((rangeKm-distanceKm)/oddRangeKm);
fade=(odd!=0)?fade_up:1.0;
if(in_step++==steps)
{
stepKm*=2.0;
c++;
uint u=(1<<c);
steps=initialSteps-uint((u&stepPos)!=0);
in_step=0;
rangeKm=distanceKm+initialSteps*stepKm;
oddRangeKm=(0.5*stepKm*initialSteps);
}

}

world_pos+=stepKm*view;
if(!consistent_steps)stepKm*=step_ratio;
vec3 cloudWorldOffsetKm=world_pos-cornerPosKm;
vec3 cloudTexCoords=cloudWorldOffsetKm*inverseScalesKm;
float fadeDistance=saturate(distanceKm/maxFadeDistanceKm);
maxDistance=max(fadeDistance,maxDistance);
if(fade>0)
{
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),cloudTexCoords,fadeDistance*0.0);

{

}


{
vec3 noise_texc=world_pos.xyz*noise3DTexcoordScale+noise3DTexcoordOffset;
vec3 noise_texc2=world_pos.xyz*noise3DTexcoordScale2+noise3DTexcoordOffset2;
vec4 noiseval=vec4(0,0,0,0);
if(noise)
{
vec4 noiseval1=density.x*textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc,1.0*fadeDistance);
vec4 noiseval2=density.x*textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc2,1.0*fadeDistance);
noiseval=noiseval1*cos(.2*3.14159*noiseval2.x)+noiseval1.wzxy*sin(.2*3.14159*noiseval2.y);
}

vec4 light=vec4(1,1,1,1);
calcDensity(cloudDensity,cloudLight,cloudTexCoords,noiseval,fractalScale,0,density,light);
density.z*=fade;
if(do_rain_effect)
{
float dm=rainEffect*fade*GetRainAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm);
moisture+=0.01*dm*light.x;
density.z=saturate(density.z+dm);
}

if(density.z>0)
{
if(noise)
{
vec3 worley_texc=(world_pos.xyz+worleyOffsetKm)*worleyTexcoordScale;
minDistance=min(max(0,fadeDistance-density.z*stepKm/maxFadeDistanceKm),minDistance);
vec4 worley=textureLod(sampler3D(smallWorleyTexture3D[1 + 6]),worley_texc,0);
float wo=4*density.y*(worley.w-0.6)*saturate(1.0/(12.0*fadeDistance));
density.z*=mix(1.0,worley.w,saturate(1.0/(12.0*fadeDistance)));
amb_dir=mix(amb_dir,worley.xyz,0.1*density.z);
}

float brightness_factor;
fade_texc.x=sqrt(fadeDistance);
vec3 volumeTexCoords=vec3(volumeTexCoordsXyC.xy,fade_texc.x);
ColourStep(res.colour,insc,meanFadeDistance,brightness_factor,lossTexture,inscTexture,skylTexture,inscatterVolumeTexture,do_godrays,godraysVolumeTexture,lightspaceScale,godraysTexCoords,lightTableTexture,density,light,distanceKm,fadeDistance,world_pos,cloudTexCoords,fade_texc,nearFarTexc,1.0,volumeTexCoords,amb_dir,BetaClouds,BetaRayleigh,BetaMie,solidDist_nearFar,noise,do_depth_mix,distScale,0,noiseval,1.0,alphaSharpness);
if(res.colour[0].a*brightness_factor<0.003)
{
for(int o=0;o<num_interp;o++)res.colour[o].a=0.0;
meanFadeDistance=fadeDistance;
break;
}

}

}

}

}

res.nearFarDepth.zw=vec2(meanFadeDistance,moisture);
#line 261 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_simple.sl"

for(int j=0;j<num_interp;j++)res.colour[j].rgb+=insc[j].rgb;
return res;
}
#line 706 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void StaticRaytrace(uvec3 pos, bool include_rain, bool depth, bool background2d, int numSteps, int num_interp, bool do_godrays, bool consistent_steps)
{
vec2 texCoords=(vec2(pos.xy)+vec2(0.5,0.5))/vec2(targetTextureSize);
vec4 clip_pos=vec4(-1.0,1.0,1.0,1.0);
clip_pos.x+=2.0*texCoords.x;
clip_pos.y-=2.0*texCoords.y;
vec3 view=normalize(mul(invViewProj[pos.z],clip_pos).xyz);
vec4 dlookup=vec4(1.0,1.0,0.000001,1.0);
if(depth)
{
dlookup=textureLod(samplerCube(depthTexture[1 + 6]),view,0);
}

vec3 worldspaceVolumeTexCoordsXyC=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(view.z)/3.1415926536),0);
RaytracePixelOutput f=RaytraceCloudsStatic(cloudDensity,cloudDensity2,precipitationVolume,noiseTexture3D,lightTableTexture,illuminationTexture,lossTexture,inscTexture,skylTexture,volumeInscatterTexture,godraysTexture,depth,dlookup,view,clip_pos,worldspaceVolumeTexCoordsXyC,background2d,include_rain,false,cloudIrRadiance1,cloudIrRadiance2,numSteps,num_interp,do_godrays,consistent_steps);
vec4 t2d=vec4(0,0,0,1.0);
vec4 c=t2d;
c.rgb*=f.colour[num_interp-1].a;
c.rgb+=f.colour[num_interp-1].rgb;
c.a=t2d.a*f.colour[num_interp-1].a;
imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*(num_interp-1))),vec4(c));
float n=float(dlookup.y>=1.0);
for(int u=0;u<num_interp-1;u++)
{
vec4 cn=t2d;
cn.rgb*=f.colour[u].a*n;
cn.a=1.0-n*(1.0-t2d.a);
cn.rgb+=f.colour[u].rgb;
cn.a*=f.colour[u].a;
imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*u)),vec4(cn));
}

if(background2d)imageStore(outputTexture3,ivec3(pos),vec4(f.nearFarDepth));
}
#line 986 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void CS_RaytraceStaticEdge(uvec3 g, uvec3 t, bool include_rain, bool depth, bool godrays, bool consistent_steps)
{
uvec2 idx=uvec2(g.xy*4+t.xy);
uint Z=cubemapFaceIndex[g.z+t.z].x;
uvec3 pos=uvec3(targetRange[Z].xy+idx,Z);
if(pos.x>=edge.x||pos.y>=edge.y)return ;
if(pos.x>=targetRange[Z].z||pos.y>=targetRange[Z].w)return ;
vec4 u=texelFetch(sampler2DArray(updateTexture[0]),ivec3(pos).xyz,0);
if(u.g<1.0&&u.b>0.0)
{
StaticRaytrace(pos,include_rain,depth,true,raytraceSteps,2,godrays,consistent_steps);
}

}
layout(local_size_x=4, local_size_y=4, local_size_z=1) in;
void main()
{
uvec3 g = gl_WorkGroupID;
uvec3 t = gl_LocalInvocationID;
#line 1184 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
CS_RaytraceStaticEdge(g,t,true,true,true,false);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_CS_RaytraceStaticEdgeRain_cons_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 12) uniform CloudStaticConstants
{
	mat4 invViewProj[6];
};
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};

#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
struct RaytracePixelOutput
{
	vec4 colour[2];
	vec4 nearFarDepth;
};













layout(rgba16f, binding = 4) uniform image2DArray outputTexture1;
layout(rgba16f, binding = 5) uniform image2DArray outputTexture3;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t smallWorleyTexture3D[24];
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
	uint64_t noiseTexture3D[24];
	uint64_t godraysTexture[24];
	uint64_t volumeInscatterTexture[24];
	uint64_t skylTexture[24];
	uint64_t inscTexture[24];
	uint64_t lossTexture[24];
	uint64_t depthTexture[24];
	uint64_t illuminationTexture[24];
	uint64_t lightTableTexture[24];
	uint64_t precipitationVolume[24];
	uint64_t updateTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float CalcRayleighBeta(float cos0)
{
return (1.0+cos0*cos0);
}
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float HenyeyGreenstein(float g, float cos0)
{
float g2=g*g;
float u=1.0+g2-2.0*g*cos0;
return (1.0-g2)*pow(u,-1.5)/(4.0*3.1415926536);
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
vec3 PrecalculatedInscatterFunction(vec4 inscatter_factor, float BetaRayleigh, float BetaMie, vec3 mieRayleighRatio)
{
vec3 mr=mieRayleighRatio.xyz;
vec3 BetaTotal=(BetaRayleigh+BetaMie*mr)/(vec3(1.0,1.0,1.0)+mr);
vec3 colour=BetaTotal*inscatter_factor.rgb;
return colour;
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float GetAltTexCoord(float alt_km, float minSunlightAltitudeKm, float fadeAltitudeRangeKm)
{
float diff_km=alt_km-minSunlightAltitudeKm;
float sun_alt_texc=0.5+0.5*saturate(diff_km/fadeAltitudeRangeKm);
sun_alt_texc-=0.5*saturate(-diff_km/(minSunlightAltitudeKm+1.0));
return sun_alt_texc;
}
#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float unshadowedBrightness(float Beta, vec4 lightResponse, vec3 ambientColour)
{
return max(1.0,(Beta+lightResponse.y)+ambientColour.b);
}
#line 34 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColour(uint64_t lossTexture[24], uint64_t inscatterVolumeTexture[24], vec3 volumeTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float Beta, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec3 amb_dir, vec2 fade_texc, out float brightnessFactor, out vec4 inscatter, float fade, float alphaSharpness)
{
float alt_texc=(world_pos.z/fadeAltitudeRangeKm);
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 amb_lookup=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
ambientColour=lightResponse.w*amb_lookup.rgb;
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
vec3 ambient=amb_lookup.rgb*light.w;
vec4 c;
float l=mix(0.75,1.2,density.z);
c.rgb=(light.y*lightResponse.x*(Beta+l)+lightResponse.y*light.x)*combinedLightColour+ambient.rgb;
c.a=density.z*fade;
c.a=saturate(0.3+(1.0+1.0*density.w*alphaSharpness)*(c.a-0.3));

{
vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

inscatter=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),volumeTexCoords,0);
inscatter.rgb*=inscatter.a;
#line 62 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

}

return c;
}
#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColourSimple(uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t lightTableTexture[24], vec4 density, float Beta, float BetaRayleigh, float BetaMie, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, out float brightnessFactor)
{
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
ambientColour=lightResponse.w*textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
vec3 ambient=density.w*ambientColour.rgb;
float opacity=density.z;
vec4 c;
c.rgb=(density.y*Beta+lightResponse.y*density.x)*combinedLightColour+ambient.rgb;
c.a=opacity;
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float earthshadowFactr=saturate((fade_texc.x-nearFarTexc.x)/0.1);
#line 88 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
vec4 insc=textureLod(sampler2D(inscTexture[1 + 5]),fade_texc,0);
vec3 skyl=textureLod(sampler2D(skylTexture[1 + 5]),fade_texc,0).rgb;
vec3 inscatter=earthshadowFactr*PrecalculatedInscatterFunction(insc,BetaRayleigh,BetaMie,mieRayleighRatio);
c.rgb+=inscatter+skyl;
return c;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void calcDensity(uint64_t cloudDensity[24], uint64_t cloudLight[24], vec3 texCoords, vec4 noiseval, vec3 fractalScale, float mip, inout vec4 density, out vec4 light)
{
vec3 pos=texCoords.xyz+fractalScale.xyz*(noiseval.xyz);
density=textureLod(sampler3D(cloudDensity[1 + 7]),pos,mip);
light=textureLod(sampler3D(cloudLight[1 + 7]),texCoords,mip);
}
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 GetPrecipitationAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm, float mip)
{
vec3 rain_texc=cloudWorldOffsetKm;
rain_texc.xy+=rain_texc.z*rainTangent;
rain_texc*=inverseScalesKm;
vec3 pvSize;
ivec3 ivprecipitationVolume = textureSize(sampler3D(precipitationVolume[0]),0);
pvSize.x = ivprecipitationVolume.x;pvSize.y = ivprecipitationVolume.y;pvSize.z = ivprecipitationVolume.z;;
uint z_texel=uint(rain_texc.z*pvSize.z);
rain_texc.z=(float(z_texel)+0.5)/pvSize.z;
return textureLod(sampler3D(precipitationVolume[1 + 7]),rain_texc,mip);
}
#line 120 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float GetRainAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm)
{
vec4 rain_lookup=GetPrecipitationAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm,0.0);
return rain_lookup.x*rain_lookup.w*saturate((20.0*rain_lookup.y-cloudWorldOffsetKm.z)/2.0);
}
#line 146 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void ColourStep(inout vec4 colour[2], inout vec4 insc[2], inout float meanFadeDistance, out float brightness_factor, uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], bool godrays, uint64_t godraysVolumeTexture[24], float godraysScale, vec3 godraysTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float distanceKm, float fadeDistance, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, float cosine, vec3 volumeTexCoords, vec3 amb_dir, float BetaClouds, float BetaRayleigh, float BetaMie, float solidDist_nearFar[2], bool noise, bool do_depth_mix, float distScale, int idx, vec4 noiseval, float fade, float alphaSharpness)
{
density.z*=saturate(distanceKm/0.24);
vec4 clr[2];
vec4 inscatter=vec4(0,0,0,0);
brightness_factor=1.0;
if(noise)clr[2-1]=calcColour(lossTexture,inscatterVolumeTexture,volumeTexCoords,lightTableTexture,density,light,BetaClouds,lightResponse,ambientColour,world_pos,cloudTexCoords,amb_dir,fade_texc,brightness_factor,inscatter,fade,alphaSharpness);else
clr[2-1]=calcColourSimple(lossTexture,inscTexture,skylTexture,lightTableTexture,vec4(light.xyw,density.z),BetaClouds,BetaRayleigh,BetaMie,lightResponse,ambientColour,world_pos,cloudTexCoords,fade_texc,nearFarTexc,brightness_factor);
clr[2-1].a*=cosine*cosine;
meanFadeDistance=mix(min(fadeDistance,meanFadeDistance),meanFadeDistance,(1.0-.4*density.z));
godraysTexCoords.z=distanceKm*godraysScale;
float gr_mult=1.0;
if(godrays)gr_mult=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),godraysTexCoords,0).x;
for(int i=0;i<2;i++)
{
clr[i]=clr[2-1];
if(do_depth_mix)
{
float m=saturate((solidDist_nearFar[i]-fadeDistance)/distScale);
clr[i].a*=m;
}

colour[i].rgb+=(clr[i].rgb)*clr[i].a*(colour[i].a);
insc[i].rgb+=gr_mult*inscatter.rgb*clr[i].a*(colour[i].a);
colour[i].a*=(1.0-clr[i].a);
}

}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_simple.sl"
RaytracePixelOutput RaytraceCloudsStatic(uint64_t cloudDensity[24], uint64_t cloudLight[24], uint64_t precipitationVolume[24], uint64_t noiseTexture3D[24], uint64_t lightTableTexture[24], uint64_t illuminationTexture[24], uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], bool do_depth_mix, vec4 dlookup, vec3 view, vec4 clip_pos, vec3 volumeTexCoordsXyC, bool noise, bool do_rain_effect, bool do_rainbow, vec3 cloudIrRadiance1, vec3 cloudIrRadiance2, int numSteps, int num_interp, bool do_godrays, bool consistent_steps)
{
RaytracePixelOutput res;
vec4 insc[2];
for(int ii=0;ii<num_interp;ii++)
{
res.colour[ii]=vec4(0,0,0,1.0);
insc[ii]=vec4(0,0,0,0);
}

res.nearFarDepth=dlookup;
float s=saturate((directionToSun.z+0.2)/0.01);
vec3 lightDirection=mix(directionToMoon,directionToSun,s);
float cos0=dot(lightDirection.xyz,view.xyz);
float sine=view.z;
float min_z=cornerPosKm.z-(fractalScale.z*1.5)/inverseScalesKm.z;
float max_z=cornerPosKm.z+(1.0+fractalScale.z*1.5)/inverseScalesKm.z;
vec3 godraysTexCoords=vec3(0,0,0);
float lightspaceScale=1.0;
if(do_godrays)
{
vec3 lightspaceView=(mul(worldToScatteringVolumeMatrix,vec4(view,1.0)).xyz);
lightspaceScale=length(lightspaceView);
godraysTexCoords=vec3(fract(atan(lightspaceView.x,lightspaceView.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceView.z/lightspaceScale)*2.0/3.1415926536,0);
}

float solidDist_nearFar[2];
vec2 nfd=(dlookup.yx)+100.0*step(vec2(1.0,1.0),dlookup.yx);
float n=nfd.x;
float f=nfd.y;
solidDist_nearFar[0]=n;
solidDist_nearFar[num_interp-1]=f;
for(int l=1;l<num_interp-1;l++)
{
float interp=float(l)/float(num_interp-1);
solidDist_nearFar[l]=mix(n,f,interp);
}

vec2 fade_texc=vec2(0.0,0.5*(1.0-sine));
vec2 illum_texc=vec2(atan(view.x,view.y)/(3.1415926536*2.0),fade_texc.y);
vec4 illum_lookup=textureLod(sampler2D(illuminationTexture[1 + 3]),illum_texc,0);
vec2 nearFarTexc=vec2(0,1.0);
float meanFadeDistance=1.0;
float minDistance=1.0;
float maxDistance=0.0;
float BetaClouds=lightResponse.x*HenyeyGreenstein(cloudEccentricity,cos0);
float BetaRayleigh=CalcRayleighBeta(cos0);
float BetaMie=HenyeyGreenstein(hazeEccentricity,cos0);
float moisture=0.0;
vec3 world_pos=viewPosKm;
view.xyz+=vec3(0.00001,0.00001,0.00001);
ivec3 c_offset=ivec3(2.0*step(vec3(0,0,0),view.xyz)-vec3(1,1,1));
ivec3 start_c_offset=-c_offset;
start_c_offset=ivec3(max(start_c_offset.x,0),max(start_c_offset.y,0),max(start_c_offset.z,0));
vec3 viewScaled=view/scaleOfGridCoordsKm;
viewScaled=normalize(viewScaled);
vec3 offset_vec=vec3(0,0,0);
float maxDistKm=maxCloudDistanceKm;
float K=log(maxDistKm);
float step_ratio=1.0+K/float(numSteps);

{
float a=1.0/(saturate(view.z)+0.00001);
offset_vec+=max(0.0,min_z-world_pos.z)*vec3(view.x*a,view.y*a,1.0);
}


{
float a=1.0/(saturate(-view.z)+0.00001);
offset_vec+=max(0.0,world_pos.z-max_z)*vec3(view.x*a,view.y*a,-1.0);
}

vec3 halfway=0.5*(lightDirection-view);
world_pos+=offset_vec;
float distanceKm=length(offset_vec);
float distScale=0.6/maxFadeDistanceKm;
bool found=false;
float stepKm=K*(1.2+distanceKm)/float(numSteps);
vec3 amb_dir=view;
uint steps=initialSteps-uint((1&stepPos)!=0);
uint in_step=0,c=0;
float rangeKm=initialSteps*stepKm;
float oddRangeKm=(0.5*stepKm*initialSteps);
for(int i=0;i<768;i++)
{
if((view.z<0&&world_pos.z<min_z)||(view.z>0&&world_pos.z>max_z)||distanceKm>maxCloudDistanceKm)break;
distanceKm+=stepKm;
float fade=1.0;
if(consistent_steps)
{
uint odd=typed_mod((steps-in_step),2);
float fade_up=saturate((rangeKm-distanceKm)/oddRangeKm);
fade=(odd!=0)?fade_up:1.0;
if(in_step++==steps)
{
stepKm*=2.0;
c++;
uint u=(1<<c);
steps=initialSteps-uint((u&stepPos)!=0);
in_step=0;
rangeKm=distanceKm+initialSteps*stepKm;
oddRangeKm=(0.5*stepKm*initialSteps);
}

}

world_pos+=stepKm*view;
if(!consistent_steps)stepKm*=step_ratio;
vec3 cloudWorldOffsetKm=world_pos-cornerPosKm;
vec3 cloudTexCoords=cloudWorldOffsetKm*inverseScalesKm;
float fadeDistance=saturate(distanceKm/maxFadeDistanceKm);
maxDistance=max(fadeDistance,maxDistance);
if(fade>0)
{
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),cloudTexCoords,fadeDistance*0.0);

{

}


{
vec3 noise_texc=world_pos.xyz*noise3DTexcoordScale+noise3DTexcoordOffset;
vec3 noise_texc2=world_pos.xyz*noise3DTexcoordScale2+noise3DTexcoordOffset2;
vec4 noiseval=vec4(0,0,0,0);
if(noise)
{
vec4 noiseval1=density.x*textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc,1.0*fadeDistance);
vec4 noiseval2=density.x*textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc2,1.0*fadeDistance);
noiseval=noiseval1*cos(.2*3.14159*noiseval2.x)+noiseval1.wzxy*sin(.2*3.14159*noiseval2.y);
}

vec4 light=vec4(1,1,1,1);
calcDensity(cloudDensity,cloudLight,cloudTexCoords,noiseval,fractalScale,0,density,light);
density.z*=fade;
if(do_rain_effect)
{
float dm=rainEffect*fade*GetRainAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm);
moisture+=0.01*dm*light.x;
density.z=saturate(density.z+dm);
}

if(density.z>0)
{
if(noise)
{
vec3 worley_texc=(world_pos.xyz+worleyOffsetKm)*worleyTexcoordScale;
minDistance=min(max(0,fadeDistance-density.z*stepKm/maxFadeDistanceKm),minDistance);
vec4 worley=textureLod(sampler3D(smallWorleyTexture3D[1 + 6]),worley_texc,0);
float wo=4*density.y*(worley.w-0.6)*saturate(1.0/(12.0*fadeDistance));
density.z*=mix(1.0,worley.w,saturate(1.0/(12.0*fadeDistance)));
amb_dir=mix(amb_dir,worley.xyz,0.1*density.z);
}

float brightness_factor;
fade_texc.x=sqrt(fadeDistance);
vec3 volumeTexCoords=vec3(volumeTexCoordsXyC.xy,fade_texc.x);
ColourStep(res.colour,insc,meanFadeDistance,brightness_factor,lossTexture,inscTexture,skylTexture,inscatterVolumeTexture,do_godrays,godraysVolumeTexture,lightspaceScale,godraysTexCoords,lightTableTexture,density,light,distanceKm,fadeDistance,world_pos,cloudTexCoords,fade_texc,nearFarTexc,1.0,volumeTexCoords,amb_dir,BetaClouds,BetaRayleigh,BetaMie,solidDist_nearFar,noise,do_depth_mix,distScale,0,noiseval,1.0,alphaSharpness);
if(res.colour[0].a*brightness_factor<0.003)
{
for(int o=0;o<num_interp;o++)res.colour[o].a=0.0;
meanFadeDistance=fadeDistance;
break;
}

}

}

}

}

res.nearFarDepth.zw=vec2(meanFadeDistance,moisture);
#line 261 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_simple.sl"

for(int j=0;j<num_interp;j++)res.colour[j].rgb+=insc[j].rgb;
return res;
}
#line 706 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void StaticRaytrace(uvec3 pos, bool include_rain, bool depth, bool background2d, int numSteps, int num_interp, bool do_godrays, bool consistent_steps)
{
vec2 texCoords=(vec2(pos.xy)+vec2(0.5,0.5))/vec2(targetTextureSize);
vec4 clip_pos=vec4(-1.0,1.0,1.0,1.0);
clip_pos.x+=2.0*texCoords.x;
clip_pos.y-=2.0*texCoords.y;
vec3 view=normalize(mul(invViewProj[pos.z],clip_pos).xyz);
vec4 dlookup=vec4(1.0,1.0,0.000001,1.0);
if(depth)
{
dlookup=textureLod(samplerCube(depthTexture[1 + 6]),view,0);
}

vec3 worldspaceVolumeTexCoordsXyC=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(view.z)/3.1415926536),0);
RaytracePixelOutput f=RaytraceCloudsStatic(cloudDensity,cloudDensity2,precipitationVolume,noiseTexture3D,lightTableTexture,illuminationTexture,lossTexture,inscTexture,skylTexture,volumeInscatterTexture,godraysTexture,depth,dlookup,view,clip_pos,worldspaceVolumeTexCoordsXyC,background2d,include_rain,false,cloudIrRadiance1,cloudIrRadiance2,numSteps,num_interp,do_godrays,consistent_steps);
vec4 t2d=vec4(0,0,0,1.0);
vec4 c=t2d;
c.rgb*=f.colour[num_interp-1].a;
c.rgb+=f.colour[num_interp-1].rgb;
c.a=t2d.a*f.colour[num_interp-1].a;
imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*(num_interp-1))),vec4(c));
float n=float(dlookup.y>=1.0);
for(int u=0;u<num_interp-1;u++)
{
vec4 cn=t2d;
cn.rgb*=f.colour[u].a*n;
cn.a=1.0-n*(1.0-t2d.a);
cn.rgb+=f.colour[u].rgb;
cn.a*=f.colour[u].a;
imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*u)),vec4(cn));
}

if(background2d)imageStore(outputTexture3,ivec3(pos),vec4(f.nearFarDepth));
}
#line 986 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void CS_RaytraceStaticEdge(uvec3 g, uvec3 t, bool include_rain, bool depth, bool godrays, bool consistent_steps)
{
uvec2 idx=uvec2(g.xy*4+t.xy);
uint Z=cubemapFaceIndex[g.z+t.z].x;
uvec3 pos=uvec3(targetRange[Z].xy+idx,Z);
if(pos.x>=edge.x||pos.y>=edge.y)return ;
if(pos.x>=targetRange[Z].z||pos.y>=targetRange[Z].w)return ;
vec4 u=texelFetch(sampler2DArray(updateTexture[0]),ivec3(pos).xyz,0);
if(u.g<1.0&&u.b>0.0)
{
StaticRaytrace(pos,include_rain,depth,true,raytraceSteps,2,godrays,consistent_steps);
}

}
layout(local_size_x=4, local_size_y=4, local_size_z=1) in;
void main()
{
uvec3 g = gl_WorkGroupID;
uvec3 t = gl_LocalInvocationID;
#line 1178 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
CS_RaytraceStaticEdge(g,t,true,true,true,true);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_CS_RaytraceStaticNoRain_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 12) uniform CloudStaticConstants
{
	mat4 invViewProj[6];
};
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};

#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
struct RaytracePixelOutput
{
	vec4 colour[2];
	vec4 nearFarDepth;
};













layout(rgba16f, binding = 4) uniform image2DArray outputTexture1;
layout(rgba16f, binding = 5) uniform image2DArray outputTexture3;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t smallWorleyTexture3D[24];
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
	uint64_t noiseTexture3D[24];
	uint64_t godraysTexture[24];
	uint64_t volumeInscatterTexture[24];
	uint64_t skylTexture[24];
	uint64_t inscTexture[24];
	uint64_t lossTexture[24];
	uint64_t depthTexture[24];
	uint64_t illuminationTexture[24];
	uint64_t lightTableTexture[24];
	uint64_t precipitationVolume[24];
	uint64_t updateTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float CalcRayleighBeta(float cos0)
{
return (1.0+cos0*cos0);
}
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float HenyeyGreenstein(float g, float cos0)
{
float g2=g*g;
float u=1.0+g2-2.0*g*cos0;
return (1.0-g2)*pow(u,-1.5)/(4.0*3.1415926536);
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
vec3 PrecalculatedInscatterFunction(vec4 inscatter_factor, float BetaRayleigh, float BetaMie, vec3 mieRayleighRatio)
{
vec3 mr=mieRayleighRatio.xyz;
vec3 BetaTotal=(BetaRayleigh+BetaMie*mr)/(vec3(1.0,1.0,1.0)+mr);
vec3 colour=BetaTotal*inscatter_factor.rgb;
return colour;
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float GetAltTexCoord(float alt_km, float minSunlightAltitudeKm, float fadeAltitudeRangeKm)
{
float diff_km=alt_km-minSunlightAltitudeKm;
float sun_alt_texc=0.5+0.5*saturate(diff_km/fadeAltitudeRangeKm);
sun_alt_texc-=0.5*saturate(-diff_km/(minSunlightAltitudeKm+1.0));
return sun_alt_texc;
}
#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float unshadowedBrightness(float Beta, vec4 lightResponse, vec3 ambientColour)
{
return max(1.0,(Beta+lightResponse.y)+ambientColour.b);
}
#line 34 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColour(uint64_t lossTexture[24], uint64_t inscatterVolumeTexture[24], vec3 volumeTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float Beta, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec3 amb_dir, vec2 fade_texc, out float brightnessFactor, out vec4 inscatter, float fade, float alphaSharpness)
{
float alt_texc=(world_pos.z/fadeAltitudeRangeKm);
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 amb_lookup=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
ambientColour=lightResponse.w*amb_lookup.rgb;
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
vec3 ambient=amb_lookup.rgb*light.w;
vec4 c;
float l=mix(0.75,1.2,density.z);
c.rgb=(light.y*lightResponse.x*(Beta+l)+lightResponse.y*light.x)*combinedLightColour+ambient.rgb;
c.a=density.z*fade;
c.a=saturate(0.3+(1.0+1.0*density.w*alphaSharpness)*(c.a-0.3));

{
vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

inscatter=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),volumeTexCoords,0);
inscatter.rgb*=inscatter.a;
#line 62 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

}

return c;
}
#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColourSimple(uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t lightTableTexture[24], vec4 density, float Beta, float BetaRayleigh, float BetaMie, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, out float brightnessFactor)
{
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
ambientColour=lightResponse.w*textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
vec3 ambient=density.w*ambientColour.rgb;
float opacity=density.z;
vec4 c;
c.rgb=(density.y*Beta+lightResponse.y*density.x)*combinedLightColour+ambient.rgb;
c.a=opacity;
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float earthshadowFactr=saturate((fade_texc.x-nearFarTexc.x)/0.1);
#line 88 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
vec4 insc=textureLod(sampler2D(inscTexture[1 + 5]),fade_texc,0);
vec3 skyl=textureLod(sampler2D(skylTexture[1 + 5]),fade_texc,0).rgb;
vec3 inscatter=earthshadowFactr*PrecalculatedInscatterFunction(insc,BetaRayleigh,BetaMie,mieRayleighRatio);
c.rgb+=inscatter+skyl;
return c;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void calcDensity(uint64_t cloudDensity[24], uint64_t cloudLight[24], vec3 texCoords, vec4 noiseval, vec3 fractalScale, float mip, inout vec4 density, out vec4 light)
{
vec3 pos=texCoords.xyz+fractalScale.xyz*(noiseval.xyz);
density=textureLod(sampler3D(cloudDensity[1 + 7]),pos,mip);
light=textureLod(sampler3D(cloudLight[1 + 7]),texCoords,mip);
}
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 GetPrecipitationAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm, float mip)
{
vec3 rain_texc=cloudWorldOffsetKm;
rain_texc.xy+=rain_texc.z*rainTangent;
rain_texc*=inverseScalesKm;
vec3 pvSize;
ivec3 ivprecipitationVolume = textureSize(sampler3D(precipitationVolume[0]),0);
pvSize.x = ivprecipitationVolume.x;pvSize.y = ivprecipitationVolume.y;pvSize.z = ivprecipitationVolume.z;;
uint z_texel=uint(rain_texc.z*pvSize.z);
rain_texc.z=(float(z_texel)+0.5)/pvSize.z;
return textureLod(sampler3D(precipitationVolume[1 + 7]),rain_texc,mip);
}
#line 120 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float GetRainAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm)
{
vec4 rain_lookup=GetPrecipitationAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm,0.0);
return rain_lookup.x*rain_lookup.w*saturate((20.0*rain_lookup.y-cloudWorldOffsetKm.z)/2.0);
}
#line 146 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void ColourStep(inout vec4 colour[2], inout vec4 insc[2], inout float meanFadeDistance, out float brightness_factor, uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], bool godrays, uint64_t godraysVolumeTexture[24], float godraysScale, vec3 godraysTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float distanceKm, float fadeDistance, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, float cosine, vec3 volumeTexCoords, vec3 amb_dir, float BetaClouds, float BetaRayleigh, float BetaMie, float solidDist_nearFar[2], bool noise, bool do_depth_mix, float distScale, int idx, vec4 noiseval, float fade, float alphaSharpness)
{
density.z*=saturate(distanceKm/0.24);
vec4 clr[2];
vec4 inscatter=vec4(0,0,0,0);
brightness_factor=1.0;
if(noise)clr[2-1]=calcColour(lossTexture,inscatterVolumeTexture,volumeTexCoords,lightTableTexture,density,light,BetaClouds,lightResponse,ambientColour,world_pos,cloudTexCoords,amb_dir,fade_texc,brightness_factor,inscatter,fade,alphaSharpness);else
clr[2-1]=calcColourSimple(lossTexture,inscTexture,skylTexture,lightTableTexture,vec4(light.xyw,density.z),BetaClouds,BetaRayleigh,BetaMie,lightResponse,ambientColour,world_pos,cloudTexCoords,fade_texc,nearFarTexc,brightness_factor);
clr[2-1].a*=cosine*cosine;
meanFadeDistance=mix(min(fadeDistance,meanFadeDistance),meanFadeDistance,(1.0-.4*density.z));
godraysTexCoords.z=distanceKm*godraysScale;
float gr_mult=1.0;
if(godrays)gr_mult=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),godraysTexCoords,0).x;
for(int i=0;i<2;i++)
{
clr[i]=clr[2-1];
if(do_depth_mix)
{
float m=saturate((solidDist_nearFar[i]-fadeDistance)/distScale);
clr[i].a*=m;
}

colour[i].rgb+=(clr[i].rgb)*clr[i].a*(colour[i].a);
insc[i].rgb+=gr_mult*inscatter.rgb*clr[i].a*(colour[i].a);
colour[i].a*=(1.0-clr[i].a);
}

}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_simple.sl"
RaytracePixelOutput RaytraceCloudsStatic(uint64_t cloudDensity[24], uint64_t cloudLight[24], uint64_t precipitationVolume[24], uint64_t noiseTexture3D[24], uint64_t lightTableTexture[24], uint64_t illuminationTexture[24], uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], bool do_depth_mix, vec4 dlookup, vec3 view, vec4 clip_pos, vec3 volumeTexCoordsXyC, bool noise, bool do_rain_effect, bool do_rainbow, vec3 cloudIrRadiance1, vec3 cloudIrRadiance2, int numSteps, int num_interp, bool do_godrays, bool consistent_steps)
{
RaytracePixelOutput res;
vec4 insc[2];
for(int ii=0;ii<num_interp;ii++)
{
res.colour[ii]=vec4(0,0,0,1.0);
insc[ii]=vec4(0,0,0,0);
}

res.nearFarDepth=dlookup;
float s=saturate((directionToSun.z+0.2)/0.01);
vec3 lightDirection=mix(directionToMoon,directionToSun,s);
float cos0=dot(lightDirection.xyz,view.xyz);
float sine=view.z;
float min_z=cornerPosKm.z-(fractalScale.z*1.5)/inverseScalesKm.z;
float max_z=cornerPosKm.z+(1.0+fractalScale.z*1.5)/inverseScalesKm.z;
vec3 godraysTexCoords=vec3(0,0,0);
float lightspaceScale=1.0;
if(do_godrays)
{
vec3 lightspaceView=(mul(worldToScatteringVolumeMatrix,vec4(view,1.0)).xyz);
lightspaceScale=length(lightspaceView);
godraysTexCoords=vec3(fract(atan(lightspaceView.x,lightspaceView.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceView.z/lightspaceScale)*2.0/3.1415926536,0);
}

float solidDist_nearFar[2];
vec2 nfd=(dlookup.yx)+100.0*step(vec2(1.0,1.0),dlookup.yx);
float n=nfd.x;
float f=nfd.y;
solidDist_nearFar[0]=n;
solidDist_nearFar[num_interp-1]=f;
for(int l=1;l<num_interp-1;l++)
{
float interp=float(l)/float(num_interp-1);
solidDist_nearFar[l]=mix(n,f,interp);
}

vec2 fade_texc=vec2(0.0,0.5*(1.0-sine));
vec2 illum_texc=vec2(atan(view.x,view.y)/(3.1415926536*2.0),fade_texc.y);
vec4 illum_lookup=textureLod(sampler2D(illuminationTexture[1 + 3]),illum_texc,0);
vec2 nearFarTexc=vec2(0,1.0);
float meanFadeDistance=1.0;
float minDistance=1.0;
float maxDistance=0.0;
float BetaClouds=lightResponse.x*HenyeyGreenstein(cloudEccentricity,cos0);
float BetaRayleigh=CalcRayleighBeta(cos0);
float BetaMie=HenyeyGreenstein(hazeEccentricity,cos0);
float moisture=0.0;
vec3 world_pos=viewPosKm;
view.xyz+=vec3(0.00001,0.00001,0.00001);
ivec3 c_offset=ivec3(2.0*step(vec3(0,0,0),view.xyz)-vec3(1,1,1));
ivec3 start_c_offset=-c_offset;
start_c_offset=ivec3(max(start_c_offset.x,0),max(start_c_offset.y,0),max(start_c_offset.z,0));
vec3 viewScaled=view/scaleOfGridCoordsKm;
viewScaled=normalize(viewScaled);
vec3 offset_vec=vec3(0,0,0);
float maxDistKm=maxCloudDistanceKm;
float K=log(maxDistKm);
float step_ratio=1.0+K/float(numSteps);

{
float a=1.0/(saturate(view.z)+0.00001);
offset_vec+=max(0.0,min_z-world_pos.z)*vec3(view.x*a,view.y*a,1.0);
}


{
float a=1.0/(saturate(-view.z)+0.00001);
offset_vec+=max(0.0,world_pos.z-max_z)*vec3(view.x*a,view.y*a,-1.0);
}

vec3 halfway=0.5*(lightDirection-view);
world_pos+=offset_vec;
float distanceKm=length(offset_vec);
float distScale=0.6/maxFadeDistanceKm;
bool found=false;
float stepKm=K*(1.2+distanceKm)/float(numSteps);
vec3 amb_dir=view;
uint steps=initialSteps-uint((1&stepPos)!=0);
uint in_step=0,c=0;
float rangeKm=initialSteps*stepKm;
float oddRangeKm=(0.5*stepKm*initialSteps);
for(int i=0;i<768;i++)
{
if((view.z<0&&world_pos.z<min_z)||(view.z>0&&world_pos.z>max_z)||distanceKm>maxCloudDistanceKm)break;
distanceKm+=stepKm;
float fade=1.0;
if(consistent_steps)
{
uint odd=typed_mod((steps-in_step),2);
float fade_up=saturate((rangeKm-distanceKm)/oddRangeKm);
fade=(odd!=0)?fade_up:1.0;
if(in_step++==steps)
{
stepKm*=2.0;
c++;
uint u=(1<<c);
steps=initialSteps-uint((u&stepPos)!=0);
in_step=0;
rangeKm=distanceKm+initialSteps*stepKm;
oddRangeKm=(0.5*stepKm*initialSteps);
}

}

world_pos+=stepKm*view;
if(!consistent_steps)stepKm*=step_ratio;
vec3 cloudWorldOffsetKm=world_pos-cornerPosKm;
vec3 cloudTexCoords=cloudWorldOffsetKm*inverseScalesKm;
float fadeDistance=saturate(distanceKm/maxFadeDistanceKm);
maxDistance=max(fadeDistance,maxDistance);
if(fade>0)
{
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),cloudTexCoords,fadeDistance*0.0);

{

}


{
vec3 noise_texc=world_pos.xyz*noise3DTexcoordScale+noise3DTexcoordOffset;
vec3 noise_texc2=world_pos.xyz*noise3DTexcoordScale2+noise3DTexcoordOffset2;
vec4 noiseval=vec4(0,0,0,0);
if(noise)
{
vec4 noiseval1=density.x*textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc,1.0*fadeDistance);
vec4 noiseval2=density.x*textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc2,1.0*fadeDistance);
noiseval=noiseval1*cos(.2*3.14159*noiseval2.x)+noiseval1.wzxy*sin(.2*3.14159*noiseval2.y);
}

vec4 light=vec4(1,1,1,1);
calcDensity(cloudDensity,cloudLight,cloudTexCoords,noiseval,fractalScale,0,density,light);
density.z*=fade;
if(do_rain_effect)
{
float dm=rainEffect*fade*GetRainAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm);
moisture+=0.01*dm*light.x;
density.z=saturate(density.z+dm);
}

if(density.z>0)
{
if(noise)
{
vec3 worley_texc=(world_pos.xyz+worleyOffsetKm)*worleyTexcoordScale;
minDistance=min(max(0,fadeDistance-density.z*stepKm/maxFadeDistanceKm),minDistance);
vec4 worley=textureLod(sampler3D(smallWorleyTexture3D[1 + 6]),worley_texc,0);
float wo=4*density.y*(worley.w-0.6)*saturate(1.0/(12.0*fadeDistance));
density.z*=mix(1.0,worley.w,saturate(1.0/(12.0*fadeDistance)));
amb_dir=mix(amb_dir,worley.xyz,0.1*density.z);
}

float brightness_factor;
fade_texc.x=sqrt(fadeDistance);
vec3 volumeTexCoords=vec3(volumeTexCoordsXyC.xy,fade_texc.x);
ColourStep(res.colour,insc,meanFadeDistance,brightness_factor,lossTexture,inscTexture,skylTexture,inscatterVolumeTexture,do_godrays,godraysVolumeTexture,lightspaceScale,godraysTexCoords,lightTableTexture,density,light,distanceKm,fadeDistance,world_pos,cloudTexCoords,fade_texc,nearFarTexc,1.0,volumeTexCoords,amb_dir,BetaClouds,BetaRayleigh,BetaMie,solidDist_nearFar,noise,do_depth_mix,distScale,0,noiseval,1.0,alphaSharpness);
if(res.colour[0].a*brightness_factor<0.003)
{
for(int o=0;o<num_interp;o++)res.colour[o].a=0.0;
meanFadeDistance=fadeDistance;
break;
}

}

}

}

}

res.nearFarDepth.zw=vec2(meanFadeDistance,moisture);
#line 261 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_simple.sl"

for(int j=0;j<num_interp;j++)res.colour[j].rgb+=insc[j].rgb;
return res;
}
#line 706 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void StaticRaytrace(uvec3 pos, bool include_rain, bool depth, bool background2d, int numSteps, int num_interp, bool do_godrays, bool consistent_steps)
{
vec2 texCoords=(vec2(pos.xy)+vec2(0.5,0.5))/vec2(targetTextureSize);
vec4 clip_pos=vec4(-1.0,1.0,1.0,1.0);
clip_pos.x+=2.0*texCoords.x;
clip_pos.y-=2.0*texCoords.y;
vec3 view=normalize(mul(invViewProj[pos.z],clip_pos).xyz);
vec4 dlookup=vec4(1.0,1.0,0.000001,1.0);
if(depth)
{
dlookup=textureLod(samplerCube(depthTexture[1 + 6]),view,0);
}

vec3 worldspaceVolumeTexCoordsXyC=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(view.z)/3.1415926536),0);
RaytracePixelOutput f=RaytraceCloudsStatic(cloudDensity,cloudDensity2,precipitationVolume,noiseTexture3D,lightTableTexture,illuminationTexture,lossTexture,inscTexture,skylTexture,volumeInscatterTexture,godraysTexture,depth,dlookup,view,clip_pos,worldspaceVolumeTexCoordsXyC,background2d,include_rain,false,cloudIrRadiance1,cloudIrRadiance2,numSteps,num_interp,do_godrays,consistent_steps);
vec4 t2d=vec4(0,0,0,1.0);
vec4 c=t2d;
c.rgb*=f.colour[num_interp-1].a;
c.rgb+=f.colour[num_interp-1].rgb;
c.a=t2d.a*f.colour[num_interp-1].a;
imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*(num_interp-1))),vec4(c));
float n=float(dlookup.y>=1.0);
for(int u=0;u<num_interp-1;u++)
{
vec4 cn=t2d;
cn.rgb*=f.colour[u].a*n;
cn.a=1.0-n*(1.0-t2d.a);
cn.rgb+=f.colour[u].rgb;
cn.a*=f.colour[u].a;
imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*u)),vec4(cn));
}

if(background2d)imageStore(outputTexture3,ivec3(pos),vec4(f.nearFarDepth));
}
#line 970 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void CS_RaytraceStatic(uvec3 g, uvec3 t, bool include_rain, bool depth, bool godrays, bool consistent_steps)
{
uvec2 idx=uvec2(g.xy*4+t.xy);
uint Z=cubemapFaceIndex[g.z+t.z].x;
uvec3 pos=uvec3(targetRange[Z].xy+idx*amortizationScale.xy,Z);
uvec2 offs=typed_mod((amortizationOffset.xy+(idx.xy+idx.yx)),amortizationScale.xy);
pos.xy+=offs;
if(pos.x>=edge.x||pos.y>=edge.y)return ;
if(pos.x>=targetRange[Z].z||pos.y>=targetRange[Z].w)return ;
if(texelFetch(sampler2DArray(updateTexture[0]),ivec3(pos).xyz,0).b==0.0)return ;
StaticRaytrace(pos,include_rain,depth,true,raytraceSteps,2,godrays,consistent_steps);
}
layout(local_size_x=4, local_size_y=4, local_size_z=1) in;
void main()
{
uvec3 g = gl_WorkGroupID;
uvec3 t = gl_LocalInvocationID;
#line 1158 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
CS_RaytraceStatic(g,t,false,true,true,false);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_CS_RaytraceStaticNoRain_cons_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 12) uniform CloudStaticConstants
{
	mat4 invViewProj[6];
};
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};

#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
struct RaytracePixelOutput
{
	vec4 colour[2];
	vec4 nearFarDepth;
};













layout(rgba16f, binding = 4) uniform image2DArray outputTexture1;
layout(rgba16f, binding = 5) uniform image2DArray outputTexture3;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t smallWorleyTexture3D[24];
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
	uint64_t noiseTexture3D[24];
	uint64_t godraysTexture[24];
	uint64_t volumeInscatterTexture[24];
	uint64_t skylTexture[24];
	uint64_t inscTexture[24];
	uint64_t lossTexture[24];
	uint64_t depthTexture[24];
	uint64_t illuminationTexture[24];
	uint64_t lightTableTexture[24];
	uint64_t precipitationVolume[24];
	uint64_t updateTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float CalcRayleighBeta(float cos0)
{
return (1.0+cos0*cos0);
}
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float HenyeyGreenstein(float g, float cos0)
{
float g2=g*g;
float u=1.0+g2-2.0*g*cos0;
return (1.0-g2)*pow(u,-1.5)/(4.0*3.1415926536);
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
vec3 PrecalculatedInscatterFunction(vec4 inscatter_factor, float BetaRayleigh, float BetaMie, vec3 mieRayleighRatio)
{
vec3 mr=mieRayleighRatio.xyz;
vec3 BetaTotal=(BetaRayleigh+BetaMie*mr)/(vec3(1.0,1.0,1.0)+mr);
vec3 colour=BetaTotal*inscatter_factor.rgb;
return colour;
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float GetAltTexCoord(float alt_km, float minSunlightAltitudeKm, float fadeAltitudeRangeKm)
{
float diff_km=alt_km-minSunlightAltitudeKm;
float sun_alt_texc=0.5+0.5*saturate(diff_km/fadeAltitudeRangeKm);
sun_alt_texc-=0.5*saturate(-diff_km/(minSunlightAltitudeKm+1.0));
return sun_alt_texc;
}
#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float unshadowedBrightness(float Beta, vec4 lightResponse, vec3 ambientColour)
{
return max(1.0,(Beta+lightResponse.y)+ambientColour.b);
}
#line 34 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColour(uint64_t lossTexture[24], uint64_t inscatterVolumeTexture[24], vec3 volumeTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float Beta, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec3 amb_dir, vec2 fade_texc, out float brightnessFactor, out vec4 inscatter, float fade, float alphaSharpness)
{
float alt_texc=(world_pos.z/fadeAltitudeRangeKm);
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 amb_lookup=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
ambientColour=lightResponse.w*amb_lookup.rgb;
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
vec3 ambient=amb_lookup.rgb*light.w;
vec4 c;
float l=mix(0.75,1.2,density.z);
c.rgb=(light.y*lightResponse.x*(Beta+l)+lightResponse.y*light.x)*combinedLightColour+ambient.rgb;
c.a=density.z*fade;
c.a=saturate(0.3+(1.0+1.0*density.w*alphaSharpness)*(c.a-0.3));

{
vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

inscatter=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),volumeTexCoords,0);
inscatter.rgb*=inscatter.a;
#line 62 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

}

return c;
}
#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColourSimple(uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t lightTableTexture[24], vec4 density, float Beta, float BetaRayleigh, float BetaMie, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, out float brightnessFactor)
{
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
ambientColour=lightResponse.w*textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
vec3 ambient=density.w*ambientColour.rgb;
float opacity=density.z;
vec4 c;
c.rgb=(density.y*Beta+lightResponse.y*density.x)*combinedLightColour+ambient.rgb;
c.a=opacity;
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float earthshadowFactr=saturate((fade_texc.x-nearFarTexc.x)/0.1);
#line 88 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
vec4 insc=textureLod(sampler2D(inscTexture[1 + 5]),fade_texc,0);
vec3 skyl=textureLod(sampler2D(skylTexture[1 + 5]),fade_texc,0).rgb;
vec3 inscatter=earthshadowFactr*PrecalculatedInscatterFunction(insc,BetaRayleigh,BetaMie,mieRayleighRatio);
c.rgb+=inscatter+skyl;
return c;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void calcDensity(uint64_t cloudDensity[24], uint64_t cloudLight[24], vec3 texCoords, vec4 noiseval, vec3 fractalScale, float mip, inout vec4 density, out vec4 light)
{
vec3 pos=texCoords.xyz+fractalScale.xyz*(noiseval.xyz);
density=textureLod(sampler3D(cloudDensity[1 + 7]),pos,mip);
light=textureLod(sampler3D(cloudLight[1 + 7]),texCoords,mip);
}
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 GetPrecipitationAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm, float mip)
{
vec3 rain_texc=cloudWorldOffsetKm;
rain_texc.xy+=rain_texc.z*rainTangent;
rain_texc*=inverseScalesKm;
vec3 pvSize;
ivec3 ivprecipitationVolume = textureSize(sampler3D(precipitationVolume[0]),0);
pvSize.x = ivprecipitationVolume.x;pvSize.y = ivprecipitationVolume.y;pvSize.z = ivprecipitationVolume.z;;
uint z_texel=uint(rain_texc.z*pvSize.z);
rain_texc.z=(float(z_texel)+0.5)/pvSize.z;
return textureLod(sampler3D(precipitationVolume[1 + 7]),rain_texc,mip);
}
#line 120 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float GetRainAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm)
{
vec4 rain_lookup=GetPrecipitationAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm,0.0);
return rain_lookup.x*rain_lookup.w*saturate((20.0*rain_lookup.y-cloudWorldOffsetKm.z)/2.0);
}
#line 146 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void ColourStep(inout vec4 colour[2], inout vec4 insc[2], inout float meanFadeDistance, out float brightness_factor, uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], bool godrays, uint64_t godraysVolumeTexture[24], float godraysScale, vec3 godraysTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float distanceKm, float fadeDistance, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, float cosine, vec3 volumeTexCoords, vec3 amb_dir, float BetaClouds, float BetaRayleigh, float BetaMie, float solidDist_nearFar[2], bool noise, bool do_depth_mix, float distScale, int idx, vec4 noiseval, float fade, float alphaSharpness)
{
density.z*=saturate(distanceKm/0.24);
vec4 clr[2];
vec4 inscatter=vec4(0,0,0,0);
brightness_factor=1.0;
if(noise)clr[2-1]=calcColour(lossTexture,inscatterVolumeTexture,volumeTexCoords,lightTableTexture,density,light,BetaClouds,lightResponse,ambientColour,world_pos,cloudTexCoords,amb_dir,fade_texc,brightness_factor,inscatter,fade,alphaSharpness);else
clr[2-1]=calcColourSimple(lossTexture,inscTexture,skylTexture,lightTableTexture,vec4(light.xyw,density.z),BetaClouds,BetaRayleigh,BetaMie,lightResponse,ambientColour,world_pos,cloudTexCoords,fade_texc,nearFarTexc,brightness_factor);
clr[2-1].a*=cosine*cosine;
meanFadeDistance=mix(min(fadeDistance,meanFadeDistance),meanFadeDistance,(1.0-.4*density.z));
godraysTexCoords.z=distanceKm*godraysScale;
float gr_mult=1.0;
if(godrays)gr_mult=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),godraysTexCoords,0).x;
for(int i=0;i<2;i++)
{
clr[i]=clr[2-1];
if(do_depth_mix)
{
float m=saturate((solidDist_nearFar[i]-fadeDistance)/distScale);
clr[i].a*=m;
}

colour[i].rgb+=(clr[i].rgb)*clr[i].a*(colour[i].a);
insc[i].rgb+=gr_mult*inscatter.rgb*clr[i].a*(colour[i].a);
colour[i].a*=(1.0-clr[i].a);
}

}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_simple.sl"
RaytracePixelOutput RaytraceCloudsStatic(uint64_t cloudDensity[24], uint64_t cloudLight[24], uint64_t precipitationVolume[24], uint64_t noiseTexture3D[24], uint64_t lightTableTexture[24], uint64_t illuminationTexture[24], uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], bool do_depth_mix, vec4 dlookup, vec3 view, vec4 clip_pos, vec3 volumeTexCoordsXyC, bool noise, bool do_rain_effect, bool do_rainbow, vec3 cloudIrRadiance1, vec3 cloudIrRadiance2, int numSteps, int num_interp, bool do_godrays, bool consistent_steps)
{
RaytracePixelOutput res;
vec4 insc[2];
for(int ii=0;ii<num_interp;ii++)
{
res.colour[ii]=vec4(0,0,0,1.0);
insc[ii]=vec4(0,0,0,0);
}

res.nearFarDepth=dlookup;
float s=saturate((directionToSun.z+0.2)/0.01);
vec3 lightDirection=mix(directionToMoon,directionToSun,s);
float cos0=dot(lightDirection.xyz,view.xyz);
float sine=view.z;
float min_z=cornerPosKm.z-(fractalScale.z*1.5)/inverseScalesKm.z;
float max_z=cornerPosKm.z+(1.0+fractalScale.z*1.5)/inverseScalesKm.z;
vec3 godraysTexCoords=vec3(0,0,0);
float lightspaceScale=1.0;
if(do_godrays)
{
vec3 lightspaceView=(mul(worldToScatteringVolumeMatrix,vec4(view,1.0)).xyz);
lightspaceScale=length(lightspaceView);
godraysTexCoords=vec3(fract(atan(lightspaceView.x,lightspaceView.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceView.z/lightspaceScale)*2.0/3.1415926536,0);
}

float solidDist_nearFar[2];
vec2 nfd=(dlookup.yx)+100.0*step(vec2(1.0,1.0),dlookup.yx);
float n=nfd.x;
float f=nfd.y;
solidDist_nearFar[0]=n;
solidDist_nearFar[num_interp-1]=f;
for(int l=1;l<num_interp-1;l++)
{
float interp=float(l)/float(num_interp-1);
solidDist_nearFar[l]=mix(n,f,interp);
}

vec2 fade_texc=vec2(0.0,0.5*(1.0-sine));
vec2 illum_texc=vec2(atan(view.x,view.y)/(3.1415926536*2.0),fade_texc.y);
vec4 illum_lookup=textureLod(sampler2D(illuminationTexture[1 + 3]),illum_texc,0);
vec2 nearFarTexc=vec2(0,1.0);
float meanFadeDistance=1.0;
float minDistance=1.0;
float maxDistance=0.0;
float BetaClouds=lightResponse.x*HenyeyGreenstein(cloudEccentricity,cos0);
float BetaRayleigh=CalcRayleighBeta(cos0);
float BetaMie=HenyeyGreenstein(hazeEccentricity,cos0);
float moisture=0.0;
vec3 world_pos=viewPosKm;
view.xyz+=vec3(0.00001,0.00001,0.00001);
ivec3 c_offset=ivec3(2.0*step(vec3(0,0,0),view.xyz)-vec3(1,1,1));
ivec3 start_c_offset=-c_offset;
start_c_offset=ivec3(max(start_c_offset.x,0),max(start_c_offset.y,0),max(start_c_offset.z,0));
vec3 viewScaled=view/scaleOfGridCoordsKm;
viewScaled=normalize(viewScaled);
vec3 offset_vec=vec3(0,0,0);
float maxDistKm=maxCloudDistanceKm;
float K=log(maxDistKm);
float step_ratio=1.0+K/float(numSteps);

{
float a=1.0/(saturate(view.z)+0.00001);
offset_vec+=max(0.0,min_z-world_pos.z)*vec3(view.x*a,view.y*a,1.0);
}


{
float a=1.0/(saturate(-view.z)+0.00001);
offset_vec+=max(0.0,world_pos.z-max_z)*vec3(view.x*a,view.y*a,-1.0);
}

vec3 halfway=0.5*(lightDirection-view);
world_pos+=offset_vec;
float distanceKm=length(offset_vec);
float distScale=0.6/maxFadeDistanceKm;
bool found=false;
float stepKm=K*(1.2+distanceKm)/float(numSteps);
vec3 amb_dir=view;
uint steps=initialSteps-uint((1&stepPos)!=0);
uint in_step=0,c=0;
float rangeKm=initialSteps*stepKm;
float oddRangeKm=(0.5*stepKm*initialSteps);
for(int i=0;i<768;i++)
{
if((view.z<0&&world_pos.z<min_z)||(view.z>0&&world_pos.z>max_z)||distanceKm>maxCloudDistanceKm)break;
distanceKm+=stepKm;
float fade=1.0;
if(consistent_steps)
{
uint odd=typed_mod((steps-in_step),2);
float fade_up=saturate((rangeKm-distanceKm)/oddRangeKm);
fade=(odd!=0)?fade_up:1.0;
if(in_step++==steps)
{
stepKm*=2.0;
c++;
uint u=(1<<c);
steps=initialSteps-uint((u&stepPos)!=0);
in_step=0;
rangeKm=distanceKm+initialSteps*stepKm;
oddRangeKm=(0.5*stepKm*initialSteps);
}

}

world_pos+=stepKm*view;
if(!consistent_steps)stepKm*=step_ratio;
vec3 cloudWorldOffsetKm=world_pos-cornerPosKm;
vec3 cloudTexCoords=cloudWorldOffsetKm*inverseScalesKm;
float fadeDistance=saturate(distanceKm/maxFadeDistanceKm);
maxDistance=max(fadeDistance,maxDistance);
if(fade>0)
{
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),cloudTexCoords,fadeDistance*0.0);

{

}


{
vec3 noise_texc=world_pos.xyz*noise3DTexcoordScale+noise3DTexcoordOffset;
vec3 noise_texc2=world_pos.xyz*noise3DTexcoordScale2+noise3DTexcoordOffset2;
vec4 noiseval=vec4(0,0,0,0);
if(noise)
{
vec4 noiseval1=density.x*textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc,1.0*fadeDistance);
vec4 noiseval2=density.x*textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc2,1.0*fadeDistance);
noiseval=noiseval1*cos(.2*3.14159*noiseval2.x)+noiseval1.wzxy*sin(.2*3.14159*noiseval2.y);
}

vec4 light=vec4(1,1,1,1);
calcDensity(cloudDensity,cloudLight,cloudTexCoords,noiseval,fractalScale,0,density,light);
density.z*=fade;
if(do_rain_effect)
{
float dm=rainEffect*fade*GetRainAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm);
moisture+=0.01*dm*light.x;
density.z=saturate(density.z+dm);
}

if(density.z>0)
{
if(noise)
{
vec3 worley_texc=(world_pos.xyz+worleyOffsetKm)*worleyTexcoordScale;
minDistance=min(max(0,fadeDistance-density.z*stepKm/maxFadeDistanceKm),minDistance);
vec4 worley=textureLod(sampler3D(smallWorleyTexture3D[1 + 6]),worley_texc,0);
float wo=4*density.y*(worley.w-0.6)*saturate(1.0/(12.0*fadeDistance));
density.z*=mix(1.0,worley.w,saturate(1.0/(12.0*fadeDistance)));
amb_dir=mix(amb_dir,worley.xyz,0.1*density.z);
}

float brightness_factor;
fade_texc.x=sqrt(fadeDistance);
vec3 volumeTexCoords=vec3(volumeTexCoordsXyC.xy,fade_texc.x);
ColourStep(res.colour,insc,meanFadeDistance,brightness_factor,lossTexture,inscTexture,skylTexture,inscatterVolumeTexture,do_godrays,godraysVolumeTexture,lightspaceScale,godraysTexCoords,lightTableTexture,density,light,distanceKm,fadeDistance,world_pos,cloudTexCoords,fade_texc,nearFarTexc,1.0,volumeTexCoords,amb_dir,BetaClouds,BetaRayleigh,BetaMie,solidDist_nearFar,noise,do_depth_mix,distScale,0,noiseval,1.0,alphaSharpness);
if(res.colour[0].a*brightness_factor<0.003)
{
for(int o=0;o<num_interp;o++)res.colour[o].a=0.0;
meanFadeDistance=fadeDistance;
break;
}

}

}

}

}

res.nearFarDepth.zw=vec2(meanFadeDistance,moisture);
#line 261 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_simple.sl"

for(int j=0;j<num_interp;j++)res.colour[j].rgb+=insc[j].rgb;
return res;
}
#line 706 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void StaticRaytrace(uvec3 pos, bool include_rain, bool depth, bool background2d, int numSteps, int num_interp, bool do_godrays, bool consistent_steps)
{
vec2 texCoords=(vec2(pos.xy)+vec2(0.5,0.5))/vec2(targetTextureSize);
vec4 clip_pos=vec4(-1.0,1.0,1.0,1.0);
clip_pos.x+=2.0*texCoords.x;
clip_pos.y-=2.0*texCoords.y;
vec3 view=normalize(mul(invViewProj[pos.z],clip_pos).xyz);
vec4 dlookup=vec4(1.0,1.0,0.000001,1.0);
if(depth)
{
dlookup=textureLod(samplerCube(depthTexture[1 + 6]),view,0);
}

vec3 worldspaceVolumeTexCoordsXyC=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(view.z)/3.1415926536),0);
RaytracePixelOutput f=RaytraceCloudsStatic(cloudDensity,cloudDensity2,precipitationVolume,noiseTexture3D,lightTableTexture,illuminationTexture,lossTexture,inscTexture,skylTexture,volumeInscatterTexture,godraysTexture,depth,dlookup,view,clip_pos,worldspaceVolumeTexCoordsXyC,background2d,include_rain,false,cloudIrRadiance1,cloudIrRadiance2,numSteps,num_interp,do_godrays,consistent_steps);
vec4 t2d=vec4(0,0,0,1.0);
vec4 c=t2d;
c.rgb*=f.colour[num_interp-1].a;
c.rgb+=f.colour[num_interp-1].rgb;
c.a=t2d.a*f.colour[num_interp-1].a;
imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*(num_interp-1))),vec4(c));
float n=float(dlookup.y>=1.0);
for(int u=0;u<num_interp-1;u++)
{
vec4 cn=t2d;
cn.rgb*=f.colour[u].a*n;
cn.a=1.0-n*(1.0-t2d.a);
cn.rgb+=f.colour[u].rgb;
cn.a*=f.colour[u].a;
imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*u)),vec4(cn));
}

if(background2d)imageStore(outputTexture3,ivec3(pos),vec4(f.nearFarDepth));
}
#line 970 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void CS_RaytraceStatic(uvec3 g, uvec3 t, bool include_rain, bool depth, bool godrays, bool consistent_steps)
{
uvec2 idx=uvec2(g.xy*4+t.xy);
uint Z=cubemapFaceIndex[g.z+t.z].x;
uvec3 pos=uvec3(targetRange[Z].xy+idx*amortizationScale.xy,Z);
uvec2 offs=typed_mod((amortizationOffset.xy+(idx.xy+idx.yx)),amortizationScale.xy);
pos.xy+=offs;
if(pos.x>=edge.x||pos.y>=edge.y)return ;
if(pos.x>=targetRange[Z].z||pos.y>=targetRange[Z].w)return ;
if(texelFetch(sampler2DArray(updateTexture[0]),ivec3(pos).xyz,0).b==0.0)return ;
StaticRaytrace(pos,include_rain,depth,true,raytraceSteps,2,godrays,consistent_steps);
}
layout(local_size_x=4, local_size_y=4, local_size_z=1) in;
void main()
{
uvec3 g = gl_WorkGroupID;
uvec3 t = gl_LocalInvocationID;
#line 1171 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
CS_RaytraceStatic(g,t,false,true,true,true);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_CS_RaytraceStaticRain_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 12) uniform CloudStaticConstants
{
	mat4 invViewProj[6];
};
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};

#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
struct RaytracePixelOutput
{
	vec4 colour[2];
	vec4 nearFarDepth;
};













layout(rgba16f, binding = 4) uniform image2DArray outputTexture1;
layout(rgba16f, binding = 5) uniform image2DArray outputTexture3;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t smallWorleyTexture3D[24];
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
	uint64_t noiseTexture3D[24];
	uint64_t godraysTexture[24];
	uint64_t volumeInscatterTexture[24];
	uint64_t skylTexture[24];
	uint64_t inscTexture[24];
	uint64_t lossTexture[24];
	uint64_t depthTexture[24];
	uint64_t illuminationTexture[24];
	uint64_t lightTableTexture[24];
	uint64_t precipitationVolume[24];
	uint64_t updateTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float CalcRayleighBeta(float cos0)
{
return (1.0+cos0*cos0);
}
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float HenyeyGreenstein(float g, float cos0)
{
float g2=g*g;
float u=1.0+g2-2.0*g*cos0;
return (1.0-g2)*pow(u,-1.5)/(4.0*3.1415926536);
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
vec3 PrecalculatedInscatterFunction(vec4 inscatter_factor, float BetaRayleigh, float BetaMie, vec3 mieRayleighRatio)
{
vec3 mr=mieRayleighRatio.xyz;
vec3 BetaTotal=(BetaRayleigh+BetaMie*mr)/(vec3(1.0,1.0,1.0)+mr);
vec3 colour=BetaTotal*inscatter_factor.rgb;
return colour;
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float GetAltTexCoord(float alt_km, float minSunlightAltitudeKm, float fadeAltitudeRangeKm)
{
float diff_km=alt_km-minSunlightAltitudeKm;
float sun_alt_texc=0.5+0.5*saturate(diff_km/fadeAltitudeRangeKm);
sun_alt_texc-=0.5*saturate(-diff_km/(minSunlightAltitudeKm+1.0));
return sun_alt_texc;
}
#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float unshadowedBrightness(float Beta, vec4 lightResponse, vec3 ambientColour)
{
return max(1.0,(Beta+lightResponse.y)+ambientColour.b);
}
#line 34 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColour(uint64_t lossTexture[24], uint64_t inscatterVolumeTexture[24], vec3 volumeTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float Beta, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec3 amb_dir, vec2 fade_texc, out float brightnessFactor, out vec4 inscatter, float fade, float alphaSharpness)
{
float alt_texc=(world_pos.z/fadeAltitudeRangeKm);
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 amb_lookup=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
ambientColour=lightResponse.w*amb_lookup.rgb;
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
vec3 ambient=amb_lookup.rgb*light.w;
vec4 c;
float l=mix(0.75,1.2,density.z);
c.rgb=(light.y*lightResponse.x*(Beta+l)+lightResponse.y*light.x)*combinedLightColour+ambient.rgb;
c.a=density.z*fade;
c.a=saturate(0.3+(1.0+1.0*density.w*alphaSharpness)*(c.a-0.3));

{
vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

inscatter=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),volumeTexCoords,0);
inscatter.rgb*=inscatter.a;
#line 62 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

}

return c;
}
#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColourSimple(uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t lightTableTexture[24], vec4 density, float Beta, float BetaRayleigh, float BetaMie, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, out float brightnessFactor)
{
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
ambientColour=lightResponse.w*textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
vec3 ambient=density.w*ambientColour.rgb;
float opacity=density.z;
vec4 c;
c.rgb=(density.y*Beta+lightResponse.y*density.x)*combinedLightColour+ambient.rgb;
c.a=opacity;
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float earthshadowFactr=saturate((fade_texc.x-nearFarTexc.x)/0.1);
#line 88 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
vec4 insc=textureLod(sampler2D(inscTexture[1 + 5]),fade_texc,0);
vec3 skyl=textureLod(sampler2D(skylTexture[1 + 5]),fade_texc,0).rgb;
vec3 inscatter=earthshadowFactr*PrecalculatedInscatterFunction(insc,BetaRayleigh,BetaMie,mieRayleighRatio);
c.rgb+=inscatter+skyl;
return c;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void calcDensity(uint64_t cloudDensity[24], uint64_t cloudLight[24], vec3 texCoords, vec4 noiseval, vec3 fractalScale, float mip, inout vec4 density, out vec4 light)
{
vec3 pos=texCoords.xyz+fractalScale.xyz*(noiseval.xyz);
density=textureLod(sampler3D(cloudDensity[1 + 7]),pos,mip);
light=textureLod(sampler3D(cloudLight[1 + 7]),texCoords,mip);
}
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 GetPrecipitationAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm, float mip)
{
vec3 rain_texc=cloudWorldOffsetKm;
rain_texc.xy+=rain_texc.z*rainTangent;
rain_texc*=inverseScalesKm;
vec3 pvSize;
ivec3 ivprecipitationVolume = textureSize(sampler3D(precipitationVolume[0]),0);
pvSize.x = ivprecipitationVolume.x;pvSize.y = ivprecipitationVolume.y;pvSize.z = ivprecipitationVolume.z;;
uint z_texel=uint(rain_texc.z*pvSize.z);
rain_texc.z=(float(z_texel)+0.5)/pvSize.z;
return textureLod(sampler3D(precipitationVolume[1 + 7]),rain_texc,mip);
}
#line 120 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float GetRainAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm)
{
vec4 rain_lookup=GetPrecipitationAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm,0.0);
return rain_lookup.x*rain_lookup.w*saturate((20.0*rain_lookup.y-cloudWorldOffsetKm.z)/2.0);
}
#line 146 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void ColourStep(inout vec4 colour[2], inout vec4 insc[2], inout float meanFadeDistance, out float brightness_factor, uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], bool godrays, uint64_t godraysVolumeTexture[24], float godraysScale, vec3 godraysTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float distanceKm, float fadeDistance, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, float cosine, vec3 volumeTexCoords, vec3 amb_dir, float BetaClouds, float BetaRayleigh, float BetaMie, float solidDist_nearFar[2], bool noise, bool do_depth_mix, float distScale, int idx, vec4 noiseval, float fade, float alphaSharpness)
{
density.z*=saturate(distanceKm/0.24);
vec4 clr[2];
vec4 inscatter=vec4(0,0,0,0);
brightness_factor=1.0;
if(noise)clr[2-1]=calcColour(lossTexture,inscatterVolumeTexture,volumeTexCoords,lightTableTexture,density,light,BetaClouds,lightResponse,ambientColour,world_pos,cloudTexCoords,amb_dir,fade_texc,brightness_factor,inscatter,fade,alphaSharpness);else
clr[2-1]=calcColourSimple(lossTexture,inscTexture,skylTexture,lightTableTexture,vec4(light.xyw,density.z),BetaClouds,BetaRayleigh,BetaMie,lightResponse,ambientColour,world_pos,cloudTexCoords,fade_texc,nearFarTexc,brightness_factor);
clr[2-1].a*=cosine*cosine;
meanFadeDistance=mix(min(fadeDistance,meanFadeDistance),meanFadeDistance,(1.0-.4*density.z));
godraysTexCoords.z=distanceKm*godraysScale;
float gr_mult=1.0;
if(godrays)gr_mult=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),godraysTexCoords,0).x;
for(int i=0;i<2;i++)
{
clr[i]=clr[2-1];
if(do_depth_mix)
{
float m=saturate((solidDist_nearFar[i]-fadeDistance)/distScale);
clr[i].a*=m;
}

colour[i].rgb+=(clr[i].rgb)*clr[i].a*(colour[i].a);
insc[i].rgb+=gr_mult*inscatter.rgb*clr[i].a*(colour[i].a);
colour[i].a*=(1.0-clr[i].a);
}

}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_simple.sl"
RaytracePixelOutput RaytraceCloudsStatic(uint64_t cloudDensity[24], uint64_t cloudLight[24], uint64_t precipitationVolume[24], uint64_t noiseTexture3D[24], uint64_t lightTableTexture[24], uint64_t illuminationTexture[24], uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], bool do_depth_mix, vec4 dlookup, vec3 view, vec4 clip_pos, vec3 volumeTexCoordsXyC, bool noise, bool do_rain_effect, bool do_rainbow, vec3 cloudIrRadiance1, vec3 cloudIrRadiance2, int numSteps, int num_interp, bool do_godrays, bool consistent_steps)
{
RaytracePixelOutput res;
vec4 insc[2];
for(int ii=0;ii<num_interp;ii++)
{
res.colour[ii]=vec4(0,0,0,1.0);
insc[ii]=vec4(0,0,0,0);
}

res.nearFarDepth=dlookup;
float s=saturate((directionToSun.z+0.2)/0.01);
vec3 lightDirection=mix(directionToMoon,directionToSun,s);
float cos0=dot(lightDirection.xyz,view.xyz);
float sine=view.z;
float min_z=cornerPosKm.z-(fractalScale.z*1.5)/inverseScalesKm.z;
float max_z=cornerPosKm.z+(1.0+fractalScale.z*1.5)/inverseScalesKm.z;
vec3 godraysTexCoords=vec3(0,0,0);
float lightspaceScale=1.0;
if(do_godrays)
{
vec3 lightspaceView=(mul(worldToScatteringVolumeMatrix,vec4(view,1.0)).xyz);
lightspaceScale=length(lightspaceView);
godraysTexCoords=vec3(fract(atan(lightspaceView.x,lightspaceView.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceView.z/lightspaceScale)*2.0/3.1415926536,0);
}

float solidDist_nearFar[2];
vec2 nfd=(dlookup.yx)+100.0*step(vec2(1.0,1.0),dlookup.yx);
float n=nfd.x;
float f=nfd.y;
solidDist_nearFar[0]=n;
solidDist_nearFar[num_interp-1]=f;
for(int l=1;l<num_interp-1;l++)
{
float interp=float(l)/float(num_interp-1);
solidDist_nearFar[l]=mix(n,f,interp);
}

vec2 fade_texc=vec2(0.0,0.5*(1.0-sine));
vec2 illum_texc=vec2(atan(view.x,view.y)/(3.1415926536*2.0),fade_texc.y);
vec4 illum_lookup=textureLod(sampler2D(illuminationTexture[1 + 3]),illum_texc,0);
vec2 nearFarTexc=vec2(0,1.0);
float meanFadeDistance=1.0;
float minDistance=1.0;
float maxDistance=0.0;
float BetaClouds=lightResponse.x*HenyeyGreenstein(cloudEccentricity,cos0);
float BetaRayleigh=CalcRayleighBeta(cos0);
float BetaMie=HenyeyGreenstein(hazeEccentricity,cos0);
float moisture=0.0;
vec3 world_pos=viewPosKm;
view.xyz+=vec3(0.00001,0.00001,0.00001);
ivec3 c_offset=ivec3(2.0*step(vec3(0,0,0),view.xyz)-vec3(1,1,1));
ivec3 start_c_offset=-c_offset;
start_c_offset=ivec3(max(start_c_offset.x,0),max(start_c_offset.y,0),max(start_c_offset.z,0));
vec3 viewScaled=view/scaleOfGridCoordsKm;
viewScaled=normalize(viewScaled);
vec3 offset_vec=vec3(0,0,0);
float maxDistKm=maxCloudDistanceKm;
float K=log(maxDistKm);
float step_ratio=1.0+K/float(numSteps);

{
float a=1.0/(saturate(view.z)+0.00001);
offset_vec+=max(0.0,min_z-world_pos.z)*vec3(view.x*a,view.y*a,1.0);
}


{
float a=1.0/(saturate(-view.z)+0.00001);
offset_vec+=max(0.0,world_pos.z-max_z)*vec3(view.x*a,view.y*a,-1.0);
}

vec3 halfway=0.5*(lightDirection-view);
world_pos+=offset_vec;
float distanceKm=length(offset_vec);
float distScale=0.6/maxFadeDistanceKm;
bool found=false;
float stepKm=K*(1.2+distanceKm)/float(numSteps);
vec3 amb_dir=view;
uint steps=initialSteps-uint((1&stepPos)!=0);
uint in_step=0,c=0;
float rangeKm=initialSteps*stepKm;
float oddRangeKm=(0.5*stepKm*initialSteps);
for(int i=0;i<768;i++)
{
if((view.z<0&&world_pos.z<min_z)||(view.z>0&&world_pos.z>max_z)||distanceKm>maxCloudDistanceKm)break;
distanceKm+=stepKm;
float fade=1.0;
if(consistent_steps)
{
uint odd=typed_mod((steps-in_step),2);
float fade_up=saturate((rangeKm-distanceKm)/oddRangeKm);
fade=(odd!=0)?fade_up:1.0;
if(in_step++==steps)
{
stepKm*=2.0;
c++;
uint u=(1<<c);
steps=initialSteps-uint((u&stepPos)!=0);
in_step=0;
rangeKm=distanceKm+initialSteps*stepKm;
oddRangeKm=(0.5*stepKm*initialSteps);
}

}

world_pos+=stepKm*view;
if(!consistent_steps)stepKm*=step_ratio;
vec3 cloudWorldOffsetKm=world_pos-cornerPosKm;
vec3 cloudTexCoords=cloudWorldOffsetKm*inverseScalesKm;
float fadeDistance=saturate(distanceKm/maxFadeDistanceKm);
maxDistance=max(fadeDistance,maxDistance);
if(fade>0)
{
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),cloudTexCoords,fadeDistance*0.0);

{

}


{
vec3 noise_texc=world_pos.xyz*noise3DTexcoordScale+noise3DTexcoordOffset;
vec3 noise_texc2=world_pos.xyz*noise3DTexcoordScale2+noise3DTexcoordOffset2;
vec4 noiseval=vec4(0,0,0,0);
if(noise)
{
vec4 noiseval1=density.x*textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc,1.0*fadeDistance);
vec4 noiseval2=density.x*textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc2,1.0*fadeDistance);
noiseval=noiseval1*cos(.2*3.14159*noiseval2.x)+noiseval1.wzxy*sin(.2*3.14159*noiseval2.y);
}

vec4 light=vec4(1,1,1,1);
calcDensity(cloudDensity,cloudLight,cloudTexCoords,noiseval,fractalScale,0,density,light);
density.z*=fade;
if(do_rain_effect)
{
float dm=rainEffect*fade*GetRainAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm);
moisture+=0.01*dm*light.x;
density.z=saturate(density.z+dm);
}

if(density.z>0)
{
if(noise)
{
vec3 worley_texc=(world_pos.xyz+worleyOffsetKm)*worleyTexcoordScale;
minDistance=min(max(0,fadeDistance-density.z*stepKm/maxFadeDistanceKm),minDistance);
vec4 worley=textureLod(sampler3D(smallWorleyTexture3D[1 + 6]),worley_texc,0);
float wo=4*density.y*(worley.w-0.6)*saturate(1.0/(12.0*fadeDistance));
density.z*=mix(1.0,worley.w,saturate(1.0/(12.0*fadeDistance)));
amb_dir=mix(amb_dir,worley.xyz,0.1*density.z);
}

float brightness_factor;
fade_texc.x=sqrt(fadeDistance);
vec3 volumeTexCoords=vec3(volumeTexCoordsXyC.xy,fade_texc.x);
ColourStep(res.colour,insc,meanFadeDistance,brightness_factor,lossTexture,inscTexture,skylTexture,inscatterVolumeTexture,do_godrays,godraysVolumeTexture,lightspaceScale,godraysTexCoords,lightTableTexture,density,light,distanceKm,fadeDistance,world_pos,cloudTexCoords,fade_texc,nearFarTexc,1.0,volumeTexCoords,amb_dir,BetaClouds,BetaRayleigh,BetaMie,solidDist_nearFar,noise,do_depth_mix,distScale,0,noiseval,1.0,alphaSharpness);
if(res.colour[0].a*brightness_factor<0.003)
{
for(int o=0;o<num_interp;o++)res.colour[o].a=0.0;
meanFadeDistance=fadeDistance;
break;
}

}

}

}

}

res.nearFarDepth.zw=vec2(meanFadeDistance,moisture);
#line 261 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_simple.sl"

for(int j=0;j<num_interp;j++)res.colour[j].rgb+=insc[j].rgb;
return res;
}
#line 706 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void StaticRaytrace(uvec3 pos, bool include_rain, bool depth, bool background2d, int numSteps, int num_interp, bool do_godrays, bool consistent_steps)
{
vec2 texCoords=(vec2(pos.xy)+vec2(0.5,0.5))/vec2(targetTextureSize);
vec4 clip_pos=vec4(-1.0,1.0,1.0,1.0);
clip_pos.x+=2.0*texCoords.x;
clip_pos.y-=2.0*texCoords.y;
vec3 view=normalize(mul(invViewProj[pos.z],clip_pos).xyz);
vec4 dlookup=vec4(1.0,1.0,0.000001,1.0);
if(depth)
{
dlookup=textureLod(samplerCube(depthTexture[1 + 6]),view,0);
}

vec3 worldspaceVolumeTexCoordsXyC=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(view.z)/3.1415926536),0);
RaytracePixelOutput f=RaytraceCloudsStatic(cloudDensity,cloudDensity2,precipitationVolume,noiseTexture3D,lightTableTexture,illuminationTexture,lossTexture,inscTexture,skylTexture,volumeInscatterTexture,godraysTexture,depth,dlookup,view,clip_pos,worldspaceVolumeTexCoordsXyC,background2d,include_rain,false,cloudIrRadiance1,cloudIrRadiance2,numSteps,num_interp,do_godrays,consistent_steps);
vec4 t2d=vec4(0,0,0,1.0);
vec4 c=t2d;
c.rgb*=f.colour[num_interp-1].a;
c.rgb+=f.colour[num_interp-1].rgb;
c.a=t2d.a*f.colour[num_interp-1].a;
imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*(num_interp-1))),vec4(c));
float n=float(dlookup.y>=1.0);
for(int u=0;u<num_interp-1;u++)
{
vec4 cn=t2d;
cn.rgb*=f.colour[u].a*n;
cn.a=1.0-n*(1.0-t2d.a);
cn.rgb+=f.colour[u].rgb;
cn.a*=f.colour[u].a;
imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*u)),vec4(cn));
}

if(background2d)imageStore(outputTexture3,ivec3(pos),vec4(f.nearFarDepth));
}
#line 970 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void CS_RaytraceStatic(uvec3 g, uvec3 t, bool include_rain, bool depth, bool godrays, bool consistent_steps)
{
uvec2 idx=uvec2(g.xy*4+t.xy);
uint Z=cubemapFaceIndex[g.z+t.z].x;
uvec3 pos=uvec3(targetRange[Z].xy+idx*amortizationScale.xy,Z);
uvec2 offs=typed_mod((amortizationOffset.xy+(idx.xy+idx.yx)),amortizationScale.xy);
pos.xy+=offs;
if(pos.x>=edge.x||pos.y>=edge.y)return ;
if(pos.x>=targetRange[Z].z||pos.y>=targetRange[Z].w)return ;
if(texelFetch(sampler2DArray(updateTexture[0]),ivec3(pos).xyz,0).b==0.0)return ;
StaticRaytrace(pos,include_rain,depth,true,raytraceSteps,2,godrays,consistent_steps);
}
layout(local_size_x=4, local_size_y=4, local_size_z=1) in;
void main()
{
uvec3 g = gl_WorkGroupID;
uvec3 t = gl_LocalInvocationID;
#line 1151 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
CS_RaytraceStatic(g,t,true,true,true,false);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_CS_RaytraceStaticRain_cons_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 12) uniform CloudStaticConstants
{
	mat4 invViewProj[6];
};
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};

#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
struct RaytracePixelOutput
{
	vec4 colour[2];
	vec4 nearFarDepth;
};













layout(rgba16f, binding = 4) uniform image2DArray outputTexture1;
layout(rgba16f, binding = 5) uniform image2DArray outputTexture3;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t smallWorleyTexture3D[24];
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
	uint64_t noiseTexture3D[24];
	uint64_t godraysTexture[24];
	uint64_t volumeInscatterTexture[24];
	uint64_t skylTexture[24];
	uint64_t inscTexture[24];
	uint64_t lossTexture[24];
	uint64_t depthTexture[24];
	uint64_t illuminationTexture[24];
	uint64_t lightTableTexture[24];
	uint64_t precipitationVolume[24];
	uint64_t updateTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float CalcRayleighBeta(float cos0)
{
return (1.0+cos0*cos0);
}
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float HenyeyGreenstein(float g, float cos0)
{
float g2=g*g;
float u=1.0+g2-2.0*g*cos0;
return (1.0-g2)*pow(u,-1.5)/(4.0*3.1415926536);
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
vec3 PrecalculatedInscatterFunction(vec4 inscatter_factor, float BetaRayleigh, float BetaMie, vec3 mieRayleighRatio)
{
vec3 mr=mieRayleighRatio.xyz;
vec3 BetaTotal=(BetaRayleigh+BetaMie*mr)/(vec3(1.0,1.0,1.0)+mr);
vec3 colour=BetaTotal*inscatter_factor.rgb;
return colour;
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float GetAltTexCoord(float alt_km, float minSunlightAltitudeKm, float fadeAltitudeRangeKm)
{
float diff_km=alt_km-minSunlightAltitudeKm;
float sun_alt_texc=0.5+0.5*saturate(diff_km/fadeAltitudeRangeKm);
sun_alt_texc-=0.5*saturate(-diff_km/(minSunlightAltitudeKm+1.0));
return sun_alt_texc;
}
#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float unshadowedBrightness(float Beta, vec4 lightResponse, vec3 ambientColour)
{
return max(1.0,(Beta+lightResponse.y)+ambientColour.b);
}
#line 34 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColour(uint64_t lossTexture[24], uint64_t inscatterVolumeTexture[24], vec3 volumeTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float Beta, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec3 amb_dir, vec2 fade_texc, out float brightnessFactor, out vec4 inscatter, float fade, float alphaSharpness)
{
float alt_texc=(world_pos.z/fadeAltitudeRangeKm);
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 amb_lookup=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
ambientColour=lightResponse.w*amb_lookup.rgb;
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
vec3 ambient=amb_lookup.rgb*light.w;
vec4 c;
float l=mix(0.75,1.2,density.z);
c.rgb=(light.y*lightResponse.x*(Beta+l)+lightResponse.y*light.x)*combinedLightColour+ambient.rgb;
c.a=density.z*fade;
c.a=saturate(0.3+(1.0+1.0*density.w*alphaSharpness)*(c.a-0.3));

{
vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

inscatter=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),volumeTexCoords,0);
inscatter.rgb*=inscatter.a;
#line 62 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

}

return c;
}
#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 calcColourSimple(uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t lightTableTexture[24], vec4 density, float Beta, float BetaRayleigh, float BetaMie, vec4 lightResponse, vec3 ambientColour, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, out float brightnessFactor)
{
float sun_alt_texc=GetAltTexCoord(world_pos.z,minSunlightAltitudeKm,fadeAltitudeRangeKm);
vec3 combinedLightColour=textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,3.5/4.0),0).rgb;
ambientColour=lightResponse.w*textureLod(sampler2D(lightTableTexture[1 + 9]),vec2(sun_alt_texc,2.5/4.0),0).rgb;
vec3 ambient=density.w*ambientColour.rgb;
float opacity=density.z;
vec4 c;
c.rgb=(density.y*Beta+lightResponse.y*density.x)*combinedLightColour+ambient.rgb;
c.a=opacity;
brightnessFactor=unshadowedBrightness(Beta,lightResponse,ambientColour);
float earthshadowFactr=saturate((fade_texc.x-nearFarTexc.x)/0.1);
#line 88 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"

vec3 loss=textureLod(sampler2D(lossTexture[1 + 5]),fade_texc,0).rgb;
c.rgb*=loss;
vec4 insc=textureLod(sampler2D(inscTexture[1 + 5]),fade_texc,0);
vec3 skyl=textureLod(sampler2D(skylTexture[1 + 5]),fade_texc,0).rgb;
vec3 inscatter=earthshadowFactr*PrecalculatedInscatterFunction(insc,BetaRayleigh,BetaMie,mieRayleighRatio);
c.rgb+=inscatter+skyl;
return c;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void calcDensity(uint64_t cloudDensity[24], uint64_t cloudLight[24], vec3 texCoords, vec4 noiseval, vec3 fractalScale, float mip, inout vec4 density, out vec4 light)
{
vec3 pos=texCoords.xyz+fractalScale.xyz*(noiseval.xyz);
density=textureLod(sampler3D(cloudDensity[1 + 7]),pos,mip);
light=textureLod(sampler3D(cloudLight[1 + 7]),texCoords,mip);
}
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
vec4 GetPrecipitationAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm, float mip)
{
vec3 rain_texc=cloudWorldOffsetKm;
rain_texc.xy+=rain_texc.z*rainTangent;
rain_texc*=inverseScalesKm;
vec3 pvSize;
ivec3 ivprecipitationVolume = textureSize(sampler3D(precipitationVolume[0]),0);
pvSize.x = ivprecipitationVolume.x;pvSize.y = ivprecipitationVolume.y;pvSize.z = ivprecipitationVolume.z;;
uint z_texel=uint(rain_texc.z*pvSize.z);
rain_texc.z=(float(z_texel)+0.5)/pvSize.z;
return textureLod(sampler3D(precipitationVolume[1 + 7]),rain_texc,mip);
}
#line 120 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
float GetRainAtOffsetKm(uint64_t precipitationVolume[24], vec3 cloudWorldOffsetKm, vec3 inverseScalesKm)
{
vec4 rain_lookup=GetPrecipitationAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm,0.0);
return rain_lookup.x*rain_lookup.w*saturate((20.0*rain_lookup.y-cloudWorldOffsetKm.z)/2.0);
}
#line 146 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
void ColourStep(inout vec4 colour[2], inout vec4 insc[2], inout float meanFadeDistance, out float brightness_factor, uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], bool godrays, uint64_t godraysVolumeTexture[24], float godraysScale, vec3 godraysTexCoords, uint64_t lightTableTexture[24], vec4 density, vec4 light, float distanceKm, float fadeDistance, vec3 world_pos, vec3 cloudTexCoords, vec2 fade_texc, vec2 nearFarTexc, float cosine, vec3 volumeTexCoords, vec3 amb_dir, float BetaClouds, float BetaRayleigh, float BetaMie, float solidDist_nearFar[2], bool noise, bool do_depth_mix, float distScale, int idx, vec4 noiseval, float fade, float alphaSharpness)
{
density.z*=saturate(distanceKm/0.24);
vec4 clr[2];
vec4 inscatter=vec4(0,0,0,0);
brightness_factor=1.0;
if(noise)clr[2-1]=calcColour(lossTexture,inscatterVolumeTexture,volumeTexCoords,lightTableTexture,density,light,BetaClouds,lightResponse,ambientColour,world_pos,cloudTexCoords,amb_dir,fade_texc,brightness_factor,inscatter,fade,alphaSharpness);else
clr[2-1]=calcColourSimple(lossTexture,inscTexture,skylTexture,lightTableTexture,vec4(light.xyw,density.z),BetaClouds,BetaRayleigh,BetaMie,lightResponse,ambientColour,world_pos,cloudTexCoords,fade_texc,nearFarTexc,brightness_factor);
clr[2-1].a*=cosine*cosine;
meanFadeDistance=mix(min(fadeDistance,meanFadeDistance),meanFadeDistance,(1.0-.4*density.z));
godraysTexCoords.z=distanceKm*godraysScale;
float gr_mult=1.0;
if(godrays)gr_mult=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),godraysTexCoords,0).x;
for(int i=0;i<2;i++)
{
clr[i]=clr[2-1];
if(do_depth_mix)
{
float m=saturate((solidDist_nearFar[i]-fadeDistance)/distScale);
clr[i].a*=m;
}

colour[i].rgb+=(clr[i].rgb)*clr[i].a*(colour[i].a);
insc[i].rgb+=gr_mult*inscatter.rgb*clr[i].a*(colour[i].a);
colour[i].a*=(1.0-clr[i].a);
}

}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_simple.sl"
RaytracePixelOutput RaytraceCloudsStatic(uint64_t cloudDensity[24], uint64_t cloudLight[24], uint64_t precipitationVolume[24], uint64_t noiseTexture3D[24], uint64_t lightTableTexture[24], uint64_t illuminationTexture[24], uint64_t lossTexture[24], uint64_t inscTexture[24], uint64_t skylTexture[24], uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], bool do_depth_mix, vec4 dlookup, vec3 view, vec4 clip_pos, vec3 volumeTexCoordsXyC, bool noise, bool do_rain_effect, bool do_rainbow, vec3 cloudIrRadiance1, vec3 cloudIrRadiance2, int numSteps, int num_interp, bool do_godrays, bool consistent_steps)
{
RaytracePixelOutput res;
vec4 insc[2];
for(int ii=0;ii<num_interp;ii++)
{
res.colour[ii]=vec4(0,0,0,1.0);
insc[ii]=vec4(0,0,0,0);
}

res.nearFarDepth=dlookup;
float s=saturate((directionToSun.z+0.2)/0.01);
vec3 lightDirection=mix(directionToMoon,directionToSun,s);
float cos0=dot(lightDirection.xyz,view.xyz);
float sine=view.z;
float min_z=cornerPosKm.z-(fractalScale.z*1.5)/inverseScalesKm.z;
float max_z=cornerPosKm.z+(1.0+fractalScale.z*1.5)/inverseScalesKm.z;
vec3 godraysTexCoords=vec3(0,0,0);
float lightspaceScale=1.0;
if(do_godrays)
{
vec3 lightspaceView=(mul(worldToScatteringVolumeMatrix,vec4(view,1.0)).xyz);
lightspaceScale=length(lightspaceView);
godraysTexCoords=vec3(fract(atan(lightspaceView.x,lightspaceView.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceView.z/lightspaceScale)*2.0/3.1415926536,0);
}

float solidDist_nearFar[2];
vec2 nfd=(dlookup.yx)+100.0*step(vec2(1.0,1.0),dlookup.yx);
float n=nfd.x;
float f=nfd.y;
solidDist_nearFar[0]=n;
solidDist_nearFar[num_interp-1]=f;
for(int l=1;l<num_interp-1;l++)
{
float interp=float(l)/float(num_interp-1);
solidDist_nearFar[l]=mix(n,f,interp);
}

vec2 fade_texc=vec2(0.0,0.5*(1.0-sine));
vec2 illum_texc=vec2(atan(view.x,view.y)/(3.1415926536*2.0),fade_texc.y);
vec4 illum_lookup=textureLod(sampler2D(illuminationTexture[1 + 3]),illum_texc,0);
vec2 nearFarTexc=vec2(0,1.0);
float meanFadeDistance=1.0;
float minDistance=1.0;
float maxDistance=0.0;
float BetaClouds=lightResponse.x*HenyeyGreenstein(cloudEccentricity,cos0);
float BetaRayleigh=CalcRayleighBeta(cos0);
float BetaMie=HenyeyGreenstein(hazeEccentricity,cos0);
float moisture=0.0;
vec3 world_pos=viewPosKm;
view.xyz+=vec3(0.00001,0.00001,0.00001);
ivec3 c_offset=ivec3(2.0*step(vec3(0,0,0),view.xyz)-vec3(1,1,1));
ivec3 start_c_offset=-c_offset;
start_c_offset=ivec3(max(start_c_offset.x,0),max(start_c_offset.y,0),max(start_c_offset.z,0));
vec3 viewScaled=view/scaleOfGridCoordsKm;
viewScaled=normalize(viewScaled);
vec3 offset_vec=vec3(0,0,0);
float maxDistKm=maxCloudDistanceKm;
float K=log(maxDistKm);
float step_ratio=1.0+K/float(numSteps);

{
float a=1.0/(saturate(view.z)+0.00001);
offset_vec+=max(0.0,min_z-world_pos.z)*vec3(view.x*a,view.y*a,1.0);
}


{
float a=1.0/(saturate(-view.z)+0.00001);
offset_vec+=max(0.0,world_pos.z-max_z)*vec3(view.x*a,view.y*a,-1.0);
}

vec3 halfway=0.5*(lightDirection-view);
world_pos+=offset_vec;
float distanceKm=length(offset_vec);
float distScale=0.6/maxFadeDistanceKm;
bool found=false;
float stepKm=K*(1.2+distanceKm)/float(numSteps);
vec3 amb_dir=view;
uint steps=initialSteps-uint((1&stepPos)!=0);
uint in_step=0,c=0;
float rangeKm=initialSteps*stepKm;
float oddRangeKm=(0.5*stepKm*initialSteps);
for(int i=0;i<768;i++)
{
if((view.z<0&&world_pos.z<min_z)||(view.z>0&&world_pos.z>max_z)||distanceKm>maxCloudDistanceKm)break;
distanceKm+=stepKm;
float fade=1.0;
if(consistent_steps)
{
uint odd=typed_mod((steps-in_step),2);
float fade_up=saturate((rangeKm-distanceKm)/oddRangeKm);
fade=(odd!=0)?fade_up:1.0;
if(in_step++==steps)
{
stepKm*=2.0;
c++;
uint u=(1<<c);
steps=initialSteps-uint((u&stepPos)!=0);
in_step=0;
rangeKm=distanceKm+initialSteps*stepKm;
oddRangeKm=(0.5*stepKm*initialSteps);
}

}

world_pos+=stepKm*view;
if(!consistent_steps)stepKm*=step_ratio;
vec3 cloudWorldOffsetKm=world_pos-cornerPosKm;
vec3 cloudTexCoords=cloudWorldOffsetKm*inverseScalesKm;
float fadeDistance=saturate(distanceKm/maxFadeDistanceKm);
maxDistance=max(fadeDistance,maxDistance);
if(fade>0)
{
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),cloudTexCoords,fadeDistance*0.0);

{

}


{
vec3 noise_texc=world_pos.xyz*noise3DTexcoordScale+noise3DTexcoordOffset;
vec3 noise_texc2=world_pos.xyz*noise3DTexcoordScale2+noise3DTexcoordOffset2;
vec4 noiseval=vec4(0,0,0,0);
if(noise)
{
vec4 noiseval1=density.x*textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc,1.0*fadeDistance);
vec4 noiseval2=density.x*textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc2,1.0*fadeDistance);
noiseval=noiseval1*cos(.2*3.14159*noiseval2.x)+noiseval1.wzxy*sin(.2*3.14159*noiseval2.y);
}

vec4 light=vec4(1,1,1,1);
calcDensity(cloudDensity,cloudLight,cloudTexCoords,noiseval,fractalScale,0,density,light);
density.z*=fade;
if(do_rain_effect)
{
float dm=rainEffect*fade*GetRainAtOffsetKm(precipitationVolume,cloudWorldOffsetKm,inverseScalesKm);
moisture+=0.01*dm*light.x;
density.z=saturate(density.z+dm);
}

if(density.z>0)
{
if(noise)
{
vec3 worley_texc=(world_pos.xyz+worleyOffsetKm)*worleyTexcoordScale;
minDistance=min(max(0,fadeDistance-density.z*stepKm/maxFadeDistanceKm),minDistance);
vec4 worley=textureLod(sampler3D(smallWorleyTexture3D[1 + 6]),worley_texc,0);
float wo=4*density.y*(worley.w-0.6)*saturate(1.0/(12.0*fadeDistance));
density.z*=mix(1.0,worley.w,saturate(1.0/(12.0*fadeDistance)));
amb_dir=mix(amb_dir,worley.xyz,0.1*density.z);
}

float brightness_factor;
fade_texc.x=sqrt(fadeDistance);
vec3 volumeTexCoords=vec3(volumeTexCoordsXyC.xy,fade_texc.x);
ColourStep(res.colour,insc,meanFadeDistance,brightness_factor,lossTexture,inscTexture,skylTexture,inscatterVolumeTexture,do_godrays,godraysVolumeTexture,lightspaceScale,godraysTexCoords,lightTableTexture,density,light,distanceKm,fadeDistance,world_pos,cloudTexCoords,fade_texc,nearFarTexc,1.0,volumeTexCoords,amb_dir,BetaClouds,BetaRayleigh,BetaMie,solidDist_nearFar,noise,do_depth_mix,distScale,0,noiseval,1.0,alphaSharpness);
if(res.colour[0].a*brightness_factor<0.003)
{
for(int o=0;o<num_interp;o++)res.colour[o].a=0.0;
meanFadeDistance=fadeDistance;
break;
}

}

}

}

}

res.nearFarDepth.zw=vec2(meanFadeDistance,moisture);
#line 261 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_simple.sl"

for(int j=0;j<num_interp;j++)res.colour[j].rgb+=insc[j].rgb;
return res;
}
#line 706 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void StaticRaytrace(uvec3 pos, bool include_rain, bool depth, bool background2d, int numSteps, int num_interp, bool do_godrays, bool consistent_steps)
{
vec2 texCoords=(vec2(pos.xy)+vec2(0.5,0.5))/vec2(targetTextureSize);
vec4 clip_pos=vec4(-1.0,1.0,1.0,1.0);
clip_pos.x+=2.0*texCoords.x;
clip_pos.y-=2.0*texCoords.y;
vec3 view=normalize(mul(invViewProj[pos.z],clip_pos).xyz);
vec4 dlookup=vec4(1.0,1.0,0.000001,1.0);
if(depth)
{
dlookup=textureLod(samplerCube(depthTexture[1 + 6]),view,0);
}

vec3 worldspaceVolumeTexCoordsXyC=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(view.z)/3.1415926536),0);
RaytracePixelOutput f=RaytraceCloudsStatic(cloudDensity,cloudDensity2,precipitationVolume,noiseTexture3D,lightTableTexture,illuminationTexture,lossTexture,inscTexture,skylTexture,volumeInscatterTexture,godraysTexture,depth,dlookup,view,clip_pos,worldspaceVolumeTexCoordsXyC,background2d,include_rain,false,cloudIrRadiance1,cloudIrRadiance2,numSteps,num_interp,do_godrays,consistent_steps);
vec4 t2d=vec4(0,0,0,1.0);
vec4 c=t2d;
c.rgb*=f.colour[num_interp-1].a;
c.rgb+=f.colour[num_interp-1].rgb;
c.a=t2d.a*f.colour[num_interp-1].a;
imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*(num_interp-1))),vec4(c));
float n=float(dlookup.y>=1.0);
for(int u=0;u<num_interp-1;u++)
{
vec4 cn=t2d;
cn.rgb*=f.colour[u].a*n;
cn.a=1.0-n*(1.0-t2d.a);
cn.rgb+=f.colour[u].rgb;
cn.a*=f.colour[u].a;
imageStore(outputTexture1,ivec3(pos+uvec3(0,0,6*u)),vec4(cn));
}

if(background2d)imageStore(outputTexture3,ivec3(pos),vec4(f.nearFarDepth));
}
#line 970 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
void CS_RaytraceStatic(uvec3 g, uvec3 t, bool include_rain, bool depth, bool godrays, bool consistent_steps)
{
uvec2 idx=uvec2(g.xy*4+t.xy);
uint Z=cubemapFaceIndex[g.z+t.z].x;
uvec3 pos=uvec3(targetRange[Z].xy+idx*amortizationScale.xy,Z);
uvec2 offs=typed_mod((amortizationOffset.xy+(idx.xy+idx.yx)),amortizationScale.xy);
pos.xy+=offs;
if(pos.x>=edge.x||pos.y>=edge.y)return ;
if(pos.x>=targetRange[Z].z||pos.y>=targetRange[Z].w)return ;
if(texelFetch(sampler2DArray(updateTexture[0]),ivec3(pos).xyz,0).b==0.0)return ;
StaticRaytrace(pos,include_rain,depth,true,raytraceSteps,2,godrays,consistent_steps);
}
layout(local_size_x=4, local_size_y=4, local_size_z=1) in;
void main()
{
uvec3 g = gl_WorkGroupID;
uvec3 t = gl_LocalInvocationID;
#line 1164 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
CS_RaytraceStatic(g,t,true,true,true,true);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_CS_Simulate_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};


layout(rgba8, binding = 1) uniform image3D outputTexture3d;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
};
layout(local_size_x=8, local_size_y=8, local_size_z=8) in;
void main()
{
uvec3 g = gl_WorkGroupID;
uvec3 t = gl_LocalInvocationID;
#line 206 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
uvec3 pos=g*8+t;
vec4 c1=texelFetch(sampler3D(cloudDensity[0]),ivec3(ivec4(pos,0)).xyz,int(ivec4(pos,0).w));
vec4 c2=texelFetch(sampler3D(cloudDensity2[0]),ivec3(ivec4(pos,0)).xyz,int(ivec4(pos,0).w));
vec4 res=mix(c1,c2,cloud_interp);
imageStore(outputTexture3d,ivec3(pos),vec4(res));
;
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_PS_AltCloudShadow.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t cloudDensity[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 220 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
float tempLength=sqrt(pow(directionToSun.x,2)+pow(directionToSun.y,2));
float angle=sinh(directionToSun.x/tempLength);
float s=sin(angle);
float c=cos(angle);
angle=tanh(directionToSun.z/tempLength);
float mscale=1.0/sin(angle);
vec2 cameraOffset=vec2(viewPosKm.xy)/150.0;
vec2 cloudOffset=vec2(0.5,0.5);
float tempx=(BlockData.texCoords.x-0.5)*0.25;
float tempy=(BlockData.texCoords.y-0.5)*mscale*0.25;
float x=((tempx*c)-(tempy*s))+0.5-cloudOffset.x;
float y=((tempx*s)+(tempy*c))+0.5-cloudOffset.y;
vec3 adjusted_texc=vec3(x,y,sampleHeight);
#line 235 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"

adjusted_texc.y=1.0-adjusted_texc.y;
#line 237 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"

vec3 shadow=saturate(3.0*textureLod(sampler3D(cloudDensity[1 + 7]),adjusted_texc,0.0).xyz-vec3(2.0,2.0,2.0));
{returnObject_vec4=vec4(1.0-shadow.z,1.0-shadow.z,1.0-shadow.z,1.0-shadow.z);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_PS_BlendedCrossSection.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};


layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 1304 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
vec2 texCoords=BlockData.texCoords;
vec3 texc=crossSectionOffset+vec3(texCoords.x,yz*texCoords.y,(1.0-yz)*texCoords.y);
int i=0;
vec3 accum=vec3(0.0,0.0,0.5);
vec2 uv=vec2(0,0);
for(i=0;i<32;i++)
{
vec4 density=textureLod(sampler3D(cloudDensity[1 + 12]),texc,0);
vec4 light=textureLod(sampler3D(cloudDensity2[1 + 12]),texc,0);
vec3 colour=light.rgb;
colour.gb+=vec2(.125,.25)*(lightResponse.z*light.z);
colour.b+=density.w;
float opacity=saturate(1000*density.z);
colour*=opacity;
accum*=1.0-opacity;
accum+=colour;
uv+=density.xy;
texc.y-=(1.0-yz)/float(32);
texc.z+=yz/float(32);
}

{returnObject_vec4=vec4(accum,0);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_PS_CloudShadow.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t cloudDensity[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 242 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
vec3 simple_texc=vec3((BlockData.texCoords.xy-vec2(0.5,0.5))*(shadowRangeKm/windowScaleKm_X),sampleHeight);
#line 261 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"

simple_texc.y=1.0-simple_texc.y;
#line 263 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"

vec3 shadow=saturate(textureLod(sampler3D(cloudDensity[1 + 7]),simple_texc,0).xyz);
{returnObject_vec4=vec4(shadow.xy,0,1.0-shadow.z);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_PS_CrossSection.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t cloudDensity[24];
};
#line 1272 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
vec4 CrossSection(vec2 texCoords, float yz)
{
vec3 texc=crossSectionOffset+vec3(0.5,0.5,0)+vec3(texCoords.x,yz*texCoords.y,(1.0-yz)*texCoords.y);
int i=0;
vec3 accum=vec3(0.0,0.5,1.0);
texc.y+=0.5*(1.0-yz)/float(32);
vec2 uv=vec2(0,0);
for(i=0;i<32;i++)
{
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),texc,0);
vec3 colour=vec3(.5,.5,.5)*(lightResponse.x*density.y+lightResponse.y*density.x);
colour.gb+=vec2(.125,.25)*(lightResponse.z*density.w);
float opacity=density.x;
colour*=opacity;
accum*=1.0-opacity;
accum+=colour;
uv+=density.xy;
texc.y-=(1.0-yz)/float(32);
texc.z+=yz/float(32);
}

return vec4(accum,1);
}
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 1299 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
{returnObject_vec4=CrossSection(BlockData.texCoords,yz);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_PS_Lightpass.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 12) uniform CloudStaticConstants
{
	mat4 invViewProj[6];
};
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};
#line 184 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 10) uniform CloudLightpassConstants
{
	vec3 sourcePosKm;
	float sourceRadiusKm;
	vec3 spectralFluxOver1e6;
	float minCosine;
	float irradianceThreshold;
	float maxRadiusKm;
	vec2 padding2;
};
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_clouds.sl"
struct FarNearPixelOutput
{
	vec4 farColour;
	vec4 nearColour;
};



layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t cloudDensity[24];
	uint64_t noiseTexture3D[24];
	uint64_t depthTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 3 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/clouds_lightpass.sl"
FarNearPixelOutput Lightpass(uint64_t cloudDensity[24], uint64_t noiseTexture3D[24], vec4 dlookup, vec3 view, vec4 clip_pos, vec3 sourcePosKm_w, float source_radius, vec3 spectralFluxOver1e6, float minCosine, float maxIlluminatedRadius, float threshold)
{
FarNearPixelOutput res;
res.farColour=vec4(0,0,0,1.0);
res.nearColour=vec4(0,0,0,1.0);
float max_spectral_flux=max(max(spectralFluxOver1e6.r,spectralFluxOver1e6.g),spectralFluxOver1e6.b);
vec3 dir_to_source=normalize(sourcePosKm_w-viewPosKm);
float cos0=dot(dir_to_source.xyz,view.xyz);
if(cos0<minCosine)return res;
float sine=view.z;
float min_z=cornerPosKm.z-(fractalScale.z*1.5)/inverseScalesKm.z;
float max_z=cornerPosKm.z+(1.0+fractalScale.z*1.5)/inverseScalesKm.z;
if(view.z<-0.1&&viewPosKm.z<cornerPosKm.z-fractalScale.z/inverseScalesKm.z)return res;
vec2 solidDist_nearFar=(dlookup.yx);
float meanFadeDistance=1.0;
vec3 world_pos=viewPosKm;
ivec3 c_offset=ivec3(sign(view.x),sign(view.y),sign(view.z));
ivec3 start_c_offset=-c_offset;
start_c_offset=ivec3(max(start_c_offset.x,0),max(start_c_offset.y,0),max(start_c_offset.z,0));
vec3 viewScaled=view/scaleOfGridCoordsKm;
viewScaled=normalize(viewScaled);
vec3 offset_vec=vec3(0,0,0);
if(world_pos.z<min_z)
{
float a=1.0/(view.z+0.00001);
offset_vec=(min_z-world_pos.z)*vec3(view.x*a,view.y*a,1.0);
}

if(view.z<0&&world_pos.z>max_z)
{
float a=1.0/(-view.z+0.00001);
offset_vec=(world_pos.z-max_z)*vec3(view.x*a,view.y*a,-1.0);
}

world_pos+=offset_vec;
float viewScale=length(viewScaled*scaleOfGridCoordsKm);
vec3 startOffsetFromOrigin=viewPosKm-gridOriginPosKm;
vec3 offsetFromOrigin=world_pos-gridOriginPosKm;
vec3 p0=startOffsetFromOrigin/scaleOfGridCoordsKm;
ivec3 c0=ivec3(floor(p0)+start_c_offset);
vec3 gridScale=scaleOfGridCoordsKm;
vec3 P0=startOffsetFromOrigin/scaleOfGridCoordsKm/2.0;
ivec3 C0=c0>>1;
float distanceKm=length(offset_vec);
ivec3 c=c0;
int idx=0;
float W=halfClipSize;
const float start=0.866*0.866;
const float ends=1.0;
const float range=ends-start;
vec4 colour=vec4(0.0,0.0,0.0,1.0);
vec4 nearColour=vec4(0.0,0.0,0.0,1.0);
float lastFadeDistance=0.0;
ivec3 b=abs(c-C0*2);
for(int j=0;j<8;j++)
{
if(max(max(b.x,b.y),0)>=W)
{
c0=C0;
c+=start_c_offset;
c-=abs(c&ivec3(1,1,1));
c=c>>1;
gridScale*=2.0;
viewScale*=2.0;
if(idx==0)W*=2;
p0=P0;
P0=startOffsetFromOrigin/gridScale/2.0;
C0+=start_c_offset;
C0-=abs(C0&ivec3(1,1,1));
C0=C0>>1;
idx++;
b=abs(c-C0*2);
}
else
break;
}

for(int i=0;i<256;i++)
{
world_pos+=0.001*view;
if((view.z<0&&world_pos.z<min_z)||(view.z>0&&world_pos.z>max_z)||distanceKm>maxCloudDistanceKm)break;
offsetFromOrigin=world_pos-gridOriginPosKm;
ivec3 c1=c+c_offset;
vec3 p=offsetFromOrigin/gridScale;
vec3 p1=c1;
vec3 dp=p1-p;
vec3 D=(dp/viewScaled);
float e=min(min(D.x,D.y),D.z);
vec3 N=step(D,vec3(e,e,e));
ivec3 c_step=c_offset*ivec3(N);
float d=e*viewScale;
distanceKm+=d;
p1=p+e*viewScaled;
world_pos+=d*view;
vec3 cloudWorldOffsetKm=world_pos-cornerPosKm;
vec3 cloudTexCoords=cloudWorldOffsetKm*inverseScalesKm;
c+=c_step;
ivec3 intermediate=abs(c&ivec3(1,1,1));
float is_inter=dot(N,vec3(intermediate));
vec3 pw=abs(p1-p0);
float fade_inter=saturate((length(pw.xy)/(float(W)*(2.0-is_inter)-1.0)-start)/range);
float fade=1.0-fade_inter;
float fadeDistance=saturate(distanceKm/maxFadeDistanceKm);
b=abs(c-C0*2);
if(fade>0)
{
const float mip=0.0;
vec3 noise_texc=vec3(0.0,0.0,0.0);
vec4 noiseval=vec4(0,0,0,0);
vec4 density=textureLod(sampler3D(cloudDensity[1 + 7]),cloudTexCoords,mip);
density.z*=fade;
if(density.z>0)
{
float brightness_factor=0.0;
float cloud_density=density.z;
float cosine=dot(N,abs(view));
density.z*=cosine;
density.z*=cosine;
density.z*=saturate(distanceKm/0.24);
vec3 dist=world_pos-sourcePosKm_w;
float radius_km=max(source_radius,length(dist));
noise_texc=world_pos.xyz*noise3DTexcoordScale/2.3+noise3DTexcoordOffset;
noiseval=textureLod(sampler3D(noiseTexture3D[1 + 6]),noise_texc,3.0*fadeDistance);
float radiance=(0.3+noiseval.x)*(1.0-density.z)*100.0/(4.0*3.14159*radius_km*radius_km);
vec4 clr=vec4(spectralFluxOver1e6.rgb*radiance*density.z,density.z);
brightness_factor=max(1.0,radiance*max_spectral_flux);

{
vec4 clr_n=clr;
clr.a*=saturate((solidDist_nearFar.y-fadeDistance)/0.01);
clr_n.a*=saturate((solidDist_nearFar.x-fadeDistance)/0.01);
nearColour.rgb+=clr_n.rgb*clr_n.a*(nearColour.a);
nearColour.a*=(1.0-clr_n.a);
}

colour.rgb+=clr.rgb*clr.a*(colour.a);
meanFadeDistance=mix(meanFadeDistance,fadeDistance,colour.a*cloud_density);
colour.a*=(1.0-clr.a);
if(nearColour.a*brightness_factor<0.3)
{
colour.a=0.0;
break;
}

}

}

lastFadeDistance=fadeDistance;
if(max(max(b.x,b.y),0)>=W)
{
c0=C0;
c+=start_c_offset;
c-=abs(c&ivec3(1,1,1));
c=c>>1;
gridScale*=2.0;
viewScale*=2.0;
if(idx==0)W*=2;
p0=P0;
P0=startOffsetFromOrigin/gridScale/2.0;
C0+=start_c_offset;
C0-=abs(C0&ivec3(1,1,1));
C0=C0>>1;
idx++;
}

}

float rad_mult=saturate((cos0-minCosine)/(1.0-minCosine));
colour.rgb=max(vec3(0,0,0),(rad_mult*colour.rgb-vec3(threshold,threshold,threshold))/(1.0+threshold));
res.farColour=vec4(exposure*colour.rgb,1.0);
return res;
}
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 1017 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
#line 1020 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"

BlockData.texCoords.y=1.0-BlockData.texCoords.y;
#line 1023 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"

vec4 clip_pos=vec4(-1.0,1.0,1.0,1.0);
clip_pos.x+=2.0*BlockData.texCoords.x;
clip_pos.y-=2.0*BlockData.texCoords.y;
vec3 view=normalize(mul(invViewProj[cubemapTargetIndex],clip_pos).xyz);
vec4 dlookup=vec4(0.0,0.0,0.0,0.0);
dlookup=textureLod(samplerCube(depthTexture[1 + 4]),view,0);
;
FarNearPixelOutput f=Lightpass(cloudDensity,noiseTexture3D,dlookup,view,clip_pos,sourcePosKm,sourceRadiusKm,spectralFluxOver1e6,minCosine,maxRadiusKm,irradianceThreshold);
{returnObject_vec4=vec4(f.farColour.rgb,1);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_PS_PlacementVolume.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 1243 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
{returnObject_vec4=vec4(1.0,1.0,BlockData.texCoords.x,1.0);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_PS_RainbowLookup.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_refract_reflect.sl"
float ReflectionFresnelSchlick(float incidentAngle, float riOld, float riNew)
{
float a=abs(riNew-riOld)/(riNew+riOld);
float R0=a*a;
float c=1.0-cos(incidentAngle);
float c2=c*c;
float oneTakeCos5=c2*c2*c;
return mix(R0,1.0,oneTakeCos5);
}
#line 34 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_refract_reflect.sl"
float WaterRefractiveIndex(float wavelength)
{
return 1.339*exp((400.0-wavelength)/50000);
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_refract_reflect.sl"
vec3 WavelengthToRGB(float wavelength)
{
float normalisedWavelength=(wavelength-400.0)/300.0;
float r=cos(2.0*3.1415926536*(normalisedWavelength-(625.0-400.0)/300.0));
float g=cos(2.0*3.1415926536*(normalisedWavelength-(555.0-400.0)/300.0));
float b=cos(2.0*3.1415926536*(normalisedWavelength-(475.0-400.0)/300.0));
if(normalisedWavelength>0.5)b=0.0;else
r=0.05*cos(12.00*(normalisedWavelength-(440.0-400.0)/300.0));
if(normalisedWavelength.x<((470.0-400.0)/300.0))
{
b=cos(2.15*3.1415926536*(normalisedWavelength-(470.0-400.0)/300.0));
}

return vec3(r,g,b);
}
#line 64 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_refract_reflect.sl"
vec3 WavelengthToRGB_Weighted(float wavelength, vec3 rgb)
{
vec3 unweighted=WavelengthToRGB(wavelength);
return vec3(unweighted.r*rgb.r,unweighted.g*rgb.g,unweighted.b*rgb.b);
}
#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_refract_reflect.sl"
float GetRefractedAngle(float ri)
{
return acos(sqrt((4.0/3.0)-(4.0/(3.0*pow(ri,2)))));
}
#line 75 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_refract_reflect.sl"
float NormalizeLERPPointWithinRange(float x0, float x1, float t)
{
return (t-x0)/(x1-x0);
}
#line 80 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_refract_reflect.sl"
vec3 lerp_vec3(vec3 v0, vec3 v1, float t)
{
vec3 result;
result.x=(1-t)*v0.x+t*v1.x;
result.y=(1-t)*v0.y+t*v1.y;
result.z=(1-t)*v0.z+t*v1.z;
return result;
}
#line 90 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_refract_reflect.sl"
vec3 SpectualEffectsDueToDropletSize(float dropletDiameter)
{
vec3 _1000um=vec3(1.00,1.00,1.00)*(3.00/3.00);
vec3 _0500um=vec3(0.50,0.75,1.00)*(3.00/2.25);
vec3 _0250um=vec3(0.25,0.50,1.00)*(3.00/1.75);
vec3 _0100um=vec3(0.25,0.25,1.00)*(3.00/1.50);
vec3 _0050um=vec3(0.00,0.00,0.00)*(3.00/3.00);
if(dropletDiameter>=1.0)return _1000um;else
if(dropletDiameter>=0.50&&dropletDiameter<1.00)return lerp_vec3(_0500um,_1000um,NormalizeLERPPointWithinRange(0.50,1.00,dropletDiameter));else
if(dropletDiameter>=0.25&&dropletDiameter<0.50)return lerp_vec3(_0250um,_0500um,NormalizeLERPPointWithinRange(0.25,0.50,dropletDiameter));else
if(dropletDiameter>=0.10&&dropletDiameter<0.25)return lerp_vec3(_0100um,_0250um,NormalizeLERPPointWithinRange(0.10,0.25,dropletDiameter));else
if(dropletDiameter>=0.05&&dropletDiameter<0.10)return lerp_vec3(_0050um,_0100um,NormalizeLERPPointWithinRange(0.05,0.10,dropletDiameter));else
return vec3(0,0,0);
}
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 420 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
const float lowerPrimaryBound=(40.7/180.0*3.1415926536);
const float upperPrimaryBound=(42.4/180.0*3.1415926536);
const float lowerSecondaryBound=(50.4/180.0*3.1415926536);
const float upperSecondaryBound=(53.5/180.0*3.1415926536);
#line 425 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"

float lookupAngle=(BlockData.texCoords.y*12.8+40.7)/180.0*3.1415926536;
#line 430 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"

float dropletDiameter=dropletRadius*2.0;
float solarPower=asin(directionToSun.z);
float lunarPower=asin(directionToMoon.z)*allowLunarRainbows;
bool solarLight=false;
vec3 lightColour=vec3(0,0,0);
float lightPower=0.0;
if(rainbowDirectionOverride==0)
{
solarLight=solarPower>0;
lightColour=solarLight?sunlightColour1:saturate(dot(-directionToSun,directionToMoon))*sunlightColour2;
lightPower=solarLight?solarPower:lunarPower;
}

if(rainbowDirectionOverride==1)
{
solarLight=true;
lightColour=sunlightColour1;
lightPower=abs(solarPower);
}

if(rainbowDirectionOverride==2)
{
solarLight=false;
lightColour=sunlightColour2;
lightPower=abs(lunarPower);
}

vec3 rgb_supernumerary=vec3(0,0,0);
if(lookupAngle<=upperPrimaryBound)
{
float lookupAngleBoundNorm=NormalizeLERPPointWithinRange(lowerPrimaryBound,upperPrimaryBound,lookupAngle);
float wavelength=lookupAngleBoundNorm*300.0+400.0;
float loss=0.0;
float n=WaterRefractiveIndex(wavelength);
float beta=GetRefractedAngle(n);
loss+=ReflectionFresnelSchlick(2.0*beta-lookupAngle,1.0,n);
loss+=ReflectionFresnelSchlick(beta,n,1.0);
vec3 rgb=WavelengthToRGB_Weighted(wavelength,normalize(lightColour))*SpectualEffectsDueToDropletSize(dropletDiameter);
float power=(solarLight?1.0:0.1)*lightPower*(rgb.r+rgb.g+rgb.b)/3.0;
{returnObject_vec4=vec4(rgb*(1.0-loss),power);}
}
else
if(lookupAngle>=lowerSecondaryBound)
{
float lookupAngleBoundNorm=NormalizeLERPPointWithinRange(lowerSecondaryBound,upperSecondaryBound,lookupAngle);
float wavelength=lookupAngleBoundNorm*-300.0+700.0;
float loss=0.0;
float n=WaterRefractiveIndex(wavelength);
float beta=GetRefractedAngle(n);
loss+=ReflectionFresnelSchlick(2.0*beta-lookupAngle,1.0,n);
loss+=ReflectionFresnelSchlick(beta,n,1.0);
vec3 rgb=WavelengthToRGB_Weighted(wavelength,normalize(lightColour))*SpectualEffectsDueToDropletSize(dropletDiameter);
float power=(solarLight?1.0:0.1)*lightPower*(rgb.r+rgb.g+rgb.b)/3.0;
{returnObject_vec4=vec4(rgb*0.25*(1.0-loss),power);}
}
else
{returnObject_vec4=vec4(0,0,0,0);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_PS_Show3DNoise.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t noiseTexture3D[24];
};
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 1255 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
float z=0;
z=0.5;
vec4 lookup=textureLod(sampler3D(noiseTexture3D[1 + 11]),vec3(BlockData.texCoords,z),0);
{returnObject_vec4=vec4(0.5*(lookup.rgb+1.0),1.0);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_PS_ShowNoise.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t cloudMaskTexture[24];
};
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 1248 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
vec4 lookup=texture(sampler2D(cloudMaskTexture[1 + 6]),BlockData.texCoords.xy);
{returnObject_vec4=vec4(0.5*(lookup.rgb+1.0),1.0);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_PS_ShowShadow.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t cloudMaskTexture[24];
};
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 1266 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
vec4 lookup=textureLod(sampler2D(cloudMaskTexture[1 + 9]),BlockData.texCoords.xy,0);
{returnObject_vec4=vec4(lookup.rgb*lookup.a,1.0);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_PS_ValidCrossSection.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t lightValidityTexture[24];
};
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 1346 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
vec2 texCoords=BlockData.texCoords;
vec3 texc=crossSectionOffset+vec3(texCoords.x,yz*texCoords.y,(1.0-yz)*texCoords.y);
texc.xy+=vec2(gridCentreTexel)/vec2(windowGrid.xy)-vec2(0.5,0.5);
ivec2 idx=ivec2(texc.xy*vec2(windowGrid.xy));
idx.xy+=ivec2(windowGrid.xy);
idx.xy=typed_mod(idx.xy,ivec2(windowGrid.xy));
uint l=texelFetch(usampler2D(lightValidityTexture[0]),ivec2(idx.xy).xy,0).x;
vec4 res=vec4(float(l),0,0,0);
{returnObject_vec4=res;}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_VS_CrossSection_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/debug_constants.sl"
layout(std140, binding = 7) uniform DebugConstants
{
	mat4 debugWorldViewProj;
	vec4 rect;
	vec4 multiplier;
	vec4 quaternion;
	uint latitudes;
	uint longitudes;
	float radius;
	float sideview;
	vec4 viewport;
	vec4 debugColour;
	vec4 debugDepthToLinFadeDistParams;
	vec4 debugTanHalfFov;
	uvec4 texSize;
	uvec2 queryPos;
	float debugGamma;
	float debugDepth;
	float displayLod;
	float displayLevel;
	vec2 dc_pad1;
};
#line 145 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput VS_ScreenQuad(idOnly IN, vec4 rect)
{
posTexVertexOutput OUT;
vec2 poss[4];
poss[0]=vec2(1.0,0.0);
poss[1]=vec2(1.0,1.0);
poss[2]=vec2(0.0,0.0);
poss[3]=vec2(0.0,1.0);
vec2 pos=poss[IN.vertex_id];
OUT.hPosition=vec4(rect.xy+rect.zw*pos,0.0,1.0);
OUT.hPosition.z=0.0;
OUT.texCoords=pos;
#line 158 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

OUT.texCoords.y=1.0-OUT.texCoords.y;
#line 160 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

return OUT;
}
layout(location = 0) out Block
{
posTexVertexOutput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 1202 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
{
ioblock.BlockData=VS_ScreenQuad(IN,rect);
gl_Position=VS_ScreenQuad(IN,rect).hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_VS_CrossSection_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/debug_constants.sl"
layout(std140, binding = 7) uniform DebugConstants
{
	mat4 debugWorldViewProj;
	vec4 rect;
	vec4 multiplier;
	vec4 quaternion;
	uint latitudes;
	uint longitudes;
	float radius;
	float sideview;
	vec4 viewport;
	vec4 debugColour;
	vec4 debugDepthToLinFadeDistParams;
	vec4 debugTanHalfFov;
	uvec4 texSize;
	uvec2 queryPos;
	float debugGamma;
	float debugDepth;
	float displayLod;
	float displayLevel;
	vec2 dc_pad1;
};
#line 145 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput VS_ScreenQuad(idOnly IN, vec4 rect)
{
posTexVertexOutput OUT;
vec2 poss[4];
poss[0]=vec2(1.0,0.0);
poss[1]=vec2(1.0,1.0);
poss[2]=vec2(0.0,0.0);
poss[3]=vec2(0.0,1.0);
vec2 pos=poss[IN.vertex_id];
OUT.hPosition=vec4(rect.xy+rect.zw*pos,0.0,1.0);
OUT.hPosition.z=0.0;
OUT.texCoords=pos;
#line 158 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

OUT.texCoords.y=1.0-OUT.texCoords.y;
#line 160 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

return OUT;
}
layout(location = 0) out Block
{
posTexVertexOutput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 1202 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
{
ioblock.BlockData=VS_ScreenQuad(IN,rect);
gl_Position=VS_ScreenQuad(IN,rect).hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_VS_PlacementVolume_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 12) uniform CloudStaticConstants
{
	mat4 invViewProj[6];
};
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
layout(location = 0) out Block
{
posTexVertexOutput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 1207 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
posTexVertexOutput OUT;
vec2 poss[4];
poss[0]=vec2(0.0,0.0);
poss[1]=vec2(1.0,0.0);
poss[2]=vec2(1.0,1.0);
poss[3]=vec2(0.0,1.0);
vec3 pos=vec3(0,0,0);
int odd=int(typed_mod(IN.vertex_id,uint(2)));
if(IN.vertex_id<8)
{
pos.z=0.0;
uint j=(uint(IN.vertex_id)/2+odd);
pos.xy=poss[typed_mod(j,4)];
}
else
if(IN.vertex_id<16)
{
pos.z=1.0;
uint i=uint(IN.vertex_id)-8;
uint j=(i/2+odd);
pos.xy=poss[typed_mod(j,4)];
}
else

{
uint i=uint(IN.vertex_id)-16;
uint j=i/2;
pos.z=float(typed_mod(i,2));
pos.xy=poss[typed_mod(j,4)];
}

OUT.hPosition=mul(invViewProj[cubemapTargetIndex],vec4(pos,1.0));
OUT.texCoords=vec2(pos.z,0);
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_VS_PlacementVolume_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 12) uniform CloudStaticConstants
{
	mat4 invViewProj[6];
};
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
layout(location = 0) out Block
{
posTexVertexOutput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 1207 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/clouds.sfx"
posTexVertexOutput OUT;
vec2 poss[4];
poss[0]=vec2(0.0,0.0);
poss[1]=vec2(1.0,0.0);
poss[2]=vec2(1.0,1.0);
poss[3]=vec2(0.0,1.0);
vec3 pos=vec3(0,0,0);
int odd=int(typed_mod(IN.vertex_id,uint(2)));
if(IN.vertex_id<8)
{
pos.z=0.0;
uint j=(uint(IN.vertex_id)/2+odd);
pos.xy=poss[typed_mod(j,4)];
}
else
if(IN.vertex_id<16)
{
pos.z=1.0;
uint i=uint(IN.vertex_id)-8;
uint j=(i/2+odd);
pos.xy=poss[typed_mod(j,4)];
}
else

{
uint i=uint(IN.vertex_id)-16;
uint j=i/2;
pos.z=float(typed_mod(i,2));
pos.xy=poss[typed_mod(j,4)];
}

OUT.hPosition=mul(invViewProj[cubemapTargetIndex],vec4(pos,1.0));
OUT.texCoords=vec2(pos.z,0);
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_VS_SimpleFullscreen_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 119 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput SimpleFullscreen(idOnly IN)
{
posTexVertexOutput OUT;
vec2 poss[4];
poss[0]=vec2(1.0,-1.0);
poss[1]=vec2(1.0,1.0);
poss[2]=vec2(-1.0,-1.0);
poss[3]=vec2(-1.0,1.0);
vec2 pos=poss[IN.vertex_id];
OUT.hPosition=vec4(pos,0.0,1.0);
OUT.hPosition.z=0.0;
OUT.texCoords=0.5*(vec2(1.0,1.0)+vec2(pos.x,-pos.y));
#line 132 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

OUT.texCoords.y=1.0-OUT.texCoords.y;
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

return OUT;
}
layout(location = 0) out Block
{
posTexVertexOutput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput pt=SimpleFullscreen(IN);
{
ioblock.BlockData=pt;
gl_Position=pt.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_VS_SimpleFullscreen_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 119 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput SimpleFullscreen(idOnly IN)
{
posTexVertexOutput OUT;
vec2 poss[4];
poss[0]=vec2(1.0,-1.0);
poss[1]=vec2(1.0,1.0);
poss[2]=vec2(-1.0,-1.0);
poss[3]=vec2(-1.0,1.0);
vec2 pos=poss[IN.vertex_id];
OUT.hPosition=vec4(pos,0.0,1.0);
OUT.hPosition.z=0.0;
OUT.texCoords=0.5*(vec2(1.0,1.0)+vec2(pos.x,-pos.y));
#line 132 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

OUT.texCoords.y=1.0-OUT.texCoords.y;
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

return OUT;
}
layout(location = 0) out Block
{
posTexVertexOutput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput pt=SimpleFullscreen(IN);
{
ioblock.BlockData=pt;
gl_Position=pt.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_VS_SimpleFullscreen_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 119 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput SimpleFullscreen(idOnly IN)
{
posTexVertexOutput OUT;
vec2 poss[4];
poss[0]=vec2(1.0,-1.0);
poss[1]=vec2(1.0,1.0);
poss[2]=vec2(-1.0,-1.0);
poss[3]=vec2(-1.0,1.0);
vec2 pos=poss[IN.vertex_id];
OUT.hPosition=vec4(pos,0.0,1.0);
OUT.hPosition.z=0.0;
OUT.texCoords=0.5*(vec2(1.0,1.0)+vec2(pos.x,-pos.y));
#line 132 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

OUT.texCoords.y=1.0-OUT.texCoords.y;
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

return OUT;
}
layout(location = 0) out Block
{
posTexVertexOutput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput pt=SimpleFullscreen(IN);
{
ioblock.BlockData=pt;
gl_Position=pt.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/clouds_VS_SimpleFullscreen_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 119 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput SimpleFullscreen(idOnly IN)
{
posTexVertexOutput OUT;
vec2 poss[4];
poss[0]=vec2(1.0,-1.0);
poss[1]=vec2(1.0,1.0);
poss[2]=vec2(-1.0,-1.0);
poss[3]=vec2(-1.0,1.0);
vec2 pos=poss[IN.vertex_id];
OUT.hPosition=vec4(pos,0.0,1.0);
OUT.hPosition.z=0.0;
OUT.texCoords=0.5*(vec2(1.0,1.0)+vec2(pos.x,-pos.y));
#line 132 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

OUT.texCoords.y=1.0-OUT.texCoords.y;
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

return OUT;
}
layout(location = 0) out Block
{
posTexVertexOutput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput pt=SimpleFullscreen(IN);
{
ioblock.BlockData=pt;
gl_Position=pt.hPosition;
}
}