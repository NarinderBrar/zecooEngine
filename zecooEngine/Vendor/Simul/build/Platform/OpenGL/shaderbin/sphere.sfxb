#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/sphere_DebugPS.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct v2f
{
	vec4 hPosition;
	vec4 colour;
	vec2 texCoords;
};
layout(location = 0) in Block
{
v2f BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
v2f BlockData=ioblock.BlockData;
//#line 1374 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 c=BlockData.colour;
{returnObject_vec4=c;}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/sphere_FillPS.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct v2f
{
	vec4 hPosition;
	vec4 colour;
	vec2 texCoords;
};
layout(location = 0) in Block
{
v2f BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
v2f BlockData=ioblock.BlockData;
//#line 1380 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 c=BlockData.colour;
c.rgb*=BlockData.colour.a;
{returnObject_vec4=c;}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/sphere_PS_DrawChequeredQuadOnSphere.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct v2f
{
	vec4 hPosition;
	vec4 colour;
	vec2 texCoords;
};
//#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
//#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
//#line 54 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
//#line 58 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
//#line 62 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
//#line 66 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
//#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
//#line 74 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
layout(location = 0) in Block
{
v2f BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
v2f BlockData=ioblock.BlockData;
//#line 1387 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 c=BlockData.colour;
vec2 p=BlockData.texCoords*512.0;
uvec2 u2=uvec2(p);
float highlight=float(typed_mod((u2.x+u2.y),2));
c.a*=highlight;
{returnObject_vec4=c;}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/sphere_PS_DrawTextureOnSphere.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct posTexColVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
	vec4 colour;
};
layout(std140, binding = 7) uniform SphereConstants
{
	mat4 debugWorldViewProj;
	vec4 rect;
	vec4 multiplier;
	vec4 quaternion;
	vec4 quaternion2;
	uint latitudes;
	uint longitudes;
	float radius;
	float sideview;
	vec4 debugColour;
	vec3 debugViewDir;
	int slices;
	vec2 texcOffset;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageTexture[24];
};
layout(location = 0) in Block
{
posTexColVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexColVertexOutput BlockData=ioblock.BlockData;
//#line 1365 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 texc=BlockData.texCoords.xy;
texc.y=1.0-texc.y;
vec4 res=BlockData.colour*multiplier*textureLod(sampler2D(imageTexture[1 + 11]),texc.xy,0);
{returnObject_vec4=res;}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/sphere_VS_DrawArcOnSphere_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct idOnly
{
	flat uint vertex_id;
};
layout(std140, binding = 7) uniform SphereConstants
{
	mat4 debugWorldViewProj;
	vec4 rect;
	vec4 multiplier;
	vec4 quaternion;
	vec4 quaternion2;
	uint latitudes;
	uint longitudes;
	float radius;
	float sideview;
	vec4 debugColour;
	vec3 debugViewDir;
	int slices;
	vec2 texcOffset;
};
struct v2f
{
	vec4 hPosition;
	vec4 colour;
	vec2 texCoords;
};
//#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
//#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
//#line 29 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
//#line 31 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
//#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
//#line 33 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
//#line 880 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_conj(vec4 q)
{
return vec4(-q.x,-q.y,-q.z,q.w);
}
//#line 897 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_mult(vec4 q1, vec4 q2)
{
vec4 qr;
qr.w=(q1.w*q2.w)-(q1.x*q2.x)-(q1.y*q2.y)-(q1.z*q2.z);
qr.x=(q1.w*q2.x)+(q1.x*q2.w)+(q1.y*q2.z)-(q1.z*q2.y);
qr.y=(q1.w*q2.y)-(q1.x*q2.z)+(q1.y*q2.w)+(q1.z*q2.x);
qr.z=(q1.w*q2.z)+(q1.x*q2.y)-(q1.y*q2.x)+(q1.z*q2.w);
return qr;
}
//#line 907 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_vec(vec4 q, vec3 v)
{
vec4 qr;
qr.w=-(q.x*v.x)-(q.y*v.y)-(q.z*v.z);
qr.x=(q.w*v.x)+(q.y*v.z)-(q.z*v.y);
qr.y=(q.w*v.y)+(q.z*v.x)-(q.x*v.z);
qr.z=(q.w*v.z)+(q.x*v.y)-(q.y*v.x);
return qr;
}
//#line 917 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 rotate_by_quaternion(vec4 quat, vec3 position)
{
vec4 qr_conj=quat_conj(quat);
vec4 q_tmp=quat_vec(quat,position);
vec4 qr=quat_mult(q_tmp,qr_conj);
return qr.xyz;
}
//#line 933 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 slerp(vec4 q1, vec4 q2, float interp)
{
vec4 Q1=normalize(q1);
vec4 Q2=normalize(q2);
float dot=Q1.x*Q2.x+Q1.y*Q2.y+Q1.z*Q2.z+Q1.w*Q2.w;
if(dot<0.0)
{
dot=-dot;
Q2.x*=-1.0;
Q2.y*=-1.0;
Q2.z*=-1.0;
Q2.w*=-1.0;
}

const float DOT_THRESHOLD=0.9995;
if(dot>DOT_THRESHOLD)
{
vec4 ret;
ret.x=Q1.x+interp*(Q2.x-Q1.x);
ret.y=Q1.y+interp*(Q2.y-Q1.y);
ret.z=Q1.z+interp*(Q2.z-Q1.z);
ret.w=Q1.w+interp*(Q2.w-Q1.w);
ret=normalize(ret);
return ret;
}

if(dot<-1.0)dot=-1.0;
if(dot>1.0)dot=1.0;
float theta_0=acos(dot);
float theta1=theta_0*(1.0-interp);
float theta2=theta_0*interp;
float s1=sin(theta1);
float s2=sin(theta2);
float ss=sin(theta_0);
vec4 ret;
ret.x=(Q1.x*s1+Q2.x*s2)/ss;
ret.y=(Q1.y*s1+Q2.y*s2)/ss;
ret.z=(Q1.z*s1+Q2.z*s2)/ss;
ret.w=(Q1.w*s1+Q2.w*s2)/ss;
ret=normalize(ret);
return ret;
}
layout(location = 0) out Block
{
v2f BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
//#line 1231 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
v2f OUT;
float interp=float(IN.vertex_id)/float(latitudes);
vec3 pos=vec3(0,0,1.0);
OUT.colour=mix(debugColour,multiplier,interp);
vec4 q=slerp(quaternion,quaternion2,interp);
pos=radius*rotate_by_quaternion(q,pos);
OUT.hPosition=mul(debugWorldViewProj,vec4(pos.xyz,1.0));
OUT.texCoords=vec2(0,0);
vec4 temp=mul(debugWorldViewProj,vec4(2.0*pos.xyz,1.0));
float tz=temp.z/temp.w;
float z=OUT.hPosition.z/OUT.hPosition.w;
if(tz<z)OUT.colour*=0;
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/sphere_VS_DrawArcOnSphere_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct idOnly
{
	flat uint vertex_id;
};
layout(std140, binding = 7) uniform SphereConstants
{
	mat4 debugWorldViewProj;
	vec4 rect;
	vec4 multiplier;
	vec4 quaternion;
	vec4 quaternion2;
	uint latitudes;
	uint longitudes;
	float radius;
	float sideview;
	vec4 debugColour;
	vec3 debugViewDir;
	int slices;
	vec2 texcOffset;
};
struct v2f
{
	vec4 hPosition;
	vec4 colour;
	vec2 texCoords;
};
//#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
//#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
//#line 29 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
//#line 31 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
//#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
//#line 33 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
//#line 880 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_conj(vec4 q)
{
return vec4(-q.x,-q.y,-q.z,q.w);
}
//#line 897 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_mult(vec4 q1, vec4 q2)
{
vec4 qr;
qr.w=(q1.w*q2.w)-(q1.x*q2.x)-(q1.y*q2.y)-(q1.z*q2.z);
qr.x=(q1.w*q2.x)+(q1.x*q2.w)+(q1.y*q2.z)-(q1.z*q2.y);
qr.y=(q1.w*q2.y)-(q1.x*q2.z)+(q1.y*q2.w)+(q1.z*q2.x);
qr.z=(q1.w*q2.z)+(q1.x*q2.y)-(q1.y*q2.x)+(q1.z*q2.w);
return qr;
}
//#line 907 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_vec(vec4 q, vec3 v)
{
vec4 qr;
qr.w=-(q.x*v.x)-(q.y*v.y)-(q.z*v.z);
qr.x=(q.w*v.x)+(q.y*v.z)-(q.z*v.y);
qr.y=(q.w*v.y)+(q.z*v.x)-(q.x*v.z);
qr.z=(q.w*v.z)+(q.x*v.y)-(q.y*v.x);
return qr;
}
//#line 917 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 rotate_by_quaternion(vec4 quat, vec3 position)
{
vec4 qr_conj=quat_conj(quat);
vec4 q_tmp=quat_vec(quat,position);
vec4 qr=quat_mult(q_tmp,qr_conj);
return qr.xyz;
}
//#line 933 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 slerp(vec4 q1, vec4 q2, float interp)
{
vec4 Q1=normalize(q1);
vec4 Q2=normalize(q2);
float dot=Q1.x*Q2.x+Q1.y*Q2.y+Q1.z*Q2.z+Q1.w*Q2.w;
if(dot<0.0)
{
dot=-dot;
Q2.x*=-1.0;
Q2.y*=-1.0;
Q2.z*=-1.0;
Q2.w*=-1.0;
}

const float DOT_THRESHOLD=0.9995;
if(dot>DOT_THRESHOLD)
{
vec4 ret;
ret.x=Q1.x+interp*(Q2.x-Q1.x);
ret.y=Q1.y+interp*(Q2.y-Q1.y);
ret.z=Q1.z+interp*(Q2.z-Q1.z);
ret.w=Q1.w+interp*(Q2.w-Q1.w);
ret=normalize(ret);
return ret;
}

if(dot<-1.0)dot=-1.0;
if(dot>1.0)dot=1.0;
float theta_0=acos(dot);
float theta1=theta_0*(1.0-interp);
float theta2=theta_0*interp;
float s1=sin(theta1);
float s2=sin(theta2);
float ss=sin(theta_0);
vec4 ret;
ret.x=(Q1.x*s1+Q2.x*s2)/ss;
ret.y=(Q1.y*s1+Q2.y*s2)/ss;
ret.z=(Q1.z*s1+Q2.z*s2)/ss;
ret.w=(Q1.w*s1+Q2.w*s2)/ss;
ret=normalize(ret);
return ret;
}
layout(location = 0) out Block
{
v2f BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
//#line 1231 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
v2f OUT;
float interp=float(IN.vertex_id)/float(latitudes);
vec3 pos=vec3(0,0,1.0);
OUT.colour=mix(debugColour,multiplier,interp);
vec4 q=slerp(quaternion,quaternion2,interp);
pos=radius*rotate_by_quaternion(q,pos);
OUT.hPosition=mul(debugWorldViewProj,vec4(pos.xyz,1.0));
OUT.texCoords=vec2(0,0);
vec4 temp=mul(debugWorldViewProj,vec4(2.0*pos.xyz,1.0));
float tz=temp.z/temp.w;
float z=OUT.hPosition.z/OUT.hPosition.w;
if(tz<z)OUT.colour*=0;
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/sphere_VS_DrawCircleOnSphere_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct idOnly
{
	flat uint vertex_id;
};
layout(std140, binding = 7) uniform SphereConstants
{
	mat4 debugWorldViewProj;
	vec4 rect;
	vec4 multiplier;
	vec4 quaternion;
	vec4 quaternion2;
	uint latitudes;
	uint longitudes;
	float radius;
	float sideview;
	vec4 debugColour;
	vec3 debugViewDir;
	int slices;
	vec2 texcOffset;
};
struct v2f
{
	vec4 hPosition;
	vec4 colour;
	vec2 texCoords;
};
//#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
//#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
//#line 29 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
//#line 31 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
//#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
//#line 33 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
//#line 880 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_conj(vec4 q)
{
return vec4(-q.x,-q.y,-q.z,q.w);
}
//#line 897 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_mult(vec4 q1, vec4 q2)
{
vec4 qr;
qr.w=(q1.w*q2.w)-(q1.x*q2.x)-(q1.y*q2.y)-(q1.z*q2.z);
qr.x=(q1.w*q2.x)+(q1.x*q2.w)+(q1.y*q2.z)-(q1.z*q2.y);
qr.y=(q1.w*q2.y)-(q1.x*q2.z)+(q1.y*q2.w)+(q1.z*q2.x);
qr.z=(q1.w*q2.z)+(q1.x*q2.y)-(q1.y*q2.x)+(q1.z*q2.w);
return qr;
}
//#line 907 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_vec(vec4 q, vec3 v)
{
vec4 qr;
qr.w=-(q.x*v.x)-(q.y*v.y)-(q.z*v.z);
qr.x=(q.w*v.x)+(q.y*v.z)-(q.z*v.y);
qr.y=(q.w*v.y)+(q.z*v.x)-(q.x*v.z);
qr.z=(q.w*v.z)+(q.x*v.y)-(q.y*v.x);
return qr;
}
//#line 917 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 rotate_by_quaternion(vec4 quat, vec3 position)
{
vec4 qr_conj=quat_conj(quat);
vec4 q_tmp=quat_vec(quat,position);
vec4 qr=quat_mult(q_tmp,qr_conj);
return qr.xyz;
}
layout(location = 0) out Block
{
v2f BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
//#line 1208 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
v2f OUT;
float angle=float(IN.vertex_id)/31.0*3.1415926536*2.0;
vec3 pos=vec3(sin(sideview)*cos(angle),sin(sideview)*sin(angle),cos(sideview));
pos=normalize(pos);
OUT.colour=debugColour;
pos=radius*rotate_by_quaternion(quaternion,pos);
OUT.hPosition=mul(debugWorldViewProj,vec4(pos.xyz,1.0));
OUT.texCoords=vec2(0,0);
vec4 temp=mul(debugWorldViewProj,vec4(2.0*pos.xyz,1.0));
float tz=temp.z/temp.w;
float z=OUT.hPosition.z/OUT.hPosition.w;
if(tz<z)OUT.colour*=0;
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/sphere_VS_DrawCircleOnSphere_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct idOnly
{
	flat uint vertex_id;
};
layout(std140, binding = 7) uniform SphereConstants
{
	mat4 debugWorldViewProj;
	vec4 rect;
	vec4 multiplier;
	vec4 quaternion;
	vec4 quaternion2;
	uint latitudes;
	uint longitudes;
	float radius;
	float sideview;
	vec4 debugColour;
	vec3 debugViewDir;
	int slices;
	vec2 texcOffset;
};
struct v2f
{
	vec4 hPosition;
	vec4 colour;
	vec2 texCoords;
};
//#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
//#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
//#line 29 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
//#line 31 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
//#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
//#line 33 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
//#line 880 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_conj(vec4 q)
{
return vec4(-q.x,-q.y,-q.z,q.w);
}
//#line 897 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_mult(vec4 q1, vec4 q2)
{
vec4 qr;
qr.w=(q1.w*q2.w)-(q1.x*q2.x)-(q1.y*q2.y)-(q1.z*q2.z);
qr.x=(q1.w*q2.x)+(q1.x*q2.w)+(q1.y*q2.z)-(q1.z*q2.y);
qr.y=(q1.w*q2.y)-(q1.x*q2.z)+(q1.y*q2.w)+(q1.z*q2.x);
qr.z=(q1.w*q2.z)+(q1.x*q2.y)-(q1.y*q2.x)+(q1.z*q2.w);
return qr;
}
//#line 907 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_vec(vec4 q, vec3 v)
{
vec4 qr;
qr.w=-(q.x*v.x)-(q.y*v.y)-(q.z*v.z);
qr.x=(q.w*v.x)+(q.y*v.z)-(q.z*v.y);
qr.y=(q.w*v.y)+(q.z*v.x)-(q.x*v.z);
qr.z=(q.w*v.z)+(q.x*v.y)-(q.y*v.x);
return qr;
}
//#line 917 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 rotate_by_quaternion(vec4 quat, vec3 position)
{
vec4 qr_conj=quat_conj(quat);
vec4 q_tmp=quat_vec(quat,position);
vec4 qr=quat_mult(q_tmp,qr_conj);
return qr.xyz;
}
layout(location = 0) out Block
{
v2f BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
//#line 1208 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
v2f OUT;
float angle=float(IN.vertex_id)/31.0*3.1415926536*2.0;
vec3 pos=vec3(sin(sideview)*cos(angle),sin(sideview)*sin(angle),cos(sideview));
pos=normalize(pos);
OUT.colour=debugColour;
pos=radius*rotate_by_quaternion(quaternion,pos);
OUT.hPosition=mul(debugWorldViewProj,vec4(pos.xyz,1.0));
OUT.texCoords=vec2(0,0);
vec4 temp=mul(debugWorldViewProj,vec4(2.0*pos.xyz,1.0));
float tz=temp.z/temp.w;
float z=OUT.hPosition.z/OUT.hPosition.w;
if(tz<z)OUT.colour*=0;
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/sphere_VS_DrawCurvedTextureOnSphere_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct idOnly
{
	flat uint vertex_id;
};
struct posTexColVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
	vec4 colour;
};
layout(std140, binding = 7) uniform SphereConstants
{
	mat4 debugWorldViewProj;
	vec4 rect;
	vec4 multiplier;
	vec4 quaternion;
	vec4 quaternion2;
	uint latitudes;
	uint longitudes;
	float radius;
	float sideview;
	vec4 debugColour;
	vec3 debugViewDir;
	int slices;
	vec2 texcOffset;
};
//#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
//#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
//#line 29 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
//#line 31 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
//#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
//#line 33 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
//#line 880 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_conj(vec4 q)
{
return vec4(-q.x,-q.y,-q.z,q.w);
}
//#line 897 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_mult(vec4 q1, vec4 q2)
{
vec4 qr;
qr.w=(q1.w*q2.w)-(q1.x*q2.x)-(q1.y*q2.y)-(q1.z*q2.z);
qr.x=(q1.w*q2.x)+(q1.x*q2.w)+(q1.y*q2.z)-(q1.z*q2.y);
qr.y=(q1.w*q2.y)-(q1.x*q2.z)+(q1.y*q2.w)+(q1.z*q2.x);
qr.z=(q1.w*q2.z)+(q1.x*q2.y)-(q1.y*q2.x)+(q1.z*q2.w);
return qr;
}
//#line 907 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_vec(vec4 q, vec3 v)
{
vec4 qr;
qr.w=-(q.x*v.x)-(q.y*v.y)-(q.z*v.z);
qr.x=(q.w*v.x)+(q.y*v.z)-(q.z*v.y);
qr.y=(q.w*v.y)+(q.z*v.x)-(q.x*v.z);
qr.z=(q.w*v.z)+(q.x*v.y)-(q.y*v.x);
return qr;
}
//#line 917 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 rotate_by_quaternion(vec4 quat, vec3 position)
{
vec4 qr_conj=quat_conj(quat);
vec4 q_tmp=quat_vec(quat,position);
vec4 qr=quat_mult(q_tmp,qr_conj);
return qr.xyz;
}
layout(location = 0) out Block
{
posTexColVertexOutput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
//#line 1308 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
const uint divisions=8;
const uint range=2;
const uint totalPosCount=(divisions+1)*(divisions+1);
float step=float(range)/float(divisions);
vec3 baseQuad[6];
baseQuad[0]=vec3(-1.0,-1.0,1.0);
baseQuad[1]=vec3(-1.0,-1.0+step,1.0);
baseQuad[2]=vec3(-1.0+step,-1.0+step,1.0);
baseQuad[3]=vec3(-1.0+step,-1.0+step,1.0);
baseQuad[4]=vec3(-1.0+step,-1.0,1.0);
baseQuad[5]=vec3(-1.0,-1.0,1.0);
vec3 poss[8*8*6];
for(uint y=0;y<divisions;y++)
{
for(uint x=0;x<divisions;x++)
{
uint cornerVertId=6*(x+divisions*y);
poss[cornerVertId+0]=baseQuad[0]+vec3(step*float(x),step*float(y),0.0);
poss[cornerVertId+1]=baseQuad[1]+vec3(step*float(x),step*float(y),0.0);
poss[cornerVertId+2]=baseQuad[2]+vec3(step*float(x),step*float(y),0.0);
poss[cornerVertId+3]=baseQuad[3]+vec3(step*float(x),step*float(y),0.0);
poss[cornerVertId+4]=baseQuad[4]+vec3(step*float(x),step*float(y),0.0);
poss[cornerVertId+5]=baseQuad[5]+vec3(step*float(x),step*float(y),0.0);
}

}

vec3 pos;
posTexColVertexOutput OUT;
uint vert=IN.vertex_id;

{
pos=poss[vert];
OUT.texCoords=pos.xy*0.5+vec2(0.5,0.5);
pos.xy*=sin(2*sideview);
pos.z=cos(2*sideview);
pos=normalize(pos);
}

pos=radius*rotate_by_quaternion(quaternion,pos);
OUT.hPosition=mul(debugWorldViewProj,vec4(pos.xyz,1.0));
vec4 temp=mul(debugWorldViewProj,vec4(2.0*pos.xyz,1.0));
float tz=temp.z/temp.w;
float z=OUT.hPosition.z/OUT.hPosition.w;
if(tz<z)OUT.colour=vec4(0,0,0,0);else
OUT.colour=vec4(1,1,1,1);
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/sphere_VS_DrawCurvedTextureOnSphere_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct idOnly
{
	flat uint vertex_id;
};
struct posTexColVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
	vec4 colour;
};
layout(std140, binding = 7) uniform SphereConstants
{
	mat4 debugWorldViewProj;
	vec4 rect;
	vec4 multiplier;
	vec4 quaternion;
	vec4 quaternion2;
	uint latitudes;
	uint longitudes;
	float radius;
	float sideview;
	vec4 debugColour;
	vec3 debugViewDir;
	int slices;
	vec2 texcOffset;
};
//#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
//#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
//#line 29 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
//#line 31 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
//#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
//#line 33 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
//#line 880 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_conj(vec4 q)
{
return vec4(-q.x,-q.y,-q.z,q.w);
}
//#line 897 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_mult(vec4 q1, vec4 q2)
{
vec4 qr;
qr.w=(q1.w*q2.w)-(q1.x*q2.x)-(q1.y*q2.y)-(q1.z*q2.z);
qr.x=(q1.w*q2.x)+(q1.x*q2.w)+(q1.y*q2.z)-(q1.z*q2.y);
qr.y=(q1.w*q2.y)-(q1.x*q2.z)+(q1.y*q2.w)+(q1.z*q2.x);
qr.z=(q1.w*q2.z)+(q1.x*q2.y)-(q1.y*q2.x)+(q1.z*q2.w);
return qr;
}
//#line 907 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_vec(vec4 q, vec3 v)
{
vec4 qr;
qr.w=-(q.x*v.x)-(q.y*v.y)-(q.z*v.z);
qr.x=(q.w*v.x)+(q.y*v.z)-(q.z*v.y);
qr.y=(q.w*v.y)+(q.z*v.x)-(q.x*v.z);
qr.z=(q.w*v.z)+(q.x*v.y)-(q.y*v.x);
return qr;
}
//#line 917 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 rotate_by_quaternion(vec4 quat, vec3 position)
{
vec4 qr_conj=quat_conj(quat);
vec4 q_tmp=quat_vec(quat,position);
vec4 qr=quat_mult(q_tmp,qr_conj);
return qr.xyz;
}
layout(location = 0) out Block
{
posTexColVertexOutput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
//#line 1308 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
const uint divisions=8;
const uint range=2;
const uint totalPosCount=(divisions+1)*(divisions+1);
float step=float(range)/float(divisions);
vec3 baseQuad[6];
baseQuad[0]=vec3(-1.0,-1.0,1.0);
baseQuad[1]=vec3(-1.0,-1.0+step,1.0);
baseQuad[2]=vec3(-1.0+step,-1.0+step,1.0);
baseQuad[3]=vec3(-1.0+step,-1.0+step,1.0);
baseQuad[4]=vec3(-1.0+step,-1.0,1.0);
baseQuad[5]=vec3(-1.0,-1.0,1.0);
vec3 poss[8*8*6];
for(uint y=0;y<divisions;y++)
{
for(uint x=0;x<divisions;x++)
{
uint cornerVertId=6*(x+divisions*y);
poss[cornerVertId+0]=baseQuad[0]+vec3(step*float(x),step*float(y),0.0);
poss[cornerVertId+1]=baseQuad[1]+vec3(step*float(x),step*float(y),0.0);
poss[cornerVertId+2]=baseQuad[2]+vec3(step*float(x),step*float(y),0.0);
poss[cornerVertId+3]=baseQuad[3]+vec3(step*float(x),step*float(y),0.0);
poss[cornerVertId+4]=baseQuad[4]+vec3(step*float(x),step*float(y),0.0);
poss[cornerVertId+5]=baseQuad[5]+vec3(step*float(x),step*float(y),0.0);
}

}

vec3 pos;
posTexColVertexOutput OUT;
uint vert=IN.vertex_id;

{
pos=poss[vert];
OUT.texCoords=pos.xy*0.5+vec2(0.5,0.5);
pos.xy*=sin(2*sideview);
pos.z=cos(2*sideview);
pos=normalize(pos);
}

pos=radius*rotate_by_quaternion(quaternion,pos);
OUT.hPosition=mul(debugWorldViewProj,vec4(pos.xyz,1.0));
vec4 temp=mul(debugWorldViewProj,vec4(2.0*pos.xyz,1.0));
float tz=temp.z/temp.w;
float z=OUT.hPosition.z/OUT.hPosition.w;
if(tz<z)OUT.colour=vec4(0,0,0,0);else
OUT.colour=vec4(1,1,1,1);
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/sphere_VS_DrawFilledCircleOnSphere_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct idOnly
{
	flat uint vertex_id;
};
layout(std140, binding = 7) uniform SphereConstants
{
	mat4 debugWorldViewProj;
	vec4 rect;
	vec4 multiplier;
	vec4 quaternion;
	vec4 quaternion2;
	uint latitudes;
	uint longitudes;
	float radius;
	float sideview;
	vec4 debugColour;
	vec3 debugViewDir;
	int slices;
	vec2 texcOffset;
};
struct v2f
{
	vec4 hPosition;
	vec4 colour;
	vec2 texCoords;
};
//#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
//#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
//#line 29 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
//#line 31 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
//#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
//#line 33 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
//#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
//#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
//#line 54 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
//#line 58 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
//#line 62 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
//#line 66 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
//#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
//#line 74 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
//#line 880 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_conj(vec4 q)
{
return vec4(-q.x,-q.y,-q.z,q.w);
}
//#line 897 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_mult(vec4 q1, vec4 q2)
{
vec4 qr;
qr.w=(q1.w*q2.w)-(q1.x*q2.x)-(q1.y*q2.y)-(q1.z*q2.z);
qr.x=(q1.w*q2.x)+(q1.x*q2.w)+(q1.y*q2.z)-(q1.z*q2.y);
qr.y=(q1.w*q2.y)-(q1.x*q2.z)+(q1.y*q2.w)+(q1.z*q2.x);
qr.z=(q1.w*q2.z)+(q1.x*q2.y)-(q1.y*q2.x)+(q1.z*q2.w);
return qr;
}
//#line 907 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_vec(vec4 q, vec3 v)
{
vec4 qr;
qr.w=-(q.x*v.x)-(q.y*v.y)-(q.z*v.z);
qr.x=(q.w*v.x)+(q.y*v.z)-(q.z*v.y);
qr.y=(q.w*v.y)+(q.z*v.x)-(q.x*v.z);
qr.z=(q.w*v.z)+(q.x*v.y)-(q.y*v.x);
return qr;
}
//#line 917 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 rotate_by_quaternion(vec4 quat, vec3 position)
{
vec4 qr_conj=quat_conj(quat);
vec4 q_tmp=quat_vec(quat,position);
vec4 qr=quat_mult(q_tmp,qr_conj);
return qr.xyz;
}
layout(location = 0) out Block
{
v2f BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
//#line 1251 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
v2f OUT;
float angle=float(IN.vertex_id/2)/31.0*3.1415926536*2.0;
float mult=float(typed_mod(IN.vertex_id,2));
vec3 pos=vec3(mult*sideview*cos(angle),mult*sideview*sin(angle),1.0);
pos=normalize(pos);
OUT.colour=multiplier;
pos=radius*rotate_by_quaternion(quaternion,pos);
OUT.hPosition=mul(debugWorldViewProj,vec4(pos.xyz,1.0));
OUT.texCoords=vec2(0,0);
vec4 temp=mul(debugWorldViewProj,vec4(2.0*pos.xyz,1.0));
float tz=temp.z/temp.w;
float z=OUT.hPosition.z/OUT.hPosition.w;
if(tz<z)OUT.colour*=0;
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/sphere_VS_DrawFilledCircleOnSphere_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct idOnly
{
	flat uint vertex_id;
};
layout(std140, binding = 7) uniform SphereConstants
{
	mat4 debugWorldViewProj;
	vec4 rect;
	vec4 multiplier;
	vec4 quaternion;
	vec4 quaternion2;
	uint latitudes;
	uint longitudes;
	float radius;
	float sideview;
	vec4 debugColour;
	vec3 debugViewDir;
	int slices;
	vec2 texcOffset;
};
struct v2f
{
	vec4 hPosition;
	vec4 colour;
	vec2 texCoords;
};
//#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
//#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
//#line 29 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
//#line 31 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
//#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
//#line 33 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
//#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
//#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
//#line 54 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
//#line 58 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
//#line 62 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
//#line 66 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
//#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
//#line 74 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
//#line 880 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_conj(vec4 q)
{
return vec4(-q.x,-q.y,-q.z,q.w);
}
//#line 897 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_mult(vec4 q1, vec4 q2)
{
vec4 qr;
qr.w=(q1.w*q2.w)-(q1.x*q2.x)-(q1.y*q2.y)-(q1.z*q2.z);
qr.x=(q1.w*q2.x)+(q1.x*q2.w)+(q1.y*q2.z)-(q1.z*q2.y);
qr.y=(q1.w*q2.y)-(q1.x*q2.z)+(q1.y*q2.w)+(q1.z*q2.x);
qr.z=(q1.w*q2.z)+(q1.x*q2.y)-(q1.y*q2.x)+(q1.z*q2.w);
return qr;
}
//#line 907 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_vec(vec4 q, vec3 v)
{
vec4 qr;
qr.w=-(q.x*v.x)-(q.y*v.y)-(q.z*v.z);
qr.x=(q.w*v.x)+(q.y*v.z)-(q.z*v.y);
qr.y=(q.w*v.y)+(q.z*v.x)-(q.x*v.z);
qr.z=(q.w*v.z)+(q.x*v.y)-(q.y*v.x);
return qr;
}
//#line 917 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 rotate_by_quaternion(vec4 quat, vec3 position)
{
vec4 qr_conj=quat_conj(quat);
vec4 q_tmp=quat_vec(quat,position);
vec4 qr=quat_mult(q_tmp,qr_conj);
return qr.xyz;
}
layout(location = 0) out Block
{
v2f BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
//#line 1251 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
v2f OUT;
float angle=float(IN.vertex_id/2)/31.0*3.1415926536*2.0;
float mult=float(typed_mod(IN.vertex_id,2));
vec3 pos=vec3(mult*sideview*cos(angle),mult*sideview*sin(angle),1.0);
pos=normalize(pos);
OUT.colour=multiplier;
pos=radius*rotate_by_quaternion(quaternion,pos);
OUT.hPosition=mul(debugWorldViewProj,vec4(pos.xyz,1.0));
OUT.texCoords=vec2(0,0);
vec4 temp=mul(debugWorldViewProj,vec4(2.0*pos.xyz,1.0));
float tz=temp.z/temp.w;
float z=OUT.hPosition.z/OUT.hPosition.w;
if(tz<z)OUT.colour*=0;
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/sphere_VS_DrawFilledQuadOnSphere_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct idOnly
{
	flat uint vertex_id;
};
layout(std140, binding = 7) uniform SphereConstants
{
	mat4 debugWorldViewProj;
	vec4 rect;
	vec4 multiplier;
	vec4 quaternion;
	vec4 quaternion2;
	uint latitudes;
	uint longitudes;
	float radius;
	float sideview;
	vec4 debugColour;
	vec3 debugViewDir;
	int slices;
	vec2 texcOffset;
};
struct v2f
{
	vec4 hPosition;
	vec4 colour;
	vec2 texCoords;
};
//#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
//#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
//#line 29 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
//#line 31 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
//#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
//#line 33 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
//#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
//#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
//#line 54 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
//#line 58 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
//#line 62 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
//#line 66 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
//#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
//#line 74 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
//#line 880 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_conj(vec4 q)
{
return vec4(-q.x,-q.y,-q.z,q.w);
}
//#line 897 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_mult(vec4 q1, vec4 q2)
{
vec4 qr;
qr.w=(q1.w*q2.w)-(q1.x*q2.x)-(q1.y*q2.y)-(q1.z*q2.z);
qr.x=(q1.w*q2.x)+(q1.x*q2.w)+(q1.y*q2.z)-(q1.z*q2.y);
qr.y=(q1.w*q2.y)-(q1.x*q2.z)+(q1.y*q2.w)+(q1.z*q2.x);
qr.z=(q1.w*q2.z)+(q1.x*q2.y)-(q1.y*q2.x)+(q1.z*q2.w);
return qr;
}
//#line 907 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_vec(vec4 q, vec3 v)
{
vec4 qr;
qr.w=-(q.x*v.x)-(q.y*v.y)-(q.z*v.z);
qr.x=(q.w*v.x)+(q.y*v.z)-(q.z*v.y);
qr.y=(q.w*v.y)+(q.z*v.x)-(q.x*v.z);
qr.z=(q.w*v.z)+(q.x*v.y)-(q.y*v.x);
return qr;
}
//#line 917 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 rotate_by_quaternion(vec4 quat, vec3 position)
{
vec4 qr_conj=quat_conj(quat);
vec4 q_tmp=quat_vec(quat,position);
vec4 qr=quat_mult(q_tmp,qr_conj);
return qr.xyz;
}
layout(location = 0) out Block
{
v2f BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
//#line 1180 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
v2f OUT;
vec3 poss[4];
poss[1]=vec3(1.0,-1.0,1.0);
poss[0]=vec3(1.0,1.0,1.0);
poss[2]=vec3(-1.0,1.0,1.0);
poss[3]=vec3(-1.0,-1.0,1.0);
vec3 pos;
uint vert=(IN.vertex_id);
pos=poss[typed_mod(vert,4)];
OUT.texCoords=pos.xy*0.5+vec2(0.5,0.5);
pos.xy*=sideview;
pos.z=1.0;
pos=normalize(pos);
OUT.colour=multiplier;
pos=radius*rotate_by_quaternion(quaternion,pos);
OUT.hPosition=mul(debugWorldViewProj,vec4(pos.xyz,1.0));
vec4 temp=mul(debugWorldViewProj,vec4(2.0*pos.xyz,1.0));
float tz=temp.z/temp.w;
float z=OUT.hPosition.z/OUT.hPosition.w;
if(tz<z)OUT.colour*=0;
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/sphere_VS_DrawFilledQuadOnSphere_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct idOnly
{
	flat uint vertex_id;
};
layout(std140, binding = 7) uniform SphereConstants
{
	mat4 debugWorldViewProj;
	vec4 rect;
	vec4 multiplier;
	vec4 quaternion;
	vec4 quaternion2;
	uint latitudes;
	uint longitudes;
	float radius;
	float sideview;
	vec4 debugColour;
	vec3 debugViewDir;
	int slices;
	vec2 texcOffset;
};
struct v2f
{
	vec4 hPosition;
	vec4 colour;
	vec2 texCoords;
};
//#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
//#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
//#line 29 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
//#line 31 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
//#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
//#line 33 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
//#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
//#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
//#line 54 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
//#line 58 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
//#line 62 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
//#line 66 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
//#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
//#line 74 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
//#line 880 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_conj(vec4 q)
{
return vec4(-q.x,-q.y,-q.z,q.w);
}
//#line 897 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_mult(vec4 q1, vec4 q2)
{
vec4 qr;
qr.w=(q1.w*q2.w)-(q1.x*q2.x)-(q1.y*q2.y)-(q1.z*q2.z);
qr.x=(q1.w*q2.x)+(q1.x*q2.w)+(q1.y*q2.z)-(q1.z*q2.y);
qr.y=(q1.w*q2.y)-(q1.x*q2.z)+(q1.y*q2.w)+(q1.z*q2.x);
qr.z=(q1.w*q2.z)+(q1.x*q2.y)-(q1.y*q2.x)+(q1.z*q2.w);
return qr;
}
//#line 907 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_vec(vec4 q, vec3 v)
{
vec4 qr;
qr.w=-(q.x*v.x)-(q.y*v.y)-(q.z*v.z);
qr.x=(q.w*v.x)+(q.y*v.z)-(q.z*v.y);
qr.y=(q.w*v.y)+(q.z*v.x)-(q.x*v.z);
qr.z=(q.w*v.z)+(q.x*v.y)-(q.y*v.x);
return qr;
}
//#line 917 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 rotate_by_quaternion(vec4 quat, vec3 position)
{
vec4 qr_conj=quat_conj(quat);
vec4 q_tmp=quat_vec(quat,position);
vec4 qr=quat_mult(q_tmp,qr_conj);
return qr.xyz;
}
layout(location = 0) out Block
{
v2f BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
//#line 1180 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
v2f OUT;
vec3 poss[4];
poss[1]=vec3(1.0,-1.0,1.0);
poss[0]=vec3(1.0,1.0,1.0);
poss[2]=vec3(-1.0,1.0,1.0);
poss[3]=vec3(-1.0,-1.0,1.0);
vec3 pos;
uint vert=(IN.vertex_id);
pos=poss[typed_mod(vert,4)];
OUT.texCoords=pos.xy*0.5+vec2(0.5,0.5);
pos.xy*=sideview;
pos.z=1.0;
pos=normalize(pos);
OUT.colour=multiplier;
pos=radius*rotate_by_quaternion(quaternion,pos);
OUT.hPosition=mul(debugWorldViewProj,vec4(pos.xyz,1.0));
vec4 temp=mul(debugWorldViewProj,vec4(2.0*pos.xyz,1.0));
float tz=temp.z/temp.w;
float z=OUT.hPosition.z/OUT.hPosition.w;
if(tz<z)OUT.colour*=0;
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/sphere_VS_DrawLatLongSphere_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct idOnly
{
	flat uint vertex_id;
};
layout(std140, binding = 7) uniform SphereConstants
{
	mat4 debugWorldViewProj;
	vec4 rect;
	vec4 multiplier;
	vec4 quaternion;
	vec4 quaternion2;
	uint latitudes;
	uint longitudes;
	float radius;
	float sideview;
	vec4 debugColour;
	vec3 debugViewDir;
	int slices;
	vec2 texcOffset;
};
struct v2f
{
	vec4 hPosition;
	vec4 colour;
	vec2 texCoords;
};
//#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
//#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
//#line 29 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
//#line 31 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
//#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
//#line 33 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
layout(location = 0) out Block
{
v2f BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
//#line 1081 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
v2f OUT;
uint vertex_id=IN.vertex_id;
vec3 pos;
if(vertex_id<(latitudes+1)*((longitudes)+1))
{
uint latitude_strip=vertex_id/(longitudes+1);
vertex_id-=latitude_strip*(longitudes+1);
uint longitude=vertex_id;
float azimuth=2.0*3.1415926536*float(longitude)/float(longitudes);
float elevation=.999*(float(latitude_strip)/float(latitudes)-0.5)*3.1415926536;
float cos_el=cos(elevation);
pos=radius*vec3(cos(azimuth)*cos_el,sin(azimuth)*cos_el,sin(elevation));
float b=(latitude_strip)==latitudes/2?1.0:0.2;
OUT.colour=multiplier*vec4(1.0,1.0,1.0,longitude>0&&longitude<(longitudes)?b:0.0);
}
else

{
vertex_id-=(latitudes+1)*(longitudes+1);
uint longitude_strip=vertex_id/(latitudes+1);
uint latitude=int(vertex_id-longitude_strip*(latitudes+1));
float azimuth=2.0*3.1415926536*float(longitude_strip)/float(longitudes);
float elevation=.999*(float(latitude)/float(latitudes)-0.5)*3.1415926536;
float cos_el=cos(elevation);
pos=radius*vec3(cos(azimuth)*cos_el,sin(azimuth)*cos_el,sin(elevation));
float b=longitude_strip==0?1.0:0.2;
OUT.colour=multiplier*vec4(1.0,1.0,1.0,latitude>0&&latitude<latitudes?b:0.0);
}

OUT.hPosition=mul(debugWorldViewProj,vec4(pos.xyz,1.0));
vec4 temp=mul(debugWorldViewProj,vec4(2.0*pos.xyz,1.0));
float tz=temp.z/temp.w;
float z=OUT.hPosition.z/OUT.hPosition.w;
OUT.texCoords=vec2(0,0);
if(tz<z)OUT.colour.a*=0;
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/sphere_VS_DrawLatLongSphere_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct idOnly
{
	flat uint vertex_id;
};
layout(std140, binding = 7) uniform SphereConstants
{
	mat4 debugWorldViewProj;
	vec4 rect;
	vec4 multiplier;
	vec4 quaternion;
	vec4 quaternion2;
	uint latitudes;
	uint longitudes;
	float radius;
	float sideview;
	vec4 debugColour;
	vec3 debugViewDir;
	int slices;
	vec2 texcOffset;
};
struct v2f
{
	vec4 hPosition;
	vec4 colour;
	vec2 texCoords;
};
//#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
//#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
//#line 29 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
//#line 31 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
//#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
//#line 33 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
layout(location = 0) out Block
{
v2f BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
//#line 1081 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
v2f OUT;
uint vertex_id=IN.vertex_id;
vec3 pos;
if(vertex_id<(latitudes+1)*((longitudes)+1))
{
uint latitude_strip=vertex_id/(longitudes+1);
vertex_id-=latitude_strip*(longitudes+1);
uint longitude=vertex_id;
float azimuth=2.0*3.1415926536*float(longitude)/float(longitudes);
float elevation=.999*(float(latitude_strip)/float(latitudes)-0.5)*3.1415926536;
float cos_el=cos(elevation);
pos=radius*vec3(cos(azimuth)*cos_el,sin(azimuth)*cos_el,sin(elevation));
float b=(latitude_strip)==latitudes/2?1.0:0.2;
OUT.colour=multiplier*vec4(1.0,1.0,1.0,longitude>0&&longitude<(longitudes)?b:0.0);
}
else

{
vertex_id-=(latitudes+1)*(longitudes+1);
uint longitude_strip=vertex_id/(latitudes+1);
uint latitude=int(vertex_id-longitude_strip*(latitudes+1));
float azimuth=2.0*3.1415926536*float(longitude_strip)/float(longitudes);
float elevation=.999*(float(latitude)/float(latitudes)-0.5)*3.1415926536;
float cos_el=cos(elevation);
pos=radius*vec3(cos(azimuth)*cos_el,sin(azimuth)*cos_el,sin(elevation));
float b=longitude_strip==0?1.0:0.2;
OUT.colour=multiplier*vec4(1.0,1.0,1.0,latitude>0&&latitude<latitudes?b:0.0);
}

OUT.hPosition=mul(debugWorldViewProj,vec4(pos.xyz,1.0));
vec4 temp=mul(debugWorldViewProj,vec4(2.0*pos.xyz,1.0));
float tz=temp.z/temp.w;
float z=OUT.hPosition.z/OUT.hPosition.w;
OUT.texCoords=vec2(0,0);
if(tz<z)OUT.colour.a*=0;
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/sphere_VS_DrawQuadOnSphere_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct idOnly
{
	flat uint vertex_id;
};
layout(std140, binding = 7) uniform SphereConstants
{
	mat4 debugWorldViewProj;
	vec4 rect;
	vec4 multiplier;
	vec4 quaternion;
	vec4 quaternion2;
	uint latitudes;
	uint longitudes;
	float radius;
	float sideview;
	vec4 debugColour;
	vec3 debugViewDir;
	int slices;
	vec2 texcOffset;
};
struct v2f
{
	vec4 hPosition;
	vec4 colour;
	vec2 texCoords;
};
//#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
//#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
//#line 29 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
//#line 31 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
//#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
//#line 33 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
//#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
//#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
//#line 54 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
//#line 58 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
//#line 62 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
//#line 66 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
//#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
//#line 74 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
//#line 880 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_conj(vec4 q)
{
return vec4(-q.x,-q.y,-q.z,q.w);
}
//#line 897 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_mult(vec4 q1, vec4 q2)
{
vec4 qr;
qr.w=(q1.w*q2.w)-(q1.x*q2.x)-(q1.y*q2.y)-(q1.z*q2.z);
qr.x=(q1.w*q2.x)+(q1.x*q2.w)+(q1.y*q2.z)-(q1.z*q2.y);
qr.y=(q1.w*q2.y)-(q1.x*q2.z)+(q1.y*q2.w)+(q1.z*q2.x);
qr.z=(q1.w*q2.z)+(q1.x*q2.y)-(q1.y*q2.x)+(q1.z*q2.w);
return qr;
}
//#line 907 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_vec(vec4 q, vec3 v)
{
vec4 qr;
qr.w=-(q.x*v.x)-(q.y*v.y)-(q.z*v.z);
qr.x=(q.w*v.x)+(q.y*v.z)-(q.z*v.y);
qr.y=(q.w*v.y)+(q.z*v.x)-(q.x*v.z);
qr.z=(q.w*v.z)+(q.x*v.y)-(q.y*v.x);
return qr;
}
//#line 917 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 rotate_by_quaternion(vec4 quat, vec3 position)
{
vec4 qr_conj=quat_conj(quat);
vec4 q_tmp=quat_vec(quat,position);
vec4 qr=quat_mult(q_tmp,qr_conj);
return qr.xyz;
}
layout(location = 0) out Block
{
v2f BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
//#line 1122 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
v2f OUT;
vec3 poss[4];
poss[0]=vec3(1.0,-1.0,1.0);
poss[1]=vec3(1.0,1.0,1.0);
poss[2]=vec3(-1.0,1.0,1.0);
poss[3]=vec3(-1.0,-1.0,1.0);
vec3 pos;
if(IN.vertex_id<8)
{
uint vert=(IN.vertex_id+1)/2;
pos=poss[typed_mod(vert,4)];
pos.xy*=sideview;
pos.z=1.0;
pos=normalize(pos);
OUT.colour=debugColour;
}
else

{
uint vert=IN.vertex_id-8;
int axis=int(vert/3);
vec3 ax=vec3(axis==0,axis==1,axis==2);
pos=vec3(0,0,1.0);
if(bool(typed_mod(vert,2)))pos+=ax*sideview;
vec4 finalCol=vec4(0.0,0.0,0.0,1.0);
if(axis==0)
{
finalCol.xyz+=vec3(0.5,0.0,0.0);
}

if(axis==1)
{
finalCol.xyz+=0.75*vec3(0.0,0.5,0.0);
}

if(axis==2)
{
finalCol.xyz+=vec3(0.0,0.0,0.5);
}

OUT.colour=finalCol;
}

OUT.texCoords=vec2(0,0);
pos=radius*rotate_by_quaternion(quaternion,pos);
OUT.hPosition=mul(debugWorldViewProj,vec4(pos.xyz,1.0));
vec4 temp=mul(debugWorldViewProj,vec4(2.0*pos.xyz,1.0));
float tz=temp.z/temp.w;
float z=OUT.hPosition.z/OUT.hPosition.w;
if(tz<z)OUT.colour*=0;
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/sphere_VS_DrawQuadOnSphere_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct idOnly
{
	flat uint vertex_id;
};
layout(std140, binding = 7) uniform SphereConstants
{
	mat4 debugWorldViewProj;
	vec4 rect;
	vec4 multiplier;
	vec4 quaternion;
	vec4 quaternion2;
	uint latitudes;
	uint longitudes;
	float radius;
	float sideview;
	vec4 debugColour;
	vec3 debugViewDir;
	int slices;
	vec2 texcOffset;
};
struct v2f
{
	vec4 hPosition;
	vec4 colour;
	vec2 texCoords;
};
//#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
//#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
//#line 29 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
//#line 31 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
//#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
//#line 33 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
//#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
//#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
//#line 54 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
//#line 58 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
//#line 62 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
//#line 66 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
//#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
//#line 74 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
//#line 880 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_conj(vec4 q)
{
return vec4(-q.x,-q.y,-q.z,q.w);
}
//#line 897 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_mult(vec4 q1, vec4 q2)
{
vec4 qr;
qr.w=(q1.w*q2.w)-(q1.x*q2.x)-(q1.y*q2.y)-(q1.z*q2.z);
qr.x=(q1.w*q2.x)+(q1.x*q2.w)+(q1.y*q2.z)-(q1.z*q2.y);
qr.y=(q1.w*q2.y)-(q1.x*q2.z)+(q1.y*q2.w)+(q1.z*q2.x);
qr.z=(q1.w*q2.z)+(q1.x*q2.y)-(q1.y*q2.x)+(q1.z*q2.w);
return qr;
}
//#line 907 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_vec(vec4 q, vec3 v)
{
vec4 qr;
qr.w=-(q.x*v.x)-(q.y*v.y)-(q.z*v.z);
qr.x=(q.w*v.x)+(q.y*v.z)-(q.z*v.y);
qr.y=(q.w*v.y)+(q.z*v.x)-(q.x*v.z);
qr.z=(q.w*v.z)+(q.x*v.y)-(q.y*v.x);
return qr;
}
//#line 917 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 rotate_by_quaternion(vec4 quat, vec3 position)
{
vec4 qr_conj=quat_conj(quat);
vec4 q_tmp=quat_vec(quat,position);
vec4 qr=quat_mult(q_tmp,qr_conj);
return qr.xyz;
}
layout(location = 0) out Block
{
v2f BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
//#line 1122 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
v2f OUT;
vec3 poss[4];
poss[0]=vec3(1.0,-1.0,1.0);
poss[1]=vec3(1.0,1.0,1.0);
poss[2]=vec3(-1.0,1.0,1.0);
poss[3]=vec3(-1.0,-1.0,1.0);
vec3 pos;
if(IN.vertex_id<8)
{
uint vert=(IN.vertex_id+1)/2;
pos=poss[typed_mod(vert,4)];
pos.xy*=sideview;
pos.z=1.0;
pos=normalize(pos);
OUT.colour=debugColour;
}
else

{
uint vert=IN.vertex_id-8;
int axis=int(vert/3);
vec3 ax=vec3(axis==0,axis==1,axis==2);
pos=vec3(0,0,1.0);
if(bool(typed_mod(vert,2)))pos+=ax*sideview;
vec4 finalCol=vec4(0.0,0.0,0.0,1.0);
if(axis==0)
{
finalCol.xyz+=vec3(0.5,0.0,0.0);
}

if(axis==1)
{
finalCol.xyz+=0.75*vec3(0.0,0.5,0.0);
}

if(axis==2)
{
finalCol.xyz+=vec3(0.0,0.0,0.5);
}

OUT.colour=finalCol;
}

OUT.texCoords=vec2(0,0);
pos=radius*rotate_by_quaternion(quaternion,pos);
OUT.hPosition=mul(debugWorldViewProj,vec4(pos.xyz,1.0));
vec4 temp=mul(debugWorldViewProj,vec4(2.0*pos.xyz,1.0));
float tz=temp.z/temp.w;
float z=OUT.hPosition.z/OUT.hPosition.w;
if(tz<z)OUT.colour*=0;
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/sphere_VS_DrawTextureOnSphere_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct idOnly
{
	flat uint vertex_id;
};
struct posTexColVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
	vec4 colour;
};
layout(std140, binding = 7) uniform SphereConstants
{
	mat4 debugWorldViewProj;
	vec4 rect;
	vec4 multiplier;
	vec4 quaternion;
	vec4 quaternion2;
	uint latitudes;
	uint longitudes;
	float radius;
	float sideview;
	vec4 debugColour;
	vec3 debugViewDir;
	int slices;
	vec2 texcOffset;
};
//#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
//#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
//#line 29 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
//#line 31 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
//#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
//#line 33 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
//#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
//#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
//#line 54 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
//#line 58 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
//#line 62 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
//#line 66 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
//#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
//#line 74 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
//#line 880 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_conj(vec4 q)
{
return vec4(-q.x,-q.y,-q.z,q.w);
}
//#line 897 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_mult(vec4 q1, vec4 q2)
{
vec4 qr;
qr.w=(q1.w*q2.w)-(q1.x*q2.x)-(q1.y*q2.y)-(q1.z*q2.z);
qr.x=(q1.w*q2.x)+(q1.x*q2.w)+(q1.y*q2.z)-(q1.z*q2.y);
qr.y=(q1.w*q2.y)-(q1.x*q2.z)+(q1.y*q2.w)+(q1.z*q2.x);
qr.z=(q1.w*q2.z)+(q1.x*q2.y)-(q1.y*q2.x)+(q1.z*q2.w);
return qr;
}
//#line 907 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_vec(vec4 q, vec3 v)
{
vec4 qr;
qr.w=-(q.x*v.x)-(q.y*v.y)-(q.z*v.z);
qr.x=(q.w*v.x)+(q.y*v.z)-(q.z*v.y);
qr.y=(q.w*v.y)+(q.z*v.x)-(q.x*v.z);
qr.z=(q.w*v.z)+(q.x*v.y)-(q.y*v.x);
return qr;
}
//#line 917 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 rotate_by_quaternion(vec4 quat, vec3 position)
{
vec4 qr_conj=quat_conj(quat);
vec4 q_tmp=quat_vec(quat,position);
vec4 qr=quat_mult(q_tmp,qr_conj);
return qr.xyz;
}
layout(location = 0) out Block
{
posTexColVertexOutput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
//#line 1275 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
posTexColVertexOutput OUT;
vec3 poss[4];
poss[0]=vec3(1.0,-1.0,1.0);
poss[1]=vec3(1.0,1.0,1.0);
poss[2]=vec3(-1.0,1.0,1.0);
poss[3]=vec3(-1.0,-1.0,1.0);
vec3 pos;
uint vert=typed_mod(IN.vertex_id,4);

{
pos=poss[vert];
OUT.texCoords=pos.xy*0.5+vec2(0.5,0.5);
pos.xy*=sideview;
pos.z=1.0;
pos=normalize(pos);
}

pos=radius*rotate_by_quaternion(quaternion,pos);
OUT.hPosition=mul(debugWorldViewProj,vec4(pos.xyz,1.0));
vec4 temp=mul(debugWorldViewProj,vec4(2.0*pos.xyz,1.0));
float tz=temp.z/temp.w;
float z=OUT.hPosition.z/OUT.hPosition.w;
if(tz<z)OUT.colour=vec4(0,0,0,0);else
OUT.colour=vec4(1,1,1,1);
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/sphere_VS_DrawTextureOnSphere_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct idOnly
{
	flat uint vertex_id;
};
struct posTexColVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
	vec4 colour;
};
layout(std140, binding = 7) uniform SphereConstants
{
	mat4 debugWorldViewProj;
	vec4 rect;
	vec4 multiplier;
	vec4 quaternion;
	vec4 quaternion2;
	uint latitudes;
	uint longitudes;
	float radius;
	float sideview;
	vec4 debugColour;
	vec3 debugViewDir;
	int slices;
	vec2 texcOffset;
};
//#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
//#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
//#line 29 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
//#line 31 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
//#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
//#line 33 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
//#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
//#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
//#line 54 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
//#line 58 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
//#line 62 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
//#line 66 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
//#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
//#line 74 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
//#line 880 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_conj(vec4 q)
{
return vec4(-q.x,-q.y,-q.z,q.w);
}
//#line 897 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_mult(vec4 q1, vec4 q2)
{
vec4 qr;
qr.w=(q1.w*q2.w)-(q1.x*q2.x)-(q1.y*q2.y)-(q1.z*q2.z);
qr.x=(q1.w*q2.x)+(q1.x*q2.w)+(q1.y*q2.z)-(q1.z*q2.y);
qr.y=(q1.w*q2.y)-(q1.x*q2.z)+(q1.y*q2.w)+(q1.z*q2.x);
qr.z=(q1.w*q2.z)+(q1.x*q2.y)-(q1.y*q2.x)+(q1.z*q2.w);
return qr;
}
//#line 907 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 quat_vec(vec4 q, vec3 v)
{
vec4 qr;
qr.w=-(q.x*v.x)-(q.y*v.y)-(q.z*v.z);
qr.x=(q.w*v.x)+(q.y*v.z)-(q.z*v.y);
qr.y=(q.w*v.y)+(q.z*v.x)-(q.x*v.z);
qr.z=(q.w*v.z)+(q.x*v.y)-(q.y*v.x);
return qr;
}
//#line 917 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec3 rotate_by_quaternion(vec4 quat, vec3 position)
{
vec4 qr_conj=quat_conj(quat);
vec4 q_tmp=quat_vec(quat,position);
vec4 qr=quat_mult(q_tmp,qr_conj);
return qr.xyz;
}
layout(location = 0) out Block
{
posTexColVertexOutput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
//#line 1275 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
posTexColVertexOutput OUT;
vec3 poss[4];
poss[0]=vec3(1.0,-1.0,1.0);
poss[1]=vec3(1.0,1.0,1.0);
poss[2]=vec3(-1.0,1.0,1.0);
poss[3]=vec3(-1.0,-1.0,1.0);
vec3 pos;
uint vert=typed_mod(IN.vertex_id,4);

{
pos=poss[vert];
OUT.texCoords=pos.xy*0.5+vec2(0.5,0.5);
pos.xy*=sideview;
pos.z=1.0;
pos=normalize(pos);
}

pos=radius*rotate_by_quaternion(quaternion,pos);
OUT.hPosition=mul(debugWorldViewProj,vec4(pos.xyz,1.0));
vec4 temp=mul(debugWorldViewProj,vec4(2.0*pos.xyz,1.0));
float tz=temp.z/temp.w;
float z=OUT.hPosition.z/OUT.hPosition.w;
if(tz<z)OUT.colour=vec4(0,0,0,0);else
OUT.colour=vec4(1,1,1,1);
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/sphere_DebugPS.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct v2f
{
	vec4 hPosition;
	vec4 colour;
	vec2 texCoords;
};
layout(location = 0) in Block
{
v2f BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
v2f BlockData=ioblock.BlockData;
//#line 1374 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 c=BlockData.colour;
{returnObject_vec4=c;}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/sphere_FillPS.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct v2f
{
	vec4 hPosition;
	vec4 colour;
	vec2 texCoords;
};
layout(location = 0) in Block
{
v2f BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
v2f BlockData=ioblock.BlockData;
//#line 1380 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/sphere.sfx"
vec4 c=BlockData.colour;
c.rgb*=BlockData.colour.a;
{returnObject_vec4=c;}
}