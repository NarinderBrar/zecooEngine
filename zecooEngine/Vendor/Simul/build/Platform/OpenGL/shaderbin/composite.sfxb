#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_Debug2DVS_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/debug_constants.sl"
layout(std140, binding = 7) uniform DebugConstants
{
	mat4 debugWorldViewProj;
	vec4 rect;
	vec4 multiplier;
	vec4 quaternion;
	uint latitudes;
	uint longitudes;
	float radius;
	float sideview;
	vec4 viewport;
	vec4 debugColour;
	vec4 debugDepthToLinFadeDistParams;
	vec4 debugTanHalfFov;
	uvec4 texSize;
	uvec2 queryPos;
	float debugGamma;
	float debugDepth;
	float displayLod;
	float displayLevel;
	vec2 dc_pad1;
};
#line 145 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput VS_ScreenQuad(idOnly IN, vec4 rect)
{
posTexVertexOutput OUT;
vec2 poss[4];
poss[0]=vec2(1.0,0.0);
poss[1]=vec2(1.0,1.0);
poss[2]=vec2(0.0,0.0);
poss[3]=vec2(0.0,1.0);
vec2 pos=poss[IN.vertex_id];
OUT.hPosition=vec4(rect.xy+rect.zw*pos,0.0,1.0);
OUT.hPosition.z=0.0;
OUT.texCoords=pos;
#line 158 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

OUT.texCoords.y=1.0-OUT.texCoords.y;
#line 160 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

return OUT;
}
layout(location = 0) out Block
{
posTexVertexOutput BlockData;
} ioblock;
void main()
{
idOnly id;
id.vertex_id=gl_VertexID;
#line 163 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
{
ioblock.BlockData=VS_ScreenQuad(id,rect);
gl_Position=VS_ScreenQuad(id,rect).hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_Debug2DVS_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/debug_constants.sl"
layout(std140, binding = 7) uniform DebugConstants
{
	mat4 debugWorldViewProj;
	vec4 rect;
	vec4 multiplier;
	vec4 quaternion;
	uint latitudes;
	uint longitudes;
	float radius;
	float sideview;
	vec4 viewport;
	vec4 debugColour;
	vec4 debugDepthToLinFadeDistParams;
	vec4 debugTanHalfFov;
	uvec4 texSize;
	uvec2 queryPos;
	float debugGamma;
	float debugDepth;
	float displayLod;
	float displayLevel;
	vec2 dc_pad1;
};
#line 145 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput VS_ScreenQuad(idOnly IN, vec4 rect)
{
posTexVertexOutput OUT;
vec2 poss[4];
poss[0]=vec2(1.0,0.0);
poss[1]=vec2(1.0,1.0);
poss[2]=vec2(0.0,0.0);
poss[3]=vec2(0.0,1.0);
vec2 pos=poss[IN.vertex_id];
OUT.hPosition=vec4(rect.xy+rect.zw*pos,0.0,1.0);
OUT.hPosition.z=0.0;
OUT.texCoords=pos;
#line 158 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

OUT.texCoords.y=1.0-OUT.texCoords.y;
#line 160 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

return OUT;
}
layout(location = 0) out Block
{
posTexVertexOutput BlockData;
} ioblock;
void main()
{
idOnly id;
id.vertex_id=gl_VertexID;
#line 163 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
{
ioblock.BlockData=VS_ScreenQuad(id,rect);
gl_Position=VS_ScreenQuad(id,rect).hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_ExposureGammaPS.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageTexture[24];
};
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 210 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
vec4 c=texture(sampler2D(imageTexture[1 + 11]),BlockData.texCoords);
c.rgb*=exposure;
c.rgb=pow(c.rgb,vec3(gamma,gamma,gamma));
vec4 u=vec4(c.rgb,1.0);
{returnObject_vec4=u;}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_ExposureGammaPS_MSAA.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageTextureMS[24];
};
#line 38 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
vec4 texture_resolve(uint64_t textureMS[24], vec2 texCoords)
{
uvec2 dims;
uint numberOfSamples;
ivec2 ivtextureMS = textureSize(sampler2DMS(textureMS[0]));
dims.x = ivtextureMS.x;dims.y = ivtextureMS.y;;
ivec2 pos=ivec2(vec2(dims)*texCoords);
vec4 d=vec4(0,0,0,0);
for(uint k=0;k<numberOfSamples;k++)
{
d+=texelFetch(sampler2DMS(textureMS[0]),ivec2(pos),int(k));
}

d/=float(numberOfSamples);
return d;
}
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 220 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
vec4 c=texture_resolve(imageTextureMS,BlockData.texCoords);
c.rgb*=exposure;
c.rgb=pow(c.rgb,vec3(gamma,gamma,gamma));
vec4 u=vec4(c.rgb,1.0);
{returnObject_vec4=u;}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_GlowExposureGammaPS.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};


layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageTexture[24];
	uint64_t glowTexture[24];
};
#line 49 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 convertInt(uint64_t glowTexture[24], uvec2 location)
{
uint int_color=uint(texelFetch(usampler2D(glowTexture[0]),ivec2(ivec3(ivec2(location),0)).xy,int(ivec3(ivec2(location),0).y)).x);
vec4 color;
color.r=float(int_color>>uint(21))/2047.0f;
color.g=float((int_color>>uint(10))&uint(0x7ff))/2047.0f;
color.b=float(int_color&uint(0x0003ff))/1023.0f;
color.a=1;
color.rgb*=10.0;
return color;
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 texture_int(uint64_t glowTexture[24], vec2 texCoord)
{
uvec2 tex_dim;
ivec2 ivglowTexture = textureSize(usampler2D(glowTexture[0]),0);
tex_dim.x = ivglowTexture.x;tex_dim.y = ivglowTexture.y;;
vec2 pos1=vec2(tex_dim.x*texCoord.x-0.5,tex_dim.y*texCoord.y-0.5);
vec2 pos2=vec2(tex_dim.x*texCoord.x+0.5,tex_dim.y*texCoord.y+0.5);
uvec2 location1=uvec2(pos1);
uvec2 location2=uvec2(pos2);
vec2 l=vec2(tex_dim.x*texCoord.x,tex_dim.y*texCoord.y)-vec2(location1);
vec4 tex00=convertInt(glowTexture,location1);
vec4 tex10=convertInt(glowTexture,uvec2(location2.x,location1.y));
vec4 tex11=convertInt(glowTexture,location2);
vec4 tex01=convertInt(glowTexture,uvec2(location1.x,location2.y));
vec4 tex0=mix(tex00,tex10,l.x);
vec4 tex1=mix(tex01,tex11,l.x);
vec4 tex=mix(tex0,tex1,l.y);
return tex;
}
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 117 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
vec4 c=textureLod(sampler2D(imageTexture[1 + 11]),BlockData.texCoords,0);
vec4 glow=texture_int(glowTexture,BlockData.texCoords);
c.rgb+=glow.rgb;
c.rgb*=exposure;
c.rgb=pow(c.rgb,vec3(gamma,gamma,gamma));
vec4 u=vec4(c.rgb,1.0);
{returnObject_vec4=u;}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_GlowExposureGammaPS_MSAA.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};


layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageTextureMS[24];
	uint64_t glowTexture[24];
};
#line 49 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 convertInt(uint64_t glowTexture[24], uvec2 location)
{
uint int_color=uint(texelFetch(usampler2D(glowTexture[0]),ivec2(ivec3(ivec2(location),0)).xy,int(ivec3(ivec2(location),0).y)).x);
vec4 color;
color.r=float(int_color>>uint(21))/2047.0f;
color.g=float((int_color>>uint(10))&uint(0x7ff))/2047.0f;
color.b=float(int_color&uint(0x0003ff))/1023.0f;
color.a=1;
color.rgb*=10.0;
return color;
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 texture_int(uint64_t glowTexture[24], vec2 texCoord)
{
uvec2 tex_dim;
ivec2 ivglowTexture = textureSize(usampler2D(glowTexture[0]),0);
tex_dim.x = ivglowTexture.x;tex_dim.y = ivglowTexture.y;;
vec2 pos1=vec2(tex_dim.x*texCoord.x-0.5,tex_dim.y*texCoord.y-0.5);
vec2 pos2=vec2(tex_dim.x*texCoord.x+0.5,tex_dim.y*texCoord.y+0.5);
uvec2 location1=uvec2(pos1);
uvec2 location2=uvec2(pos2);
vec2 l=vec2(tex_dim.x*texCoord.x,tex_dim.y*texCoord.y)-vec2(location1);
vec4 tex00=convertInt(glowTexture,location1);
vec4 tex10=convertInt(glowTexture,uvec2(location2.x,location1.y));
vec4 tex11=convertInt(glowTexture,location2);
vec4 tex01=convertInt(glowTexture,uvec2(location1.x,location2.y));
vec4 tex0=mix(tex00,tex10,l.x);
vec4 tex1=mix(tex01,tex11,l.x);
vec4 tex=mix(tex0,tex1,l.y);
return tex;
}
#line 38 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
vec4 texture_resolve(uint64_t textureMS[24], vec2 texCoords)
{
uvec2 dims;
uint numberOfSamples;
ivec2 ivtextureMS = textureSize(sampler2DMS(textureMS[0]));
dims.x = ivtextureMS.x;dims.y = ivtextureMS.y;;
ivec2 pos=ivec2(vec2(dims)*texCoords);
vec4 d=vec4(0,0,0,0);
for(uint k=0;k<numberOfSamples;k++)
{
d+=texelFetch(sampler2DMS(textureMS[0]),ivec2(pos),int(k));
}

d/=float(numberOfSamples);
return d;
}
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 128 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
vec4 c=texture_resolve(imageTextureMS,BlockData.texCoords);
vec4 glow=texture_int(glowTexture,BlockData.texCoords);
c.rgb+=glow.rgb;
c.rgb*=exposure;
c.rgb=pow(c.rgb,vec3(gamma,gamma,gamma));
vec4 u=vec4(c.rgb,1.0);
{returnObject_vec4=u;}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_GlowPS.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageTexture[24];
};
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 517 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
vec4 c=vec4(0,0,0,0);
c+=texture(sampler2D(imageTexture[1 + 9]),BlockData.texCoords+offset/2.0);
c+=texture(sampler2D(imageTexture[1 + 9]),BlockData.texCoords-offset/2.0);
vec2 offset2=offset;
offset2.x=offset.x*-1.0;
c+=texture(sampler2D(imageTexture[1 + 9]),BlockData.texCoords+offset2/2.0);
c+=texture(sampler2D(imageTexture[1 + 9]),BlockData.texCoords-offset2/2.0);
c=c*exposure/4.0;
c-=1.0*vec4(1.0,1.0,1.0,1.0);
c=clamp(c,vec4(0.0,0.0,0.0,0.0),vec4(10.0,10.0,10.0,10.0));
{returnObject_vec4=c;}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_PS_Blur.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageTexture[24];
};
#line 8 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/noise.sl"
float rand(float c)
{
return fract(sin(dot(vec2(c,11.1*c),vec2(12.9898,78.233)))*43758.5453);
}
#line 13 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/noise.sl"
float rand(vec2 co)
{
return fract(sin(dot(co.xy,vec2(12.9898,78.233)))*43758.5453);
}
#line 532 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
float safelog(float x)
{
if(x<0.001)x=0.001;
return log(x);
}
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 540 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
float r1=rand(BlockData.texCoords.xy+vec2(11.19*randomSeed,2.3*randomSeed));
float r2=rand(vec2(1.0,0.5)+13.09*BlockData.texCoords.xy-vec2(5.1*randomSeed,3.9*randomSeed));
float rad=sqrt(-2.0*safelog(r1));
float angle=2.0*3.1415926536*r2;
vec2 sampleOffset=offset*rad*vec2(cos(angle),sin(angle));
vec4 c=textureLod(sampler2D(imageTexture[1 + 9]),BlockData.texCoords+sampleOffset,0);
{returnObject_vec4=vec4(c.rgb,alpha);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_PS_CompositeAtmospherics_Cubemap_ForwardDepth.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
struct TwoColourCompositeOutput
{
	vec4 add;
	vec4 multiply;
};






#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
struct CompositeShaderInput
{
	vec4 hPosition;
	vec2 texCoords;
	vec2 lowResTexCoords;
	vec4 clip_pos;
	vec2 depth_texc;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageCubeArrayTex[24];
	uint64_t nearFarTexture[24];
	uint64_t lightpassTexture[24];
	uint64_t loss2dTexture[24];
	uint64_t inscatterVolumeTexture[24];
	uint64_t godraysVolumeTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
TwoColourCompositeOutput CompositeAtmospherics(vec4 clip_pos, uint64_t cloudCubeArray[24], uint64_t nearFarTexture[24], uint64_t lightpassTexture[24], uint64_t loss2dTexture[24], float dist, mat4 invViewProj, vec3 viewPos, uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], float maxFadeDistanceKm, float nearDist, bool do_lightpass, bool do_godrays, bool do_interp, bool do_near, bool do_clouds, vec3 fogColour, vec3 fogAmbient, bool do_height_fog, float fogExtinction, float fogHeightKm)
{
TwoColourCompositeOutput res;
vec3 view=normalize(mul(invViewProj,clip_pos).xyz);
float sine=view.z;
vec4 nearFarCloud=vec4(1.0,0.0,1,1);
if(do_interp)nearFarCloud=textureLod(samplerCube(nearFarTexture[1 + 4]),view,0);
;
float dist_rt=sqrt(abs(dist));
vec3 worldspaceVolumeTexCoords=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(sine)/3.1415926536),dist_rt);
vec4 insc=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),worldspaceVolumeTexCoords,0);
vec2 loss_texc=vec2(dist_rt,0.5*(1.f-sine));
float f=nearFarCloud.x;
float n=nearFarCloud.y;
float hiResInterp=1.0-saturate((f-dist)/max(0.000000001,f-n));
float cloudLevel=float(2-1)*hiResInterp;
float cloudLevel_0=floor(cloudLevel);
vec4 lp=vec4(0.0,0.0,0.0,0.0);
if(do_lightpass)lp=textureLod(samplerCube(lightpassTexture[1 + 4]),view,0);
;
vec4 cloudNear=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0));
vec4 cloud;
if(do_interp)
{
vec4 cloudFar=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0+1.0));
cloud=mix(cloudNear,cloudFar,fract(cloudLevel));
if(do_lightpass)
{
cloud.rgb+=lp.rgb;
}

if(do_near)
{
float nearInterp=saturate((dist-nearDist)/max(0.00000001,2.0*nearDist));
cloud=mix(vec4(0,0,0,1.0),cloud,nearInterp);
}

}
else

{
cloud=cloudNear;
}

if(do_godrays)
{
vec3 offsetKm=view*dist*maxFadeDistanceKm;
vec3 lightspaceOffset=mul(worldToScatteringVolumeMatrix,vec4(offsetKm,1.0)).xyz;
float r=length(lightspaceOffset);
vec3 lightspaceVolumeTexCoords=vec3(fract(atan(lightspaceOffset.x,lightspaceOffset.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceOffset.z/r)*2.0/3.1415926536,r);
vec4 godrays=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),lightspaceVolumeTexCoords,0);
insc.rgb*=godrays.x;
}

if(do_clouds)insc.rgb*=cloud.a;
if(do_clouds)insc+=cloud;
res.multiply=textureLod(sampler2D(loss2dTexture[1 + 5]),loss_texc,0)*cloud.a;
if(do_height_fog)
{
float H_km=fogHeightKm;
float d_solid=maxFadeDistanceKm*dist;
float z=viewPos.z/1000.0;
float transition=pow(saturate(H_km-z),0.5);
float zs=z+sine*d_solid;
float z_max=max(z,zs);
float z_min=min(z,zs);
float z_1=min(z_min,H_km);
float z_2=min(z_max,H_km);
float sn=max(0.0000000001,abs(sine));
float sn1=max(0.0000000001,(-sine));
float s1=min(dist,saturate((max(0,(z-z_2)/sn1))/maxFadeDistanceKm));
float above_fog=step(0,z-H_km);
float upwards=step(0,sine);
float dz=z_2-z_1;
float s=(1.0-above_fog*upwards)*min(maxFadeDistanceKm,min(d_solid,dz/sn));
float z_mean=0.5*(z_1+z_2);
s*=saturate((H_km-z_mean)/0.1);
float fog_in=1.0-saturate(exp(-s*fogExtinction));
vec3 fogLoss=vec3(1.0,1.0,1.0);
float rt_s1=sqrt(s1);

{
fogLoss*=fog_in*mix((1-(above_fog*(1-cloud.a)))*textureLod(sampler2D(loss2dTexture[1 + 5]),vec2(rt_s1,loss_texc.y),0).rgb,vec3(1,1,1),transition);
}

insc.rgb*=vec3(1.0,1.0,1.0)-fogLoss;
insc.rgb+=(fogColour+fogAmbient)*fogLoss;
res.multiply*=(1.0-fog_in);
}

res.add=insc;
return res;
}
#line 297 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput PS_CompositeAtmospherics_Cubemap(CompositeShaderInput IN, bool reverseDepth)
{
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
depthInterpretationStruct.reverseDepth=reverseDepth;
vec3 view=normalize(mul(invViewProj,IN.clip_pos).xyz);
float sine=view.z;
float R=6378.0;
float r=R+max(1.0,viewPos.z/1000.0);
float dist=1.0;
float m=R*R+r*r*(sine*sine-1.0);
dist=step(0.0,m)*(-r*sine-sqrt(max(0.0,m)))/maxFadeDistanceKm;
if(dist<=0)dist=1.0;
TwoColourCompositeOutput result=CompositeAtmospherics(IN.clip_pos,imageCubeArrayTex,nearFarTexture,lightpassTexture,loss2dTexture,dist,invViewProj,viewPos,inscatterVolumeTexture,godraysVolumeTexture,maxFadeDistanceKm,nearDist,false,false,false,false,true,fogColour,fogAmbient,false,0.0,0.0);
float sine_horizon=sin(-acos(R/r));
result.add.rgb+=cubemapGroundColour*step(sine,sine_horizon)*result.multiply.rgb;
result.add.rgb=pow(result.add.rgb,vec3(gamma,gamma,gamma));
result.add.rgb*=exposure;
return result;
}
layout(location = 0) in Block
{
CompositeShaderInput BlockData;
} ioblock;
layout(location = 0, index = 0) out vec4 add;

layout(location = 0, index = 1) out vec4 multiply;

void main()
{
CompositeShaderInput BlockData=ioblock.BlockData;
#line 512 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput tmp =  PS_CompositeAtmospherics_Cubemap(BlockData,false);
add = tmp.add;
multiply = tmp.multiply;

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_PS_CompositeAtmospherics_Cubemap_ReverseDepth.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
struct TwoColourCompositeOutput
{
	vec4 add;
	vec4 multiply;
};






#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
struct CompositeShaderInput
{
	vec4 hPosition;
	vec2 texCoords;
	vec2 lowResTexCoords;
	vec4 clip_pos;
	vec2 depth_texc;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageCubeArrayTex[24];
	uint64_t nearFarTexture[24];
	uint64_t lightpassTexture[24];
	uint64_t loss2dTexture[24];
	uint64_t inscatterVolumeTexture[24];
	uint64_t godraysVolumeTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
TwoColourCompositeOutput CompositeAtmospherics(vec4 clip_pos, uint64_t cloudCubeArray[24], uint64_t nearFarTexture[24], uint64_t lightpassTexture[24], uint64_t loss2dTexture[24], float dist, mat4 invViewProj, vec3 viewPos, uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], float maxFadeDistanceKm, float nearDist, bool do_lightpass, bool do_godrays, bool do_interp, bool do_near, bool do_clouds, vec3 fogColour, vec3 fogAmbient, bool do_height_fog, float fogExtinction, float fogHeightKm)
{
TwoColourCompositeOutput res;
vec3 view=normalize(mul(invViewProj,clip_pos).xyz);
float sine=view.z;
vec4 nearFarCloud=vec4(1.0,0.0,1,1);
if(do_interp)nearFarCloud=textureLod(samplerCube(nearFarTexture[1 + 4]),view,0);
;
float dist_rt=sqrt(abs(dist));
vec3 worldspaceVolumeTexCoords=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(sine)/3.1415926536),dist_rt);
vec4 insc=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),worldspaceVolumeTexCoords,0);
vec2 loss_texc=vec2(dist_rt,0.5*(1.f-sine));
float f=nearFarCloud.x;
float n=nearFarCloud.y;
float hiResInterp=1.0-saturate((f-dist)/max(0.000000001,f-n));
float cloudLevel=float(2-1)*hiResInterp;
float cloudLevel_0=floor(cloudLevel);
vec4 lp=vec4(0.0,0.0,0.0,0.0);
if(do_lightpass)lp=textureLod(samplerCube(lightpassTexture[1 + 4]),view,0);
;
vec4 cloudNear=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0));
vec4 cloud;
if(do_interp)
{
vec4 cloudFar=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0+1.0));
cloud=mix(cloudNear,cloudFar,fract(cloudLevel));
if(do_lightpass)
{
cloud.rgb+=lp.rgb;
}

if(do_near)
{
float nearInterp=saturate((dist-nearDist)/max(0.00000001,2.0*nearDist));
cloud=mix(vec4(0,0,0,1.0),cloud,nearInterp);
}

}
else

{
cloud=cloudNear;
}

if(do_godrays)
{
vec3 offsetKm=view*dist*maxFadeDistanceKm;
vec3 lightspaceOffset=mul(worldToScatteringVolumeMatrix,vec4(offsetKm,1.0)).xyz;
float r=length(lightspaceOffset);
vec3 lightspaceVolumeTexCoords=vec3(fract(atan(lightspaceOffset.x,lightspaceOffset.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceOffset.z/r)*2.0/3.1415926536,r);
vec4 godrays=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),lightspaceVolumeTexCoords,0);
insc.rgb*=godrays.x;
}

if(do_clouds)insc.rgb*=cloud.a;
if(do_clouds)insc+=cloud;
res.multiply=textureLod(sampler2D(loss2dTexture[1 + 5]),loss_texc,0)*cloud.a;
if(do_height_fog)
{
float H_km=fogHeightKm;
float d_solid=maxFadeDistanceKm*dist;
float z=viewPos.z/1000.0;
float transition=pow(saturate(H_km-z),0.5);
float zs=z+sine*d_solid;
float z_max=max(z,zs);
float z_min=min(z,zs);
float z_1=min(z_min,H_km);
float z_2=min(z_max,H_km);
float sn=max(0.0000000001,abs(sine));
float sn1=max(0.0000000001,(-sine));
float s1=min(dist,saturate((max(0,(z-z_2)/sn1))/maxFadeDistanceKm));
float above_fog=step(0,z-H_km);
float upwards=step(0,sine);
float dz=z_2-z_1;
float s=(1.0-above_fog*upwards)*min(maxFadeDistanceKm,min(d_solid,dz/sn));
float z_mean=0.5*(z_1+z_2);
s*=saturate((H_km-z_mean)/0.1);
float fog_in=1.0-saturate(exp(-s*fogExtinction));
vec3 fogLoss=vec3(1.0,1.0,1.0);
float rt_s1=sqrt(s1);

{
fogLoss*=fog_in*mix((1-(above_fog*(1-cloud.a)))*textureLod(sampler2D(loss2dTexture[1 + 5]),vec2(rt_s1,loss_texc.y),0).rgb,vec3(1,1,1),transition);
}

insc.rgb*=vec3(1.0,1.0,1.0)-fogLoss;
insc.rgb+=(fogColour+fogAmbient)*fogLoss;
res.multiply*=(1.0-fog_in);
}

res.add=insc;
return res;
}
#line 297 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput PS_CompositeAtmospherics_Cubemap(CompositeShaderInput IN, bool reverseDepth)
{
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
depthInterpretationStruct.reverseDepth=reverseDepth;
vec3 view=normalize(mul(invViewProj,IN.clip_pos).xyz);
float sine=view.z;
float R=6378.0;
float r=R+max(1.0,viewPos.z/1000.0);
float dist=1.0;
float m=R*R+r*r*(sine*sine-1.0);
dist=step(0.0,m)*(-r*sine-sqrt(max(0.0,m)))/maxFadeDistanceKm;
if(dist<=0)dist=1.0;
TwoColourCompositeOutput result=CompositeAtmospherics(IN.clip_pos,imageCubeArrayTex,nearFarTexture,lightpassTexture,loss2dTexture,dist,invViewProj,viewPos,inscatterVolumeTexture,godraysVolumeTexture,maxFadeDistanceKm,nearDist,false,false,false,false,true,fogColour,fogAmbient,false,0.0,0.0);
float sine_horizon=sin(-acos(R/r));
result.add.rgb+=cubemapGroundColour*step(sine,sine_horizon)*result.multiply.rgb;
result.add.rgb=pow(result.add.rgb,vec3(gamma,gamma,gamma));
result.add.rgb*=exposure;
return result;
}
layout(location = 0) in Block
{
CompositeShaderInput BlockData;
} ioblock;
layout(location = 0, index = 0) out vec4 add;

layout(location = 0, index = 1) out vec4 multiply;

void main()
{
CompositeShaderInput BlockData=ioblock.BlockData;
#line 507 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput tmp =  PS_CompositeAtmospherics_Cubemap(BlockData,true);
add = tmp.add;
multiply = tmp.multiply;

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_PS_CompositeAtmospherics_ForwardDepth.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
struct TwoColourCompositeOutput
{
	vec4 add;
	vec4 multiply;
};







#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
struct CompositeShaderInput
{
	vec4 hPosition;
	vec2 texCoords;
	vec2 lowResTexCoords;
	vec4 clip_pos;
	vec2 depth_texc;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageCubeArrayTex[24];
	uint64_t nearFarTexture[24];
	uint64_t lightpassTexture[24];
	uint64_t depthTexture[24];
	uint64_t loss2dTexture[24];
	uint64_t inscatterVolumeTexture[24];
	uint64_t godraysVolumeTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
TwoColourCompositeOutput CompositeAtmospherics(vec4 clip_pos, uint64_t cloudCubeArray[24], uint64_t nearFarTexture[24], uint64_t lightpassTexture[24], uint64_t loss2dTexture[24], float dist, mat4 invViewProj, vec3 viewPos, uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], float maxFadeDistanceKm, float nearDist, bool do_lightpass, bool do_godrays, bool do_interp, bool do_near, bool do_clouds, vec3 fogColour, vec3 fogAmbient, bool do_height_fog, float fogExtinction, float fogHeightKm)
{
TwoColourCompositeOutput res;
vec3 view=normalize(mul(invViewProj,clip_pos).xyz);
float sine=view.z;
vec4 nearFarCloud=vec4(1.0,0.0,1,1);
if(do_interp)nearFarCloud=textureLod(samplerCube(nearFarTexture[1 + 4]),view,0);
;
float dist_rt=sqrt(abs(dist));
vec3 worldspaceVolumeTexCoords=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(sine)/3.1415926536),dist_rt);
vec4 insc=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),worldspaceVolumeTexCoords,0);
vec2 loss_texc=vec2(dist_rt,0.5*(1.f-sine));
float f=nearFarCloud.x;
float n=nearFarCloud.y;
float hiResInterp=1.0-saturate((f-dist)/max(0.000000001,f-n));
float cloudLevel=float(2-1)*hiResInterp;
float cloudLevel_0=floor(cloudLevel);
vec4 lp=vec4(0.0,0.0,0.0,0.0);
if(do_lightpass)lp=textureLod(samplerCube(lightpassTexture[1 + 4]),view,0);
;
vec4 cloudNear=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0));
vec4 cloud;
if(do_interp)
{
vec4 cloudFar=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0+1.0));
cloud=mix(cloudNear,cloudFar,fract(cloudLevel));
if(do_lightpass)
{
cloud.rgb+=lp.rgb;
}

if(do_near)
{
float nearInterp=saturate((dist-nearDist)/max(0.00000001,2.0*nearDist));
cloud=mix(vec4(0,0,0,1.0),cloud,nearInterp);
}

}
else

{
cloud=cloudNear;
}

if(do_godrays)
{
vec3 offsetKm=view*dist*maxFadeDistanceKm;
vec3 lightspaceOffset=mul(worldToScatteringVolumeMatrix,vec4(offsetKm,1.0)).xyz;
float r=length(lightspaceOffset);
vec3 lightspaceVolumeTexCoords=vec3(fract(atan(lightspaceOffset.x,lightspaceOffset.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceOffset.z/r)*2.0/3.1415926536,r);
vec4 godrays=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),lightspaceVolumeTexCoords,0);
insc.rgb*=godrays.x;
}

if(do_clouds)insc.rgb*=cloud.a;
if(do_clouds)insc+=cloud;
res.multiply=textureLod(sampler2D(loss2dTexture[1 + 5]),loss_texc,0)*cloud.a;
if(do_height_fog)
{
float H_km=fogHeightKm;
float d_solid=maxFadeDistanceKm*dist;
float z=viewPos.z/1000.0;
float transition=pow(saturate(H_km-z),0.5);
float zs=z+sine*d_solid;
float z_max=max(z,zs);
float z_min=min(z,zs);
float z_1=min(z_min,H_km);
float z_2=min(z_max,H_km);
float sn=max(0.0000000001,abs(sine));
float sn1=max(0.0000000001,(-sine));
float s1=min(dist,saturate((max(0,(z-z_2)/sn1))/maxFadeDistanceKm));
float above_fog=step(0,z-H_km);
float upwards=step(0,sine);
float dz=z_2-z_1;
float s=(1.0-above_fog*upwards)*min(maxFadeDistanceKm,min(d_solid,dz/sn));
float z_mean=0.5*(z_1+z_2);
s*=saturate((H_km-z_mean)/0.1);
float fog_in=1.0-saturate(exp(-s*fogExtinction));
vec3 fogLoss=vec3(1.0,1.0,1.0);
float rt_s1=sqrt(s1);

{
fogLoss*=fog_in*mix((1-(above_fog*(1-cloud.a)))*textureLod(sampler2D(loss2dTexture[1 + 5]),vec2(rt_s1,loss_texc.y),0).rgb,vec3(1,1,1),transition);
}

insc.rgb*=vec3(1.0,1.0,1.0)-fogLoss;
insc.rgb+=(fogColour+fogAmbient)*fogLoss;
res.multiply*=(1.0-fog_in);
}

res.add=insc;
return res;
}
#line 261 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput PS_CompositeAtmospherics(CompositeShaderInput IN, bool reverseDepth, bool doLightpass, bool doGodrays, bool doNear)
{
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
depthInterpretationStruct.reverseDepth=reverseDepth;
float depth=textureLod(sampler2D(depthTexture[1 + 14]),IN.depth_texc,0).x;
float dist=depthToFadeDistance(depth,IN.clip_pos.xy,depthInterpretationStruct,tanHalfFov);
TwoColourCompositeOutput result=CompositeAtmospherics(IN.clip_pos,imageCubeArrayTex,nearFarTexture,lightpassTexture,loss2dTexture,dist,invViewProj,viewPos,inscatterVolumeTexture,godraysVolumeTexture,maxFadeDistanceKm,nearDist,doLightpass,doGodrays,true,doNear,true,fogColour,fogAmbient,true,fogExtinction,fogCeilingKm);
result.add.rgb=pow(result.add.rgb,vec3(gamma,gamma,gamma));
result.add.rgb*=exposure;
return result;
}
layout(location = 0) in Block
{
CompositeShaderInput BlockData;
} ioblock;
layout(location = 0, index = 0) out vec4 add;

layout(location = 0, index = 1) out vec4 multiply;

void main()
{
CompositeShaderInput BlockData=ioblock.BlockData;
#line 348 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput tmp =  PS_CompositeAtmospherics(BlockData,false,false,false,false);
add = tmp.add;
multiply = tmp.multiply;

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_PS_CompositeAtmospherics_ForwardDepth_Godrays.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
struct TwoColourCompositeOutput
{
	vec4 add;
	vec4 multiply;
};







#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
struct CompositeShaderInput
{
	vec4 hPosition;
	vec2 texCoords;
	vec2 lowResTexCoords;
	vec4 clip_pos;
	vec2 depth_texc;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageCubeArrayTex[24];
	uint64_t nearFarTexture[24];
	uint64_t lightpassTexture[24];
	uint64_t depthTexture[24];
	uint64_t loss2dTexture[24];
	uint64_t inscatterVolumeTexture[24];
	uint64_t godraysVolumeTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
TwoColourCompositeOutput CompositeAtmospherics(vec4 clip_pos, uint64_t cloudCubeArray[24], uint64_t nearFarTexture[24], uint64_t lightpassTexture[24], uint64_t loss2dTexture[24], float dist, mat4 invViewProj, vec3 viewPos, uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], float maxFadeDistanceKm, float nearDist, bool do_lightpass, bool do_godrays, bool do_interp, bool do_near, bool do_clouds, vec3 fogColour, vec3 fogAmbient, bool do_height_fog, float fogExtinction, float fogHeightKm)
{
TwoColourCompositeOutput res;
vec3 view=normalize(mul(invViewProj,clip_pos).xyz);
float sine=view.z;
vec4 nearFarCloud=vec4(1.0,0.0,1,1);
if(do_interp)nearFarCloud=textureLod(samplerCube(nearFarTexture[1 + 4]),view,0);
;
float dist_rt=sqrt(abs(dist));
vec3 worldspaceVolumeTexCoords=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(sine)/3.1415926536),dist_rt);
vec4 insc=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),worldspaceVolumeTexCoords,0);
vec2 loss_texc=vec2(dist_rt,0.5*(1.f-sine));
float f=nearFarCloud.x;
float n=nearFarCloud.y;
float hiResInterp=1.0-saturate((f-dist)/max(0.000000001,f-n));
float cloudLevel=float(2-1)*hiResInterp;
float cloudLevel_0=floor(cloudLevel);
vec4 lp=vec4(0.0,0.0,0.0,0.0);
if(do_lightpass)lp=textureLod(samplerCube(lightpassTexture[1 + 4]),view,0);
;
vec4 cloudNear=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0));
vec4 cloud;
if(do_interp)
{
vec4 cloudFar=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0+1.0));
cloud=mix(cloudNear,cloudFar,fract(cloudLevel));
if(do_lightpass)
{
cloud.rgb+=lp.rgb;
}

if(do_near)
{
float nearInterp=saturate((dist-nearDist)/max(0.00000001,2.0*nearDist));
cloud=mix(vec4(0,0,0,1.0),cloud,nearInterp);
}

}
else

{
cloud=cloudNear;
}

if(do_godrays)
{
vec3 offsetKm=view*dist*maxFadeDistanceKm;
vec3 lightspaceOffset=mul(worldToScatteringVolumeMatrix,vec4(offsetKm,1.0)).xyz;
float r=length(lightspaceOffset);
vec3 lightspaceVolumeTexCoords=vec3(fract(atan(lightspaceOffset.x,lightspaceOffset.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceOffset.z/r)*2.0/3.1415926536,r);
vec4 godrays=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),lightspaceVolumeTexCoords,0);
insc.rgb*=godrays.x;
}

if(do_clouds)insc.rgb*=cloud.a;
if(do_clouds)insc+=cloud;
res.multiply=textureLod(sampler2D(loss2dTexture[1 + 5]),loss_texc,0)*cloud.a;
if(do_height_fog)
{
float H_km=fogHeightKm;
float d_solid=maxFadeDistanceKm*dist;
float z=viewPos.z/1000.0;
float transition=pow(saturate(H_km-z),0.5);
float zs=z+sine*d_solid;
float z_max=max(z,zs);
float z_min=min(z,zs);
float z_1=min(z_min,H_km);
float z_2=min(z_max,H_km);
float sn=max(0.0000000001,abs(sine));
float sn1=max(0.0000000001,(-sine));
float s1=min(dist,saturate((max(0,(z-z_2)/sn1))/maxFadeDistanceKm));
float above_fog=step(0,z-H_km);
float upwards=step(0,sine);
float dz=z_2-z_1;
float s=(1.0-above_fog*upwards)*min(maxFadeDistanceKm,min(d_solid,dz/sn));
float z_mean=0.5*(z_1+z_2);
s*=saturate((H_km-z_mean)/0.1);
float fog_in=1.0-saturate(exp(-s*fogExtinction));
vec3 fogLoss=vec3(1.0,1.0,1.0);
float rt_s1=sqrt(s1);

{
fogLoss*=fog_in*mix((1-(above_fog*(1-cloud.a)))*textureLod(sampler2D(loss2dTexture[1 + 5]),vec2(rt_s1,loss_texc.y),0).rgb,vec3(1,1,1),transition);
}

insc.rgb*=vec3(1.0,1.0,1.0)-fogLoss;
insc.rgb+=(fogColour+fogAmbient)*fogLoss;
res.multiply*=(1.0-fog_in);
}

res.add=insc;
return res;
}
#line 261 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput PS_CompositeAtmospherics(CompositeShaderInput IN, bool reverseDepth, bool doLightpass, bool doGodrays, bool doNear)
{
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
depthInterpretationStruct.reverseDepth=reverseDepth;
float depth=textureLod(sampler2D(depthTexture[1 + 14]),IN.depth_texc,0).x;
float dist=depthToFadeDistance(depth,IN.clip_pos.xy,depthInterpretationStruct,tanHalfFov);
TwoColourCompositeOutput result=CompositeAtmospherics(IN.clip_pos,imageCubeArrayTex,nearFarTexture,lightpassTexture,loss2dTexture,dist,invViewProj,viewPos,inscatterVolumeTexture,godraysVolumeTexture,maxFadeDistanceKm,nearDist,doLightpass,doGodrays,true,doNear,true,fogColour,fogAmbient,true,fogExtinction,fogCeilingKm);
result.add.rgb=pow(result.add.rgb,vec3(gamma,gamma,gamma));
result.add.rgb*=exposure;
return result;
}
layout(location = 0) in Block
{
CompositeShaderInput BlockData;
} ioblock;
layout(location = 0, index = 0) out vec4 add;

layout(location = 0, index = 1) out vec4 multiply;

void main()
{
CompositeShaderInput BlockData=ioblock.BlockData;
#line 368 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput tmp =  PS_CompositeAtmospherics(BlockData,false,false,true,false);
add = tmp.add;
multiply = tmp.multiply;

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_PS_CompositeAtmospherics_ForwardDepth_Godrays_NearInterp.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
struct TwoColourCompositeOutput
{
	vec4 add;
	vec4 multiply;
};







#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
struct CompositeShaderInput
{
	vec4 hPosition;
	vec2 texCoords;
	vec2 lowResTexCoords;
	vec4 clip_pos;
	vec2 depth_texc;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageCubeArrayTex[24];
	uint64_t nearFarTexture[24];
	uint64_t lightpassTexture[24];
	uint64_t depthTexture[24];
	uint64_t loss2dTexture[24];
	uint64_t inscatterVolumeTexture[24];
	uint64_t godraysVolumeTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
TwoColourCompositeOutput CompositeAtmospherics(vec4 clip_pos, uint64_t cloudCubeArray[24], uint64_t nearFarTexture[24], uint64_t lightpassTexture[24], uint64_t loss2dTexture[24], float dist, mat4 invViewProj, vec3 viewPos, uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], float maxFadeDistanceKm, float nearDist, bool do_lightpass, bool do_godrays, bool do_interp, bool do_near, bool do_clouds, vec3 fogColour, vec3 fogAmbient, bool do_height_fog, float fogExtinction, float fogHeightKm)
{
TwoColourCompositeOutput res;
vec3 view=normalize(mul(invViewProj,clip_pos).xyz);
float sine=view.z;
vec4 nearFarCloud=vec4(1.0,0.0,1,1);
if(do_interp)nearFarCloud=textureLod(samplerCube(nearFarTexture[1 + 4]),view,0);
;
float dist_rt=sqrt(abs(dist));
vec3 worldspaceVolumeTexCoords=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(sine)/3.1415926536),dist_rt);
vec4 insc=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),worldspaceVolumeTexCoords,0);
vec2 loss_texc=vec2(dist_rt,0.5*(1.f-sine));
float f=nearFarCloud.x;
float n=nearFarCloud.y;
float hiResInterp=1.0-saturate((f-dist)/max(0.000000001,f-n));
float cloudLevel=float(2-1)*hiResInterp;
float cloudLevel_0=floor(cloudLevel);
vec4 lp=vec4(0.0,0.0,0.0,0.0);
if(do_lightpass)lp=textureLod(samplerCube(lightpassTexture[1 + 4]),view,0);
;
vec4 cloudNear=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0));
vec4 cloud;
if(do_interp)
{
vec4 cloudFar=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0+1.0));
cloud=mix(cloudNear,cloudFar,fract(cloudLevel));
if(do_lightpass)
{
cloud.rgb+=lp.rgb;
}

if(do_near)
{
float nearInterp=saturate((dist-nearDist)/max(0.00000001,2.0*nearDist));
cloud=mix(vec4(0,0,0,1.0),cloud,nearInterp);
}

}
else

{
cloud=cloudNear;
}

if(do_godrays)
{
vec3 offsetKm=view*dist*maxFadeDistanceKm;
vec3 lightspaceOffset=mul(worldToScatteringVolumeMatrix,vec4(offsetKm,1.0)).xyz;
float r=length(lightspaceOffset);
vec3 lightspaceVolumeTexCoords=vec3(fract(atan(lightspaceOffset.x,lightspaceOffset.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceOffset.z/r)*2.0/3.1415926536,r);
vec4 godrays=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),lightspaceVolumeTexCoords,0);
insc.rgb*=godrays.x;
}

if(do_clouds)insc.rgb*=cloud.a;
if(do_clouds)insc+=cloud;
res.multiply=textureLod(sampler2D(loss2dTexture[1 + 5]),loss_texc,0)*cloud.a;
if(do_height_fog)
{
float H_km=fogHeightKm;
float d_solid=maxFadeDistanceKm*dist;
float z=viewPos.z/1000.0;
float transition=pow(saturate(H_km-z),0.5);
float zs=z+sine*d_solid;
float z_max=max(z,zs);
float z_min=min(z,zs);
float z_1=min(z_min,H_km);
float z_2=min(z_max,H_km);
float sn=max(0.0000000001,abs(sine));
float sn1=max(0.0000000001,(-sine));
float s1=min(dist,saturate((max(0,(z-z_2)/sn1))/maxFadeDistanceKm));
float above_fog=step(0,z-H_km);
float upwards=step(0,sine);
float dz=z_2-z_1;
float s=(1.0-above_fog*upwards)*min(maxFadeDistanceKm,min(d_solid,dz/sn));
float z_mean=0.5*(z_1+z_2);
s*=saturate((H_km-z_mean)/0.1);
float fog_in=1.0-saturate(exp(-s*fogExtinction));
vec3 fogLoss=vec3(1.0,1.0,1.0);
float rt_s1=sqrt(s1);

{
fogLoss*=fog_in*mix((1-(above_fog*(1-cloud.a)))*textureLod(sampler2D(loss2dTexture[1 + 5]),vec2(rt_s1,loss_texc.y),0).rgb,vec3(1,1,1),transition);
}

insc.rgb*=vec3(1.0,1.0,1.0)-fogLoss;
insc.rgb+=(fogColour+fogAmbient)*fogLoss;
res.multiply*=(1.0-fog_in);
}

res.add=insc;
return res;
}
#line 261 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput PS_CompositeAtmospherics(CompositeShaderInput IN, bool reverseDepth, bool doLightpass, bool doGodrays, bool doNear)
{
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
depthInterpretationStruct.reverseDepth=reverseDepth;
float depth=textureLod(sampler2D(depthTexture[1 + 14]),IN.depth_texc,0).x;
float dist=depthToFadeDistance(depth,IN.clip_pos.xy,depthInterpretationStruct,tanHalfFov);
TwoColourCompositeOutput result=CompositeAtmospherics(IN.clip_pos,imageCubeArrayTex,nearFarTexture,lightpassTexture,loss2dTexture,dist,invViewProj,viewPos,inscatterVolumeTexture,godraysVolumeTexture,maxFadeDistanceKm,nearDist,doLightpass,doGodrays,true,doNear,true,fogColour,fogAmbient,true,fogExtinction,fogCeilingKm);
result.add.rgb=pow(result.add.rgb,vec3(gamma,gamma,gamma));
result.add.rgb*=exposure;
return result;
}
layout(location = 0) in Block
{
CompositeShaderInput BlockData;
} ioblock;
layout(location = 0, index = 0) out vec4 add;

layout(location = 0, index = 1) out vec4 multiply;

void main()
{
CompositeShaderInput BlockData=ioblock.BlockData;
#line 408 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput tmp =  PS_CompositeAtmospherics(BlockData,false,false,true,true);
add = tmp.add;
multiply = tmp.multiply;

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_PS_CompositeAtmospherics_ForwardDepth_Lightpass.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
struct TwoColourCompositeOutput
{
	vec4 add;
	vec4 multiply;
};







#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
struct CompositeShaderInput
{
	vec4 hPosition;
	vec2 texCoords;
	vec2 lowResTexCoords;
	vec4 clip_pos;
	vec2 depth_texc;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageCubeArrayTex[24];
	uint64_t nearFarTexture[24];
	uint64_t lightpassTexture[24];
	uint64_t depthTexture[24];
	uint64_t loss2dTexture[24];
	uint64_t inscatterVolumeTexture[24];
	uint64_t godraysVolumeTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
TwoColourCompositeOutput CompositeAtmospherics(vec4 clip_pos, uint64_t cloudCubeArray[24], uint64_t nearFarTexture[24], uint64_t lightpassTexture[24], uint64_t loss2dTexture[24], float dist, mat4 invViewProj, vec3 viewPos, uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], float maxFadeDistanceKm, float nearDist, bool do_lightpass, bool do_godrays, bool do_interp, bool do_near, bool do_clouds, vec3 fogColour, vec3 fogAmbient, bool do_height_fog, float fogExtinction, float fogHeightKm)
{
TwoColourCompositeOutput res;
vec3 view=normalize(mul(invViewProj,clip_pos).xyz);
float sine=view.z;
vec4 nearFarCloud=vec4(1.0,0.0,1,1);
if(do_interp)nearFarCloud=textureLod(samplerCube(nearFarTexture[1 + 4]),view,0);
;
float dist_rt=sqrt(abs(dist));
vec3 worldspaceVolumeTexCoords=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(sine)/3.1415926536),dist_rt);
vec4 insc=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),worldspaceVolumeTexCoords,0);
vec2 loss_texc=vec2(dist_rt,0.5*(1.f-sine));
float f=nearFarCloud.x;
float n=nearFarCloud.y;
float hiResInterp=1.0-saturate((f-dist)/max(0.000000001,f-n));
float cloudLevel=float(2-1)*hiResInterp;
float cloudLevel_0=floor(cloudLevel);
vec4 lp=vec4(0.0,0.0,0.0,0.0);
if(do_lightpass)lp=textureLod(samplerCube(lightpassTexture[1 + 4]),view,0);
;
vec4 cloudNear=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0));
vec4 cloud;
if(do_interp)
{
vec4 cloudFar=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0+1.0));
cloud=mix(cloudNear,cloudFar,fract(cloudLevel));
if(do_lightpass)
{
cloud.rgb+=lp.rgb;
}

if(do_near)
{
float nearInterp=saturate((dist-nearDist)/max(0.00000001,2.0*nearDist));
cloud=mix(vec4(0,0,0,1.0),cloud,nearInterp);
}

}
else

{
cloud=cloudNear;
}

if(do_godrays)
{
vec3 offsetKm=view*dist*maxFadeDistanceKm;
vec3 lightspaceOffset=mul(worldToScatteringVolumeMatrix,vec4(offsetKm,1.0)).xyz;
float r=length(lightspaceOffset);
vec3 lightspaceVolumeTexCoords=vec3(fract(atan(lightspaceOffset.x,lightspaceOffset.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceOffset.z/r)*2.0/3.1415926536,r);
vec4 godrays=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),lightspaceVolumeTexCoords,0);
insc.rgb*=godrays.x;
}

if(do_clouds)insc.rgb*=cloud.a;
if(do_clouds)insc+=cloud;
res.multiply=textureLod(sampler2D(loss2dTexture[1 + 5]),loss_texc,0)*cloud.a;
if(do_height_fog)
{
float H_km=fogHeightKm;
float d_solid=maxFadeDistanceKm*dist;
float z=viewPos.z/1000.0;
float transition=pow(saturate(H_km-z),0.5);
float zs=z+sine*d_solid;
float z_max=max(z,zs);
float z_min=min(z,zs);
float z_1=min(z_min,H_km);
float z_2=min(z_max,H_km);
float sn=max(0.0000000001,abs(sine));
float sn1=max(0.0000000001,(-sine));
float s1=min(dist,saturate((max(0,(z-z_2)/sn1))/maxFadeDistanceKm));
float above_fog=step(0,z-H_km);
float upwards=step(0,sine);
float dz=z_2-z_1;
float s=(1.0-above_fog*upwards)*min(maxFadeDistanceKm,min(d_solid,dz/sn));
float z_mean=0.5*(z_1+z_2);
s*=saturate((H_km-z_mean)/0.1);
float fog_in=1.0-saturate(exp(-s*fogExtinction));
vec3 fogLoss=vec3(1.0,1.0,1.0);
float rt_s1=sqrt(s1);

{
fogLoss*=fog_in*mix((1-(above_fog*(1-cloud.a)))*textureLod(sampler2D(loss2dTexture[1 + 5]),vec2(rt_s1,loss_texc.y),0).rgb,vec3(1,1,1),transition);
}

insc.rgb*=vec3(1.0,1.0,1.0)-fogLoss;
insc.rgb+=(fogColour+fogAmbient)*fogLoss;
res.multiply*=(1.0-fog_in);
}

res.add=insc;
return res;
}
#line 261 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput PS_CompositeAtmospherics(CompositeShaderInput IN, bool reverseDepth, bool doLightpass, bool doGodrays, bool doNear)
{
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
depthInterpretationStruct.reverseDepth=reverseDepth;
float depth=textureLod(sampler2D(depthTexture[1 + 14]),IN.depth_texc,0).x;
float dist=depthToFadeDistance(depth,IN.clip_pos.xy,depthInterpretationStruct,tanHalfFov);
TwoColourCompositeOutput result=CompositeAtmospherics(IN.clip_pos,imageCubeArrayTex,nearFarTexture,lightpassTexture,loss2dTexture,dist,invViewProj,viewPos,inscatterVolumeTexture,godraysVolumeTexture,maxFadeDistanceKm,nearDist,doLightpass,doGodrays,true,doNear,true,fogColour,fogAmbient,true,fogExtinction,fogCeilingKm);
result.add.rgb=pow(result.add.rgb,vec3(gamma,gamma,gamma));
result.add.rgb*=exposure;
return result;
}
layout(location = 0) in Block
{
CompositeShaderInput BlockData;
} ioblock;
layout(location = 0, index = 0) out vec4 add;

layout(location = 0, index = 1) out vec4 multiply;

void main()
{
CompositeShaderInput BlockData=ioblock.BlockData;
#line 358 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput tmp =  PS_CompositeAtmospherics(BlockData,false,true,false,false);
add = tmp.add;
multiply = tmp.multiply;

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_PS_CompositeAtmospherics_ForwardDepth_Lightpass_Godrays.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
struct TwoColourCompositeOutput
{
	vec4 add;
	vec4 multiply;
};







#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
struct CompositeShaderInput
{
	vec4 hPosition;
	vec2 texCoords;
	vec2 lowResTexCoords;
	vec4 clip_pos;
	vec2 depth_texc;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageCubeArrayTex[24];
	uint64_t nearFarTexture[24];
	uint64_t lightpassTexture[24];
	uint64_t depthTexture[24];
	uint64_t loss2dTexture[24];
	uint64_t inscatterVolumeTexture[24];
	uint64_t godraysVolumeTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
TwoColourCompositeOutput CompositeAtmospherics(vec4 clip_pos, uint64_t cloudCubeArray[24], uint64_t nearFarTexture[24], uint64_t lightpassTexture[24], uint64_t loss2dTexture[24], float dist, mat4 invViewProj, vec3 viewPos, uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], float maxFadeDistanceKm, float nearDist, bool do_lightpass, bool do_godrays, bool do_interp, bool do_near, bool do_clouds, vec3 fogColour, vec3 fogAmbient, bool do_height_fog, float fogExtinction, float fogHeightKm)
{
TwoColourCompositeOutput res;
vec3 view=normalize(mul(invViewProj,clip_pos).xyz);
float sine=view.z;
vec4 nearFarCloud=vec4(1.0,0.0,1,1);
if(do_interp)nearFarCloud=textureLod(samplerCube(nearFarTexture[1 + 4]),view,0);
;
float dist_rt=sqrt(abs(dist));
vec3 worldspaceVolumeTexCoords=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(sine)/3.1415926536),dist_rt);
vec4 insc=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),worldspaceVolumeTexCoords,0);
vec2 loss_texc=vec2(dist_rt,0.5*(1.f-sine));
float f=nearFarCloud.x;
float n=nearFarCloud.y;
float hiResInterp=1.0-saturate((f-dist)/max(0.000000001,f-n));
float cloudLevel=float(2-1)*hiResInterp;
float cloudLevel_0=floor(cloudLevel);
vec4 lp=vec4(0.0,0.0,0.0,0.0);
if(do_lightpass)lp=textureLod(samplerCube(lightpassTexture[1 + 4]),view,0);
;
vec4 cloudNear=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0));
vec4 cloud;
if(do_interp)
{
vec4 cloudFar=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0+1.0));
cloud=mix(cloudNear,cloudFar,fract(cloudLevel));
if(do_lightpass)
{
cloud.rgb+=lp.rgb;
}

if(do_near)
{
float nearInterp=saturate((dist-nearDist)/max(0.00000001,2.0*nearDist));
cloud=mix(vec4(0,0,0,1.0),cloud,nearInterp);
}

}
else

{
cloud=cloudNear;
}

if(do_godrays)
{
vec3 offsetKm=view*dist*maxFadeDistanceKm;
vec3 lightspaceOffset=mul(worldToScatteringVolumeMatrix,vec4(offsetKm,1.0)).xyz;
float r=length(lightspaceOffset);
vec3 lightspaceVolumeTexCoords=vec3(fract(atan(lightspaceOffset.x,lightspaceOffset.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceOffset.z/r)*2.0/3.1415926536,r);
vec4 godrays=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),lightspaceVolumeTexCoords,0);
insc.rgb*=godrays.x;
}

if(do_clouds)insc.rgb*=cloud.a;
if(do_clouds)insc+=cloud;
res.multiply=textureLod(sampler2D(loss2dTexture[1 + 5]),loss_texc,0)*cloud.a;
if(do_height_fog)
{
float H_km=fogHeightKm;
float d_solid=maxFadeDistanceKm*dist;
float z=viewPos.z/1000.0;
float transition=pow(saturate(H_km-z),0.5);
float zs=z+sine*d_solid;
float z_max=max(z,zs);
float z_min=min(z,zs);
float z_1=min(z_min,H_km);
float z_2=min(z_max,H_km);
float sn=max(0.0000000001,abs(sine));
float sn1=max(0.0000000001,(-sine));
float s1=min(dist,saturate((max(0,(z-z_2)/sn1))/maxFadeDistanceKm));
float above_fog=step(0,z-H_km);
float upwards=step(0,sine);
float dz=z_2-z_1;
float s=(1.0-above_fog*upwards)*min(maxFadeDistanceKm,min(d_solid,dz/sn));
float z_mean=0.5*(z_1+z_2);
s*=saturate((H_km-z_mean)/0.1);
float fog_in=1.0-saturate(exp(-s*fogExtinction));
vec3 fogLoss=vec3(1.0,1.0,1.0);
float rt_s1=sqrt(s1);

{
fogLoss*=fog_in*mix((1-(above_fog*(1-cloud.a)))*textureLod(sampler2D(loss2dTexture[1 + 5]),vec2(rt_s1,loss_texc.y),0).rgb,vec3(1,1,1),transition);
}

insc.rgb*=vec3(1.0,1.0,1.0)-fogLoss;
insc.rgb+=(fogColour+fogAmbient)*fogLoss;
res.multiply*=(1.0-fog_in);
}

res.add=insc;
return res;
}
#line 261 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput PS_CompositeAtmospherics(CompositeShaderInput IN, bool reverseDepth, bool doLightpass, bool doGodrays, bool doNear)
{
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
depthInterpretationStruct.reverseDepth=reverseDepth;
float depth=textureLod(sampler2D(depthTexture[1 + 14]),IN.depth_texc,0).x;
float dist=depthToFadeDistance(depth,IN.clip_pos.xy,depthInterpretationStruct,tanHalfFov);
TwoColourCompositeOutput result=CompositeAtmospherics(IN.clip_pos,imageCubeArrayTex,nearFarTexture,lightpassTexture,loss2dTexture,dist,invViewProj,viewPos,inscatterVolumeTexture,godraysVolumeTexture,maxFadeDistanceKm,nearDist,doLightpass,doGodrays,true,doNear,true,fogColour,fogAmbient,true,fogExtinction,fogCeilingKm);
result.add.rgb=pow(result.add.rgb,vec3(gamma,gamma,gamma));
result.add.rgb*=exposure;
return result;
}
layout(location = 0) in Block
{
CompositeShaderInput BlockData;
} ioblock;
layout(location = 0, index = 0) out vec4 add;

layout(location = 0, index = 1) out vec4 multiply;

void main()
{
CompositeShaderInput BlockData=ioblock.BlockData;
#line 378 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput tmp =  PS_CompositeAtmospherics(BlockData,false,true,true,false);
add = tmp.add;
multiply = tmp.multiply;

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_PS_CompositeAtmospherics_ForwardDepth_Lightpass_Godrays_NearInterp.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
struct TwoColourCompositeOutput
{
	vec4 add;
	vec4 multiply;
};







#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
struct CompositeShaderInput
{
	vec4 hPosition;
	vec2 texCoords;
	vec2 lowResTexCoords;
	vec4 clip_pos;
	vec2 depth_texc;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageCubeArrayTex[24];
	uint64_t nearFarTexture[24];
	uint64_t lightpassTexture[24];
	uint64_t depthTexture[24];
	uint64_t loss2dTexture[24];
	uint64_t inscatterVolumeTexture[24];
	uint64_t godraysVolumeTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
TwoColourCompositeOutput CompositeAtmospherics(vec4 clip_pos, uint64_t cloudCubeArray[24], uint64_t nearFarTexture[24], uint64_t lightpassTexture[24], uint64_t loss2dTexture[24], float dist, mat4 invViewProj, vec3 viewPos, uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], float maxFadeDistanceKm, float nearDist, bool do_lightpass, bool do_godrays, bool do_interp, bool do_near, bool do_clouds, vec3 fogColour, vec3 fogAmbient, bool do_height_fog, float fogExtinction, float fogHeightKm)
{
TwoColourCompositeOutput res;
vec3 view=normalize(mul(invViewProj,clip_pos).xyz);
float sine=view.z;
vec4 nearFarCloud=vec4(1.0,0.0,1,1);
if(do_interp)nearFarCloud=textureLod(samplerCube(nearFarTexture[1 + 4]),view,0);
;
float dist_rt=sqrt(abs(dist));
vec3 worldspaceVolumeTexCoords=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(sine)/3.1415926536),dist_rt);
vec4 insc=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),worldspaceVolumeTexCoords,0);
vec2 loss_texc=vec2(dist_rt,0.5*(1.f-sine));
float f=nearFarCloud.x;
float n=nearFarCloud.y;
float hiResInterp=1.0-saturate((f-dist)/max(0.000000001,f-n));
float cloudLevel=float(2-1)*hiResInterp;
float cloudLevel_0=floor(cloudLevel);
vec4 lp=vec4(0.0,0.0,0.0,0.0);
if(do_lightpass)lp=textureLod(samplerCube(lightpassTexture[1 + 4]),view,0);
;
vec4 cloudNear=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0));
vec4 cloud;
if(do_interp)
{
vec4 cloudFar=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0+1.0));
cloud=mix(cloudNear,cloudFar,fract(cloudLevel));
if(do_lightpass)
{
cloud.rgb+=lp.rgb;
}

if(do_near)
{
float nearInterp=saturate((dist-nearDist)/max(0.00000001,2.0*nearDist));
cloud=mix(vec4(0,0,0,1.0),cloud,nearInterp);
}

}
else

{
cloud=cloudNear;
}

if(do_godrays)
{
vec3 offsetKm=view*dist*maxFadeDistanceKm;
vec3 lightspaceOffset=mul(worldToScatteringVolumeMatrix,vec4(offsetKm,1.0)).xyz;
float r=length(lightspaceOffset);
vec3 lightspaceVolumeTexCoords=vec3(fract(atan(lightspaceOffset.x,lightspaceOffset.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceOffset.z/r)*2.0/3.1415926536,r);
vec4 godrays=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),lightspaceVolumeTexCoords,0);
insc.rgb*=godrays.x;
}

if(do_clouds)insc.rgb*=cloud.a;
if(do_clouds)insc+=cloud;
res.multiply=textureLod(sampler2D(loss2dTexture[1 + 5]),loss_texc,0)*cloud.a;
if(do_height_fog)
{
float H_km=fogHeightKm;
float d_solid=maxFadeDistanceKm*dist;
float z=viewPos.z/1000.0;
float transition=pow(saturate(H_km-z),0.5);
float zs=z+sine*d_solid;
float z_max=max(z,zs);
float z_min=min(z,zs);
float z_1=min(z_min,H_km);
float z_2=min(z_max,H_km);
float sn=max(0.0000000001,abs(sine));
float sn1=max(0.0000000001,(-sine));
float s1=min(dist,saturate((max(0,(z-z_2)/sn1))/maxFadeDistanceKm));
float above_fog=step(0,z-H_km);
float upwards=step(0,sine);
float dz=z_2-z_1;
float s=(1.0-above_fog*upwards)*min(maxFadeDistanceKm,min(d_solid,dz/sn));
float z_mean=0.5*(z_1+z_2);
s*=saturate((H_km-z_mean)/0.1);
float fog_in=1.0-saturate(exp(-s*fogExtinction));
vec3 fogLoss=vec3(1.0,1.0,1.0);
float rt_s1=sqrt(s1);

{
fogLoss*=fog_in*mix((1-(above_fog*(1-cloud.a)))*textureLod(sampler2D(loss2dTexture[1 + 5]),vec2(rt_s1,loss_texc.y),0).rgb,vec3(1,1,1),transition);
}

insc.rgb*=vec3(1.0,1.0,1.0)-fogLoss;
insc.rgb+=(fogColour+fogAmbient)*fogLoss;
res.multiply*=(1.0-fog_in);
}

res.add=insc;
return res;
}
#line 261 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput PS_CompositeAtmospherics(CompositeShaderInput IN, bool reverseDepth, bool doLightpass, bool doGodrays, bool doNear)
{
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
depthInterpretationStruct.reverseDepth=reverseDepth;
float depth=textureLod(sampler2D(depthTexture[1 + 14]),IN.depth_texc,0).x;
float dist=depthToFadeDistance(depth,IN.clip_pos.xy,depthInterpretationStruct,tanHalfFov);
TwoColourCompositeOutput result=CompositeAtmospherics(IN.clip_pos,imageCubeArrayTex,nearFarTexture,lightpassTexture,loss2dTexture,dist,invViewProj,viewPos,inscatterVolumeTexture,godraysVolumeTexture,maxFadeDistanceKm,nearDist,doLightpass,doGodrays,true,doNear,true,fogColour,fogAmbient,true,fogExtinction,fogCeilingKm);
result.add.rgb=pow(result.add.rgb,vec3(gamma,gamma,gamma));
result.add.rgb*=exposure;
return result;
}
layout(location = 0) in Block
{
CompositeShaderInput BlockData;
} ioblock;
layout(location = 0, index = 0) out vec4 add;

layout(location = 0, index = 1) out vec4 multiply;

void main()
{
CompositeShaderInput BlockData=ioblock.BlockData;
#line 418 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput tmp =  PS_CompositeAtmospherics(BlockData,false,true,true,true);
add = tmp.add;
multiply = tmp.multiply;

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_PS_CompositeAtmospherics_ForwardDepth_Lightpass_NearInterp.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
struct TwoColourCompositeOutput
{
	vec4 add;
	vec4 multiply;
};







#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
struct CompositeShaderInput
{
	vec4 hPosition;
	vec2 texCoords;
	vec2 lowResTexCoords;
	vec4 clip_pos;
	vec2 depth_texc;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageCubeArrayTex[24];
	uint64_t nearFarTexture[24];
	uint64_t lightpassTexture[24];
	uint64_t depthTexture[24];
	uint64_t loss2dTexture[24];
	uint64_t inscatterVolumeTexture[24];
	uint64_t godraysVolumeTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
TwoColourCompositeOutput CompositeAtmospherics(vec4 clip_pos, uint64_t cloudCubeArray[24], uint64_t nearFarTexture[24], uint64_t lightpassTexture[24], uint64_t loss2dTexture[24], float dist, mat4 invViewProj, vec3 viewPos, uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], float maxFadeDistanceKm, float nearDist, bool do_lightpass, bool do_godrays, bool do_interp, bool do_near, bool do_clouds, vec3 fogColour, vec3 fogAmbient, bool do_height_fog, float fogExtinction, float fogHeightKm)
{
TwoColourCompositeOutput res;
vec3 view=normalize(mul(invViewProj,clip_pos).xyz);
float sine=view.z;
vec4 nearFarCloud=vec4(1.0,0.0,1,1);
if(do_interp)nearFarCloud=textureLod(samplerCube(nearFarTexture[1 + 4]),view,0);
;
float dist_rt=sqrt(abs(dist));
vec3 worldspaceVolumeTexCoords=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(sine)/3.1415926536),dist_rt);
vec4 insc=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),worldspaceVolumeTexCoords,0);
vec2 loss_texc=vec2(dist_rt,0.5*(1.f-sine));
float f=nearFarCloud.x;
float n=nearFarCloud.y;
float hiResInterp=1.0-saturate((f-dist)/max(0.000000001,f-n));
float cloudLevel=float(2-1)*hiResInterp;
float cloudLevel_0=floor(cloudLevel);
vec4 lp=vec4(0.0,0.0,0.0,0.0);
if(do_lightpass)lp=textureLod(samplerCube(lightpassTexture[1 + 4]),view,0);
;
vec4 cloudNear=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0));
vec4 cloud;
if(do_interp)
{
vec4 cloudFar=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0+1.0));
cloud=mix(cloudNear,cloudFar,fract(cloudLevel));
if(do_lightpass)
{
cloud.rgb+=lp.rgb;
}

if(do_near)
{
float nearInterp=saturate((dist-nearDist)/max(0.00000001,2.0*nearDist));
cloud=mix(vec4(0,0,0,1.0),cloud,nearInterp);
}

}
else

{
cloud=cloudNear;
}

if(do_godrays)
{
vec3 offsetKm=view*dist*maxFadeDistanceKm;
vec3 lightspaceOffset=mul(worldToScatteringVolumeMatrix,vec4(offsetKm,1.0)).xyz;
float r=length(lightspaceOffset);
vec3 lightspaceVolumeTexCoords=vec3(fract(atan(lightspaceOffset.x,lightspaceOffset.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceOffset.z/r)*2.0/3.1415926536,r);
vec4 godrays=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),lightspaceVolumeTexCoords,0);
insc.rgb*=godrays.x;
}

if(do_clouds)insc.rgb*=cloud.a;
if(do_clouds)insc+=cloud;
res.multiply=textureLod(sampler2D(loss2dTexture[1 + 5]),loss_texc,0)*cloud.a;
if(do_height_fog)
{
float H_km=fogHeightKm;
float d_solid=maxFadeDistanceKm*dist;
float z=viewPos.z/1000.0;
float transition=pow(saturate(H_km-z),0.5);
float zs=z+sine*d_solid;
float z_max=max(z,zs);
float z_min=min(z,zs);
float z_1=min(z_min,H_km);
float z_2=min(z_max,H_km);
float sn=max(0.0000000001,abs(sine));
float sn1=max(0.0000000001,(-sine));
float s1=min(dist,saturate((max(0,(z-z_2)/sn1))/maxFadeDistanceKm));
float above_fog=step(0,z-H_km);
float upwards=step(0,sine);
float dz=z_2-z_1;
float s=(1.0-above_fog*upwards)*min(maxFadeDistanceKm,min(d_solid,dz/sn));
float z_mean=0.5*(z_1+z_2);
s*=saturate((H_km-z_mean)/0.1);
float fog_in=1.0-saturate(exp(-s*fogExtinction));
vec3 fogLoss=vec3(1.0,1.0,1.0);
float rt_s1=sqrt(s1);

{
fogLoss*=fog_in*mix((1-(above_fog*(1-cloud.a)))*textureLod(sampler2D(loss2dTexture[1 + 5]),vec2(rt_s1,loss_texc.y),0).rgb,vec3(1,1,1),transition);
}

insc.rgb*=vec3(1.0,1.0,1.0)-fogLoss;
insc.rgb+=(fogColour+fogAmbient)*fogLoss;
res.multiply*=(1.0-fog_in);
}

res.add=insc;
return res;
}
#line 261 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput PS_CompositeAtmospherics(CompositeShaderInput IN, bool reverseDepth, bool doLightpass, bool doGodrays, bool doNear)
{
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
depthInterpretationStruct.reverseDepth=reverseDepth;
float depth=textureLod(sampler2D(depthTexture[1 + 14]),IN.depth_texc,0).x;
float dist=depthToFadeDistance(depth,IN.clip_pos.xy,depthInterpretationStruct,tanHalfFov);
TwoColourCompositeOutput result=CompositeAtmospherics(IN.clip_pos,imageCubeArrayTex,nearFarTexture,lightpassTexture,loss2dTexture,dist,invViewProj,viewPos,inscatterVolumeTexture,godraysVolumeTexture,maxFadeDistanceKm,nearDist,doLightpass,doGodrays,true,doNear,true,fogColour,fogAmbient,true,fogExtinction,fogCeilingKm);
result.add.rgb=pow(result.add.rgb,vec3(gamma,gamma,gamma));
result.add.rgb*=exposure;
return result;
}
layout(location = 0) in Block
{
CompositeShaderInput BlockData;
} ioblock;
layout(location = 0, index = 0) out vec4 add;

layout(location = 0, index = 1) out vec4 multiply;

void main()
{
CompositeShaderInput BlockData=ioblock.BlockData;
#line 398 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput tmp =  PS_CompositeAtmospherics(BlockData,false,true,false,true);
add = tmp.add;
multiply = tmp.multiply;

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_PS_CompositeAtmospherics_ForwardDepth_NearInterp.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
struct TwoColourCompositeOutput
{
	vec4 add;
	vec4 multiply;
};







#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
struct CompositeShaderInput
{
	vec4 hPosition;
	vec2 texCoords;
	vec2 lowResTexCoords;
	vec4 clip_pos;
	vec2 depth_texc;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageCubeArrayTex[24];
	uint64_t nearFarTexture[24];
	uint64_t lightpassTexture[24];
	uint64_t depthTexture[24];
	uint64_t loss2dTexture[24];
	uint64_t inscatterVolumeTexture[24];
	uint64_t godraysVolumeTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
TwoColourCompositeOutput CompositeAtmospherics(vec4 clip_pos, uint64_t cloudCubeArray[24], uint64_t nearFarTexture[24], uint64_t lightpassTexture[24], uint64_t loss2dTexture[24], float dist, mat4 invViewProj, vec3 viewPos, uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], float maxFadeDistanceKm, float nearDist, bool do_lightpass, bool do_godrays, bool do_interp, bool do_near, bool do_clouds, vec3 fogColour, vec3 fogAmbient, bool do_height_fog, float fogExtinction, float fogHeightKm)
{
TwoColourCompositeOutput res;
vec3 view=normalize(mul(invViewProj,clip_pos).xyz);
float sine=view.z;
vec4 nearFarCloud=vec4(1.0,0.0,1,1);
if(do_interp)nearFarCloud=textureLod(samplerCube(nearFarTexture[1 + 4]),view,0);
;
float dist_rt=sqrt(abs(dist));
vec3 worldspaceVolumeTexCoords=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(sine)/3.1415926536),dist_rt);
vec4 insc=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),worldspaceVolumeTexCoords,0);
vec2 loss_texc=vec2(dist_rt,0.5*(1.f-sine));
float f=nearFarCloud.x;
float n=nearFarCloud.y;
float hiResInterp=1.0-saturate((f-dist)/max(0.000000001,f-n));
float cloudLevel=float(2-1)*hiResInterp;
float cloudLevel_0=floor(cloudLevel);
vec4 lp=vec4(0.0,0.0,0.0,0.0);
if(do_lightpass)lp=textureLod(samplerCube(lightpassTexture[1 + 4]),view,0);
;
vec4 cloudNear=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0));
vec4 cloud;
if(do_interp)
{
vec4 cloudFar=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0+1.0));
cloud=mix(cloudNear,cloudFar,fract(cloudLevel));
if(do_lightpass)
{
cloud.rgb+=lp.rgb;
}

if(do_near)
{
float nearInterp=saturate((dist-nearDist)/max(0.00000001,2.0*nearDist));
cloud=mix(vec4(0,0,0,1.0),cloud,nearInterp);
}

}
else

{
cloud=cloudNear;
}

if(do_godrays)
{
vec3 offsetKm=view*dist*maxFadeDistanceKm;
vec3 lightspaceOffset=mul(worldToScatteringVolumeMatrix,vec4(offsetKm,1.0)).xyz;
float r=length(lightspaceOffset);
vec3 lightspaceVolumeTexCoords=vec3(fract(atan(lightspaceOffset.x,lightspaceOffset.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceOffset.z/r)*2.0/3.1415926536,r);
vec4 godrays=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),lightspaceVolumeTexCoords,0);
insc.rgb*=godrays.x;
}

if(do_clouds)insc.rgb*=cloud.a;
if(do_clouds)insc+=cloud;
res.multiply=textureLod(sampler2D(loss2dTexture[1 + 5]),loss_texc,0)*cloud.a;
if(do_height_fog)
{
float H_km=fogHeightKm;
float d_solid=maxFadeDistanceKm*dist;
float z=viewPos.z/1000.0;
float transition=pow(saturate(H_km-z),0.5);
float zs=z+sine*d_solid;
float z_max=max(z,zs);
float z_min=min(z,zs);
float z_1=min(z_min,H_km);
float z_2=min(z_max,H_km);
float sn=max(0.0000000001,abs(sine));
float sn1=max(0.0000000001,(-sine));
float s1=min(dist,saturate((max(0,(z-z_2)/sn1))/maxFadeDistanceKm));
float above_fog=step(0,z-H_km);
float upwards=step(0,sine);
float dz=z_2-z_1;
float s=(1.0-above_fog*upwards)*min(maxFadeDistanceKm,min(d_solid,dz/sn));
float z_mean=0.5*(z_1+z_2);
s*=saturate((H_km-z_mean)/0.1);
float fog_in=1.0-saturate(exp(-s*fogExtinction));
vec3 fogLoss=vec3(1.0,1.0,1.0);
float rt_s1=sqrt(s1);

{
fogLoss*=fog_in*mix((1-(above_fog*(1-cloud.a)))*textureLod(sampler2D(loss2dTexture[1 + 5]),vec2(rt_s1,loss_texc.y),0).rgb,vec3(1,1,1),transition);
}

insc.rgb*=vec3(1.0,1.0,1.0)-fogLoss;
insc.rgb+=(fogColour+fogAmbient)*fogLoss;
res.multiply*=(1.0-fog_in);
}

res.add=insc;
return res;
}
#line 261 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput PS_CompositeAtmospherics(CompositeShaderInput IN, bool reverseDepth, bool doLightpass, bool doGodrays, bool doNear)
{
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
depthInterpretationStruct.reverseDepth=reverseDepth;
float depth=textureLod(sampler2D(depthTexture[1 + 14]),IN.depth_texc,0).x;
float dist=depthToFadeDistance(depth,IN.clip_pos.xy,depthInterpretationStruct,tanHalfFov);
TwoColourCompositeOutput result=CompositeAtmospherics(IN.clip_pos,imageCubeArrayTex,nearFarTexture,lightpassTexture,loss2dTexture,dist,invViewProj,viewPos,inscatterVolumeTexture,godraysVolumeTexture,maxFadeDistanceKm,nearDist,doLightpass,doGodrays,true,doNear,true,fogColour,fogAmbient,true,fogExtinction,fogCeilingKm);
result.add.rgb=pow(result.add.rgb,vec3(gamma,gamma,gamma));
result.add.rgb*=exposure;
return result;
}
layout(location = 0) in Block
{
CompositeShaderInput BlockData;
} ioblock;
layout(location = 0, index = 0) out vec4 add;

layout(location = 0, index = 1) out vec4 multiply;

void main()
{
CompositeShaderInput BlockData=ioblock.BlockData;
#line 388 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput tmp =  PS_CompositeAtmospherics(BlockData,false,false,false,true);
add = tmp.add;
multiply = tmp.multiply;

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_PS_CompositeAtmospherics_MSAA_ForwardDepth.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
struct TwoColourCompositeOutput
{
	vec4 add;
	vec4 multiply;
};







#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
struct CompositeShaderInput
{
	vec4 hPosition;
	vec2 texCoords;
	vec2 lowResTexCoords;
	vec4 clip_pos;
	vec2 depth_texc;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageCubeArrayTex[24];
	uint64_t nearFarTexture[24];
	uint64_t lightpassTexture[24];
	uint64_t depthTextureMS[24];
	uint64_t loss2dTexture[24];
	uint64_t inscatterVolumeTexture[24];
	uint64_t godraysVolumeTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 13 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite_msaa.sl"
TwoColourCompositeOutput CompositeAtmospherics_MSAA(vec4 clip_pos, vec2 depth_texc, uint64_t cloudCubeArray[24], uint64_t nearFarTexture[24], uint64_t lightpassTexture[24], uint64_t loss2dTexture[24], uint64_t depthTextureMS[24], int numSamples, uvec2 fullResDims, mat4 invViewProj, vec3 viewPos, vec4 viewportToTexRegionScaleBias, DepthInterpretationStruct depthInterpretationStruct, vec4 tanHalfFov, vec2 lowResTexCoords, uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], float maxFadeDistanceKm, float nearDist, bool do_lightpass, bool do_godrays, bool do_interp, bool do_near, bool do_clouds, vec3 fogColour, vec3 fogAmbient, bool do_height_fog, float fogExtinction, float fogHeightKm)
{
TwoColourCompositeOutput res;
vec3 view=normalize(mul(invViewProj,clip_pos).xyz);
float sine=view.z;
vec4 nearFarCloud=vec4(1.0,0.0,0,0);
if(do_interp)nearFarCloud=textureLod(samplerCube(nearFarTexture[1 + 4]),view,0);
;
ivec2 fullres_depth_pos2=ivec2(depth_texc*vec2(fullResDims.xy));
res.add=vec4(0,0,0,1.0);
res.multiply=vec4(0,0,0,0);
for(int k=0;k<numSamples;k++)
{
float depth=texelFetch(sampler2DMS(depthTextureMS[0]),ivec2(fullres_depth_pos2),int(k)).x;
float dist=depthToFadeDistance(depth,clip_pos.xy,depthInterpretationStruct,tanHalfFov);
float dist_rt=sqrt(dist);
vec3 offsetMetres=view*dist*1000.0*maxFadeDistanceKm;
vec3 worldspaceVolumeTexCoords=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(sine)/3.1415926536),dist_rt);
vec4 insc=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),worldspaceVolumeTexCoords,0);
vec2 loss_texc=vec2(dist_rt,0.5*(1.f-sine));
float f=nearFarCloud.x;
float n=nearFarCloud.y;
float hiResInterp=1.0-saturate((f-dist)/max(0.000000001,f-n));
float cloudLevel=float(2-1)*hiResInterp;
float cloudLevel_0=floor(cloudLevel);
vec4 lp;
if(do_lightpass)lp=textureLod(samplerCube(lightpassTexture[1 + 4]),view,0);
;
vec4 cloudNear=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0));
vec4 cloud;
if(do_interp)
{
vec4 cloudFar=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0+1.0));
if(do_lightpass)cloudFar.rgb+=lp.rgb;
cloud=mix(cloudNear,cloudFar,fract(cloudLevel));
if(do_near)
{
float nearInterp=saturate((dist-nearDist)/max(0.00000001,2.0*nearDist));
cloud=mix(vec4(0,0,0,1.0),cloud,nearInterp);
}

}
else

{
cloud=cloudNear;
}

if(do_godrays)
{
vec3 offsetKm=view*min(nearFarCloud.z,dist)*maxFadeDistanceKm;
vec3 lightspaceOffset1=(mul(worldToScatteringVolumeMatrix,vec4(offsetKm,1.0)).xyz);
float r=length(lightspaceOffset1);
vec3 lightspaceVolumeTexCoords=vec3(fract(atan(lightspaceOffset1.x,lightspaceOffset1.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceOffset1.z/r)*2.0/3.1415926536,r);
vec4 godrays=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),lightspaceVolumeTexCoords,0);
insc.rgb*=godrays.x;
}

if(do_clouds)insc.rgb*=cloud.a;
if(do_clouds)insc+=cloud;
vec4 multiply=textureLod(sampler2D(loss2dTexture[1 + 5]),loss_texc,0)*cloud.a;
if(do_height_fog)
{
float H_km=fogHeightKm;
float d_solid=maxFadeDistanceKm*dist;
float z=viewPos.z/1000.0;
float transition=pow(saturate(H_km-z),0.5);
float zs=z+sine*d_solid;
float z_max=max(z,zs);
float z_min=min(z,zs);
float z_1=min(z_min,H_km);
float z_2=min(z_max,H_km);
float sn=max(0.0000000001,abs(sine));
float sn1=max(0.0000000001,(-sine));
float s1=min(dist,saturate((max(0,(z-z_2)/sn1))/maxFadeDistanceKm));
float above_fog=step(0,z-H_km);
float upwards=step(0,sine);
float dz=z_2-z_1;
float s=(1.0-above_fog*upwards)*min(maxFadeDistanceKm,min(d_solid,dz/sn));
float z_mean=0.5*(z_1+z_2);
s*=saturate((H_km-z_mean)/0.1);
float fog_in=1.0-saturate(exp(-s*fogExtinction));
vec3 fogLoss=vec3(1.0,1.0,1.0);
float rt_s1=sqrt(s1);

{
fogLoss*=fog_in*mix((1-(above_fog*(1-cloud.a)))*textureLod(sampler2D(loss2dTexture[1 + 5]),vec2(rt_s1,loss_texc.y),0).rgb,vec3(1,1,1),transition);
}

insc.rgb*=vec3(1.0,1.0,1.0)-fogLoss;
insc.rgb+=(fogColour+fogAmbient)*fogLoss;
multiply*=(1.0-fog_in);
}

res.multiply+=multiply;
res.add+=insc;
}

res.multiply/=float(numSamples);
res.add/=float(numSamples);
return res;
}
#line 446 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA(CompositeShaderInput IN, bool reverseDepth, bool doLightpass, bool doGodrays, bool doNear)
{
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
depthInterpretationStruct.reverseDepth=reverseDepth;
TwoColourCompositeOutput result=CompositeAtmospherics_MSAA(IN.clip_pos,IN.depth_texc,imageCubeArrayTex,nearFarTexture,lightpassTexture,loss2dTexture,depthTextureMS,numSamples,ivec2(fullResDims),invViewProj,viewPos,viewportToTexRegionScaleBias,depthInterpretationStruct,tanHalfFov,IN.lowResTexCoords,inscatterVolumeTexture,godraysVolumeTexture,maxFadeDistanceKm,nearDist,doLightpass,doGodrays,true,doNear,true,fogColour,fogAmbient,true,fogExtinction,fogCeilingKm);
result.add.rgb=pow(result.add.rgb,vec3(gamma,gamma,gamma));
result.add.rgb*=exposure;
return result;
}
layout(location = 0) in Block
{
CompositeShaderInput BlockData;
} ioblock;
layout(location = 0, index = 0) out vec4 add;

layout(location = 0, index = 1) out vec4 multiply;

void main()
{
CompositeShaderInput BlockData=ioblock.BlockData;
#line 492 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput tmp =  PS_CompositeAtmospherics_MSAA(BlockData,false,false,true,true);
add = tmp.add;
multiply = tmp.multiply;

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_PS_CompositeAtmospherics_MSAA_LightPass_ForwardDepth.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
struct TwoColourCompositeOutput
{
	vec4 add;
	vec4 multiply;
};







#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
struct CompositeShaderInput
{
	vec4 hPosition;
	vec2 texCoords;
	vec2 lowResTexCoords;
	vec4 clip_pos;
	vec2 depth_texc;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageCubeArrayTex[24];
	uint64_t nearFarTexture[24];
	uint64_t lightpassTexture[24];
	uint64_t depthTextureMS[24];
	uint64_t loss2dTexture[24];
	uint64_t inscatterVolumeTexture[24];
	uint64_t godraysVolumeTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 13 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite_msaa.sl"
TwoColourCompositeOutput CompositeAtmospherics_MSAA(vec4 clip_pos, vec2 depth_texc, uint64_t cloudCubeArray[24], uint64_t nearFarTexture[24], uint64_t lightpassTexture[24], uint64_t loss2dTexture[24], uint64_t depthTextureMS[24], int numSamples, uvec2 fullResDims, mat4 invViewProj, vec3 viewPos, vec4 viewportToTexRegionScaleBias, DepthInterpretationStruct depthInterpretationStruct, vec4 tanHalfFov, vec2 lowResTexCoords, uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], float maxFadeDistanceKm, float nearDist, bool do_lightpass, bool do_godrays, bool do_interp, bool do_near, bool do_clouds, vec3 fogColour, vec3 fogAmbient, bool do_height_fog, float fogExtinction, float fogHeightKm)
{
TwoColourCompositeOutput res;
vec3 view=normalize(mul(invViewProj,clip_pos).xyz);
float sine=view.z;
vec4 nearFarCloud=vec4(1.0,0.0,0,0);
if(do_interp)nearFarCloud=textureLod(samplerCube(nearFarTexture[1 + 4]),view,0);
;
ivec2 fullres_depth_pos2=ivec2(depth_texc*vec2(fullResDims.xy));
res.add=vec4(0,0,0,1.0);
res.multiply=vec4(0,0,0,0);
for(int k=0;k<numSamples;k++)
{
float depth=texelFetch(sampler2DMS(depthTextureMS[0]),ivec2(fullres_depth_pos2),int(k)).x;
float dist=depthToFadeDistance(depth,clip_pos.xy,depthInterpretationStruct,tanHalfFov);
float dist_rt=sqrt(dist);
vec3 offsetMetres=view*dist*1000.0*maxFadeDistanceKm;
vec3 worldspaceVolumeTexCoords=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(sine)/3.1415926536),dist_rt);
vec4 insc=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),worldspaceVolumeTexCoords,0);
vec2 loss_texc=vec2(dist_rt,0.5*(1.f-sine));
float f=nearFarCloud.x;
float n=nearFarCloud.y;
float hiResInterp=1.0-saturate((f-dist)/max(0.000000001,f-n));
float cloudLevel=float(2-1)*hiResInterp;
float cloudLevel_0=floor(cloudLevel);
vec4 lp;
if(do_lightpass)lp=textureLod(samplerCube(lightpassTexture[1 + 4]),view,0);
;
vec4 cloudNear=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0));
vec4 cloud;
if(do_interp)
{
vec4 cloudFar=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0+1.0));
if(do_lightpass)cloudFar.rgb+=lp.rgb;
cloud=mix(cloudNear,cloudFar,fract(cloudLevel));
if(do_near)
{
float nearInterp=saturate((dist-nearDist)/max(0.00000001,2.0*nearDist));
cloud=mix(vec4(0,0,0,1.0),cloud,nearInterp);
}

}
else

{
cloud=cloudNear;
}

if(do_godrays)
{
vec3 offsetKm=view*min(nearFarCloud.z,dist)*maxFadeDistanceKm;
vec3 lightspaceOffset1=(mul(worldToScatteringVolumeMatrix,vec4(offsetKm,1.0)).xyz);
float r=length(lightspaceOffset1);
vec3 lightspaceVolumeTexCoords=vec3(fract(atan(lightspaceOffset1.x,lightspaceOffset1.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceOffset1.z/r)*2.0/3.1415926536,r);
vec4 godrays=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),lightspaceVolumeTexCoords,0);
insc.rgb*=godrays.x;
}

if(do_clouds)insc.rgb*=cloud.a;
if(do_clouds)insc+=cloud;
vec4 multiply=textureLod(sampler2D(loss2dTexture[1 + 5]),loss_texc,0)*cloud.a;
if(do_height_fog)
{
float H_km=fogHeightKm;
float d_solid=maxFadeDistanceKm*dist;
float z=viewPos.z/1000.0;
float transition=pow(saturate(H_km-z),0.5);
float zs=z+sine*d_solid;
float z_max=max(z,zs);
float z_min=min(z,zs);
float z_1=min(z_min,H_km);
float z_2=min(z_max,H_km);
float sn=max(0.0000000001,abs(sine));
float sn1=max(0.0000000001,(-sine));
float s1=min(dist,saturate((max(0,(z-z_2)/sn1))/maxFadeDistanceKm));
float above_fog=step(0,z-H_km);
float upwards=step(0,sine);
float dz=z_2-z_1;
float s=(1.0-above_fog*upwards)*min(maxFadeDistanceKm,min(d_solid,dz/sn));
float z_mean=0.5*(z_1+z_2);
s*=saturate((H_km-z_mean)/0.1);
float fog_in=1.0-saturate(exp(-s*fogExtinction));
vec3 fogLoss=vec3(1.0,1.0,1.0);
float rt_s1=sqrt(s1);

{
fogLoss*=fog_in*mix((1-(above_fog*(1-cloud.a)))*textureLod(sampler2D(loss2dTexture[1 + 5]),vec2(rt_s1,loss_texc.y),0).rgb,vec3(1,1,1),transition);
}

insc.rgb*=vec3(1.0,1.0,1.0)-fogLoss;
insc.rgb+=(fogColour+fogAmbient)*fogLoss;
multiply*=(1.0-fog_in);
}

res.multiply+=multiply;
res.add+=insc;
}

res.multiply/=float(numSamples);
res.add/=float(numSamples);
return res;
}
#line 446 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA(CompositeShaderInput IN, bool reverseDepth, bool doLightpass, bool doGodrays, bool doNear)
{
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
depthInterpretationStruct.reverseDepth=reverseDepth;
TwoColourCompositeOutput result=CompositeAtmospherics_MSAA(IN.clip_pos,IN.depth_texc,imageCubeArrayTex,nearFarTexture,lightpassTexture,loss2dTexture,depthTextureMS,numSamples,ivec2(fullResDims),invViewProj,viewPos,viewportToTexRegionScaleBias,depthInterpretationStruct,tanHalfFov,IN.lowResTexCoords,inscatterVolumeTexture,godraysVolumeTexture,maxFadeDistanceKm,nearDist,doLightpass,doGodrays,true,doNear,true,fogColour,fogAmbient,true,fogExtinction,fogCeilingKm);
result.add.rgb=pow(result.add.rgb,vec3(gamma,gamma,gamma));
result.add.rgb*=exposure;
return result;
}
layout(location = 0) in Block
{
CompositeShaderInput BlockData;
} ioblock;
layout(location = 0, index = 0) out vec4 add;

layout(location = 0, index = 1) out vec4 multiply;

void main()
{
CompositeShaderInput BlockData=ioblock.BlockData;
#line 502 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput tmp =  PS_CompositeAtmospherics_MSAA(BlockData,false,true,true,true);
add = tmp.add;
multiply = tmp.multiply;

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_PS_CompositeAtmospherics_MSAA_LightPass_ReverseDepth.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
struct TwoColourCompositeOutput
{
	vec4 add;
	vec4 multiply;
};







#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
struct CompositeShaderInput
{
	vec4 hPosition;
	vec2 texCoords;
	vec2 lowResTexCoords;
	vec4 clip_pos;
	vec2 depth_texc;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageCubeArrayTex[24];
	uint64_t nearFarTexture[24];
	uint64_t lightpassTexture[24];
	uint64_t depthTextureMS[24];
	uint64_t loss2dTexture[24];
	uint64_t inscatterVolumeTexture[24];
	uint64_t godraysVolumeTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 13 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite_msaa.sl"
TwoColourCompositeOutput CompositeAtmospherics_MSAA(vec4 clip_pos, vec2 depth_texc, uint64_t cloudCubeArray[24], uint64_t nearFarTexture[24], uint64_t lightpassTexture[24], uint64_t loss2dTexture[24], uint64_t depthTextureMS[24], int numSamples, uvec2 fullResDims, mat4 invViewProj, vec3 viewPos, vec4 viewportToTexRegionScaleBias, DepthInterpretationStruct depthInterpretationStruct, vec4 tanHalfFov, vec2 lowResTexCoords, uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], float maxFadeDistanceKm, float nearDist, bool do_lightpass, bool do_godrays, bool do_interp, bool do_near, bool do_clouds, vec3 fogColour, vec3 fogAmbient, bool do_height_fog, float fogExtinction, float fogHeightKm)
{
TwoColourCompositeOutput res;
vec3 view=normalize(mul(invViewProj,clip_pos).xyz);
float sine=view.z;
vec4 nearFarCloud=vec4(1.0,0.0,0,0);
if(do_interp)nearFarCloud=textureLod(samplerCube(nearFarTexture[1 + 4]),view,0);
;
ivec2 fullres_depth_pos2=ivec2(depth_texc*vec2(fullResDims.xy));
res.add=vec4(0,0,0,1.0);
res.multiply=vec4(0,0,0,0);
for(int k=0;k<numSamples;k++)
{
float depth=texelFetch(sampler2DMS(depthTextureMS[0]),ivec2(fullres_depth_pos2),int(k)).x;
float dist=depthToFadeDistance(depth,clip_pos.xy,depthInterpretationStruct,tanHalfFov);
float dist_rt=sqrt(dist);
vec3 offsetMetres=view*dist*1000.0*maxFadeDistanceKm;
vec3 worldspaceVolumeTexCoords=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(sine)/3.1415926536),dist_rt);
vec4 insc=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),worldspaceVolumeTexCoords,0);
vec2 loss_texc=vec2(dist_rt,0.5*(1.f-sine));
float f=nearFarCloud.x;
float n=nearFarCloud.y;
float hiResInterp=1.0-saturate((f-dist)/max(0.000000001,f-n));
float cloudLevel=float(2-1)*hiResInterp;
float cloudLevel_0=floor(cloudLevel);
vec4 lp;
if(do_lightpass)lp=textureLod(samplerCube(lightpassTexture[1 + 4]),view,0);
;
vec4 cloudNear=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0));
vec4 cloud;
if(do_interp)
{
vec4 cloudFar=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0+1.0));
if(do_lightpass)cloudFar.rgb+=lp.rgb;
cloud=mix(cloudNear,cloudFar,fract(cloudLevel));
if(do_near)
{
float nearInterp=saturate((dist-nearDist)/max(0.00000001,2.0*nearDist));
cloud=mix(vec4(0,0,0,1.0),cloud,nearInterp);
}

}
else

{
cloud=cloudNear;
}

if(do_godrays)
{
vec3 offsetKm=view*min(nearFarCloud.z,dist)*maxFadeDistanceKm;
vec3 lightspaceOffset1=(mul(worldToScatteringVolumeMatrix,vec4(offsetKm,1.0)).xyz);
float r=length(lightspaceOffset1);
vec3 lightspaceVolumeTexCoords=vec3(fract(atan(lightspaceOffset1.x,lightspaceOffset1.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceOffset1.z/r)*2.0/3.1415926536,r);
vec4 godrays=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),lightspaceVolumeTexCoords,0);
insc.rgb*=godrays.x;
}

if(do_clouds)insc.rgb*=cloud.a;
if(do_clouds)insc+=cloud;
vec4 multiply=textureLod(sampler2D(loss2dTexture[1 + 5]),loss_texc,0)*cloud.a;
if(do_height_fog)
{
float H_km=fogHeightKm;
float d_solid=maxFadeDistanceKm*dist;
float z=viewPos.z/1000.0;
float transition=pow(saturate(H_km-z),0.5);
float zs=z+sine*d_solid;
float z_max=max(z,zs);
float z_min=min(z,zs);
float z_1=min(z_min,H_km);
float z_2=min(z_max,H_km);
float sn=max(0.0000000001,abs(sine));
float sn1=max(0.0000000001,(-sine));
float s1=min(dist,saturate((max(0,(z-z_2)/sn1))/maxFadeDistanceKm));
float above_fog=step(0,z-H_km);
float upwards=step(0,sine);
float dz=z_2-z_1;
float s=(1.0-above_fog*upwards)*min(maxFadeDistanceKm,min(d_solid,dz/sn));
float z_mean=0.5*(z_1+z_2);
s*=saturate((H_km-z_mean)/0.1);
float fog_in=1.0-saturate(exp(-s*fogExtinction));
vec3 fogLoss=vec3(1.0,1.0,1.0);
float rt_s1=sqrt(s1);

{
fogLoss*=fog_in*mix((1-(above_fog*(1-cloud.a)))*textureLod(sampler2D(loss2dTexture[1 + 5]),vec2(rt_s1,loss_texc.y),0).rgb,vec3(1,1,1),transition);
}

insc.rgb*=vec3(1.0,1.0,1.0)-fogLoss;
insc.rgb+=(fogColour+fogAmbient)*fogLoss;
multiply*=(1.0-fog_in);
}

res.multiply+=multiply;
res.add+=insc;
}

res.multiply/=float(numSamples);
res.add/=float(numSamples);
return res;
}
#line 446 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA(CompositeShaderInput IN, bool reverseDepth, bool doLightpass, bool doGodrays, bool doNear)
{
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
depthInterpretationStruct.reverseDepth=reverseDepth;
TwoColourCompositeOutput result=CompositeAtmospherics_MSAA(IN.clip_pos,IN.depth_texc,imageCubeArrayTex,nearFarTexture,lightpassTexture,loss2dTexture,depthTextureMS,numSamples,ivec2(fullResDims),invViewProj,viewPos,viewportToTexRegionScaleBias,depthInterpretationStruct,tanHalfFov,IN.lowResTexCoords,inscatterVolumeTexture,godraysVolumeTexture,maxFadeDistanceKm,nearDist,doLightpass,doGodrays,true,doNear,true,fogColour,fogAmbient,true,fogExtinction,fogCeilingKm);
result.add.rgb=pow(result.add.rgb,vec3(gamma,gamma,gamma));
result.add.rgb*=exposure;
return result;
}
layout(location = 0) in Block
{
CompositeShaderInput BlockData;
} ioblock;
layout(location = 0, index = 0) out vec4 add;

layout(location = 0, index = 1) out vec4 multiply;

void main()
{
CompositeShaderInput BlockData=ioblock.BlockData;
#line 497 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput tmp =  PS_CompositeAtmospherics_MSAA(BlockData,true,true,true,true);
add = tmp.add;
multiply = tmp.multiply;

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_PS_CompositeAtmospherics_MSAA_ReverseDepth.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
struct TwoColourCompositeOutput
{
	vec4 add;
	vec4 multiply;
};







#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
struct CompositeShaderInput
{
	vec4 hPosition;
	vec2 texCoords;
	vec2 lowResTexCoords;
	vec4 clip_pos;
	vec2 depth_texc;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageCubeArrayTex[24];
	uint64_t nearFarTexture[24];
	uint64_t lightpassTexture[24];
	uint64_t depthTextureMS[24];
	uint64_t loss2dTexture[24];
	uint64_t inscatterVolumeTexture[24];
	uint64_t godraysVolumeTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 13 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite_msaa.sl"
TwoColourCompositeOutput CompositeAtmospherics_MSAA(vec4 clip_pos, vec2 depth_texc, uint64_t cloudCubeArray[24], uint64_t nearFarTexture[24], uint64_t lightpassTexture[24], uint64_t loss2dTexture[24], uint64_t depthTextureMS[24], int numSamples, uvec2 fullResDims, mat4 invViewProj, vec3 viewPos, vec4 viewportToTexRegionScaleBias, DepthInterpretationStruct depthInterpretationStruct, vec4 tanHalfFov, vec2 lowResTexCoords, uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], float maxFadeDistanceKm, float nearDist, bool do_lightpass, bool do_godrays, bool do_interp, bool do_near, bool do_clouds, vec3 fogColour, vec3 fogAmbient, bool do_height_fog, float fogExtinction, float fogHeightKm)
{
TwoColourCompositeOutput res;
vec3 view=normalize(mul(invViewProj,clip_pos).xyz);
float sine=view.z;
vec4 nearFarCloud=vec4(1.0,0.0,0,0);
if(do_interp)nearFarCloud=textureLod(samplerCube(nearFarTexture[1 + 4]),view,0);
;
ivec2 fullres_depth_pos2=ivec2(depth_texc*vec2(fullResDims.xy));
res.add=vec4(0,0,0,1.0);
res.multiply=vec4(0,0,0,0);
for(int k=0;k<numSamples;k++)
{
float depth=texelFetch(sampler2DMS(depthTextureMS[0]),ivec2(fullres_depth_pos2),int(k)).x;
float dist=depthToFadeDistance(depth,clip_pos.xy,depthInterpretationStruct,tanHalfFov);
float dist_rt=sqrt(dist);
vec3 offsetMetres=view*dist*1000.0*maxFadeDistanceKm;
vec3 worldspaceVolumeTexCoords=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(sine)/3.1415926536),dist_rt);
vec4 insc=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),worldspaceVolumeTexCoords,0);
vec2 loss_texc=vec2(dist_rt,0.5*(1.f-sine));
float f=nearFarCloud.x;
float n=nearFarCloud.y;
float hiResInterp=1.0-saturate((f-dist)/max(0.000000001,f-n));
float cloudLevel=float(2-1)*hiResInterp;
float cloudLevel_0=floor(cloudLevel);
vec4 lp;
if(do_lightpass)lp=textureLod(samplerCube(lightpassTexture[1 + 4]),view,0);
;
vec4 cloudNear=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0));
vec4 cloud;
if(do_interp)
{
vec4 cloudFar=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0+1.0));
if(do_lightpass)cloudFar.rgb+=lp.rgb;
cloud=mix(cloudNear,cloudFar,fract(cloudLevel));
if(do_near)
{
float nearInterp=saturate((dist-nearDist)/max(0.00000001,2.0*nearDist));
cloud=mix(vec4(0,0,0,1.0),cloud,nearInterp);
}

}
else

{
cloud=cloudNear;
}

if(do_godrays)
{
vec3 offsetKm=view*min(nearFarCloud.z,dist)*maxFadeDistanceKm;
vec3 lightspaceOffset1=(mul(worldToScatteringVolumeMatrix,vec4(offsetKm,1.0)).xyz);
float r=length(lightspaceOffset1);
vec3 lightspaceVolumeTexCoords=vec3(fract(atan(lightspaceOffset1.x,lightspaceOffset1.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceOffset1.z/r)*2.0/3.1415926536,r);
vec4 godrays=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),lightspaceVolumeTexCoords,0);
insc.rgb*=godrays.x;
}

if(do_clouds)insc.rgb*=cloud.a;
if(do_clouds)insc+=cloud;
vec4 multiply=textureLod(sampler2D(loss2dTexture[1 + 5]),loss_texc,0)*cloud.a;
if(do_height_fog)
{
float H_km=fogHeightKm;
float d_solid=maxFadeDistanceKm*dist;
float z=viewPos.z/1000.0;
float transition=pow(saturate(H_km-z),0.5);
float zs=z+sine*d_solid;
float z_max=max(z,zs);
float z_min=min(z,zs);
float z_1=min(z_min,H_km);
float z_2=min(z_max,H_km);
float sn=max(0.0000000001,abs(sine));
float sn1=max(0.0000000001,(-sine));
float s1=min(dist,saturate((max(0,(z-z_2)/sn1))/maxFadeDistanceKm));
float above_fog=step(0,z-H_km);
float upwards=step(0,sine);
float dz=z_2-z_1;
float s=(1.0-above_fog*upwards)*min(maxFadeDistanceKm,min(d_solid,dz/sn));
float z_mean=0.5*(z_1+z_2);
s*=saturate((H_km-z_mean)/0.1);
float fog_in=1.0-saturate(exp(-s*fogExtinction));
vec3 fogLoss=vec3(1.0,1.0,1.0);
float rt_s1=sqrt(s1);

{
fogLoss*=fog_in*mix((1-(above_fog*(1-cloud.a)))*textureLod(sampler2D(loss2dTexture[1 + 5]),vec2(rt_s1,loss_texc.y),0).rgb,vec3(1,1,1),transition);
}

insc.rgb*=vec3(1.0,1.0,1.0)-fogLoss;
insc.rgb+=(fogColour+fogAmbient)*fogLoss;
multiply*=(1.0-fog_in);
}

res.multiply+=multiply;
res.add+=insc;
}

res.multiply/=float(numSamples);
res.add/=float(numSamples);
return res;
}
#line 446 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput PS_CompositeAtmospherics_MSAA(CompositeShaderInput IN, bool reverseDepth, bool doLightpass, bool doGodrays, bool doNear)
{
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
depthInterpretationStruct.reverseDepth=reverseDepth;
TwoColourCompositeOutput result=CompositeAtmospherics_MSAA(IN.clip_pos,IN.depth_texc,imageCubeArrayTex,nearFarTexture,lightpassTexture,loss2dTexture,depthTextureMS,numSamples,ivec2(fullResDims),invViewProj,viewPos,viewportToTexRegionScaleBias,depthInterpretationStruct,tanHalfFov,IN.lowResTexCoords,inscatterVolumeTexture,godraysVolumeTexture,maxFadeDistanceKm,nearDist,doLightpass,doGodrays,true,doNear,true,fogColour,fogAmbient,true,fogExtinction,fogCeilingKm);
result.add.rgb=pow(result.add.rgb,vec3(gamma,gamma,gamma));
result.add.rgb*=exposure;
return result;
}
layout(location = 0) in Block
{
CompositeShaderInput BlockData;
} ioblock;
layout(location = 0, index = 0) out vec4 add;

layout(location = 0, index = 1) out vec4 multiply;

void main()
{
CompositeShaderInput BlockData=ioblock.BlockData;
#line 487 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput tmp =  PS_CompositeAtmospherics_MSAA(BlockData,true,false,true,true);
add = tmp.add;
multiply = tmp.multiply;

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_PS_CompositeAtmospherics_ReverseDepth.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
struct TwoColourCompositeOutput
{
	vec4 add;
	vec4 multiply;
};







#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
struct CompositeShaderInput
{
	vec4 hPosition;
	vec2 texCoords;
	vec2 lowResTexCoords;
	vec4 clip_pos;
	vec2 depth_texc;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageCubeArrayTex[24];
	uint64_t nearFarTexture[24];
	uint64_t lightpassTexture[24];
	uint64_t depthTexture[24];
	uint64_t loss2dTexture[24];
	uint64_t inscatterVolumeTexture[24];
	uint64_t godraysVolumeTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
TwoColourCompositeOutput CompositeAtmospherics(vec4 clip_pos, uint64_t cloudCubeArray[24], uint64_t nearFarTexture[24], uint64_t lightpassTexture[24], uint64_t loss2dTexture[24], float dist, mat4 invViewProj, vec3 viewPos, uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], float maxFadeDistanceKm, float nearDist, bool do_lightpass, bool do_godrays, bool do_interp, bool do_near, bool do_clouds, vec3 fogColour, vec3 fogAmbient, bool do_height_fog, float fogExtinction, float fogHeightKm)
{
TwoColourCompositeOutput res;
vec3 view=normalize(mul(invViewProj,clip_pos).xyz);
float sine=view.z;
vec4 nearFarCloud=vec4(1.0,0.0,1,1);
if(do_interp)nearFarCloud=textureLod(samplerCube(nearFarTexture[1 + 4]),view,0);
;
float dist_rt=sqrt(abs(dist));
vec3 worldspaceVolumeTexCoords=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(sine)/3.1415926536),dist_rt);
vec4 insc=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),worldspaceVolumeTexCoords,0);
vec2 loss_texc=vec2(dist_rt,0.5*(1.f-sine));
float f=nearFarCloud.x;
float n=nearFarCloud.y;
float hiResInterp=1.0-saturate((f-dist)/max(0.000000001,f-n));
float cloudLevel=float(2-1)*hiResInterp;
float cloudLevel_0=floor(cloudLevel);
vec4 lp=vec4(0.0,0.0,0.0,0.0);
if(do_lightpass)lp=textureLod(samplerCube(lightpassTexture[1 + 4]),view,0);
;
vec4 cloudNear=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0));
vec4 cloud;
if(do_interp)
{
vec4 cloudFar=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0+1.0));
cloud=mix(cloudNear,cloudFar,fract(cloudLevel));
if(do_lightpass)
{
cloud.rgb+=lp.rgb;
}

if(do_near)
{
float nearInterp=saturate((dist-nearDist)/max(0.00000001,2.0*nearDist));
cloud=mix(vec4(0,0,0,1.0),cloud,nearInterp);
}

}
else

{
cloud=cloudNear;
}

if(do_godrays)
{
vec3 offsetKm=view*dist*maxFadeDistanceKm;
vec3 lightspaceOffset=mul(worldToScatteringVolumeMatrix,vec4(offsetKm,1.0)).xyz;
float r=length(lightspaceOffset);
vec3 lightspaceVolumeTexCoords=vec3(fract(atan(lightspaceOffset.x,lightspaceOffset.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceOffset.z/r)*2.0/3.1415926536,r);
vec4 godrays=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),lightspaceVolumeTexCoords,0);
insc.rgb*=godrays.x;
}

if(do_clouds)insc.rgb*=cloud.a;
if(do_clouds)insc+=cloud;
res.multiply=textureLod(sampler2D(loss2dTexture[1 + 5]),loss_texc,0)*cloud.a;
if(do_height_fog)
{
float H_km=fogHeightKm;
float d_solid=maxFadeDistanceKm*dist;
float z=viewPos.z/1000.0;
float transition=pow(saturate(H_km-z),0.5);
float zs=z+sine*d_solid;
float z_max=max(z,zs);
float z_min=min(z,zs);
float z_1=min(z_min,H_km);
float z_2=min(z_max,H_km);
float sn=max(0.0000000001,abs(sine));
float sn1=max(0.0000000001,(-sine));
float s1=min(dist,saturate((max(0,(z-z_2)/sn1))/maxFadeDistanceKm));
float above_fog=step(0,z-H_km);
float upwards=step(0,sine);
float dz=z_2-z_1;
float s=(1.0-above_fog*upwards)*min(maxFadeDistanceKm,min(d_solid,dz/sn));
float z_mean=0.5*(z_1+z_2);
s*=saturate((H_km-z_mean)/0.1);
float fog_in=1.0-saturate(exp(-s*fogExtinction));
vec3 fogLoss=vec3(1.0,1.0,1.0);
float rt_s1=sqrt(s1);

{
fogLoss*=fog_in*mix((1-(above_fog*(1-cloud.a)))*textureLod(sampler2D(loss2dTexture[1 + 5]),vec2(rt_s1,loss_texc.y),0).rgb,vec3(1,1,1),transition);
}

insc.rgb*=vec3(1.0,1.0,1.0)-fogLoss;
insc.rgb+=(fogColour+fogAmbient)*fogLoss;
res.multiply*=(1.0-fog_in);
}

res.add=insc;
return res;
}
#line 261 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput PS_CompositeAtmospherics(CompositeShaderInput IN, bool reverseDepth, bool doLightpass, bool doGodrays, bool doNear)
{
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
depthInterpretationStruct.reverseDepth=reverseDepth;
float depth=textureLod(sampler2D(depthTexture[1 + 14]),IN.depth_texc,0).x;
float dist=depthToFadeDistance(depth,IN.clip_pos.xy,depthInterpretationStruct,tanHalfFov);
TwoColourCompositeOutput result=CompositeAtmospherics(IN.clip_pos,imageCubeArrayTex,nearFarTexture,lightpassTexture,loss2dTexture,dist,invViewProj,viewPos,inscatterVolumeTexture,godraysVolumeTexture,maxFadeDistanceKm,nearDist,doLightpass,doGodrays,true,doNear,true,fogColour,fogAmbient,true,fogExtinction,fogCeilingKm);
result.add.rgb=pow(result.add.rgb,vec3(gamma,gamma,gamma));
result.add.rgb*=exposure;
return result;
}
layout(location = 0) in Block
{
CompositeShaderInput BlockData;
} ioblock;
layout(location = 0, index = 0) out vec4 add;

layout(location = 0, index = 1) out vec4 multiply;

void main()
{
CompositeShaderInput BlockData=ioblock.BlockData;
#line 343 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput tmp =  PS_CompositeAtmospherics(BlockData,true,false,false,false);
add = tmp.add;
multiply = tmp.multiply;

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_PS_CompositeAtmospherics_ReverseDepth_Godrays.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
struct TwoColourCompositeOutput
{
	vec4 add;
	vec4 multiply;
};







#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
struct CompositeShaderInput
{
	vec4 hPosition;
	vec2 texCoords;
	vec2 lowResTexCoords;
	vec4 clip_pos;
	vec2 depth_texc;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageCubeArrayTex[24];
	uint64_t nearFarTexture[24];
	uint64_t lightpassTexture[24];
	uint64_t depthTexture[24];
	uint64_t loss2dTexture[24];
	uint64_t inscatterVolumeTexture[24];
	uint64_t godraysVolumeTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
TwoColourCompositeOutput CompositeAtmospherics(vec4 clip_pos, uint64_t cloudCubeArray[24], uint64_t nearFarTexture[24], uint64_t lightpassTexture[24], uint64_t loss2dTexture[24], float dist, mat4 invViewProj, vec3 viewPos, uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], float maxFadeDistanceKm, float nearDist, bool do_lightpass, bool do_godrays, bool do_interp, bool do_near, bool do_clouds, vec3 fogColour, vec3 fogAmbient, bool do_height_fog, float fogExtinction, float fogHeightKm)
{
TwoColourCompositeOutput res;
vec3 view=normalize(mul(invViewProj,clip_pos).xyz);
float sine=view.z;
vec4 nearFarCloud=vec4(1.0,0.0,1,1);
if(do_interp)nearFarCloud=textureLod(samplerCube(nearFarTexture[1 + 4]),view,0);
;
float dist_rt=sqrt(abs(dist));
vec3 worldspaceVolumeTexCoords=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(sine)/3.1415926536),dist_rt);
vec4 insc=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),worldspaceVolumeTexCoords,0);
vec2 loss_texc=vec2(dist_rt,0.5*(1.f-sine));
float f=nearFarCloud.x;
float n=nearFarCloud.y;
float hiResInterp=1.0-saturate((f-dist)/max(0.000000001,f-n));
float cloudLevel=float(2-1)*hiResInterp;
float cloudLevel_0=floor(cloudLevel);
vec4 lp=vec4(0.0,0.0,0.0,0.0);
if(do_lightpass)lp=textureLod(samplerCube(lightpassTexture[1 + 4]),view,0);
;
vec4 cloudNear=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0));
vec4 cloud;
if(do_interp)
{
vec4 cloudFar=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0+1.0));
cloud=mix(cloudNear,cloudFar,fract(cloudLevel));
if(do_lightpass)
{
cloud.rgb+=lp.rgb;
}

if(do_near)
{
float nearInterp=saturate((dist-nearDist)/max(0.00000001,2.0*nearDist));
cloud=mix(vec4(0,0,0,1.0),cloud,nearInterp);
}

}
else

{
cloud=cloudNear;
}

if(do_godrays)
{
vec3 offsetKm=view*dist*maxFadeDistanceKm;
vec3 lightspaceOffset=mul(worldToScatteringVolumeMatrix,vec4(offsetKm,1.0)).xyz;
float r=length(lightspaceOffset);
vec3 lightspaceVolumeTexCoords=vec3(fract(atan(lightspaceOffset.x,lightspaceOffset.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceOffset.z/r)*2.0/3.1415926536,r);
vec4 godrays=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),lightspaceVolumeTexCoords,0);
insc.rgb*=godrays.x;
}

if(do_clouds)insc.rgb*=cloud.a;
if(do_clouds)insc+=cloud;
res.multiply=textureLod(sampler2D(loss2dTexture[1 + 5]),loss_texc,0)*cloud.a;
if(do_height_fog)
{
float H_km=fogHeightKm;
float d_solid=maxFadeDistanceKm*dist;
float z=viewPos.z/1000.0;
float transition=pow(saturate(H_km-z),0.5);
float zs=z+sine*d_solid;
float z_max=max(z,zs);
float z_min=min(z,zs);
float z_1=min(z_min,H_km);
float z_2=min(z_max,H_km);
float sn=max(0.0000000001,abs(sine));
float sn1=max(0.0000000001,(-sine));
float s1=min(dist,saturate((max(0,(z-z_2)/sn1))/maxFadeDistanceKm));
float above_fog=step(0,z-H_km);
float upwards=step(0,sine);
float dz=z_2-z_1;
float s=(1.0-above_fog*upwards)*min(maxFadeDistanceKm,min(d_solid,dz/sn));
float z_mean=0.5*(z_1+z_2);
s*=saturate((H_km-z_mean)/0.1);
float fog_in=1.0-saturate(exp(-s*fogExtinction));
vec3 fogLoss=vec3(1.0,1.0,1.0);
float rt_s1=sqrt(s1);

{
fogLoss*=fog_in*mix((1-(above_fog*(1-cloud.a)))*textureLod(sampler2D(loss2dTexture[1 + 5]),vec2(rt_s1,loss_texc.y),0).rgb,vec3(1,1,1),transition);
}

insc.rgb*=vec3(1.0,1.0,1.0)-fogLoss;
insc.rgb+=(fogColour+fogAmbient)*fogLoss;
res.multiply*=(1.0-fog_in);
}

res.add=insc;
return res;
}
#line 261 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput PS_CompositeAtmospherics(CompositeShaderInput IN, bool reverseDepth, bool doLightpass, bool doGodrays, bool doNear)
{
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
depthInterpretationStruct.reverseDepth=reverseDepth;
float depth=textureLod(sampler2D(depthTexture[1 + 14]),IN.depth_texc,0).x;
float dist=depthToFadeDistance(depth,IN.clip_pos.xy,depthInterpretationStruct,tanHalfFov);
TwoColourCompositeOutput result=CompositeAtmospherics(IN.clip_pos,imageCubeArrayTex,nearFarTexture,lightpassTexture,loss2dTexture,dist,invViewProj,viewPos,inscatterVolumeTexture,godraysVolumeTexture,maxFadeDistanceKm,nearDist,doLightpass,doGodrays,true,doNear,true,fogColour,fogAmbient,true,fogExtinction,fogCeilingKm);
result.add.rgb=pow(result.add.rgb,vec3(gamma,gamma,gamma));
result.add.rgb*=exposure;
return result;
}
layout(location = 0) in Block
{
CompositeShaderInput BlockData;
} ioblock;
layout(location = 0, index = 0) out vec4 add;

layout(location = 0, index = 1) out vec4 multiply;

void main()
{
CompositeShaderInput BlockData=ioblock.BlockData;
#line 363 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput tmp =  PS_CompositeAtmospherics(BlockData,true,false,true,false);
add = tmp.add;
multiply = tmp.multiply;

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_PS_CompositeAtmospherics_ReverseDepth_Godrays_NearInterp.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
struct TwoColourCompositeOutput
{
	vec4 add;
	vec4 multiply;
};







#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
struct CompositeShaderInput
{
	vec4 hPosition;
	vec2 texCoords;
	vec2 lowResTexCoords;
	vec4 clip_pos;
	vec2 depth_texc;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageCubeArrayTex[24];
	uint64_t nearFarTexture[24];
	uint64_t lightpassTexture[24];
	uint64_t depthTexture[24];
	uint64_t loss2dTexture[24];
	uint64_t inscatterVolumeTexture[24];
	uint64_t godraysVolumeTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
TwoColourCompositeOutput CompositeAtmospherics(vec4 clip_pos, uint64_t cloudCubeArray[24], uint64_t nearFarTexture[24], uint64_t lightpassTexture[24], uint64_t loss2dTexture[24], float dist, mat4 invViewProj, vec3 viewPos, uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], float maxFadeDistanceKm, float nearDist, bool do_lightpass, bool do_godrays, bool do_interp, bool do_near, bool do_clouds, vec3 fogColour, vec3 fogAmbient, bool do_height_fog, float fogExtinction, float fogHeightKm)
{
TwoColourCompositeOutput res;
vec3 view=normalize(mul(invViewProj,clip_pos).xyz);
float sine=view.z;
vec4 nearFarCloud=vec4(1.0,0.0,1,1);
if(do_interp)nearFarCloud=textureLod(samplerCube(nearFarTexture[1 + 4]),view,0);
;
float dist_rt=sqrt(abs(dist));
vec3 worldspaceVolumeTexCoords=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(sine)/3.1415926536),dist_rt);
vec4 insc=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),worldspaceVolumeTexCoords,0);
vec2 loss_texc=vec2(dist_rt,0.5*(1.f-sine));
float f=nearFarCloud.x;
float n=nearFarCloud.y;
float hiResInterp=1.0-saturate((f-dist)/max(0.000000001,f-n));
float cloudLevel=float(2-1)*hiResInterp;
float cloudLevel_0=floor(cloudLevel);
vec4 lp=vec4(0.0,0.0,0.0,0.0);
if(do_lightpass)lp=textureLod(samplerCube(lightpassTexture[1 + 4]),view,0);
;
vec4 cloudNear=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0));
vec4 cloud;
if(do_interp)
{
vec4 cloudFar=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0+1.0));
cloud=mix(cloudNear,cloudFar,fract(cloudLevel));
if(do_lightpass)
{
cloud.rgb+=lp.rgb;
}

if(do_near)
{
float nearInterp=saturate((dist-nearDist)/max(0.00000001,2.0*nearDist));
cloud=mix(vec4(0,0,0,1.0),cloud,nearInterp);
}

}
else

{
cloud=cloudNear;
}

if(do_godrays)
{
vec3 offsetKm=view*dist*maxFadeDistanceKm;
vec3 lightspaceOffset=mul(worldToScatteringVolumeMatrix,vec4(offsetKm,1.0)).xyz;
float r=length(lightspaceOffset);
vec3 lightspaceVolumeTexCoords=vec3(fract(atan(lightspaceOffset.x,lightspaceOffset.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceOffset.z/r)*2.0/3.1415926536,r);
vec4 godrays=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),lightspaceVolumeTexCoords,0);
insc.rgb*=godrays.x;
}

if(do_clouds)insc.rgb*=cloud.a;
if(do_clouds)insc+=cloud;
res.multiply=textureLod(sampler2D(loss2dTexture[1 + 5]),loss_texc,0)*cloud.a;
if(do_height_fog)
{
float H_km=fogHeightKm;
float d_solid=maxFadeDistanceKm*dist;
float z=viewPos.z/1000.0;
float transition=pow(saturate(H_km-z),0.5);
float zs=z+sine*d_solid;
float z_max=max(z,zs);
float z_min=min(z,zs);
float z_1=min(z_min,H_km);
float z_2=min(z_max,H_km);
float sn=max(0.0000000001,abs(sine));
float sn1=max(0.0000000001,(-sine));
float s1=min(dist,saturate((max(0,(z-z_2)/sn1))/maxFadeDistanceKm));
float above_fog=step(0,z-H_km);
float upwards=step(0,sine);
float dz=z_2-z_1;
float s=(1.0-above_fog*upwards)*min(maxFadeDistanceKm,min(d_solid,dz/sn));
float z_mean=0.5*(z_1+z_2);
s*=saturate((H_km-z_mean)/0.1);
float fog_in=1.0-saturate(exp(-s*fogExtinction));
vec3 fogLoss=vec3(1.0,1.0,1.0);
float rt_s1=sqrt(s1);

{
fogLoss*=fog_in*mix((1-(above_fog*(1-cloud.a)))*textureLod(sampler2D(loss2dTexture[1 + 5]),vec2(rt_s1,loss_texc.y),0).rgb,vec3(1,1,1),transition);
}

insc.rgb*=vec3(1.0,1.0,1.0)-fogLoss;
insc.rgb+=(fogColour+fogAmbient)*fogLoss;
res.multiply*=(1.0-fog_in);
}

res.add=insc;
return res;
}
#line 261 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput PS_CompositeAtmospherics(CompositeShaderInput IN, bool reverseDepth, bool doLightpass, bool doGodrays, bool doNear)
{
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
depthInterpretationStruct.reverseDepth=reverseDepth;
float depth=textureLod(sampler2D(depthTexture[1 + 14]),IN.depth_texc,0).x;
float dist=depthToFadeDistance(depth,IN.clip_pos.xy,depthInterpretationStruct,tanHalfFov);
TwoColourCompositeOutput result=CompositeAtmospherics(IN.clip_pos,imageCubeArrayTex,nearFarTexture,lightpassTexture,loss2dTexture,dist,invViewProj,viewPos,inscatterVolumeTexture,godraysVolumeTexture,maxFadeDistanceKm,nearDist,doLightpass,doGodrays,true,doNear,true,fogColour,fogAmbient,true,fogExtinction,fogCeilingKm);
result.add.rgb=pow(result.add.rgb,vec3(gamma,gamma,gamma));
result.add.rgb*=exposure;
return result;
}
layout(location = 0) in Block
{
CompositeShaderInput BlockData;
} ioblock;
layout(location = 0, index = 0) out vec4 add;

layout(location = 0, index = 1) out vec4 multiply;

void main()
{
CompositeShaderInput BlockData=ioblock.BlockData;
#line 403 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput tmp =  PS_CompositeAtmospherics(BlockData,true,false,true,true);
add = tmp.add;
multiply = tmp.multiply;

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_PS_CompositeAtmospherics_ReverseDepth_Lightpass.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
struct TwoColourCompositeOutput
{
	vec4 add;
	vec4 multiply;
};







#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
struct CompositeShaderInput
{
	vec4 hPosition;
	vec2 texCoords;
	vec2 lowResTexCoords;
	vec4 clip_pos;
	vec2 depth_texc;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageCubeArrayTex[24];
	uint64_t nearFarTexture[24];
	uint64_t lightpassTexture[24];
	uint64_t depthTexture[24];
	uint64_t loss2dTexture[24];
	uint64_t inscatterVolumeTexture[24];
	uint64_t godraysVolumeTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
TwoColourCompositeOutput CompositeAtmospherics(vec4 clip_pos, uint64_t cloudCubeArray[24], uint64_t nearFarTexture[24], uint64_t lightpassTexture[24], uint64_t loss2dTexture[24], float dist, mat4 invViewProj, vec3 viewPos, uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], float maxFadeDistanceKm, float nearDist, bool do_lightpass, bool do_godrays, bool do_interp, bool do_near, bool do_clouds, vec3 fogColour, vec3 fogAmbient, bool do_height_fog, float fogExtinction, float fogHeightKm)
{
TwoColourCompositeOutput res;
vec3 view=normalize(mul(invViewProj,clip_pos).xyz);
float sine=view.z;
vec4 nearFarCloud=vec4(1.0,0.0,1,1);
if(do_interp)nearFarCloud=textureLod(samplerCube(nearFarTexture[1 + 4]),view,0);
;
float dist_rt=sqrt(abs(dist));
vec3 worldspaceVolumeTexCoords=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(sine)/3.1415926536),dist_rt);
vec4 insc=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),worldspaceVolumeTexCoords,0);
vec2 loss_texc=vec2(dist_rt,0.5*(1.f-sine));
float f=nearFarCloud.x;
float n=nearFarCloud.y;
float hiResInterp=1.0-saturate((f-dist)/max(0.000000001,f-n));
float cloudLevel=float(2-1)*hiResInterp;
float cloudLevel_0=floor(cloudLevel);
vec4 lp=vec4(0.0,0.0,0.0,0.0);
if(do_lightpass)lp=textureLod(samplerCube(lightpassTexture[1 + 4]),view,0);
;
vec4 cloudNear=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0));
vec4 cloud;
if(do_interp)
{
vec4 cloudFar=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0+1.0));
cloud=mix(cloudNear,cloudFar,fract(cloudLevel));
if(do_lightpass)
{
cloud.rgb+=lp.rgb;
}

if(do_near)
{
float nearInterp=saturate((dist-nearDist)/max(0.00000001,2.0*nearDist));
cloud=mix(vec4(0,0,0,1.0),cloud,nearInterp);
}

}
else

{
cloud=cloudNear;
}

if(do_godrays)
{
vec3 offsetKm=view*dist*maxFadeDistanceKm;
vec3 lightspaceOffset=mul(worldToScatteringVolumeMatrix,vec4(offsetKm,1.0)).xyz;
float r=length(lightspaceOffset);
vec3 lightspaceVolumeTexCoords=vec3(fract(atan(lightspaceOffset.x,lightspaceOffset.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceOffset.z/r)*2.0/3.1415926536,r);
vec4 godrays=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),lightspaceVolumeTexCoords,0);
insc.rgb*=godrays.x;
}

if(do_clouds)insc.rgb*=cloud.a;
if(do_clouds)insc+=cloud;
res.multiply=textureLod(sampler2D(loss2dTexture[1 + 5]),loss_texc,0)*cloud.a;
if(do_height_fog)
{
float H_km=fogHeightKm;
float d_solid=maxFadeDistanceKm*dist;
float z=viewPos.z/1000.0;
float transition=pow(saturate(H_km-z),0.5);
float zs=z+sine*d_solid;
float z_max=max(z,zs);
float z_min=min(z,zs);
float z_1=min(z_min,H_km);
float z_2=min(z_max,H_km);
float sn=max(0.0000000001,abs(sine));
float sn1=max(0.0000000001,(-sine));
float s1=min(dist,saturate((max(0,(z-z_2)/sn1))/maxFadeDistanceKm));
float above_fog=step(0,z-H_km);
float upwards=step(0,sine);
float dz=z_2-z_1;
float s=(1.0-above_fog*upwards)*min(maxFadeDistanceKm,min(d_solid,dz/sn));
float z_mean=0.5*(z_1+z_2);
s*=saturate((H_km-z_mean)/0.1);
float fog_in=1.0-saturate(exp(-s*fogExtinction));
vec3 fogLoss=vec3(1.0,1.0,1.0);
float rt_s1=sqrt(s1);

{
fogLoss*=fog_in*mix((1-(above_fog*(1-cloud.a)))*textureLod(sampler2D(loss2dTexture[1 + 5]),vec2(rt_s1,loss_texc.y),0).rgb,vec3(1,1,1),transition);
}

insc.rgb*=vec3(1.0,1.0,1.0)-fogLoss;
insc.rgb+=(fogColour+fogAmbient)*fogLoss;
res.multiply*=(1.0-fog_in);
}

res.add=insc;
return res;
}
#line 261 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput PS_CompositeAtmospherics(CompositeShaderInput IN, bool reverseDepth, bool doLightpass, bool doGodrays, bool doNear)
{
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
depthInterpretationStruct.reverseDepth=reverseDepth;
float depth=textureLod(sampler2D(depthTexture[1 + 14]),IN.depth_texc,0).x;
float dist=depthToFadeDistance(depth,IN.clip_pos.xy,depthInterpretationStruct,tanHalfFov);
TwoColourCompositeOutput result=CompositeAtmospherics(IN.clip_pos,imageCubeArrayTex,nearFarTexture,lightpassTexture,loss2dTexture,dist,invViewProj,viewPos,inscatterVolumeTexture,godraysVolumeTexture,maxFadeDistanceKm,nearDist,doLightpass,doGodrays,true,doNear,true,fogColour,fogAmbient,true,fogExtinction,fogCeilingKm);
result.add.rgb=pow(result.add.rgb,vec3(gamma,gamma,gamma));
result.add.rgb*=exposure;
return result;
}
layout(location = 0) in Block
{
CompositeShaderInput BlockData;
} ioblock;
layout(location = 0, index = 0) out vec4 add;

layout(location = 0, index = 1) out vec4 multiply;

void main()
{
CompositeShaderInput BlockData=ioblock.BlockData;
#line 353 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput tmp =  PS_CompositeAtmospherics(BlockData,true,true,false,false);
add = tmp.add;
multiply = tmp.multiply;

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_PS_CompositeAtmospherics_ReverseDepth_Lightpass_Godrays.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
struct TwoColourCompositeOutput
{
	vec4 add;
	vec4 multiply;
};







#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
struct CompositeShaderInput
{
	vec4 hPosition;
	vec2 texCoords;
	vec2 lowResTexCoords;
	vec4 clip_pos;
	vec2 depth_texc;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageCubeArrayTex[24];
	uint64_t nearFarTexture[24];
	uint64_t lightpassTexture[24];
	uint64_t depthTexture[24];
	uint64_t loss2dTexture[24];
	uint64_t inscatterVolumeTexture[24];
	uint64_t godraysVolumeTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
TwoColourCompositeOutput CompositeAtmospherics(vec4 clip_pos, uint64_t cloudCubeArray[24], uint64_t nearFarTexture[24], uint64_t lightpassTexture[24], uint64_t loss2dTexture[24], float dist, mat4 invViewProj, vec3 viewPos, uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], float maxFadeDistanceKm, float nearDist, bool do_lightpass, bool do_godrays, bool do_interp, bool do_near, bool do_clouds, vec3 fogColour, vec3 fogAmbient, bool do_height_fog, float fogExtinction, float fogHeightKm)
{
TwoColourCompositeOutput res;
vec3 view=normalize(mul(invViewProj,clip_pos).xyz);
float sine=view.z;
vec4 nearFarCloud=vec4(1.0,0.0,1,1);
if(do_interp)nearFarCloud=textureLod(samplerCube(nearFarTexture[1 + 4]),view,0);
;
float dist_rt=sqrt(abs(dist));
vec3 worldspaceVolumeTexCoords=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(sine)/3.1415926536),dist_rt);
vec4 insc=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),worldspaceVolumeTexCoords,0);
vec2 loss_texc=vec2(dist_rt,0.5*(1.f-sine));
float f=nearFarCloud.x;
float n=nearFarCloud.y;
float hiResInterp=1.0-saturate((f-dist)/max(0.000000001,f-n));
float cloudLevel=float(2-1)*hiResInterp;
float cloudLevel_0=floor(cloudLevel);
vec4 lp=vec4(0.0,0.0,0.0,0.0);
if(do_lightpass)lp=textureLod(samplerCube(lightpassTexture[1 + 4]),view,0);
;
vec4 cloudNear=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0));
vec4 cloud;
if(do_interp)
{
vec4 cloudFar=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0+1.0));
cloud=mix(cloudNear,cloudFar,fract(cloudLevel));
if(do_lightpass)
{
cloud.rgb+=lp.rgb;
}

if(do_near)
{
float nearInterp=saturate((dist-nearDist)/max(0.00000001,2.0*nearDist));
cloud=mix(vec4(0,0,0,1.0),cloud,nearInterp);
}

}
else

{
cloud=cloudNear;
}

if(do_godrays)
{
vec3 offsetKm=view*dist*maxFadeDistanceKm;
vec3 lightspaceOffset=mul(worldToScatteringVolumeMatrix,vec4(offsetKm,1.0)).xyz;
float r=length(lightspaceOffset);
vec3 lightspaceVolumeTexCoords=vec3(fract(atan(lightspaceOffset.x,lightspaceOffset.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceOffset.z/r)*2.0/3.1415926536,r);
vec4 godrays=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),lightspaceVolumeTexCoords,0);
insc.rgb*=godrays.x;
}

if(do_clouds)insc.rgb*=cloud.a;
if(do_clouds)insc+=cloud;
res.multiply=textureLod(sampler2D(loss2dTexture[1 + 5]),loss_texc,0)*cloud.a;
if(do_height_fog)
{
float H_km=fogHeightKm;
float d_solid=maxFadeDistanceKm*dist;
float z=viewPos.z/1000.0;
float transition=pow(saturate(H_km-z),0.5);
float zs=z+sine*d_solid;
float z_max=max(z,zs);
float z_min=min(z,zs);
float z_1=min(z_min,H_km);
float z_2=min(z_max,H_km);
float sn=max(0.0000000001,abs(sine));
float sn1=max(0.0000000001,(-sine));
float s1=min(dist,saturate((max(0,(z-z_2)/sn1))/maxFadeDistanceKm));
float above_fog=step(0,z-H_km);
float upwards=step(0,sine);
float dz=z_2-z_1;
float s=(1.0-above_fog*upwards)*min(maxFadeDistanceKm,min(d_solid,dz/sn));
float z_mean=0.5*(z_1+z_2);
s*=saturate((H_km-z_mean)/0.1);
float fog_in=1.0-saturate(exp(-s*fogExtinction));
vec3 fogLoss=vec3(1.0,1.0,1.0);
float rt_s1=sqrt(s1);

{
fogLoss*=fog_in*mix((1-(above_fog*(1-cloud.a)))*textureLod(sampler2D(loss2dTexture[1 + 5]),vec2(rt_s1,loss_texc.y),0).rgb,vec3(1,1,1),transition);
}

insc.rgb*=vec3(1.0,1.0,1.0)-fogLoss;
insc.rgb+=(fogColour+fogAmbient)*fogLoss;
res.multiply*=(1.0-fog_in);
}

res.add=insc;
return res;
}
#line 261 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput PS_CompositeAtmospherics(CompositeShaderInput IN, bool reverseDepth, bool doLightpass, bool doGodrays, bool doNear)
{
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
depthInterpretationStruct.reverseDepth=reverseDepth;
float depth=textureLod(sampler2D(depthTexture[1 + 14]),IN.depth_texc,0).x;
float dist=depthToFadeDistance(depth,IN.clip_pos.xy,depthInterpretationStruct,tanHalfFov);
TwoColourCompositeOutput result=CompositeAtmospherics(IN.clip_pos,imageCubeArrayTex,nearFarTexture,lightpassTexture,loss2dTexture,dist,invViewProj,viewPos,inscatterVolumeTexture,godraysVolumeTexture,maxFadeDistanceKm,nearDist,doLightpass,doGodrays,true,doNear,true,fogColour,fogAmbient,true,fogExtinction,fogCeilingKm);
result.add.rgb=pow(result.add.rgb,vec3(gamma,gamma,gamma));
result.add.rgb*=exposure;
return result;
}
layout(location = 0) in Block
{
CompositeShaderInput BlockData;
} ioblock;
layout(location = 0, index = 0) out vec4 add;

layout(location = 0, index = 1) out vec4 multiply;

void main()
{
CompositeShaderInput BlockData=ioblock.BlockData;
#line 373 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput tmp =  PS_CompositeAtmospherics(BlockData,true,true,true,false);
add = tmp.add;
multiply = tmp.multiply;

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_PS_CompositeAtmospherics_ReverseDepth_Lightpass_Godrays_NearInterp.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
struct TwoColourCompositeOutput
{
	vec4 add;
	vec4 multiply;
};







#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
struct CompositeShaderInput
{
	vec4 hPosition;
	vec2 texCoords;
	vec2 lowResTexCoords;
	vec4 clip_pos;
	vec2 depth_texc;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageCubeArrayTex[24];
	uint64_t nearFarTexture[24];
	uint64_t lightpassTexture[24];
	uint64_t depthTexture[24];
	uint64_t loss2dTexture[24];
	uint64_t inscatterVolumeTexture[24];
	uint64_t godraysVolumeTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
TwoColourCompositeOutput CompositeAtmospherics(vec4 clip_pos, uint64_t cloudCubeArray[24], uint64_t nearFarTexture[24], uint64_t lightpassTexture[24], uint64_t loss2dTexture[24], float dist, mat4 invViewProj, vec3 viewPos, uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], float maxFadeDistanceKm, float nearDist, bool do_lightpass, bool do_godrays, bool do_interp, bool do_near, bool do_clouds, vec3 fogColour, vec3 fogAmbient, bool do_height_fog, float fogExtinction, float fogHeightKm)
{
TwoColourCompositeOutput res;
vec3 view=normalize(mul(invViewProj,clip_pos).xyz);
float sine=view.z;
vec4 nearFarCloud=vec4(1.0,0.0,1,1);
if(do_interp)nearFarCloud=textureLod(samplerCube(nearFarTexture[1 + 4]),view,0);
;
float dist_rt=sqrt(abs(dist));
vec3 worldspaceVolumeTexCoords=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(sine)/3.1415926536),dist_rt);
vec4 insc=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),worldspaceVolumeTexCoords,0);
vec2 loss_texc=vec2(dist_rt,0.5*(1.f-sine));
float f=nearFarCloud.x;
float n=nearFarCloud.y;
float hiResInterp=1.0-saturate((f-dist)/max(0.000000001,f-n));
float cloudLevel=float(2-1)*hiResInterp;
float cloudLevel_0=floor(cloudLevel);
vec4 lp=vec4(0.0,0.0,0.0,0.0);
if(do_lightpass)lp=textureLod(samplerCube(lightpassTexture[1 + 4]),view,0);
;
vec4 cloudNear=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0));
vec4 cloud;
if(do_interp)
{
vec4 cloudFar=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0+1.0));
cloud=mix(cloudNear,cloudFar,fract(cloudLevel));
if(do_lightpass)
{
cloud.rgb+=lp.rgb;
}

if(do_near)
{
float nearInterp=saturate((dist-nearDist)/max(0.00000001,2.0*nearDist));
cloud=mix(vec4(0,0,0,1.0),cloud,nearInterp);
}

}
else

{
cloud=cloudNear;
}

if(do_godrays)
{
vec3 offsetKm=view*dist*maxFadeDistanceKm;
vec3 lightspaceOffset=mul(worldToScatteringVolumeMatrix,vec4(offsetKm,1.0)).xyz;
float r=length(lightspaceOffset);
vec3 lightspaceVolumeTexCoords=vec3(fract(atan(lightspaceOffset.x,lightspaceOffset.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceOffset.z/r)*2.0/3.1415926536,r);
vec4 godrays=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),lightspaceVolumeTexCoords,0);
insc.rgb*=godrays.x;
}

if(do_clouds)insc.rgb*=cloud.a;
if(do_clouds)insc+=cloud;
res.multiply=textureLod(sampler2D(loss2dTexture[1 + 5]),loss_texc,0)*cloud.a;
if(do_height_fog)
{
float H_km=fogHeightKm;
float d_solid=maxFadeDistanceKm*dist;
float z=viewPos.z/1000.0;
float transition=pow(saturate(H_km-z),0.5);
float zs=z+sine*d_solid;
float z_max=max(z,zs);
float z_min=min(z,zs);
float z_1=min(z_min,H_km);
float z_2=min(z_max,H_km);
float sn=max(0.0000000001,abs(sine));
float sn1=max(0.0000000001,(-sine));
float s1=min(dist,saturate((max(0,(z-z_2)/sn1))/maxFadeDistanceKm));
float above_fog=step(0,z-H_km);
float upwards=step(0,sine);
float dz=z_2-z_1;
float s=(1.0-above_fog*upwards)*min(maxFadeDistanceKm,min(d_solid,dz/sn));
float z_mean=0.5*(z_1+z_2);
s*=saturate((H_km-z_mean)/0.1);
float fog_in=1.0-saturate(exp(-s*fogExtinction));
vec3 fogLoss=vec3(1.0,1.0,1.0);
float rt_s1=sqrt(s1);

{
fogLoss*=fog_in*mix((1-(above_fog*(1-cloud.a)))*textureLod(sampler2D(loss2dTexture[1 + 5]),vec2(rt_s1,loss_texc.y),0).rgb,vec3(1,1,1),transition);
}

insc.rgb*=vec3(1.0,1.0,1.0)-fogLoss;
insc.rgb+=(fogColour+fogAmbient)*fogLoss;
res.multiply*=(1.0-fog_in);
}

res.add=insc;
return res;
}
#line 261 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput PS_CompositeAtmospherics(CompositeShaderInput IN, bool reverseDepth, bool doLightpass, bool doGodrays, bool doNear)
{
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
depthInterpretationStruct.reverseDepth=reverseDepth;
float depth=textureLod(sampler2D(depthTexture[1 + 14]),IN.depth_texc,0).x;
float dist=depthToFadeDistance(depth,IN.clip_pos.xy,depthInterpretationStruct,tanHalfFov);
TwoColourCompositeOutput result=CompositeAtmospherics(IN.clip_pos,imageCubeArrayTex,nearFarTexture,lightpassTexture,loss2dTexture,dist,invViewProj,viewPos,inscatterVolumeTexture,godraysVolumeTexture,maxFadeDistanceKm,nearDist,doLightpass,doGodrays,true,doNear,true,fogColour,fogAmbient,true,fogExtinction,fogCeilingKm);
result.add.rgb=pow(result.add.rgb,vec3(gamma,gamma,gamma));
result.add.rgb*=exposure;
return result;
}
layout(location = 0) in Block
{
CompositeShaderInput BlockData;
} ioblock;
layout(location = 0, index = 0) out vec4 add;

layout(location = 0, index = 1) out vec4 multiply;

void main()
{
CompositeShaderInput BlockData=ioblock.BlockData;
#line 413 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput tmp =  PS_CompositeAtmospherics(BlockData,true,true,true,true);
add = tmp.add;
multiply = tmp.multiply;

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_PS_CompositeAtmospherics_ReverseDepth_Lightpass_NearInterp.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
struct TwoColourCompositeOutput
{
	vec4 add;
	vec4 multiply;
};







#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
struct CompositeShaderInput
{
	vec4 hPosition;
	vec2 texCoords;
	vec2 lowResTexCoords;
	vec4 clip_pos;
	vec2 depth_texc;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageCubeArrayTex[24];
	uint64_t nearFarTexture[24];
	uint64_t lightpassTexture[24];
	uint64_t depthTexture[24];
	uint64_t loss2dTexture[24];
	uint64_t inscatterVolumeTexture[24];
	uint64_t godraysVolumeTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
TwoColourCompositeOutput CompositeAtmospherics(vec4 clip_pos, uint64_t cloudCubeArray[24], uint64_t nearFarTexture[24], uint64_t lightpassTexture[24], uint64_t loss2dTexture[24], float dist, mat4 invViewProj, vec3 viewPos, uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], float maxFadeDistanceKm, float nearDist, bool do_lightpass, bool do_godrays, bool do_interp, bool do_near, bool do_clouds, vec3 fogColour, vec3 fogAmbient, bool do_height_fog, float fogExtinction, float fogHeightKm)
{
TwoColourCompositeOutput res;
vec3 view=normalize(mul(invViewProj,clip_pos).xyz);
float sine=view.z;
vec4 nearFarCloud=vec4(1.0,0.0,1,1);
if(do_interp)nearFarCloud=textureLod(samplerCube(nearFarTexture[1 + 4]),view,0);
;
float dist_rt=sqrt(abs(dist));
vec3 worldspaceVolumeTexCoords=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(sine)/3.1415926536),dist_rt);
vec4 insc=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),worldspaceVolumeTexCoords,0);
vec2 loss_texc=vec2(dist_rt,0.5*(1.f-sine));
float f=nearFarCloud.x;
float n=nearFarCloud.y;
float hiResInterp=1.0-saturate((f-dist)/max(0.000000001,f-n));
float cloudLevel=float(2-1)*hiResInterp;
float cloudLevel_0=floor(cloudLevel);
vec4 lp=vec4(0.0,0.0,0.0,0.0);
if(do_lightpass)lp=textureLod(samplerCube(lightpassTexture[1 + 4]),view,0);
;
vec4 cloudNear=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0));
vec4 cloud;
if(do_interp)
{
vec4 cloudFar=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0+1.0));
cloud=mix(cloudNear,cloudFar,fract(cloudLevel));
if(do_lightpass)
{
cloud.rgb+=lp.rgb;
}

if(do_near)
{
float nearInterp=saturate((dist-nearDist)/max(0.00000001,2.0*nearDist));
cloud=mix(vec4(0,0,0,1.0),cloud,nearInterp);
}

}
else

{
cloud=cloudNear;
}

if(do_godrays)
{
vec3 offsetKm=view*dist*maxFadeDistanceKm;
vec3 lightspaceOffset=mul(worldToScatteringVolumeMatrix,vec4(offsetKm,1.0)).xyz;
float r=length(lightspaceOffset);
vec3 lightspaceVolumeTexCoords=vec3(fract(atan(lightspaceOffset.x,lightspaceOffset.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceOffset.z/r)*2.0/3.1415926536,r);
vec4 godrays=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),lightspaceVolumeTexCoords,0);
insc.rgb*=godrays.x;
}

if(do_clouds)insc.rgb*=cloud.a;
if(do_clouds)insc+=cloud;
res.multiply=textureLod(sampler2D(loss2dTexture[1 + 5]),loss_texc,0)*cloud.a;
if(do_height_fog)
{
float H_km=fogHeightKm;
float d_solid=maxFadeDistanceKm*dist;
float z=viewPos.z/1000.0;
float transition=pow(saturate(H_km-z),0.5);
float zs=z+sine*d_solid;
float z_max=max(z,zs);
float z_min=min(z,zs);
float z_1=min(z_min,H_km);
float z_2=min(z_max,H_km);
float sn=max(0.0000000001,abs(sine));
float sn1=max(0.0000000001,(-sine));
float s1=min(dist,saturate((max(0,(z-z_2)/sn1))/maxFadeDistanceKm));
float above_fog=step(0,z-H_km);
float upwards=step(0,sine);
float dz=z_2-z_1;
float s=(1.0-above_fog*upwards)*min(maxFadeDistanceKm,min(d_solid,dz/sn));
float z_mean=0.5*(z_1+z_2);
s*=saturate((H_km-z_mean)/0.1);
float fog_in=1.0-saturate(exp(-s*fogExtinction));
vec3 fogLoss=vec3(1.0,1.0,1.0);
float rt_s1=sqrt(s1);

{
fogLoss*=fog_in*mix((1-(above_fog*(1-cloud.a)))*textureLod(sampler2D(loss2dTexture[1 + 5]),vec2(rt_s1,loss_texc.y),0).rgb,vec3(1,1,1),transition);
}

insc.rgb*=vec3(1.0,1.0,1.0)-fogLoss;
insc.rgb+=(fogColour+fogAmbient)*fogLoss;
res.multiply*=(1.0-fog_in);
}

res.add=insc;
return res;
}
#line 261 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput PS_CompositeAtmospherics(CompositeShaderInput IN, bool reverseDepth, bool doLightpass, bool doGodrays, bool doNear)
{
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
depthInterpretationStruct.reverseDepth=reverseDepth;
float depth=textureLod(sampler2D(depthTexture[1 + 14]),IN.depth_texc,0).x;
float dist=depthToFadeDistance(depth,IN.clip_pos.xy,depthInterpretationStruct,tanHalfFov);
TwoColourCompositeOutput result=CompositeAtmospherics(IN.clip_pos,imageCubeArrayTex,nearFarTexture,lightpassTexture,loss2dTexture,dist,invViewProj,viewPos,inscatterVolumeTexture,godraysVolumeTexture,maxFadeDistanceKm,nearDist,doLightpass,doGodrays,true,doNear,true,fogColour,fogAmbient,true,fogExtinction,fogCeilingKm);
result.add.rgb=pow(result.add.rgb,vec3(gamma,gamma,gamma));
result.add.rgb*=exposure;
return result;
}
layout(location = 0) in Block
{
CompositeShaderInput BlockData;
} ioblock;
layout(location = 0, index = 0) out vec4 add;

layout(location = 0, index = 1) out vec4 multiply;

void main()
{
CompositeShaderInput BlockData=ioblock.BlockData;
#line 393 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput tmp =  PS_CompositeAtmospherics(BlockData,true,true,false,true);
add = tmp.add;
multiply = tmp.multiply;

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_PS_CompositeAtmospherics_ReverseDepth_NearInterp.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
struct TwoColourCompositeOutput
{
	vec4 add;
	vec4 multiply;
};







#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
struct CompositeShaderInput
{
	vec4 hPosition;
	vec2 texCoords;
	vec2 lowResTexCoords;
	vec4 clip_pos;
	vec2 depth_texc;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageCubeArrayTex[24];
	uint64_t nearFarTexture[24];
	uint64_t lightpassTexture[24];
	uint64_t depthTexture[24];
	uint64_t loss2dTexture[24];
	uint64_t inscatterVolumeTexture[24];
	uint64_t godraysVolumeTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/composite.sl"
TwoColourCompositeOutput CompositeAtmospherics(vec4 clip_pos, uint64_t cloudCubeArray[24], uint64_t nearFarTexture[24], uint64_t lightpassTexture[24], uint64_t loss2dTexture[24], float dist, mat4 invViewProj, vec3 viewPos, uint64_t inscatterVolumeTexture[24], uint64_t godraysVolumeTexture[24], float maxFadeDistanceKm, float nearDist, bool do_lightpass, bool do_godrays, bool do_interp, bool do_near, bool do_clouds, vec3 fogColour, vec3 fogAmbient, bool do_height_fog, float fogExtinction, float fogHeightKm)
{
TwoColourCompositeOutput res;
vec3 view=normalize(mul(invViewProj,clip_pos).xyz);
float sine=view.z;
vec4 nearFarCloud=vec4(1.0,0.0,1,1);
if(do_interp)nearFarCloud=textureLod(samplerCube(nearFarTexture[1 + 4]),view,0);
;
float dist_rt=sqrt(abs(dist));
vec3 worldspaceVolumeTexCoords=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(sine)/3.1415926536),dist_rt);
vec4 insc=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),worldspaceVolumeTexCoords,0);
vec2 loss_texc=vec2(dist_rt,0.5*(1.f-sine));
float f=nearFarCloud.x;
float n=nearFarCloud.y;
float hiResInterp=1.0-saturate((f-dist)/max(0.000000001,f-n));
float cloudLevel=float(2-1)*hiResInterp;
float cloudLevel_0=floor(cloudLevel);
vec4 lp=vec4(0.0,0.0,0.0,0.0);
if(do_lightpass)lp=textureLod(samplerCube(lightpassTexture[1 + 4]),view,0);
;
vec4 cloudNear=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0));
vec4 cloud;
if(do_interp)
{
vec4 cloudFar=texture(samplerCubeArray(cloudCubeArray[1 + 4]),vec4(view,cloudLevel_0+1.0));
cloud=mix(cloudNear,cloudFar,fract(cloudLevel));
if(do_lightpass)
{
cloud.rgb+=lp.rgb;
}

if(do_near)
{
float nearInterp=saturate((dist-nearDist)/max(0.00000001,2.0*nearDist));
cloud=mix(vec4(0,0,0,1.0),cloud,nearInterp);
}

}
else

{
cloud=cloudNear;
}

if(do_godrays)
{
vec3 offsetKm=view*dist*maxFadeDistanceKm;
vec3 lightspaceOffset=mul(worldToScatteringVolumeMatrix,vec4(offsetKm,1.0)).xyz;
float r=length(lightspaceOffset);
vec3 lightspaceVolumeTexCoords=vec3(fract(atan(lightspaceOffset.x,lightspaceOffset.y)/(2.0*3.1415926536)),0.5+0.5*asin(lightspaceOffset.z/r)*2.0/3.1415926536,r);
vec4 godrays=textureLod(sampler3D(godraysVolumeTexture[1 + 1]),lightspaceVolumeTexCoords,0);
insc.rgb*=godrays.x;
}

if(do_clouds)insc.rgb*=cloud.a;
if(do_clouds)insc+=cloud;
res.multiply=textureLod(sampler2D(loss2dTexture[1 + 5]),loss_texc,0)*cloud.a;
if(do_height_fog)
{
float H_km=fogHeightKm;
float d_solid=maxFadeDistanceKm*dist;
float z=viewPos.z/1000.0;
float transition=pow(saturate(H_km-z),0.5);
float zs=z+sine*d_solid;
float z_max=max(z,zs);
float z_min=min(z,zs);
float z_1=min(z_min,H_km);
float z_2=min(z_max,H_km);
float sn=max(0.0000000001,abs(sine));
float sn1=max(0.0000000001,(-sine));
float s1=min(dist,saturate((max(0,(z-z_2)/sn1))/maxFadeDistanceKm));
float above_fog=step(0,z-H_km);
float upwards=step(0,sine);
float dz=z_2-z_1;
float s=(1.0-above_fog*upwards)*min(maxFadeDistanceKm,min(d_solid,dz/sn));
float z_mean=0.5*(z_1+z_2);
s*=saturate((H_km-z_mean)/0.1);
float fog_in=1.0-saturate(exp(-s*fogExtinction));
vec3 fogLoss=vec3(1.0,1.0,1.0);
float rt_s1=sqrt(s1);

{
fogLoss*=fog_in*mix((1-(above_fog*(1-cloud.a)))*textureLod(sampler2D(loss2dTexture[1 + 5]),vec2(rt_s1,loss_texc.y),0).rgb,vec3(1,1,1),transition);
}

insc.rgb*=vec3(1.0,1.0,1.0)-fogLoss;
insc.rgb+=(fogColour+fogAmbient)*fogLoss;
res.multiply*=(1.0-fog_in);
}

res.add=insc;
return res;
}
#line 261 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput PS_CompositeAtmospherics(CompositeShaderInput IN, bool reverseDepth, bool doLightpass, bool doGodrays, bool doNear)
{
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
depthInterpretationStruct.reverseDepth=reverseDepth;
float depth=textureLod(sampler2D(depthTexture[1 + 14]),IN.depth_texc,0).x;
float dist=depthToFadeDistance(depth,IN.clip_pos.xy,depthInterpretationStruct,tanHalfFov);
TwoColourCompositeOutput result=CompositeAtmospherics(IN.clip_pos,imageCubeArrayTex,nearFarTexture,lightpassTexture,loss2dTexture,dist,invViewProj,viewPos,inscatterVolumeTexture,godraysVolumeTexture,maxFadeDistanceKm,nearDist,doLightpass,doGodrays,true,doNear,true,fogColour,fogAmbient,true,fogExtinction,fogCeilingKm);
result.add.rgb=pow(result.add.rgb,vec3(gamma,gamma,gamma));
result.add.rgb*=exposure;
return result;
}
layout(location = 0) in Block
{
CompositeShaderInput BlockData;
} ioblock;
layout(location = 0, index = 0) out vec4 add;

layout(location = 0, index = 1) out vec4 multiply;

void main()
{
CompositeShaderInput BlockData=ioblock.BlockData;
#line 383 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
TwoColourCompositeOutput tmp =  PS_CompositeAtmospherics(BlockData,true,false,false,true);
add = tmp.add;
multiply = tmp.multiply;

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_PS_CubemapToScreenspace.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t nearFarTexture[24];
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 424 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
vec4 clip_pos=vec4(-1.0,1.0,1.0,1.0);
clip_pos.x+=2.0*BlockData.texCoords.x;
clip_pos.y-=2.0*BlockData.texCoords.y;
vec3 view=mul(invViewProj,clip_pos).xyz;
vec4 res=textureLod(samplerCube(nearFarTexture[1 + 4]),view,0);
;
{returnObject_vec4=res;}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_PS_CubemapToScreenspaceVisibility.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};


layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageCubeArrayTex[24];
	uint64_t nearFarTexture[24];
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 435 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
vec4 clip_pos=vec4(-1.0,1.0,1.0,1.0);
clip_pos.x+=2.0*BlockData.texCoords.x;
clip_pos.y-=2.0*BlockData.texCoords.y;
vec3 view=mul(invViewProj,clip_pos).xyz;
vec4 nearfar=textureLod(samplerCube(nearFarTexture[1 + 4]),view,0);
;
vec4 img=textureLod(samplerCubeArray(imageCubeArrayTex[1 + 4]),vec4(view,0),0);
;
vec4 result=vec4(img.a,0.02,nearfar.wz);
{returnObject_vec4=result;}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_PS_InfraRed.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageTexture[24];
};
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 139 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
vec4 c=texture(sampler2D(imageTexture[1 + 9]),BlockData.texCoords);
c.rgb*=infraredIntegrationFactors.xyz;
float final_radiance=c.x+c.y+c.z;
c=vec4(final_radiance,final_radiance,final_radiance,c.a);
c.rgb*=exposure;
c.rgb=pow(c.rgb,vec3(gamma,gamma,gamma));
vec4 u=vec4(c.rgb,1.0);
{returnObject_vec4=u;}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_PS_InfraRed_MSAA.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t imageTextureMS[24];
};
#line 38 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
vec4 texture_resolve(uint64_t textureMS[24], vec2 texCoords)
{
uvec2 dims;
uint numberOfSamples;
ivec2 ivtextureMS = textureSize(sampler2DMS(textureMS[0]));
dims.x = ivtextureMS.x;dims.y = ivtextureMS.y;;
ivec2 pos=ivec2(vec2(dims)*texCoords);
vec4 d=vec4(0,0,0,0);
for(uint k=0;k<numberOfSamples;k++)
{
d+=texelFetch(sampler2DMS(textureMS[0]),ivec2(pos),int(k));
}

d/=float(numberOfSamples);
return d;
}
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 151 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
vec4 c=texture_resolve(imageTextureMS,BlockData.texCoords);
c.rgb*=infraredIntegrationFactors.xyz;
float final_radiance=c.x+c.y+c.z;
c=vec4(final_radiance,final_radiance,final_radiance,c.a);
c.rgb*=exposure;
c.rgb=pow(c.rgb,vec3(gamma,gamma,gamma));
vec4 u=vec4(c.rgb,1.0);
{returnObject_vec4=u;}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_PS_ShowScatteringVolume.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t inscatterVolumeTexture[24];
};
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 181 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
vec3 texc=vec3(BlockData.texCoords,1.0);
texc.y*=2.0;
if(texc.y<1.0)
{
texc.z=floor(8.0f*BlockData.texCoords.x)/8.0f;
}
else

{
texc.y-=1.0;
}

texc.x+=0.5;
vec4 sc=textureLod(sampler3D(inscatterVolumeTexture[1 + 7]),texc,0);
vec4 u=vec4(sc.rgb,1.0);
{returnObject_vec4=u;}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_PS_ShowVolume.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t inscatterVolumeTexture[24];
};
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 200 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
float z=floor(8.0f*BlockData.texCoords.x)/8.0f;
if(BlockData.texCoords.y<.5)z=.5;
vec4 colour=textureLod(sampler3D(inscatterVolumeTexture[1 + 11]),vec3(BlockData.texCoords,z),0);
{returnObject_vec4=colour;}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_ShowDepthPS_ForwardDepth.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t depthTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 86 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
vec4 depth=texture(sampler2D(depthTexture[1 + 9]),BlockData.texCoords);
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
depthInterpretationStruct.reverseDepth=false;
float dist=10.0*depthToFadeDistance(depth.x,2.0*(BlockData.texCoords-0.5),depthInterpretationStruct,tanHalfFov);
vec4 u=vec4(1,dist,dist,1.0);
{returnObject_vec4=u;}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_ShowDepthPS_ReverseDepth.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t depthTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 75 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
vec4 depth=texture(sampler2D(depthTexture[1 + 9]),BlockData.texCoords);
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
depthInterpretationStruct.reverseDepth=true;
float dist=10.0*depthToFadeDistance(depth.x,2.0*(BlockData.texCoords-0.5),depthInterpretationStruct,tanHalfFov);
vec4 u=vec4(1,dist,dist,1.0);
{returnObject_vec4=u;}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_TexturedPS.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 168 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
vec4 res=vec4(0,1,0,1);
{returnObject_vec4=res;}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_VS_Composite_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};
#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
struct CompositeShaderInput
{
	vec4 hPosition;
	vec2 texCoords;
	vec2 lowResTexCoords;
	vec4 clip_pos;
	vec2 depth_texc;
};
#line 199 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 viewportCoordToTexRegionCoord(vec2 iViewportCoord, vec4 iViewportToTexRegionScaleBias)
{
return iViewportCoord*iViewportToTexRegionScaleBias.xy+iViewportToTexRegionScaleBias.zw;
}
layout(location = 0) out Block
{
CompositeShaderInput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 54 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
CompositeShaderInput OUT;
vec2 poss[4];
poss[0]=vec2(1.0,-1.0);
poss[1]=vec2(1.0,1.0);
poss[2]=vec2(-1.0,-1.0);
poss[3]=vec2(-1.0,1.0);
vec2 pos=poss[IN.vertex_id];
OUT.hPosition=vec4(pos,0.0,1.0);
OUT.hPosition.z=0.0;
OUT.texCoords=0.5*(vec2(1.0,1.0)+vec2(pos.x,-pos.y));
OUT.lowResTexCoords=OUT.texCoords.xy;
OUT.clip_pos=vec4(-1.0,1.0,1.0,1.0);
OUT.clip_pos.x+=2.0*OUT.texCoords.x;
OUT.clip_pos.y-=2.0*OUT.texCoords.y;
OUT.depth_texc=viewportCoordToTexRegionCoord(OUT.texCoords.xy,viewportToTexRegionScaleBias);
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_VS_Composite_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};
#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
struct CompositeShaderInput
{
	vec4 hPosition;
	vec2 texCoords;
	vec2 lowResTexCoords;
	vec4 clip_pos;
	vec2 depth_texc;
};
#line 199 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 viewportCoordToTexRegionCoord(vec2 iViewportCoord, vec4 iViewportToTexRegionScaleBias)
{
return iViewportCoord*iViewportToTexRegionScaleBias.xy+iViewportToTexRegionScaleBias.zw;
}
layout(location = 0) out Block
{
CompositeShaderInput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 54 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
CompositeShaderInput OUT;
vec2 poss[4];
poss[0]=vec2(1.0,-1.0);
poss[1]=vec2(1.0,1.0);
poss[2]=vec2(-1.0,-1.0);
poss[3]=vec2(-1.0,1.0);
vec2 pos=poss[IN.vertex_id];
OUT.hPosition=vec4(pos,0.0,1.0);
OUT.hPosition.z=0.0;
OUT.texCoords=0.5*(vec2(1.0,1.0)+vec2(pos.x,-pos.y));
OUT.lowResTexCoords=OUT.texCoords.xy;
OUT.clip_pos=vec4(-1.0,1.0,1.0,1.0);
OUT.clip_pos.x+=2.0*OUT.texCoords.x;
OUT.clip_pos.y-=2.0*OUT.texCoords.y;
OUT.depth_texc=viewportCoordToTexRegionCoord(OUT.texCoords.xy,viewportToTexRegionScaleBias);
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_VS_SimpleFullscreen_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 119 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput SimpleFullscreen(idOnly IN)
{
posTexVertexOutput OUT;
vec2 poss[4];
poss[0]=vec2(1.0,-1.0);
poss[1]=vec2(1.0,1.0);
poss[2]=vec2(-1.0,-1.0);
poss[3]=vec2(-1.0,1.0);
vec2 pos=poss[IN.vertex_id];
OUT.hPosition=vec4(pos,0.0,1.0);
OUT.hPosition.z=0.0;
OUT.texCoords=0.5*(vec2(1.0,1.0)+vec2(pos.x,-pos.y));
#line 132 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

OUT.texCoords.y=1.0-OUT.texCoords.y;
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

return OUT;
}
layout(location = 0) out Block
{
posTexVertexOutput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput pt=SimpleFullscreen(IN);
{
ioblock.BlockData=pt;
gl_Position=pt.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_VS_SimpleFullscreen_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 119 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput SimpleFullscreen(idOnly IN)
{
posTexVertexOutput OUT;
vec2 poss[4];
poss[0]=vec2(1.0,-1.0);
poss[1]=vec2(1.0,1.0);
poss[2]=vec2(-1.0,-1.0);
poss[3]=vec2(-1.0,1.0);
vec2 pos=poss[IN.vertex_id];
OUT.hPosition=vec4(pos,0.0,1.0);
OUT.hPosition.z=0.0;
OUT.texCoords=0.5*(vec2(1.0,1.0)+vec2(pos.x,-pos.y));
#line 132 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

OUT.texCoords.y=1.0-OUT.texCoords.y;
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

return OUT;
}
layout(location = 0) out Block
{
posTexVertexOutput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput pt=SimpleFullscreen(IN);
{
ioblock.BlockData=pt;
gl_Position=pt.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_VS_SimpleFullscreen_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 119 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput SimpleFullscreen(idOnly IN)
{
posTexVertexOutput OUT;
vec2 poss[4];
poss[0]=vec2(1.0,-1.0);
poss[1]=vec2(1.0,1.0);
poss[2]=vec2(-1.0,-1.0);
poss[3]=vec2(-1.0,1.0);
vec2 pos=poss[IN.vertex_id];
OUT.hPosition=vec4(pos,0.0,1.0);
OUT.hPosition.z=0.0;
OUT.texCoords=0.5*(vec2(1.0,1.0)+vec2(pos.x,-pos.y));
#line 132 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

OUT.texCoords.y=1.0-OUT.texCoords.y;
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

return OUT;
}
layout(location = 0) out Block
{
posTexVertexOutput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput pt=SimpleFullscreen(IN);
{
ioblock.BlockData=pt;
gl_Position=pt.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_VS_SimpleFullscreen_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 119 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput SimpleFullscreen(idOnly IN)
{
posTexVertexOutput OUT;
vec2 poss[4];
poss[0]=vec2(1.0,-1.0);
poss[1]=vec2(1.0,1.0);
poss[2]=vec2(-1.0,-1.0);
poss[3]=vec2(-1.0,1.0);
vec2 pos=poss[IN.vertex_id];
OUT.hPosition=vec4(pos,0.0,1.0);
OUT.hPosition.z=0.0;
OUT.texCoords=0.5*(vec2(1.0,1.0)+vec2(pos.x,-pos.y));
#line 132 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

OUT.texCoords.y=1.0-OUT.texCoords.y;
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

return OUT;
}
layout(location = 0) out Block
{
posTexVertexOutput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput pt=SimpleFullscreen(IN);
{
ioblock.BlockData=pt;
gl_Position=pt.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_VS_Composite_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};
#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
struct CompositeShaderInput
{
	vec4 hPosition;
	vec2 texCoords;
	vec2 lowResTexCoords;
	vec4 clip_pos;
	vec2 depth_texc;
};
#line 199 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 viewportCoordToTexRegionCoord(vec2 iViewportCoord, vec4 iViewportToTexRegionScaleBias)
{
return iViewportCoord*iViewportToTexRegionScaleBias.xy+iViewportToTexRegionScaleBias.zw;
}
layout(location = 0) out Block
{
CompositeShaderInput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 54 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
CompositeShaderInput OUT;
vec2 poss[4];
poss[0]=vec2(1.0,-1.0);
poss[1]=vec2(1.0,1.0);
poss[2]=vec2(-1.0,-1.0);
poss[3]=vec2(-1.0,1.0);
vec2 pos=poss[IN.vertex_id];
OUT.hPosition=vec4(pos,0.0,1.0);
OUT.hPosition.z=0.0;
OUT.texCoords=0.5*(vec2(1.0,1.0)+vec2(pos.x,-pos.y));
OUT.lowResTexCoords=OUT.texCoords.xy;
OUT.clip_pos=vec4(-1.0,1.0,1.0,1.0);
OUT.clip_pos.x+=2.0*OUT.texCoords.x;
OUT.clip_pos.y-=2.0*OUT.texCoords.y;
OUT.depth_texc=viewportCoordToTexRegionCoord(OUT.texCoords.xy,viewportToTexRegionScaleBias);
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_VS_Composite_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/compositing_constants.sl"
layout(std140, binding = 12) uniform CompositingConstants
{
	mat4 worldToScatteringVolumeMatrix;
	mat4 invViewProj;
	vec4 viewportToTexRegionScaleBias;
	vec2 offset;
	float alpha;
	float nearDist;
	vec4 colour2;
	vec4 tanHalfFov;
	vec2 tanHalfFovUnused;
	float exposure;
	float gamma;
	vec4 depthToLinFadeDistParams;
	vec4 warpHmdWarpParam;
	vec3 cubemapGroundColour;
	float ccgcpad;
	vec2 warpScreenCentre;
	vec2 warpScale;
	vec2 warpScaleIn;
	vec2 padHdrConstants1;
	uvec2 hiResDimsX;
	uvec2 lowResDims;
	uvec2 fullResDims;
	int numSamples;
	float maxFadeDistanceKm;
	vec3 infraredIntegrationFactors;
	int randomSeed;
	vec3 viewPos;
	float fogExtinction;
	vec3 fogColour;
	float fogCeilingKm;
	vec3 fogAmbient;
	float anotherFloatXXX;
};
#line 36 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
struct CompositeShaderInput
{
	vec4 hPosition;
	vec2 texCoords;
	vec2 lowResTexCoords;
	vec4 clip_pos;
	vec2 depth_texc;
};
#line 199 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 viewportCoordToTexRegionCoord(vec2 iViewportCoord, vec4 iViewportToTexRegionScaleBias)
{
return iViewportCoord*iViewportToTexRegionScaleBias.xy+iViewportToTexRegionScaleBias.zw;
}
layout(location = 0) out Block
{
CompositeShaderInput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 54 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/composite.sfx"
CompositeShaderInput OUT;
vec2 poss[4];
poss[0]=vec2(1.0,-1.0);
poss[1]=vec2(1.0,1.0);
poss[2]=vec2(-1.0,-1.0);
poss[3]=vec2(-1.0,1.0);
vec2 pos=poss[IN.vertex_id];
OUT.hPosition=vec4(pos,0.0,1.0);
OUT.hPosition.z=0.0;
OUT.texCoords=0.5*(vec2(1.0,1.0)+vec2(pos.x,-pos.y));
OUT.lowResTexCoords=OUT.texCoords.xy;
OUT.clip_pos=vec4(-1.0,1.0,1.0,1.0);
OUT.clip_pos.x+=2.0*OUT.texCoords.x;
OUT.clip_pos.y-=2.0*OUT.texCoords.y;
OUT.depth_texc=viewportCoordToTexRegionCoord(OUT.texCoords.xy,viewportToTexRegionScaleBias);
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_VS_SimpleFullscreen_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 119 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput SimpleFullscreen(idOnly IN)
{
posTexVertexOutput OUT;
vec2 poss[4];
poss[0]=vec2(1.0,-1.0);
poss[1]=vec2(1.0,1.0);
poss[2]=vec2(-1.0,-1.0);
poss[3]=vec2(-1.0,1.0);
vec2 pos=poss[IN.vertex_id];
OUT.hPosition=vec4(pos,0.0,1.0);
OUT.hPosition.z=0.0;
OUT.texCoords=0.5*(vec2(1.0,1.0)+vec2(pos.x,-pos.y));
#line 132 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

OUT.texCoords.y=1.0-OUT.texCoords.y;
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

return OUT;
}
layout(location = 0) out Block
{
posTexVertexOutput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput pt=SimpleFullscreen(IN);
{
ioblock.BlockData=pt;
gl_Position=pt.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_VS_SimpleFullscreen_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 119 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput SimpleFullscreen(idOnly IN)
{
posTexVertexOutput OUT;
vec2 poss[4];
poss[0]=vec2(1.0,-1.0);
poss[1]=vec2(1.0,1.0);
poss[2]=vec2(-1.0,-1.0);
poss[3]=vec2(-1.0,1.0);
vec2 pos=poss[IN.vertex_id];
OUT.hPosition=vec4(pos,0.0,1.0);
OUT.hPosition.z=0.0;
OUT.texCoords=0.5*(vec2(1.0,1.0)+vec2(pos.x,-pos.y));
#line 132 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

OUT.texCoords.y=1.0-OUT.texCoords.y;
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

return OUT;
}
layout(location = 0) out Block
{
posTexVertexOutput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput pt=SimpleFullscreen(IN);
{
ioblock.BlockData=pt;
gl_Position=pt.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_VS_SimpleFullscreen_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 119 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput SimpleFullscreen(idOnly IN)
{
posTexVertexOutput OUT;
vec2 poss[4];
poss[0]=vec2(1.0,-1.0);
poss[1]=vec2(1.0,1.0);
poss[2]=vec2(-1.0,-1.0);
poss[3]=vec2(-1.0,1.0);
vec2 pos=poss[IN.vertex_id];
OUT.hPosition=vec4(pos,0.0,1.0);
OUT.hPosition.z=0.0;
OUT.texCoords=0.5*(vec2(1.0,1.0)+vec2(pos.x,-pos.y));
#line 132 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

OUT.texCoords.y=1.0-OUT.texCoords.y;
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

return OUT;
}
layout(location = 0) out Block
{
posTexVertexOutput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput pt=SimpleFullscreen(IN);
{
ioblock.BlockData=pt;
gl_Position=pt.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/composite_VS_SimpleFullscreen_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 119 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput SimpleFullscreen(idOnly IN)
{
posTexVertexOutput OUT;
vec2 poss[4];
poss[0]=vec2(1.0,-1.0);
poss[1]=vec2(1.0,1.0);
poss[2]=vec2(-1.0,-1.0);
poss[3]=vec2(-1.0,1.0);
vec2 pos=poss[IN.vertex_id];
OUT.hPosition=vec4(pos,0.0,1.0);
OUT.hPosition.z=0.0;
OUT.texCoords=0.5*(vec2(1.0,1.0)+vec2(pos.x,-pos.y));
#line 132 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

OUT.texCoords.y=1.0-OUT.texCoords.y;
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

return OUT;
}
layout(location = 0) out Block
{
posTexVertexOutput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput pt=SimpleFullscreen(IN);
{
ioblock.BlockData=pt;
gl_Position=pt.hPosition;
}
}