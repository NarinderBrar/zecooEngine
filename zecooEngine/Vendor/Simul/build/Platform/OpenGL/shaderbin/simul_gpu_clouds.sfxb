#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/simul_gpu_clouds_CS_Cumulus_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)

layout(r32f, binding = 1) uniform image3D targetTexture1;
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
layout(std140, binding = 8) uniform GpuCloudConstants
{
	mat4 transformMatrix;
	vec4 yRange;
	vec3 noiseScale;
	float sourceNoiseScaleKm;
	vec2 extinctions;
	float stepLength;
	float cloudBaseKm;
	uvec3 threadOffset;
	int octaves;
	float time;
	float persistence;
	float humidity;
	float numWorleyOctaves;
	float zPixel;
	int numVolumes;
	float baseLayer;
	float transition;
	float upperDensity;
	float diffusivity;
	float baseMixingRatio;
	float maskThickness;
	vec2 maskCentre;
	float maskRadius;
	float maskFeather;
	vec3 cloudScalesKm;
	float time_step;
	vec3 lightDir;
	float alpha;
	float invBeta;
	int wrap;
	float viscousCoefficient;
	float seaLevelTemperatureK;
	vec3 cloudOriginKm;
	float vorticityConfinement;
	float worleyNoiseStrength;
	float worleyNoiseScale;
	float noisePeriod;
	int numAffectors;
	float localNoiseStrength;
	float localCellNoiseStrength;
	float baseNoiseFactor;
	float max_density_gm3;
	ivec3 gridEdge;
	float edgeSharpness;
	ivec3 idxOffset;
	float cloudLayerThicknessKm;
};
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t volumeNoiseTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/noise.sl"
float rand3(vec3 co)
{
return fract(sin(dot(co.xyz,vec3(12.9898,78.233,42.1897)))*43758.5453);
}
#line 42 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/noise.sl"
vec3 SphericalRandom(vec3 co)
{
float r=1.f-pow(rand3(co),4.0);
float az=rand3(43.1138*co)*2*3.1415926536;
float sine_el=rand3(17.981*co)*2.0-1.0;
float el=asin(sine_el);
float cos_el=cos(el);
vec3 v;
v.x=r*sin(az)*cos_el;
v.y=r*cos(az)*cos_el;
v.z=r*sine_el;
return v;
}
#line 75 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/noise.sl"
vec4 VirtualNoiseLookup(vec3 texCoords, int gridsize, int seed, bool pfilter)
{
vec4 result=vec4(0,0,0,0);
vec3 pos=fract(texCoords)*gridsize;
vec3 intpart,floatpart;
floatpart=modf(pos,intpart);
ivec3 seedpos=ivec3(2*seed,17*seed,7*seed);
ivec3 firstCorner=ivec3(intpart);
if(pfilter)
{
for(int i=0;i<2;i++)
{
for(int j=0;j<2;j++)
{
for(int k=0;k<2;k++)
{
ivec3 corner_pos=firstCorner+ivec3(1-i,1-j,1-k);
if(corner_pos.x==gridsize)corner_pos.x=0;
if(corner_pos.y==gridsize)corner_pos.y=0;
if(corner_pos.z==gridsize)corner_pos.z=0;
vec3 lookup_pos=seedpos+vec3(corner_pos);
float rndTap=rand3(lookup_pos);
vec4 rnd_lookup=vec4(rndTap,rndTap,rndTap,rndTap);
float proportion=abs(i-floatpart.x)*abs(j-floatpart.y)*abs(k-floatpart.z);
result+=rnd_lookup*proportion;
}

}

}

}
else

{
ivec3 corner_pos=ivec3(pos+vec3(0.5,0.5,0.5));
vec3 lookup_pos=seedpos+vec3(corner_pos);
float rndTap=rand3(lookup_pos);
result=vec4(rndTap,rndTap,rndTap,rndTap);
}

return result;
}
#line 69 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_gpu_clouds.sl"
float GetHumidityMultiplier2(float z, float baseLayerZ, float transitionZ, float upperDensity)
{
float upperLayerZ=1.0-baseLayerZ-transitionZ;
float i=saturate((z-baseLayerZ)/transitionZ);
float j=1.0-saturate((1.0-z)/upperLayerZ);
float m=mix(1.0,upperDensity,i);
float n=upperDensity*sqrt(1.0-j*j);
m*=step(z,baseLayerZ+transitionZ);
m=max(m,n);
return m;
}
#line 186 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_gpu_clouds.sl"
float NoiseFunction(uint64_t volumeNoiseTexture[24], vec3 pos, int octaves, float persistence, float t, float height, float texel)
{
float dens=0.0;
float mult=1.0;
float sum=0.0;
int resolution=4;
for(int i=0;i<5;i++)
{
vec3 pos2=pos;
float zmin=0.5*texel;
float zmax=height-0.5*texel;
pos2.z=clamp(pos2.z,0,0);
pos2.z*=saturate(i);
float lookup=VirtualNoiseLookup(pos2,resolution,1,true).x;
float val=cos(2.0*3.1415926536*(lookup+t));
dens=dens+mult*val;
sum=sum+mult;
mult=mult*persistence;
pos=pos*2.0;
t=t*2.0;
height*=2.0;
resolution*=2;
}

dens=persistence*(dens/sum);
return dens;
}
#line 229 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_gpu_clouds.sl"
float RestrictedWorley(vec3 texc, int grid, int seed, float zmax)
{
vec3 pos=float(grid)*texc;
vec3 fractional,intpart;
fractional=modf(pos,intpart);
ivec3 ip=ivec3(intpart);
vec3 loc=fractional-vec3(0.5,0.5,0.5);
float g=float(grid);
float n=g;
for(int i=-1;i<2;++i)
{
for(int j=-1;j<2;++j)
{
for(int k=-1;k<2;++k)
{
ivec3 I=ivec3(i,j,k);
vec3 c=vec3(I);
ivec3 u=(ip+I);
ivec3 v=ivec3(typed_mod((u+ivec3(grid,grid,grid)),ivec3(grid,grid,grid)));
vec3 random=SphericalRandom(vec3(v)*float(seed));
c+=.5*random.xyz;
vec3 diff=loc-c;
float dist=length(diff);
float top=(ip.z+c.z+1.0)/g;
float bot=(ip.z+c.z-1.0)/g;
if(top<zmax)n=min(n,dist);
}

}

}

float p=saturate(1.0-n/1.0);
return p;
}
#line 429 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/simul_gpu_clouds.sfx"
float CSCumulus(uvec3 pos)
{
uvec3 dims;
ivec3 ivtargetTexture1 = imageSize(targetTexture1);
dims.x = ivtargetTexture1.x;dims.y = ivtargetTexture1.y;dims.z = ivtargetTexture1.z;;
uvec3 noise_dims;
ivec3 ivvolumeNoiseTexture = textureSize(sampler3D(volumeNoiseTexture[0]),0);
noise_dims.x = ivvolumeNoiseTexture.x;noise_dims.y = ivvolumeNoiseTexture.y;noise_dims.z = ivvolumeNoiseTexture.z;;
if(pos.x>=dims.x||pos.y>=dims.y||pos.z>=dims.z)return 0.0;
vec3 densityspace_texcoord=(vec3(pos)+vec3(0.5,0.5,0.5))/vec3(dims);
vec3 noisespace_texcoord=densityspace_texcoord*noiseScale;
vec4 worley=vec4(0,0,0,0);
vec3 tc=2*noisespace_texcoord;
float u=1.5;
float a=.75;
float noise_texel=1.0/float(noise_dims.z);
float height=noiseScale.z;
float fl=0.0;
float ff=modf(worleyNoiseScale,fl);
vec3 worley_texcoord=noisespace_texcoord;
float p=0;
float m=4.0;
float hm=2.0*(humidity*GetHumidityMultiplier2(densityspace_texcoord.z,baseLayer,transition,upperDensity)-0.5);
float noise_val=NoiseFunction(volumeNoiseTexture,noisespace_texcoord,octaves,.5,time,height,noise_texel);
float dens=hm+noise_val;
float texc_scale=noiseScale.z;
float grid1=fl*4.0;
float grid2=(fl+1.0)*4.0;
vec3 wtexc=densityspace_texcoord*noiseScale/noiseScale.x;
float zratio=4.0*noiseScale.z/noiseScale.x;
for(int j=0;j<5;j++)
{
float w1=RestrictedWorley(wtexc,int(grid1),int(grid1),zratio);
float w2=RestrictedWorley(wtexc,int(grid2),int(grid2),zratio);
float w=pow(mix(w1,w2,ff),0.7);
w=m*(w-0.52);
dens=(dens+worleyNoiseStrength*w);
m*=persistence;
grid1*=3.0;
grid2*=3.0;
grid1+=1.0;
grid2+=1.0;
}

vec3 wPos=(mul(transformMatrix,vec4(densityspace_texcoord.xyz,1.0))).xyz;
return dens;
}
layout(local_size_x=8, local_size_y=8, local_size_z=1) in;
void main()
{
uvec3 g = gl_WorkGroupID;
uvec3 t = gl_LocalInvocationID;
#line 534 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/simul_gpu_clouds.sfx"
uvec3 sub_pos=g*uvec3(8,8,1)+t;
uvec3 pos=sub_pos+threadOffset;
uvec3 dims;
ivec3 ivtargetTexture1 = imageSize(targetTexture1);
dims.x = ivtargetTexture1.x;dims.y = ivtargetTexture1.y;dims.z = ivtargetTexture1.z;;
if(pos.x>=dims.x||pos.y>=dims.y||pos.z>=dims.z)return ;
float dens=CSCumulus(pos);
imageStore(targetTexture1,ivec3(ivec3(pos)),vec4(dens));
;
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/simul_gpu_clouds_CS_Density_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)

layout(r32f, binding = 1) uniform image3D targetTexture1;
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
layout(std140, binding = 8) uniform GpuCloudConstants
{
	mat4 transformMatrix;
	vec4 yRange;
	vec3 noiseScale;
	float sourceNoiseScaleKm;
	vec2 extinctions;
	float stepLength;
	float cloudBaseKm;
	uvec3 threadOffset;
	int octaves;
	float time;
	float persistence;
	float humidity;
	float numWorleyOctaves;
	float zPixel;
	int numVolumes;
	float baseLayer;
	float transition;
	float upperDensity;
	float diffusivity;
	float baseMixingRatio;
	float maskThickness;
	vec2 maskCentre;
	float maskRadius;
	float maskFeather;
	vec3 cloudScalesKm;
	float time_step;
	vec3 lightDir;
	float alpha;
	float invBeta;
	int wrap;
	float viscousCoefficient;
	float seaLevelTemperatureK;
	vec3 cloudOriginKm;
	float vorticityConfinement;
	float worleyNoiseStrength;
	float worleyNoiseScale;
	float noisePeriod;
	int numAffectors;
	float localNoiseStrength;
	float localCellNoiseStrength;
	float baseNoiseFactor;
	float max_density_gm3;
	ivec3 gridEdge;
	float edgeSharpness;
	ivec3 idxOffset;
	float cloudLayerThicknessKm;
};
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t volumeNoiseTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/noise.sl"
float rand3(vec3 co)
{
return fract(sin(dot(co.xyz,vec3(12.9898,78.233,42.1897)))*43758.5453);
}
#line 42 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/noise.sl"
vec3 SphericalRandom(vec3 co)
{
float r=1.f-pow(rand3(co),4.0);
float az=rand3(43.1138*co)*2*3.1415926536;
float sine_el=rand3(17.981*co)*2.0-1.0;
float el=asin(sine_el);
float cos_el=cos(el);
vec3 v;
v.x=r*sin(az)*cos_el;
v.y=r*cos(az)*cos_el;
v.z=r*sine_el;
return v;
}
#line 75 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/noise.sl"
vec4 VirtualNoiseLookup(vec3 texCoords, int gridsize, int seed, bool pfilter)
{
vec4 result=vec4(0,0,0,0);
vec3 pos=fract(texCoords)*gridsize;
vec3 intpart,floatpart;
floatpart=modf(pos,intpart);
ivec3 seedpos=ivec3(2*seed,17*seed,7*seed);
ivec3 firstCorner=ivec3(intpart);
if(pfilter)
{
for(int i=0;i<2;i++)
{
for(int j=0;j<2;j++)
{
for(int k=0;k<2;k++)
{
ivec3 corner_pos=firstCorner+ivec3(1-i,1-j,1-k);
if(corner_pos.x==gridsize)corner_pos.x=0;
if(corner_pos.y==gridsize)corner_pos.y=0;
if(corner_pos.z==gridsize)corner_pos.z=0;
vec3 lookup_pos=seedpos+vec3(corner_pos);
float rndTap=rand3(lookup_pos);
vec4 rnd_lookup=vec4(rndTap,rndTap,rndTap,rndTap);
float proportion=abs(i-floatpart.x)*abs(j-floatpart.y)*abs(k-floatpart.z);
result+=rnd_lookup*proportion;
}

}

}

}
else

{
ivec3 corner_pos=ivec3(pos+vec3(0.5,0.5,0.5));
vec3 lookup_pos=seedpos+vec3(corner_pos);
float rndTap=rand3(lookup_pos);
result=vec4(rndTap,rndTap,rndTap,rndTap);
}

return result;
}
#line 69 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_gpu_clouds.sl"
float GetHumidityMultiplier2(float z, float baseLayerZ, float transitionZ, float upperDensity)
{
float upperLayerZ=1.0-baseLayerZ-transitionZ;
float i=saturate((z-baseLayerZ)/transitionZ);
float j=1.0-saturate((1.0-z)/upperLayerZ);
float m=mix(1.0,upperDensity,i);
float n=upperDensity*sqrt(1.0-j*j);
m*=step(z,baseLayerZ+transitionZ);
m=max(m,n);
return m;
}
#line 186 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_gpu_clouds.sl"
float NoiseFunction(uint64_t volumeNoiseTexture[24], vec3 pos, int octaves, float persistence, float t, float height, float texel)
{
float dens=0.0;
float mult=1.0;
float sum=0.0;
int resolution=4;
for(int i=0;i<5;i++)
{
vec3 pos2=pos;
float zmin=0.5*texel;
float zmax=height-0.5*texel;
pos2.z=clamp(pos2.z,0,0);
pos2.z*=saturate(i);
float lookup=VirtualNoiseLookup(pos2,resolution,1,true).x;
float val=cos(2.0*3.1415926536*(lookup+t));
dens=dens+mult*val;
sum=sum+mult;
mult=mult*persistence;
pos=pos*2.0;
t=t*2.0;
height*=2.0;
resolution*=2;
}

dens=persistence*(dens/sum);
return dens;
}
#line 229 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_gpu_clouds.sl"
float RestrictedWorley(vec3 texc, int grid, int seed, float zmax)
{
vec3 pos=float(grid)*texc;
vec3 fractional,intpart;
fractional=modf(pos,intpart);
ivec3 ip=ivec3(intpart);
vec3 loc=fractional-vec3(0.5,0.5,0.5);
float g=float(grid);
float n=g;
for(int i=-1;i<2;++i)
{
for(int j=-1;j<2;++j)
{
for(int k=-1;k<2;++k)
{
ivec3 I=ivec3(i,j,k);
vec3 c=vec3(I);
ivec3 u=(ip+I);
ivec3 v=ivec3(typed_mod((u+ivec3(grid,grid,grid)),ivec3(grid,grid,grid)));
vec3 random=SphericalRandom(vec3(v)*float(seed));
c+=.5*random.xyz;
vec3 diff=loc-c;
float dist=length(diff);
float top=(ip.z+c.z+1.0)/g;
float bot=(ip.z+c.z-1.0)/g;
if(top<zmax)n=min(n,dist);
}

}

}

float p=saturate(1.0-n/1.0);
return p;
}
#line 256 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/simul_gpu_clouds.sfx"
float CSDensity(uvec3 pos)
{
uvec3 dims;
ivec3 ivtargetTexture1 = imageSize(targetTexture1);
dims.x = ivtargetTexture1.x;dims.y = ivtargetTexture1.y;dims.z = ivtargetTexture1.z;;
uvec3 noise_dims;
ivec3 ivvolumeNoiseTexture = textureSize(sampler3D(volumeNoiseTexture[0]),0);
noise_dims.x = ivvolumeNoiseTexture.x;noise_dims.y = ivvolumeNoiseTexture.y;noise_dims.z = ivvolumeNoiseTexture.z;;
if(pos.x>=dims.x||pos.y>=dims.y||pos.z>=dims.z)return 0.0;
vec3 densityspace_texcoord=(vec3(pos)+vec3(0.5,0.5,0.5))/vec3(dims);
vec3 noisespace_texcoord=densityspace_texcoord*noiseScale;
vec4 worley=vec4(0,0,0,0);
vec3 tc=2*noisespace_texcoord;
float u=1.5;
float a=.75;
float noise_texel=1.0/float(noise_dims.z);
float height=noiseScale.z;
float fl=0.0;
float ff=modf(worleyNoiseScale,fl);
vec3 worley_texcoord=noisespace_texcoord;
float p=0;
float m=4.0;
float hm=2.0*(humidity*GetHumidityMultiplier2(densityspace_texcoord.z,baseLayer,transition,upperDensity)-0.5);
float noise_val=NoiseFunction(volumeNoiseTexture,noisespace_texcoord,octaves,persistence,time,height,noise_texel);
float dens=hm+noise_val;
float texc_scale=noiseScale.z;
float grid1=fl*4.0;
float grid2=(fl+1.0)*4.0;
vec3 wtexc=densityspace_texcoord*noiseScale/noiseScale.x;
float zratio=4.0*noiseScale.z/noiseScale.x;
for(int j=0;j<2;j++)
{
float w1=RestrictedWorley(wtexc,int(grid1),int(grid1),zratio);
float w2=RestrictedWorley(wtexc,int(grid2),int(grid2),zratio);
float w=pow(mix(w1,w2,ff),0.7);
w=m*(w-0.52);
dens=(dens+worleyNoiseStrength*w);
m*=.53;
grid1*=2.0;
grid2*=2.0;
grid1+=1.0;
grid2+=1.0;
}

vec3 wPos=(mul(transformMatrix,vec4(densityspace_texcoord.xyz,1.0))).xyz;
return dens;
}
layout(local_size_x=8, local_size_y=8, local_size_z=1) in;
void main()
{
uvec3 g = gl_WorkGroupID;
uvec3 t = gl_LocalInvocationID;
#line 495 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/simul_gpu_clouds.sfx"
uvec3 sub_pos=g*uvec3(8,8,1)+t;
uvec3 pos=sub_pos+threadOffset;
uvec3 dims;
ivec3 ivtargetTexture1 = imageSize(targetTexture1);
dims.x = ivtargetTexture1.x;dims.y = ivtargetTexture1.y;dims.z = ivtargetTexture1.z;;
if(pos.x>=dims.x||pos.y>=dims.y||pos.z>=dims.z)return ;
float dens=CSDensity(pos);
imageStore(targetTexture1,ivec3(ivec3(pos)),vec4(dens));
;
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/simul_gpu_clouds_CS_Density_41a_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)


layout(r32f, binding = 1) uniform image3D targetTexture1;
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
layout(std140, binding = 8) uniform GpuCloudConstants
{
	mat4 transformMatrix;
	vec4 yRange;
	vec3 noiseScale;
	float sourceNoiseScaleKm;
	vec2 extinctions;
	float stepLength;
	float cloudBaseKm;
	uvec3 threadOffset;
	int octaves;
	float time;
	float persistence;
	float humidity;
	float numWorleyOctaves;
	float zPixel;
	int numVolumes;
	float baseLayer;
	float transition;
	float upperDensity;
	float diffusivity;
	float baseMixingRatio;
	float maskThickness;
	vec2 maskCentre;
	float maskRadius;
	float maskFeather;
	vec3 cloudScalesKm;
	float time_step;
	vec3 lightDir;
	float alpha;
	float invBeta;
	int wrap;
	float viscousCoefficient;
	float seaLevelTemperatureK;
	vec3 cloudOriginKm;
	float vorticityConfinement;
	float worleyNoiseStrength;
	float worleyNoiseScale;
	float noisePeriod;
	int numAffectors;
	float localNoiseStrength;
	float localCellNoiseStrength;
	float baseNoiseFactor;
	float max_density_gm3;
	ivec3 gridEdge;
	float edgeSharpness;
	ivec3 idxOffset;
	float cloudLayerThicknessKm;
};
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t volumeNoiseTexture[24];
	uint64_t worleyTexture3D[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_gpu_clouds.sl"
float GetHumidityMultiplier_41a(float z, float baseLayer, float transition, float upperDensity)
{
float i=pow(saturate((z-baseLayer)/transition),0.5);
float m=(1.0-i)+upperDensity*i;
m*=pow(saturate((1.0-z)/transition),0.5);
return m;
}
#line 155 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_gpu_clouds.sl"
float NoiseFunction_41a(uint64_t volumeNoiseTexture[24], vec3 pos, int octaves, float persistence, float t, float height, float texel)
{
float dens=0.0;
float mult=0.5;
float sum=0.0;
for(int i=0;i<5;i++)
{
if(i>=octaves)break;
vec3 pos2=pos;
float zmin=0.5*texel;
float zmax=height-0.5*texel;
pos2.z=clamp(pos2.z,zmin,zmax);
pos2.z*=saturate(i);
float lookup=textureLod(sampler3D(volumeNoiseTexture[1 + 6]),pos2,0).x;
float val=cos(2.0*3.1415926536*(lookup+t));
dens=dens+mult*val;
sum=sum+mult;
mult=mult*persistence;
pos=pos*2.0;
t=t*2.0;
height*=2.0;
}

dens=(dens/sum);
return dens;
}
#line 324 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/simul_gpu_clouds.sfx"
float CSDensity_41a(uvec3 pos)
{
uvec3 dims;
ivec3 ivtargetTexture1 = imageSize(targetTexture1);
dims.x = ivtargetTexture1.x;dims.y = ivtargetTexture1.y;dims.z = ivtargetTexture1.z;;
uvec3 noise_dims;
ivec3 ivvolumeNoiseTexture = textureSize(sampler3D(volumeNoiseTexture[0]),0);
noise_dims.x = ivvolumeNoiseTexture.x;noise_dims.y = ivvolumeNoiseTexture.y;noise_dims.z = ivvolumeNoiseTexture.z;;
if(pos.x>=dims.x||pos.y>=dims.y||pos.z>=dims.z)return 0.0;
vec3 densityspace_texcoord=(vec3(pos)+vec3(0.5,0.5,0.5))/vec3(dims);
vec3 noisespace_texcoord=(densityspace_texcoord+vec3(0,0,0.0*zPixel))*vec3(noiseScale)+vec3(1.0,1.0,0);
vec4 worley=vec4(0,0,0,0);
vec3 tc=2*noisespace_texcoord;
float u=1.5;
float a=.75;
float noise_texel=1.0/float(noise_dims.z);
float height=noiseScale.z;
float fl=0.0;
float ff=modf(worleyNoiseScale,fl);
vec3 worley_texcoord=noisespace_texcoord;
vec4 w1=textureLod(sampler3D(worleyTexture3D[1 + 6]),fl*worley_texcoord,0);
vec4 w2=textureLod(sampler3D(worleyTexture3D[1 + 6]),(fl+1.0)*worley_texcoord,0);
worley=mix(w1,w2,ff);
float noise_val=NoiseFunction_41a(volumeNoiseTexture,noisespace_texcoord,octaves,persistence,time,height,noise_texel);
float w=(worley.x-1.0)+(worley.y-1.0)+(worley.z-1.0)+(worley.w-1.0);
vec4 mask=vec4(0.0,0.0,0.0,1.0);
float hm=humidity*mask.a;
hm=saturate(hm+mask.r-mask.g);
hm*=GetHumidityMultiplier_41a(densityspace_texcoord.z,baseLayer,transition,upperDensity);
float dens=noise_val+2.5*hm-1.0;
dens=saturate((dens-0.5)/diffusivity+0.5);
dens=saturate(3.0*dens-2.0+2.0*worleyNoiseStrength*(1.5+w));
#line 359 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/simul_gpu_clouds.sfx"

vec3 wPos=(mul(transformMatrix,vec4(densityspace_texcoord.xyz,1.0))).xyz;
dens*=saturate(densityspace_texcoord.z/zPixel-0.5)*saturate((1.0-0.5*zPixel-densityspace_texcoord.z)/zPixel);
return dens;
}
layout(local_size_x=8, local_size_y=8, local_size_z=1) in;
void main()
{
uvec3 g = gl_WorkGroupID;
uvec3 t = gl_LocalInvocationID;
#line 508 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/simul_gpu_clouds.sfx"
uvec3 sub_pos=g*uvec3(8,8,1)+t;
uvec3 pos=sub_pos+threadOffset;
uvec3 dims;
ivec3 ivtargetTexture1 = imageSize(targetTexture1);
dims.x = ivtargetTexture1.x;dims.y = ivtargetTexture1.y;dims.z = ivtargetTexture1.z;;
if(pos.x>=dims.x||pos.y>=dims.y||pos.z>=dims.z)return ;
float dens=CSDensity_41a(pos);
imageStore(targetTexture1,ivec3(ivec3(pos)),vec4(dens));
;
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/simul_gpu_clouds_CS_Density_James_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)


layout(r32f, binding = 1) uniform image3D targetTexture1;
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
layout(std140, binding = 8) uniform GpuCloudConstants
{
	mat4 transformMatrix;
	vec4 yRange;
	vec3 noiseScale;
	float sourceNoiseScaleKm;
	vec2 extinctions;
	float stepLength;
	float cloudBaseKm;
	uvec3 threadOffset;
	int octaves;
	float time;
	float persistence;
	float humidity;
	float numWorleyOctaves;
	float zPixel;
	int numVolumes;
	float baseLayer;
	float transition;
	float upperDensity;
	float diffusivity;
	float baseMixingRatio;
	float maskThickness;
	vec2 maskCentre;
	float maskRadius;
	float maskFeather;
	vec3 cloudScalesKm;
	float time_step;
	vec3 lightDir;
	float alpha;
	float invBeta;
	int wrap;
	float viscousCoefficient;
	float seaLevelTemperatureK;
	vec3 cloudOriginKm;
	float vorticityConfinement;
	float worleyNoiseStrength;
	float worleyNoiseScale;
	float noisePeriod;
	int numAffectors;
	float localNoiseStrength;
	float localCellNoiseStrength;
	float baseNoiseFactor;
	float max_density_gm3;
	ivec3 gridEdge;
	float edgeSharpness;
	ivec3 idxOffset;
	float cloudLayerThicknessKm;
};
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t volumeNoiseTexture[24];
	uint64_t worleyTexture3D[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_gpu_clouds.sl"
float GetHumidityMultiplier_41a(float z, float baseLayer, float transition, float upperDensity)
{
float i=pow(saturate((z-baseLayer)/transition),0.5);
float m=(1.0-i)+upperDensity*i;
m*=pow(saturate((1.0-z)/transition),0.5);
return m;
}
#line 155 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_gpu_clouds.sl"
float NoiseFunction_41a(uint64_t volumeNoiseTexture[24], vec3 pos, int octaves, float persistence, float t, float height, float texel)
{
float dens=0.0;
float mult=0.5;
float sum=0.0;
for(int i=0;i<5;i++)
{
if(i>=octaves)break;
vec3 pos2=pos;
float zmin=0.5*texel;
float zmax=height-0.5*texel;
pos2.z=clamp(pos2.z,zmin,zmax);
pos2.z*=saturate(i);
float lookup=textureLod(sampler3D(volumeNoiseTexture[1 + 6]),pos2,0).x;
float val=cos(2.0*3.1415926536*(lookup+t));
dens=dens+mult*val;
sum=sum+mult;
mult=mult*persistence;
pos=pos*2.0;
t=t*2.0;
height*=2.0;
}

dens=(dens/sum);
return dens;
}
#line 324 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/simul_gpu_clouds.sfx"
float CSDensity_41a(uvec3 pos)
{
uvec3 dims;
ivec3 ivtargetTexture1 = imageSize(targetTexture1);
dims.x = ivtargetTexture1.x;dims.y = ivtargetTexture1.y;dims.z = ivtargetTexture1.z;;
uvec3 noise_dims;
ivec3 ivvolumeNoiseTexture = textureSize(sampler3D(volumeNoiseTexture[0]),0);
noise_dims.x = ivvolumeNoiseTexture.x;noise_dims.y = ivvolumeNoiseTexture.y;noise_dims.z = ivvolumeNoiseTexture.z;;
if(pos.x>=dims.x||pos.y>=dims.y||pos.z>=dims.z)return 0.0;
vec3 densityspace_texcoord=(vec3(pos)+vec3(0.5,0.5,0.5))/vec3(dims);
vec3 noisespace_texcoord=(densityspace_texcoord+vec3(0,0,0.0*zPixel))*vec3(noiseScale)+vec3(1.0,1.0,0);
vec4 worley=vec4(0,0,0,0);
vec3 tc=2*noisespace_texcoord;
float u=1.5;
float a=.75;
float noise_texel=1.0/float(noise_dims.z);
float height=noiseScale.z;
float fl=0.0;
float ff=modf(worleyNoiseScale,fl);
vec3 worley_texcoord=noisespace_texcoord;
vec4 w1=textureLod(sampler3D(worleyTexture3D[1 + 6]),fl*worley_texcoord,0);
vec4 w2=textureLod(sampler3D(worleyTexture3D[1 + 6]),(fl+1.0)*worley_texcoord,0);
worley=mix(w1,w2,ff);
float noise_val=NoiseFunction_41a(volumeNoiseTexture,noisespace_texcoord,octaves,persistence,time,height,noise_texel);
float w=(worley.x-1.0)+(worley.y-1.0)+(worley.z-1.0)+(worley.w-1.0);
vec4 mask=vec4(0.0,0.0,0.0,1.0);
float hm=humidity*mask.a;
hm=saturate(hm+mask.r-mask.g);
hm*=GetHumidityMultiplier_41a(densityspace_texcoord.z,baseLayer,transition,upperDensity);
float dens=noise_val+2.5*hm-1.0;
dens=saturate((dens-0.5)/diffusivity+0.5);
dens=saturate(3.0*dens-2.0+2.0*worleyNoiseStrength*(1.5+w));
#line 359 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/simul_gpu_clouds.sfx"

vec3 wPos=(mul(transformMatrix,vec4(densityspace_texcoord.xyz,1.0))).xyz;
dens*=saturate(densityspace_texcoord.z/zPixel-0.5)*saturate((1.0-0.5*zPixel-densityspace_texcoord.z)/zPixel);
return dens;
}
layout(local_size_x=8, local_size_y=8, local_size_z=1) in;
void main()
{
uvec3 g = gl_WorkGroupID;
uvec3 t = gl_LocalInvocationID;
#line 521 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/simul_gpu_clouds.sfx"
uvec3 sub_pos=g*uvec3(8,8,1)+t;
uvec3 pos=sub_pos+threadOffset;
uvec3 dims;
ivec3 ivtargetTexture1 = imageSize(targetTexture1);
dims.x = ivtargetTexture1.x;dims.y = ivtargetTexture1.y;dims.z = ivtargetTexture1.z;;
if(pos.x>=dims.x||pos.y>=dims.y||pos.z>=dims.z)return ;
float dens=CSDensity_41a(pos);
imageStore(targetTexture1,ivec3(ivec3(pos)),vec4(dens));
;
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/simul_gpu_clouds_CS_GenMip_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)

layout(rgba8, binding = 0) uniform image3D targetTexture;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t densityTexture[24];
};
layout(local_size_x=4, local_size_y=4, local_size_z=4) in;
void main()
{
uvec3 g = gl_WorkGroupID;
uvec3 t = gl_LocalInvocationID;
#line 693 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/simul_gpu_clouds.sfx"
uvec3 pos=uvec3(g*4+t);
uvec3 pos2=pos*2;
uint x=1;
uint y=1;
vec4 c1=texelFetch(sampler3D(densityTexture[0]),ivec3(pos2+ivec3(0,0,0)).xyz,0);
vec4 c2=texelFetch(sampler3D(densityTexture[0]),ivec3(pos2+ivec3(x,0,0)).xyz,0);
vec4 c3=texelFetch(sampler3D(densityTexture[0]),ivec3(pos2+ivec3(0,y,0)).xyz,0);
vec4 c4=texelFetch(sampler3D(densityTexture[0]),ivec3(pos2+ivec3(x,y,0)).xyz,0);
vec4 c5=texelFetch(sampler3D(densityTexture[0]),ivec3(pos2+ivec3(0,0,1)).xyz,0);
vec4 c6=texelFetch(sampler3D(densityTexture[0]),ivec3(pos2+ivec3(x,0,1)).xyz,0);
vec4 c7=texelFetch(sampler3D(densityTexture[0]),ivec3(pos2+ivec3(0,y,1)).xyz,0);
vec4 c8=texelFetch(sampler3D(densityTexture[0]),ivec3(pos2+ivec3(x,y,1)).xyz,0);
vec4 res=0.125*(c1+c2+c3+c4+c5+c6+c7+c8);
vec4 mx=max(max(max(c1,c2),max(c3,c4)),max(max(c5,c6),max(c7,c8)));
uvec3 dims;
ivec3 ivtargetTexture = imageSize(targetTexture);
dims.x = ivtargetTexture.x;dims.y = ivtargetTexture.y;dims.z = ivtargetTexture.z;;
if(pos.z==0||pos.z==dims.z-1)
{
res=vec4(mx.xy,res.z,mx.w);
}

imageStore(targetTexture,ivec3(pos),vec4(res));
;
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/simul_gpu_clouds_PS_DensityMask.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
layout(std140, binding = 8) uniform GpuCloudConstants
{
	mat4 transformMatrix;
	vec4 yRange;
	vec3 noiseScale;
	float sourceNoiseScaleKm;
	vec2 extinctions;
	float stepLength;
	float cloudBaseKm;
	uvec3 threadOffset;
	int octaves;
	float time;
	float persistence;
	float humidity;
	float numWorleyOctaves;
	float zPixel;
	int numVolumes;
	float baseLayer;
	float transition;
	float upperDensity;
	float diffusivity;
	float baseMixingRatio;
	float maskThickness;
	vec2 maskCentre;
	float maskRadius;
	float maskFeather;
	vec3 cloudScalesKm;
	float time_step;
	vec3 lightDir;
	float alpha;
	float invBeta;
	int wrap;
	float viscousCoefficient;
	float seaLevelTemperatureK;
	vec3 cloudOriginKm;
	float vorticityConfinement;
	float worleyNoiseStrength;
	float worleyNoiseScale;
	float noisePeriod;
	int numAffectors;
	float localNoiseStrength;
	float localCellNoiseStrength;
	float baseNoiseFactor;
	float max_density_gm3;
	ivec3 gridEdge;
	float edgeSharpness;
	ivec3 idxOffset;
	float cloudLayerThicknessKm;
};
#line 31 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/simul_gpu_clouds.sfx"
struct vertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/simul_gpu_clouds.sfx"
struct ColourDepthOutput
{
	vec4 colour;
	float depth;
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 217 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_gpu_clouds.sl"
float GpuCloudMask(vec2 texCoords, vec2 maskCentre, float maskRadius, float maskFeather, float maskThickness, mat4 cloudspaceToWorldspaceMatrix)
{
vec3 wPos=(mul(cloudspaceToWorldspaceMatrix,vec4(texCoords.xy,0,1))).xyz;
vec2 pos=wPos.xy-maskCentre;
float r=length(pos);
float dens=maskThickness*saturate((maskRadius-r)/maskFeather);
return dens;
}
layout(location = 0) in Block
{
vertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 colour;

layout(location = 1) out float depth;

void main()
{
vertexOutput BlockData=ioblock.BlockData;
#line 58 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/simul_gpu_clouds.sfx"
ColourDepthOutput result;
float dens=GpuCloudMask(BlockData.texCoords,maskCentre,maskRadius,maskFeather,maskThickness,transformMatrix);
result.colour=vec4(0.0,0.0,0.0,dens);
result.depth=dens;
ColourDepthOutput tmp =  result;
colour = tmp.colour;
depth = tmp.depth;

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/simul_gpu_clouds_VS_Main_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
layout(std140, binding = 8) uniform GpuCloudConstants
{
	mat4 transformMatrix;
	vec4 yRange;
	vec3 noiseScale;
	float sourceNoiseScaleKm;
	vec2 extinctions;
	float stepLength;
	float cloudBaseKm;
	uvec3 threadOffset;
	int octaves;
	float time;
	float persistence;
	float humidity;
	float numWorleyOctaves;
	float zPixel;
	int numVolumes;
	float baseLayer;
	float transition;
	float upperDensity;
	float diffusivity;
	float baseMixingRatio;
	float maskThickness;
	vec2 maskCentre;
	float maskRadius;
	float maskFeather;
	vec3 cloudScalesKm;
	float time_step;
	vec3 lightDir;
	float alpha;
	float invBeta;
	int wrap;
	float viscousCoefficient;
	float seaLevelTemperatureK;
	vec3 cloudOriginKm;
	float vorticityConfinement;
	float worleyNoiseStrength;
	float worleyNoiseScale;
	float noisePeriod;
	int numAffectors;
	float localNoiseStrength;
	float localCellNoiseStrength;
	float baseNoiseFactor;
	float max_density_gm3;
	ivec3 gridEdge;
	float edgeSharpness;
	ivec3 idxOffset;
	float cloudLayerThicknessKm;
};
#line 31 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/simul_gpu_clouds.sfx"
struct vertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
layout(location = 0) out Block
{
vertexOutput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 34 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/simul_gpu_clouds.sfx"
vertexOutput OUT;
vec2 poss[4]={{1.0,0.0},{1.0,1.0},{0.0,0.0},{0.0,1.0},};
vec2 pos=poss[IN.vertex_id];
pos.y=yRange.x+pos.y*yRange.y;
vec4 vert_pos=vec4(vec2(-1.0,1.0)+2.0*vec2(pos.x,-pos.y),1.0,1.0);
OUT.hPosition=vert_pos;
OUT.texCoords=pos;
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/simul_gpu_clouds_VS_Main_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
layout(std140, binding = 8) uniform GpuCloudConstants
{
	mat4 transformMatrix;
	vec4 yRange;
	vec3 noiseScale;
	float sourceNoiseScaleKm;
	vec2 extinctions;
	float stepLength;
	float cloudBaseKm;
	uvec3 threadOffset;
	int octaves;
	float time;
	float persistence;
	float humidity;
	float numWorleyOctaves;
	float zPixel;
	int numVolumes;
	float baseLayer;
	float transition;
	float upperDensity;
	float diffusivity;
	float baseMixingRatio;
	float maskThickness;
	vec2 maskCentre;
	float maskRadius;
	float maskFeather;
	vec3 cloudScalesKm;
	float time_step;
	vec3 lightDir;
	float alpha;
	float invBeta;
	int wrap;
	float viscousCoefficient;
	float seaLevelTemperatureK;
	vec3 cloudOriginKm;
	float vorticityConfinement;
	float worleyNoiseStrength;
	float worleyNoiseScale;
	float noisePeriod;
	int numAffectors;
	float localNoiseStrength;
	float localCellNoiseStrength;
	float baseNoiseFactor;
	float max_density_gm3;
	ivec3 gridEdge;
	float edgeSharpness;
	ivec3 idxOffset;
	float cloudLayerThicknessKm;
};
#line 31 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/simul_gpu_clouds.sfx"
struct vertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
layout(location = 0) out Block
{
vertexOutput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 34 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/simul_gpu_clouds.sfx"
vertexOutput OUT;
vec2 poss[4]={{1.0,0.0},{1.0,1.0},{0.0,0.0},{0.0,1.0},};
vec2 pos=poss[IN.vertex_id];
pos.y=yRange.x+pos.y*yRange.y;
vec4 vert_pos=vec4(vec2(-1.0,1.0)+2.0*vec2(pos.x,-pos.y),1.0,1.0);
OUT.hPosition=vert_pos;
OUT.texCoords=pos;
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}