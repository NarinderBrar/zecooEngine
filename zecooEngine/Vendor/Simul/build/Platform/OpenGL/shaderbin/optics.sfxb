#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/optics_PS_Flare.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/optics_constants.sl"
layout(std140, binding = 10) uniform OpticsConstants
{
	mat4 worldViewProj;
	vec4 colour;
	mat4 view;
	mat4 invProj;
	mat4 invViewProj;
	vec3 lightDir;
	float radiusRadians;
	vec4 depthToLinFadeDistParams;
	float rainbowIntensity;
	float dropletRadius;
	float ahgage;
	float aejhue;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t flareTexture[24];
};
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 37 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/optics.sfx"
vec3 res=colour.rgb*texture(sampler2D(flareTexture[1 + 9]),vec2(0.5,0.5)+0.5*BlockData.texCoords).rgb;
{returnObject_vec4=vec4(res.rgb,1.f);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/optics_PS_rainbowAndCorona.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/optics_constants.sl"
layout(std140, binding = 10) uniform OpticsConstants
{
	mat4 worldViewProj;
	vec4 colour;
	mat4 view;
	mat4 invProj;
	mat4 invViewProj;
	vec3 lightDir;
	float radiusRadians;
	vec4 depthToLinFadeDistParams;
	float rainbowIntensity;
	float dropletRadius;
	float ahgage;
	float aejhue;
};



#line 48 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/optics.sfx"
struct rainbowVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
	vec3 view;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t rainbowLookupTexture[24];
	uint64_t coronaLookupTexture[24];
	uint64_t moistureTexture[24];
};
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/optics.sfx"
vec4 CalculateRainbowColor(rainbowVertexOutput IN, float d, out vec4 moisture)
{
vec4 scattered=texture(sampler2D(rainbowLookupTexture[1 + 9]),vec2(dropletRadius,d));
moisture=texture(sampler2D(moistureTexture[1 + 9]),IN.texCoords);
return scattered;
}
layout(location = 0) in Block
{
rainbowVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
rainbowVertexOutput BlockData=ioblock.BlockData;
#line 101 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/optics.sfx"
float d=-dot(lightDir,normalize(BlockData.view));
vec4 moisture;
vec4 scattered=CalculateRainbowColor(BlockData,d,moisture);
vec4 coronaDiffracted=texture(sampler2D(coronaLookupTexture[1 + 9]),vec2(dropletRadius,1.0+d));
{returnObject_vec4=vec4(.1,0,0,0);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/optics_VS_Flare_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/optics_constants.sl"
layout(std140, binding = 10) uniform OpticsConstants
{
	mat4 worldViewProj;
	vec4 colour;
	mat4 view;
	mat4 invProj;
	mat4 invViewProj;
	vec3 lightDir;
	float radiusRadians;
	vec4 depthToLinFadeDistParams;
	float rainbowIntensity;
	float dropletRadius;
	float ahgage;
	float aejhue;
};
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/optics.sfx"
struct indexVertexInput
{
	flat uint vertex_id;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
layout(location = 0) out Block
{
posTexVertexOutput BlockData;
} ioblock;
void main()
{
indexVertexInput IN;
IN.vertex_id=gl_VertexID;
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/optics.sfx"
posTexVertexOutput OUT;
vec2 poss[4]={{1.0,-1.0},{1.0,1.0},{-1.0,-1.0},{-1.0,1.0},};
vec3 pos=vec3(poss[IN.vertex_id],1.0/tan(radiusRadians));
OUT.hPosition=mul(worldViewProj,vec4(pos,1.0));
OUT.hPosition.z=0.0f;
OUT.texCoords=pos.xy;
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/optics_VS_Flare_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/optics_constants.sl"
layout(std140, binding = 10) uniform OpticsConstants
{
	mat4 worldViewProj;
	vec4 colour;
	mat4 view;
	mat4 invProj;
	mat4 invViewProj;
	vec3 lightDir;
	float radiusRadians;
	vec4 depthToLinFadeDistParams;
	float rainbowIntensity;
	float dropletRadius;
	float ahgage;
	float aejhue;
};
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/optics.sfx"
struct indexVertexInput
{
	flat uint vertex_id;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
layout(location = 0) out Block
{
posTexVertexOutput BlockData;
} ioblock;
void main()
{
indexVertexInput IN;
IN.vertex_id=gl_VertexID;
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/optics.sfx"
posTexVertexOutput OUT;
vec2 poss[4]={{1.0,-1.0},{1.0,1.0},{-1.0,-1.0},{-1.0,1.0},};
vec3 pos=vec3(poss[IN.vertex_id],1.0/tan(radiusRadians));
OUT.hPosition=mul(worldViewProj,vec4(pos,1.0));
OUT.hPosition.z=0.0f;
OUT.texCoords=pos.xy;
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/optics_VS_rainbow_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/optics_constants.sl"
layout(std140, binding = 10) uniform OpticsConstants
{
	mat4 worldViewProj;
	vec4 colour;
	mat4 view;
	mat4 invProj;
	mat4 invViewProj;
	vec3 lightDir;
	float radiusRadians;
	vec4 depthToLinFadeDistParams;
	float rainbowIntensity;
	float dropletRadius;
	float ahgage;
	float aejhue;
};
#line 48 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/optics.sfx"
struct rainbowVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
	vec3 view;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 119 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput SimpleFullscreen(idOnly IN)
{
posTexVertexOutput OUT;
vec2 poss[4];
poss[0]=vec2(1.0,-1.0);
poss[1]=vec2(1.0,1.0);
poss[2]=vec2(-1.0,-1.0);
poss[3]=vec2(-1.0,1.0);
vec2 pos=poss[IN.vertex_id];
OUT.hPosition=vec4(pos,0.0,1.0);
OUT.hPosition.z=0.0;
OUT.texCoords=0.5*(vec2(1.0,1.0)+vec2(pos.x,-pos.y));
#line 132 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

OUT.texCoords.y=1.0-OUT.texCoords.y;
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

return OUT;
}
layout(location = 0) out Block
{
rainbowVertexOutput BlockData;
} ioblock;
void main()
{
idOnly id;
id.vertex_id=gl_VertexID;
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/optics.sfx"
posTexVertexOutput posTex=SimpleFullscreen(id);
rainbowVertexOutput OUT;
OUT.hPosition=posTex.hPosition;
OUT.texCoords=posTex.texCoords;
vec2 clip_pos=OUT.hPosition.xy;
OUT.view=mul(invViewProj,vec4(clip_pos.xy,1.0,1.0)).xyz;
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/optics_VS_rainbow_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/optics_constants.sl"
layout(std140, binding = 10) uniform OpticsConstants
{
	mat4 worldViewProj;
	vec4 colour;
	mat4 view;
	mat4 invProj;
	mat4 invViewProj;
	vec3 lightDir;
	float radiusRadians;
	vec4 depthToLinFadeDistParams;
	float rainbowIntensity;
	float dropletRadius;
	float ahgage;
	float aejhue;
};
#line 48 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/optics.sfx"
struct rainbowVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
	vec3 view;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 119 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput SimpleFullscreen(idOnly IN)
{
posTexVertexOutput OUT;
vec2 poss[4];
poss[0]=vec2(1.0,-1.0);
poss[1]=vec2(1.0,1.0);
poss[2]=vec2(-1.0,-1.0);
poss[3]=vec2(-1.0,1.0);
vec2 pos=poss[IN.vertex_id];
OUT.hPosition=vec4(pos,0.0,1.0);
OUT.hPosition.z=0.0;
OUT.texCoords=0.5*(vec2(1.0,1.0)+vec2(pos.x,-pos.y));
#line 132 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

OUT.texCoords.y=1.0-OUT.texCoords.y;
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

return OUT;
}
layout(location = 0) out Block
{
rainbowVertexOutput BlockData;
} ioblock;
void main()
{
idOnly id;
id.vertex_id=gl_VertexID;
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/optics.sfx"
posTexVertexOutput posTex=SimpleFullscreen(id);
rainbowVertexOutput OUT;
OUT.hPosition=posTex.hPosition;
OUT.texCoords=posTex.texCoords;
vec2 clip_pos=OUT.hPosition.xy;
OUT.view=mul(invViewProj,vec4(clip_pos.xy,1.0,1.0)).xyz;
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}