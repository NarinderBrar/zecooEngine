#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
//#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/light_probes_CS_CopyFace_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)

layout(rgba32f, binding = 0) uniform image2D copyTargetTexture;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t copySourceTexture[24];
};
layout(local_size_x=8, local_size_y=8, local_size_z=1) in;
void main()
{
uvec3 sub_pos = gl_GlobalInvocationID;
//#line 1581 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec4 linear_src=texelFetch(sampler2D(copySourceTexture[0]),ivec2(sub_pos.xy).xy,0);
vec4 result=linear_src;
imageStore(copyTargetTexture,ivec2(sub_pos.xy),vec4(result));
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/light_probes_PS_BlendMip.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
layout(std140, binding = 9) uniform LightProbeConstants
{
	mat4 invViewProj;
	int cubeFace;
	int numSHBands;
	int mipIndex;
	int numMips;
	float alpha;
	float roughness;
	vec2 padding;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t sourceTextureArray[24];
};
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
//#line 1392 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec4 src_lookup=textureLod(sampler2DArray(sourceTextureArray[1 + 9]),vec3(BlockData.texCoords.xy,0),0);
src_lookup.a=alpha;
{returnObject_vec4=src_lookup;}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/light_probes_PS_CopyFace.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t copySourceTexture[24];
};
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
//#line 1544 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec4 linear_src=textureLod(sampler2D(copySourceTexture[1 + 9]),BlockData.texCoords,0);
vec4 result=linear_src;
{returnObject_vec4=result;}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/light_probes_PS_IrradianceMap.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
layout(std140, binding = 9) uniform LightProbeConstants
{
	mat4 invViewProj;
	int cubeFace;
	int numSHBands;
	int mipIndex;
	int numMips;
	float alpha;
	float roughness;
	vec2 padding;
};
layout(std430, binding = 0) buffer basisBuffer_ssbo
{
	vec4 basisBuffer[]; 
};
//#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
//#line 23 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
//#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
//#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
//#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
//#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
//#line 29 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
//#line 31 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
//#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
//#line 33 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
//#line 1012 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
float K(int l, int m)
{
const float kval[]={0.282094792,0.488602512,0.345494149,0.630783131,0.257516135,0.128758067,0.746352665,0.215453456,0.068132365,0.027814922,0.846284375,0.189234939,0.044603103,0.011920681,0.004214597,0.93560258,0.170816879,0.032281356,0.006589404,0.001553137,0.000491145,1.017107236,0.156943054,0.024814876,0.004135813,0.000755093,0.000160986,4.64727E-05,1.092548431,0.145997925,0.019867801,0.002809731,0.000423583,7.05972E-05,1.38452E-05,3.7003E-06,1.163106623,0.13707343,0.016383409,0.002016658,0.000260349,3.6104E-05,5.57096E-06,1.01711E-06,2.54279E-07,1.22962269,0.129613612,0.013816857,0.001507543,0.000170696,2.0402E-05,2.63389E-06,3.80169E-07,6.51985E-08,1.53674E-08,1.292720736,0.123256086,0.011860322,0.001163,0.000117481,1.23836E-05,1.38452E-06,1.67898E-07,2.28481E-08,3.70644E-09,8.28786E-10,1.352879095,0.117753011,0.010327622,0.000920058,8.39894E-05,7.93625E-06,7.85806E-07,8.28312E-08,9.50139E-09,1.22662E-09,1.89272E-10,4.0353E-11};
int idx=l*(l+1)/2+abs(m);
return kval[idx];
}
//#line 1101 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
float P(int l, int m, float x)
{
float pmm=1.0;
if(m>0)
{
float somx2=sqrt((1.0-x)*(1.0+x));
float fact=1.0;
for(int i=1;i<=m;i++)
{
pmm*=(-fact)*somx2;
fact+=2.0;
}

}

if(l==m)return pmm;
float pmmp1=x*(2.0*m+1.0)*pmm;
if(l==m+1)return pmmp1;
float pll=0.0;
for(int ll=m+2;ll<=l;++ll)
{
pll=((2.0*ll-1.0)*x*pmmp1-(ll+m-1.0)*pmm)/(ll-m);
pmm=pmmp1;
pmmp1=pll;
}

return pll;
}
//#line 1129 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
float WindowFunction(float x)
{
return saturate((0.0001+sin(3.1415926536*x))/(0.0001+3.1415926536*x));
}
//#line 1134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
float SH(int l, int m, float theta, float phi)
{
const float sqrt2=sqrt(2.0);
float s=0.0;
if(m==0)s=K(l,0)*float(P(l,m,cos(theta)));else
if(m>0)s=sqrt2*K(l,m)*cos(m*phi)*P(l,m,cos(theta));else
s=sqrt2*K(l,-m)*sin(-m*phi)*P(l,-m,cos(theta));
return s;
}
//#line 1309 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec4 EvaluateSH(vec3 view)
{
float theta=acos(view.z);
float phi=atan(view.y,view.x);
vec4 result=vec4(0,0,0,0);
float A[]={3.1415926,2.094395,0.785398,0,-0.130900,0,0.049087,0,-0.02454,0,0.014317154,0,-0.009203885,0,0.006327671,0};
int n=0;
for(int l=0;l<4;l++)
{
if(l>=numSHBands)break;
float w=WindowFunction(float(l)/float(numSHBands));
for(int m=-l;m<=l;m++)result+=basisBuffer[n++]*SH(l,m,theta,phi)*w*A[l]/3.1415926;
}

return result;
}
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
//#line 1358 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec4 clip_pos=vec4(-1.0,1.0,1.0,1.0);
clip_pos.x+=2.0*BlockData.texCoords.x;
clip_pos.y-=2.0*BlockData.texCoords.y;
vec3 view=mul(invViewProj,clip_pos).xyz;
view=normalize(view);
vec4 result=EvaluateSH(view);
result.a=alpha;
{returnObject_vec4=max(result,vec4(0,0,0,0));}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/light_probes_PS_RoughnessMip.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
layout(std140, binding = 9) uniform LightProbeConstants
{
	mat4 invViewProj;
	int cubeFace;
	int numSHBands;
	int mipIndex;
	int numMips;
	float alpha;
	float roughness;
	vec2 padding;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t sourceCubemap[24];
};
//#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
//#line 23 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
//#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
//#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
//#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
//#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
//#line 29 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
//#line 31 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
//#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
//#line 33 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
//#line 35 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
uint reversebits(uint value)
{
return bitfieldReverse(value);
}
//#line 1231 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec3 CubeClipPosToView(int cube_face, vec4 clip_pos)
{
mat4 cubeInvViewProj[6]={{{0,0,-1,0},{0,-1,0,0},{1,0,0,0},{0,0,0,1}},{{0,0,1,0},{0,-1,0,0},{-1,0,0,0},{0,0,0,1}},{{-1,0,0,0},{0,0,-1,0},{0,1,0,0},{0,0,0,1}},{{-1,0,0,0},{0,0,1,0},{0,-1,0,0},{0,0,0,1}},{{-1,0,0,0},{0,-1,0,0},{0,0,-1,0},{0,0,0,1}},{{1,0,0,0},{0,-1,0,0},{0,0,1,0},{0,0,0,1}}};
vec3 view=-normalize(mul(cubeInvViewProj[cube_face],clip_pos).xyz);
return view;
}
//#line 1245 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec3 CubeClipPosToView(int cube_face, vec2 clip_pos2)
{
mat4 cubeInvViewProj[6]={{{0,0,-1,0},{0,-1,0,0},{1,0,0,0},{0,0,0,1}},{{0,0,1,0},{0,-1,0,0},{-1,0,0,0},{0,0,0,1}},{{-1,0,0,0},{0,0,-1,0},{0,1,0,0},{0,0,0,1}},{{-1,0,0,0},{0,0,1,0},{0,-1,0,0},{0,0,0,1}},{{-1,0,0,0},{0,-1,0,0},{0,0,-1,0},{0,0,0,1}},{{1,0,0,0},{0,-1,0,0},{0,0,1,0},{0,0,0,1}}};
vec4 clip_pos=vec4(clip_pos2,1.0,1.0);
vec3 view=-normalize(mul(cubeInvViewProj[cube_face],clip_pos).xyz);
return view;
}
//#line 1260 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec3 CubeTexCoordsToView(int cube_face, vec2 texCoords)
{
vec4 clip_pos=vec4(-1.0,1.0,1.0,1.0);
clip_pos.x+=2.0*texCoords.x;
clip_pos.y-=2.0*texCoords.y;
return CubeClipPosToView(cube_face,clip_pos);
}
//#line 1289 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
float D_GGX(float roughness, float NoH)
{
float a=roughness*roughness;
float a2=a*a;
float d=(NoH*a2-NoH)*NoH+1;
return a2/(3.1415926536*d*d);
}
//#line 1382 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec2 Hammersley(uint index, uint NumSamples, uvec2 random)
{
float E1=fract((index)/float(NumSamples)+(float(random.x&0xFFFF)/float(1<<16)));
float E2=fract(float(reversebits(index)^random.y)*2.3283064365386963e-10);
return vec2(E1,E2);
}
//#line 1400 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
mat3 GetTangentBasis(vec3 Z_dir)
{
vec3 UpVector=abs(Z_dir.z)<0.999?vec3(0,0,1.0):vec3(1.0,0,0);
vec3 TangentX=normalize(cross(UpVector,Z_dir));
vec3 TangentY=cross(Z_dir,TangentX);
return transpose(mat3(TangentX,TangentY,Z_dir));
}
//#line 1418 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec4 CosineSampleHemisphere(vec2 E)
{
float Phi=2.0*3.1415926536*E.x;
float cos_theta=sqrt(E.y);
float sin_theta=sqrt(1.0-cos_theta*cos_theta);
vec3 H;
H.x=sin_theta*cos(Phi);
H.y=sin_theta*sin(Phi);
H.z=cos_theta;
float PDF=cos_theta/3.1415926536;
return vec4(H,PDF);
}
//#line 1434 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec4 ImportanceSampleGGX(vec2 E, float roughness)
{
float m=roughness*roughness;
float m2=m*m;
float Phi=2*3.1415926536*E.x;
float cos_theta=sqrt((1-E.y)/(1+(m2-1)*E.y));
float sin_theta=sqrt(1-cos_theta*cos_theta);
vec3 H;
H.x=sin_theta*cos(Phi);
H.y=sin_theta*sin(Phi);
H.z=cos_theta;
float d=(cos_theta*m2-cos_theta)*cos_theta+1;
float D=m2/(3.1415926536*d*d);
float PDF=D*cos_theta;
return vec4(H,PDF);
}
//#line 1462 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec4 RoughnessMip(vec3 view, bool rough)
{
vec4 outp;
float r=saturate(roughness);
float CubeSize=float(1<<(numMips-1));
const float SolidAngleTexel=4.0*3.1415926536/float((6.0*CubeSize*CubeSize)*2.0);
const uint NumSamples=roughness<0.1?32:64;
vec4 result=vec4(0,0,0,0);
mat3 TangentToWorld=GetTangentBasis(view);
float Weight=0.0;
for(uint i=0;i<NumSamples;i++)
{
vec2 E=Hammersley(i,NumSamples,uvec2(0,0));
vec3 L;
if(rough)
{
L=CosineSampleHemisphere(E).xyz;
float NoL=L.z;
L=mul(TangentToWorld,L);
result+=textureLod(samplerCube(sourceCubemap[1 + 4]),vec3(-L.x,-L.y,L.z),0)*NoL;
Weight+=NoL;
}
else

{
E.y*=0.995;
vec3 H=ImportanceSampleGGX(E,r).xyz;
L=2*H.z*H-vec3(0,0,1.0);
float NoL=L.z;
if(NoL>0)
{
float NoH=H.z;
float PDF=D_GGX(r,NoH)*0.25;
float SolidAngleSample=1.0/(NumSamples*PDF);
float Mip=0.5*log2(SolidAngleSample/SolidAngleTexel);
float ConeAngle=acos(saturate(1.0-SolidAngleSample/(2.0*3.1415926536)));
L=mul(TangentToWorld,L);
vec4 lookup=100.0*saturate(0.01*textureLod(samplerCube(sourceCubemap[1 + 4]),vec3(-L.x,-L.y,L.z),0));
result+=NoL*lookup;
Weight+=NoL;
}

}

}

outp=result/Weight;
return vec4(outp.rgb,alpha);
}
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
//#line 1522 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec3 view=CubeTexCoordsToView(cubeFace,BlockData.texCoords);
{returnObject_vec4=RoughnessMip(view,false);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/light_probes_PS_RoughnessMip_Rough.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
layout(std140, binding = 9) uniform LightProbeConstants
{
	mat4 invViewProj;
	int cubeFace;
	int numSHBands;
	int mipIndex;
	int numMips;
	float alpha;
	float roughness;
	vec2 padding;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t sourceCubemap[24];
};
//#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
//#line 23 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
//#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
//#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
//#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
//#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
//#line 29 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
//#line 31 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
//#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
//#line 33 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
//#line 35 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
uint reversebits(uint value)
{
return bitfieldReverse(value);
}
//#line 1231 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec3 CubeClipPosToView(int cube_face, vec4 clip_pos)
{
mat4 cubeInvViewProj[6]={{{0,0,-1,0},{0,-1,0,0},{1,0,0,0},{0,0,0,1}},{{0,0,1,0},{0,-1,0,0},{-1,0,0,0},{0,0,0,1}},{{-1,0,0,0},{0,0,-1,0},{0,1,0,0},{0,0,0,1}},{{-1,0,0,0},{0,0,1,0},{0,-1,0,0},{0,0,0,1}},{{-1,0,0,0},{0,-1,0,0},{0,0,-1,0},{0,0,0,1}},{{1,0,0,0},{0,-1,0,0},{0,0,1,0},{0,0,0,1}}};
vec3 view=-normalize(mul(cubeInvViewProj[cube_face],clip_pos).xyz);
return view;
}
//#line 1245 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec3 CubeClipPosToView(int cube_face, vec2 clip_pos2)
{
mat4 cubeInvViewProj[6]={{{0,0,-1,0},{0,-1,0,0},{1,0,0,0},{0,0,0,1}},{{0,0,1,0},{0,-1,0,0},{-1,0,0,0},{0,0,0,1}},{{-1,0,0,0},{0,0,-1,0},{0,1,0,0},{0,0,0,1}},{{-1,0,0,0},{0,0,1,0},{0,-1,0,0},{0,0,0,1}},{{-1,0,0,0},{0,-1,0,0},{0,0,-1,0},{0,0,0,1}},{{1,0,0,0},{0,-1,0,0},{0,0,1,0},{0,0,0,1}}};
vec4 clip_pos=vec4(clip_pos2,1.0,1.0);
vec3 view=-normalize(mul(cubeInvViewProj[cube_face],clip_pos).xyz);
return view;
}
//#line 1260 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec3 CubeTexCoordsToView(int cube_face, vec2 texCoords)
{
vec4 clip_pos=vec4(-1.0,1.0,1.0,1.0);
clip_pos.x+=2.0*texCoords.x;
clip_pos.y-=2.0*texCoords.y;
return CubeClipPosToView(cube_face,clip_pos);
}
//#line 1289 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
float D_GGX(float roughness, float NoH)
{
float a=roughness*roughness;
float a2=a*a;
float d=(NoH*a2-NoH)*NoH+1;
return a2/(3.1415926536*d*d);
}
//#line 1382 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec2 Hammersley(uint index, uint NumSamples, uvec2 random)
{
float E1=fract((index)/float(NumSamples)+(float(random.x&0xFFFF)/float(1<<16)));
float E2=fract(float(reversebits(index)^random.y)*2.3283064365386963e-10);
return vec2(E1,E2);
}
//#line 1400 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
mat3 GetTangentBasis(vec3 Z_dir)
{
vec3 UpVector=abs(Z_dir.z)<0.999?vec3(0,0,1.0):vec3(1.0,0,0);
vec3 TangentX=normalize(cross(UpVector,Z_dir));
vec3 TangentY=cross(Z_dir,TangentX);
return transpose(mat3(TangentX,TangentY,Z_dir));
}
//#line 1418 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec4 CosineSampleHemisphere(vec2 E)
{
float Phi=2.0*3.1415926536*E.x;
float cos_theta=sqrt(E.y);
float sin_theta=sqrt(1.0-cos_theta*cos_theta);
vec3 H;
H.x=sin_theta*cos(Phi);
H.y=sin_theta*sin(Phi);
H.z=cos_theta;
float PDF=cos_theta/3.1415926536;
return vec4(H,PDF);
}
//#line 1434 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec4 ImportanceSampleGGX(vec2 E, float roughness)
{
float m=roughness*roughness;
float m2=m*m;
float Phi=2*3.1415926536*E.x;
float cos_theta=sqrt((1-E.y)/(1+(m2-1)*E.y));
float sin_theta=sqrt(1-cos_theta*cos_theta);
vec3 H;
H.x=sin_theta*cos(Phi);
H.y=sin_theta*sin(Phi);
H.z=cos_theta;
float d=(cos_theta*m2-cos_theta)*cos_theta+1;
float D=m2/(3.1415926536*d*d);
float PDF=D*cos_theta;
return vec4(H,PDF);
}
//#line 1462 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec4 RoughnessMip(vec3 view, bool rough)
{
vec4 outp;
float r=saturate(roughness);
float CubeSize=float(1<<(numMips-1));
const float SolidAngleTexel=4.0*3.1415926536/float((6.0*CubeSize*CubeSize)*2.0);
const uint NumSamples=roughness<0.1?32:64;
vec4 result=vec4(0,0,0,0);
mat3 TangentToWorld=GetTangentBasis(view);
float Weight=0.0;
for(uint i=0;i<NumSamples;i++)
{
vec2 E=Hammersley(i,NumSamples,uvec2(0,0));
vec3 L;
if(rough)
{
L=CosineSampleHemisphere(E).xyz;
float NoL=L.z;
L=mul(TangentToWorld,L);
result+=textureLod(samplerCube(sourceCubemap[1 + 4]),vec3(-L.x,-L.y,L.z),0)*NoL;
Weight+=NoL;
}
else

{
E.y*=0.995;
vec3 H=ImportanceSampleGGX(E,r).xyz;
L=2*H.z*H-vec3(0,0,1.0);
float NoL=L.z;
if(NoL>0)
{
float NoH=H.z;
float PDF=D_GGX(r,NoH)*0.25;
float SolidAngleSample=1.0/(NumSamples*PDF);
float Mip=0.5*log2(SolidAngleSample/SolidAngleTexel);
float ConeAngle=acos(saturate(1.0-SolidAngleSample/(2.0*3.1415926536)));
L=mul(TangentToWorld,L);
vec4 lookup=100.0*saturate(0.01*textureLod(samplerCube(sourceCubemap[1 + 4]),vec3(-L.x,-L.y,L.z),0));
result+=NoL*lookup;
Weight+=NoL;
}

}

}

outp=result/Weight;
return vec4(outp.rgb,alpha);
}
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
//#line 1529 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec3 view=CubeTexCoordsToView(cubeFace,BlockData.texCoords);
{returnObject_vec4=RoughnessMip(view,true);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/light_probes_PS_RoughnessMip_Smooth.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
layout(std140, binding = 9) uniform LightProbeConstants
{
	mat4 invViewProj;
	int cubeFace;
	int numSHBands;
	int mipIndex;
	int numMips;
	float alpha;
	float roughness;
	vec2 padding;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t sourceCubemap[24];
};
//#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
//#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
//#line 29 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
//#line 31 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
//#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
//#line 33 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
//#line 1231 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec3 CubeClipPosToView(int cube_face, vec4 clip_pos)
{
mat4 cubeInvViewProj[6]={{{0,0,-1,0},{0,-1,0,0},{1,0,0,0},{0,0,0,1}},{{0,0,1,0},{0,-1,0,0},{-1,0,0,0},{0,0,0,1}},{{-1,0,0,0},{0,0,-1,0},{0,1,0,0},{0,0,0,1}},{{-1,0,0,0},{0,0,1,0},{0,-1,0,0},{0,0,0,1}},{{-1,0,0,0},{0,-1,0,0},{0,0,-1,0},{0,0,0,1}},{{1,0,0,0},{0,-1,0,0},{0,0,1,0},{0,0,0,1}}};
vec3 view=-normalize(mul(cubeInvViewProj[cube_face],clip_pos).xyz);
return view;
}
//#line 1245 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec3 CubeClipPosToView(int cube_face, vec2 clip_pos2)
{
mat4 cubeInvViewProj[6]={{{0,0,-1,0},{0,-1,0,0},{1,0,0,0},{0,0,0,1}},{{0,0,1,0},{0,-1,0,0},{-1,0,0,0},{0,0,0,1}},{{-1,0,0,0},{0,0,-1,0},{0,1,0,0},{0,0,0,1}},{{-1,0,0,0},{0,0,1,0},{0,-1,0,0},{0,0,0,1}},{{-1,0,0,0},{0,-1,0,0},{0,0,-1,0},{0,0,0,1}},{{1,0,0,0},{0,-1,0,0},{0,0,1,0},{0,0,0,1}}};
vec4 clip_pos=vec4(clip_pos2,1.0,1.0);
vec3 view=-normalize(mul(cubeInvViewProj[cube_face],clip_pos).xyz);
return view;
}
//#line 1260 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec3 CubeTexCoordsToView(int cube_face, vec2 texCoords)
{
vec4 clip_pos=vec4(-1.0,1.0,1.0,1.0);
clip_pos.x+=2.0*texCoords.x;
clip_pos.y-=2.0*texCoords.y;
return CubeClipPosToView(cube_face,clip_pos);
}
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
//#line 1536 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
vec3 view=CubeTexCoordsToView(cubeFace,BlockData.texCoords);
{returnObject_vec4=textureLod(samplerCube(sourceCubemap[1 + 4]),view,0);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/light_probes_VS_SimpleFullscreenFlipTC_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct idOnly
{
	flat uint vertex_id;
};
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
//#line 1550 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
posTexVertexOutput SimpleFullscreenFlipTC(idOnly IN, bool flipHorizonal, bool flipVertical)
{
posTexVertexOutput OUT;
vec2 poss[4];
poss[0]=vec2(1.0,-1.0);
poss[1]=vec2(1.0,1.0);
poss[2]=vec2(-1.0,-1.0);
poss[3]=vec2(-1.0,1.0);
vec2 pos=poss[IN.vertex_id];
OUT.hPosition=vec4(pos,0.0,1.0);
OUT.hPosition.z=0.0;
OUT.texCoords=0.5*(vec2(1.0,1.0)+vec2(pos.x,-pos.y));
if(flipHorizonal)OUT.texCoords.x=1.0-OUT.texCoords.x;
if(flipVertical)OUT.texCoords.y=1.0-OUT.texCoords.y;
return OUT;
}
layout(location = 0) out Block
{
posTexVertexOutput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
//#line 1572 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
posTexVertexOutput pt=SimpleFullscreenFlipTC(IN,true,true);
{
ioblock.BlockData=pt;
gl_Position=pt.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/light_probes_VS_SimpleFullscreenFlipTC_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
struct idOnly
{
	flat uint vertex_id;
};
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
//#line 1550 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
posTexVertexOutput SimpleFullscreenFlipTC(idOnly IN, bool flipHorizonal, bool flipVertical)
{
posTexVertexOutput OUT;
vec2 poss[4];
poss[0]=vec2(1.0,-1.0);
poss[1]=vec2(1.0,1.0);
poss[2]=vec2(-1.0,-1.0);
poss[3]=vec2(-1.0,1.0);
vec2 pos=poss[IN.vertex_id];
OUT.hPosition=vec4(pos,0.0,1.0);
OUT.hPosition.z=0.0;
OUT.texCoords=0.5*(vec2(1.0,1.0)+vec2(pos.x,-pos.y));
if(flipHorizonal)OUT.texCoords.x=1.0-OUT.texCoords.x;
if(flipVertical)OUT.texCoords.y=1.0-OUT.texCoords.y;
return OUT;
}
layout(location = 0) out Block
{
posTexVertexOutput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
//#line 1572 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/light_probes.sfx"
posTexVertexOutput pt=SimpleFullscreenFlipTC(IN,true,true);
{
ioblock.BlockData=pt;
gl_Position=pt.hPosition;
}
}