#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/rain_PS_RainParticles_ForwardDepth.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 10) uniform RainConstants
{
	mat4 rainMapMatrix;
	mat4 cubemapTransform;
	vec4 lightColour;
	vec3 lightDir;
	float particleWidth;
	vec3 meanFallVelocity;
	float intensity;
	float flurry;
	float flurryRate;
	float phase0;
	float phase1;
	float timeStepSeconds;
	float particleZoneSize;
	vec2 padding;
};
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 8) uniform RainPerViewConstants
{
	mat4 worldViewProj[2];
	mat4 worldView[2];
	mat4 rainDepthTransform;
	vec4 tanHalfFov;
	vec4 viewPos[2];
	vec4 offset[2];
	vec4 depthToLinFadeDistRain;
	vec4 depthToLinFadeDistTexture;
	vec4 viewportToTexRegionScaleBias;
	vec2 tanHalfFovUnused;
	vec2 screenSize;
	vec3 viewPositionOffset;
	float nearRainDistance;
	float rainDepthTextureScale;
	float splashDelta;
	float minDistanceM;
	float padding2;
};
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};


#line 95 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct ParticleGeometryOutput
{
	vec4 position;
	vec4 clip_pos;
	vec3 dir;
	float strength;
	vec3 light;
	float betaMie;
	vec2 texCoords;
	flat uint type;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t cubeTexture[24];
	uint64_t depthTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 199 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 viewportCoordToTexRegionCoord(vec2 iViewportCoord, vec4 iViewportToTexRegionScaleBias)
{
return iViewportCoord*iViewportToTexRegionScaleBias.xy+iViewportToTexRegionScaleBias.zw;
}
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/quaternion.sl"
vec4 quat_from_axis_angle_radians(vec3 axis, float angle)
{
vec4 qr;
float half_angle=angle*0.5;
qr.x=axis.x*sin(half_angle);
qr.y=axis.y*sin(half_angle);
qr.z=axis.z*sin(half_angle);
qr.w=cos(half_angle);
return qr;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/quaternion.sl"
vec4 quat_conj(vec4 q)
{
return vec4(-q.x,-q.y,-q.z,q.w);
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/quaternion.sl"
vec4 quat_mult(vec4 q1, vec4 q2)
{
vec4 qr;
qr.w=(q1.w*q2.w)-(q1.x*q2.x)-(q1.y*q2.y)-(q1.z*q2.z);
qr.x=(q1.w*q2.x)+(q1.x*q2.w)+(q1.y*q2.z)-(q1.z*q2.y);
qr.y=(q1.w*q2.y)-(q1.x*q2.z)+(q1.y*q2.w)+(q1.z*q2.x);
qr.z=(q1.w*q2.z)+(q1.x*q2.y)-(q1.y*q2.x)+(q1.z*q2.w);
return qr;
}
#line 53 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/quaternion.sl"
vec4 quat_vec(vec4 q, vec3 v)
{
vec4 qr;
qr.w=-(q.x*v.x)-(q.y*v.y)-(q.z*v.z);
qr.x=(q.w*v.x)+(q.y*v.z)-(q.z*v.y);
qr.y=(q.w*v.y)+(q.z*v.x)-(q.x*v.z);
qr.z=(q.w*v.z)+(q.x*v.y)-(q.y*v.x);
return qr;
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/quaternion.sl"
vec3 rotate_by_quaternion(vec4 quat, vec3 position)
{
vec4 qr_conj=quat_conj(quat);
vec4 q_tmp=quat_vec(quat,position);
vec4 qr=quat_mult(q_tmp,qr_conj);
return qr.xyz;
}
#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_refract_reflect.sl"
float ReflectionFresnelSchlick(float incidentAngle, float riOld, float riNew)
{
float a=abs(riNew-riOld)/(riNew+riOld);
float R0=a*a;
float c=1.0-cos(incidentAngle);
float c2=c*c;
float oneTakeCos5=c2*c2*c;
return mix(R0,1.0,oneTakeCos5);
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_refract_reflect.sl"
float RefractionSnell(float incidentAngle, float riOld, float riNew)
{
float riRatio=riOld/riNew;
float sinOfIncidentAngle=sin(incidentAngle);
float temp=riRatio*sinOfIncidentAngle;
if(temp>1.0f)
{
return 3.1415926536*2-incidentAngle;
}
else

{
return asin(temp);
}

}
#line 551 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
vec4 PSRainParticles(ParticleGeometryOutput IN, bool reverseDepth, vec3 light)
{
if(IN.type==44)
{
discard;
}

vec2 texc=IN.texCoords;
float r=length(texc);
if(r>1.0)discard;
float ri_Air=1.00;
float ri_Water=1.33;
float incident1=0.0;
float incident2=0.0;
float loss1=0.0;
float loss2=0.0;
float refraction1=0.0;
float refraction2=0.0;
incident1=asin(r);
loss1=ReflectionFresnelSchlick(incident1,ri_Air,ri_Water);
refraction1=RefractionSnell(incident1,ri_Air,ri_Water);
incident2=refraction1;
loss2=ReflectionFresnelSchlick(incident2,ri_Water,ri_Air);
refraction2=RefractionSnell(incident2,ri_Water,ri_Air);
if(refraction2>3.1415926536)discard;
float totalAngleChange=incident1-refraction1-incident2+refraction2;
float totalLossDueToReflection=loss1+loss2;
float phi=atan(texc.y,texc.x);
if(phi<0.0)phi+=3.1415926536*2;
vec3 view_dir=-normalize(light.xyz);
vec3 globalUp=vec3(0,0,1);
vec3 right=cross(view_dir,globalUp);
vec3 up=cross(right,view_dir);
vec4 quat_1=quat_from_axis_angle_radians(view_dir,phi);
vec3 rotatedNormal=rotate_by_quaternion(quat_1,up);
vec4 quat_2=quat_from_axis_angle_radians(rotatedNormal,totalAngleChange);
vec3 finalLightLookUp=rotate_by_quaternion(quat_2,view_dir);
float refractFactor=1.0-totalLossDueToReflection;
float reflectFactor=totalLossDueToReflection;
vec3 refractLight=refractFactor*textureLod(samplerCube(cubeTexture[1 + 6]),mul(cubemapTransform,vec4(finalLightLookUp,0)).xyz,0).rgb;
vec3 reflectLight=reflectFactor*textureLod(samplerCube(cubeTexture[1 + 6]),mul(cubemapTransform,vec4(IN.dir.xyz,0)).xyz,0).rgb;
vec3 lightPS=reflectLight+refractLight;
vec4 clip_pos=IN.clip_pos/IN.clip_pos.w;
vec2 nxy=IN.dir.xy;
vec3 n=vec3(nxy,sqrt(1.0-r*r));
vec2 screen_texc=vec2(0.5*(clip_pos.x+1.0),0.5*(1.0-clip_pos.y));
vec2 depth_texc=viewportCoordToTexRegionCoord(screen_texc,viewportToTexRegionScaleBias);
float solid_depth=texture(sampler2D(depthTexture[1 + 9]),depth_texc.xy).x;
float render_depth=clip_pos.z;
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.reverseDepth=reverseDepth;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistTexture;
float solid_dist=depthToFadeDistance(solid_depth,clip_pos.xy,depthInterpretationStruct,tanHalfFov);
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistRain;
float rain_dist=depthToFadeDistance(render_depth,clip_pos.xy,depthInterpretationStruct,tanHalfFov);
float mapped_rain=IN.strength;
if(mapped_rain<=0||rain_dist>solid_dist)
{
discard;
}

float vis=mapped_rain;
vec3 normal=mul(worldView[1],vec4(n,0.0)).xyz;
vec4 result=vec4(lightPS,mix(0.0,vis,r));
return result;
}
#line 655 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
vec4 PSRainParticles(ParticleGeometryOutput IN, bool reverseDepth)
{
return PSRainParticles(IN,reverseDepth,IN.light);
}
#line 660 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
vec4 PS_RainParticles(ParticleGeometryOutput IN, bool reverseDepth)
{
return PSRainParticles(IN,reverseDepth);
}
layout(location = 0) in Block
{
ParticleGeometryOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
ParticleGeometryOutput BlockData=ioblock.BlockData;
#line 671 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
{returnObject_vec4=PS_RainParticles(BlockData,false);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/rain_PS_RainParticles_NoCubemap_ForwardDepth.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 10) uniform RainConstants
{
	mat4 rainMapMatrix;
	mat4 cubemapTransform;
	vec4 lightColour;
	vec3 lightDir;
	float particleWidth;
	vec3 meanFallVelocity;
	float intensity;
	float flurry;
	float flurryRate;
	float phase0;
	float phase1;
	float timeStepSeconds;
	float particleZoneSize;
	vec2 padding;
};
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 8) uniform RainPerViewConstants
{
	mat4 worldViewProj[2];
	mat4 worldView[2];
	mat4 rainDepthTransform;
	vec4 tanHalfFov;
	vec4 viewPos[2];
	vec4 offset[2];
	vec4 depthToLinFadeDistRain;
	vec4 depthToLinFadeDistTexture;
	vec4 viewportToTexRegionScaleBias;
	vec2 tanHalfFovUnused;
	vec2 screenSize;
	vec3 viewPositionOffset;
	float nearRainDistance;
	float rainDepthTextureScale;
	float splashDelta;
	float minDistanceM;
	float padding2;
};
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};


#line 95 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct ParticleGeometryOutput
{
	vec4 position;
	vec4 clip_pos;
	vec3 dir;
	float strength;
	vec3 light;
	float betaMie;
	vec2 texCoords;
	flat uint type;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t cubeTexture[24];
	uint64_t depthTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 199 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 viewportCoordToTexRegionCoord(vec2 iViewportCoord, vec4 iViewportToTexRegionScaleBias)
{
return iViewportCoord*iViewportToTexRegionScaleBias.xy+iViewportToTexRegionScaleBias.zw;
}
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/quaternion.sl"
vec4 quat_from_axis_angle_radians(vec3 axis, float angle)
{
vec4 qr;
float half_angle=angle*0.5;
qr.x=axis.x*sin(half_angle);
qr.y=axis.y*sin(half_angle);
qr.z=axis.z*sin(half_angle);
qr.w=cos(half_angle);
return qr;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/quaternion.sl"
vec4 quat_conj(vec4 q)
{
return vec4(-q.x,-q.y,-q.z,q.w);
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/quaternion.sl"
vec4 quat_mult(vec4 q1, vec4 q2)
{
vec4 qr;
qr.w=(q1.w*q2.w)-(q1.x*q2.x)-(q1.y*q2.y)-(q1.z*q2.z);
qr.x=(q1.w*q2.x)+(q1.x*q2.w)+(q1.y*q2.z)-(q1.z*q2.y);
qr.y=(q1.w*q2.y)-(q1.x*q2.z)+(q1.y*q2.w)+(q1.z*q2.x);
qr.z=(q1.w*q2.z)+(q1.x*q2.y)-(q1.y*q2.x)+(q1.z*q2.w);
return qr;
}
#line 53 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/quaternion.sl"
vec4 quat_vec(vec4 q, vec3 v)
{
vec4 qr;
qr.w=-(q.x*v.x)-(q.y*v.y)-(q.z*v.z);
qr.x=(q.w*v.x)+(q.y*v.z)-(q.z*v.y);
qr.y=(q.w*v.y)+(q.z*v.x)-(q.x*v.z);
qr.z=(q.w*v.z)+(q.x*v.y)-(q.y*v.x);
return qr;
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/quaternion.sl"
vec3 rotate_by_quaternion(vec4 quat, vec3 position)
{
vec4 qr_conj=quat_conj(quat);
vec4 q_tmp=quat_vec(quat,position);
vec4 qr=quat_mult(q_tmp,qr_conj);
return qr.xyz;
}
#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_refract_reflect.sl"
float ReflectionFresnelSchlick(float incidentAngle, float riOld, float riNew)
{
float a=abs(riNew-riOld)/(riNew+riOld);
float R0=a*a;
float c=1.0-cos(incidentAngle);
float c2=c*c;
float oneTakeCos5=c2*c2*c;
return mix(R0,1.0,oneTakeCos5);
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_refract_reflect.sl"
float RefractionSnell(float incidentAngle, float riOld, float riNew)
{
float riRatio=riOld/riNew;
float sinOfIncidentAngle=sin(incidentAngle);
float temp=riRatio*sinOfIncidentAngle;
if(temp>1.0f)
{
return 3.1415926536*2-incidentAngle;
}
else

{
return asin(temp);
}

}
#line 551 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
vec4 PSRainParticles(ParticleGeometryOutput IN, bool reverseDepth, vec3 light)
{
if(IN.type==44)
{
discard;
}

vec2 texc=IN.texCoords;
float r=length(texc);
if(r>1.0)discard;
float ri_Air=1.00;
float ri_Water=1.33;
float incident1=0.0;
float incident2=0.0;
float loss1=0.0;
float loss2=0.0;
float refraction1=0.0;
float refraction2=0.0;
incident1=asin(r);
loss1=ReflectionFresnelSchlick(incident1,ri_Air,ri_Water);
refraction1=RefractionSnell(incident1,ri_Air,ri_Water);
incident2=refraction1;
loss2=ReflectionFresnelSchlick(incident2,ri_Water,ri_Air);
refraction2=RefractionSnell(incident2,ri_Water,ri_Air);
if(refraction2>3.1415926536)discard;
float totalAngleChange=incident1-refraction1-incident2+refraction2;
float totalLossDueToReflection=loss1+loss2;
float phi=atan(texc.y,texc.x);
if(phi<0.0)phi+=3.1415926536*2;
vec3 view_dir=-normalize(light.xyz);
vec3 globalUp=vec3(0,0,1);
vec3 right=cross(view_dir,globalUp);
vec3 up=cross(right,view_dir);
vec4 quat_1=quat_from_axis_angle_radians(view_dir,phi);
vec3 rotatedNormal=rotate_by_quaternion(quat_1,up);
vec4 quat_2=quat_from_axis_angle_radians(rotatedNormal,totalAngleChange);
vec3 finalLightLookUp=rotate_by_quaternion(quat_2,view_dir);
float refractFactor=1.0-totalLossDueToReflection;
float reflectFactor=totalLossDueToReflection;
vec3 refractLight=refractFactor*textureLod(samplerCube(cubeTexture[1 + 6]),mul(cubemapTransform,vec4(finalLightLookUp,0)).xyz,0).rgb;
vec3 reflectLight=reflectFactor*textureLod(samplerCube(cubeTexture[1 + 6]),mul(cubemapTransform,vec4(IN.dir.xyz,0)).xyz,0).rgb;
vec3 lightPS=reflectLight+refractLight;
vec4 clip_pos=IN.clip_pos/IN.clip_pos.w;
vec2 nxy=IN.dir.xy;
vec3 n=vec3(nxy,sqrt(1.0-r*r));
vec2 screen_texc=vec2(0.5*(clip_pos.x+1.0),0.5*(1.0-clip_pos.y));
vec2 depth_texc=viewportCoordToTexRegionCoord(screen_texc,viewportToTexRegionScaleBias);
float solid_depth=texture(sampler2D(depthTexture[1 + 9]),depth_texc.xy).x;
float render_depth=clip_pos.z;
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.reverseDepth=reverseDepth;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistTexture;
float solid_dist=depthToFadeDistance(solid_depth,clip_pos.xy,depthInterpretationStruct,tanHalfFov);
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistRain;
float rain_dist=depthToFadeDistance(render_depth,clip_pos.xy,depthInterpretationStruct,tanHalfFov);
float mapped_rain=IN.strength;
if(mapped_rain<=0||rain_dist>solid_dist)
{
discard;
}

float vis=mapped_rain;
vec3 normal=mul(worldView[1],vec4(n,0.0)).xyz;
vec4 result=vec4(lightPS,mix(0.0,vis,r));
return result;
}
#line 675 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
vec4 PS_RainParticles_NoCubemap(ParticleGeometryOutput IN, bool reverseDepth)
{
vec3 light=lightColour.rgb;
return PSRainParticles(IN,reverseDepth,light);
}
layout(location = 0) in Block
{
ParticleGeometryOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
ParticleGeometryOutput BlockData=ioblock.BlockData;
#line 687 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
{returnObject_vec4=PS_RainParticles_NoCubemap(BlockData,false);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/rain_PS_RainParticles_NoCubemap_ReverseDepth.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 10) uniform RainConstants
{
	mat4 rainMapMatrix;
	mat4 cubemapTransform;
	vec4 lightColour;
	vec3 lightDir;
	float particleWidth;
	vec3 meanFallVelocity;
	float intensity;
	float flurry;
	float flurryRate;
	float phase0;
	float phase1;
	float timeStepSeconds;
	float particleZoneSize;
	vec2 padding;
};
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 8) uniform RainPerViewConstants
{
	mat4 worldViewProj[2];
	mat4 worldView[2];
	mat4 rainDepthTransform;
	vec4 tanHalfFov;
	vec4 viewPos[2];
	vec4 offset[2];
	vec4 depthToLinFadeDistRain;
	vec4 depthToLinFadeDistTexture;
	vec4 viewportToTexRegionScaleBias;
	vec2 tanHalfFovUnused;
	vec2 screenSize;
	vec3 viewPositionOffset;
	float nearRainDistance;
	float rainDepthTextureScale;
	float splashDelta;
	float minDistanceM;
	float padding2;
};
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};


#line 95 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct ParticleGeometryOutput
{
	vec4 position;
	vec4 clip_pos;
	vec3 dir;
	float strength;
	vec3 light;
	float betaMie;
	vec2 texCoords;
	flat uint type;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t cubeTexture[24];
	uint64_t depthTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 199 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 viewportCoordToTexRegionCoord(vec2 iViewportCoord, vec4 iViewportToTexRegionScaleBias)
{
return iViewportCoord*iViewportToTexRegionScaleBias.xy+iViewportToTexRegionScaleBias.zw;
}
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/quaternion.sl"
vec4 quat_from_axis_angle_radians(vec3 axis, float angle)
{
vec4 qr;
float half_angle=angle*0.5;
qr.x=axis.x*sin(half_angle);
qr.y=axis.y*sin(half_angle);
qr.z=axis.z*sin(half_angle);
qr.w=cos(half_angle);
return qr;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/quaternion.sl"
vec4 quat_conj(vec4 q)
{
return vec4(-q.x,-q.y,-q.z,q.w);
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/quaternion.sl"
vec4 quat_mult(vec4 q1, vec4 q2)
{
vec4 qr;
qr.w=(q1.w*q2.w)-(q1.x*q2.x)-(q1.y*q2.y)-(q1.z*q2.z);
qr.x=(q1.w*q2.x)+(q1.x*q2.w)+(q1.y*q2.z)-(q1.z*q2.y);
qr.y=(q1.w*q2.y)-(q1.x*q2.z)+(q1.y*q2.w)+(q1.z*q2.x);
qr.z=(q1.w*q2.z)+(q1.x*q2.y)-(q1.y*q2.x)+(q1.z*q2.w);
return qr;
}
#line 53 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/quaternion.sl"
vec4 quat_vec(vec4 q, vec3 v)
{
vec4 qr;
qr.w=-(q.x*v.x)-(q.y*v.y)-(q.z*v.z);
qr.x=(q.w*v.x)+(q.y*v.z)-(q.z*v.y);
qr.y=(q.w*v.y)+(q.z*v.x)-(q.x*v.z);
qr.z=(q.w*v.z)+(q.x*v.y)-(q.y*v.x);
return qr;
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/quaternion.sl"
vec3 rotate_by_quaternion(vec4 quat, vec3 position)
{
vec4 qr_conj=quat_conj(quat);
vec4 q_tmp=quat_vec(quat,position);
vec4 qr=quat_mult(q_tmp,qr_conj);
return qr.xyz;
}
#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_refract_reflect.sl"
float ReflectionFresnelSchlick(float incidentAngle, float riOld, float riNew)
{
float a=abs(riNew-riOld)/(riNew+riOld);
float R0=a*a;
float c=1.0-cos(incidentAngle);
float c2=c*c;
float oneTakeCos5=c2*c2*c;
return mix(R0,1.0,oneTakeCos5);
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_refract_reflect.sl"
float RefractionSnell(float incidentAngle, float riOld, float riNew)
{
float riRatio=riOld/riNew;
float sinOfIncidentAngle=sin(incidentAngle);
float temp=riRatio*sinOfIncidentAngle;
if(temp>1.0f)
{
return 3.1415926536*2-incidentAngle;
}
else

{
return asin(temp);
}

}
#line 551 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
vec4 PSRainParticles(ParticleGeometryOutput IN, bool reverseDepth, vec3 light)
{
if(IN.type==44)
{
discard;
}

vec2 texc=IN.texCoords;
float r=length(texc);
if(r>1.0)discard;
float ri_Air=1.00;
float ri_Water=1.33;
float incident1=0.0;
float incident2=0.0;
float loss1=0.0;
float loss2=0.0;
float refraction1=0.0;
float refraction2=0.0;
incident1=asin(r);
loss1=ReflectionFresnelSchlick(incident1,ri_Air,ri_Water);
refraction1=RefractionSnell(incident1,ri_Air,ri_Water);
incident2=refraction1;
loss2=ReflectionFresnelSchlick(incident2,ri_Water,ri_Air);
refraction2=RefractionSnell(incident2,ri_Water,ri_Air);
if(refraction2>3.1415926536)discard;
float totalAngleChange=incident1-refraction1-incident2+refraction2;
float totalLossDueToReflection=loss1+loss2;
float phi=atan(texc.y,texc.x);
if(phi<0.0)phi+=3.1415926536*2;
vec3 view_dir=-normalize(light.xyz);
vec3 globalUp=vec3(0,0,1);
vec3 right=cross(view_dir,globalUp);
vec3 up=cross(right,view_dir);
vec4 quat_1=quat_from_axis_angle_radians(view_dir,phi);
vec3 rotatedNormal=rotate_by_quaternion(quat_1,up);
vec4 quat_2=quat_from_axis_angle_radians(rotatedNormal,totalAngleChange);
vec3 finalLightLookUp=rotate_by_quaternion(quat_2,view_dir);
float refractFactor=1.0-totalLossDueToReflection;
float reflectFactor=totalLossDueToReflection;
vec3 refractLight=refractFactor*textureLod(samplerCube(cubeTexture[1 + 6]),mul(cubemapTransform,vec4(finalLightLookUp,0)).xyz,0).rgb;
vec3 reflectLight=reflectFactor*textureLod(samplerCube(cubeTexture[1 + 6]),mul(cubemapTransform,vec4(IN.dir.xyz,0)).xyz,0).rgb;
vec3 lightPS=reflectLight+refractLight;
vec4 clip_pos=IN.clip_pos/IN.clip_pos.w;
vec2 nxy=IN.dir.xy;
vec3 n=vec3(nxy,sqrt(1.0-r*r));
vec2 screen_texc=vec2(0.5*(clip_pos.x+1.0),0.5*(1.0-clip_pos.y));
vec2 depth_texc=viewportCoordToTexRegionCoord(screen_texc,viewportToTexRegionScaleBias);
float solid_depth=texture(sampler2D(depthTexture[1 + 9]),depth_texc.xy).x;
float render_depth=clip_pos.z;
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.reverseDepth=reverseDepth;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistTexture;
float solid_dist=depthToFadeDistance(solid_depth,clip_pos.xy,depthInterpretationStruct,tanHalfFov);
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistRain;
float rain_dist=depthToFadeDistance(render_depth,clip_pos.xy,depthInterpretationStruct,tanHalfFov);
float mapped_rain=IN.strength;
if(mapped_rain<=0||rain_dist>solid_dist)
{
discard;
}

float vis=mapped_rain;
vec3 normal=mul(worldView[1],vec4(n,0.0)).xyz;
vec4 result=vec4(lightPS,mix(0.0,vis,r));
return result;
}
#line 675 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
vec4 PS_RainParticles_NoCubemap(ParticleGeometryOutput IN, bool reverseDepth)
{
vec3 light=lightColour.rgb;
return PSRainParticles(IN,reverseDepth,light);
}
layout(location = 0) in Block
{
ParticleGeometryOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
ParticleGeometryOutput BlockData=ioblock.BlockData;
#line 682 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
{returnObject_vec4=PS_RainParticles_NoCubemap(BlockData,true);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/rain_PS_RainParticles_ReverseDepth.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 10) uniform RainConstants
{
	mat4 rainMapMatrix;
	mat4 cubemapTransform;
	vec4 lightColour;
	vec3 lightDir;
	float particleWidth;
	vec3 meanFallVelocity;
	float intensity;
	float flurry;
	float flurryRate;
	float phase0;
	float phase1;
	float timeStepSeconds;
	float particleZoneSize;
	vec2 padding;
};
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 8) uniform RainPerViewConstants
{
	mat4 worldViewProj[2];
	mat4 worldView[2];
	mat4 rainDepthTransform;
	vec4 tanHalfFov;
	vec4 viewPos[2];
	vec4 offset[2];
	vec4 depthToLinFadeDistRain;
	vec4 depthToLinFadeDistTexture;
	vec4 viewportToTexRegionScaleBias;
	vec2 tanHalfFovUnused;
	vec2 screenSize;
	vec3 viewPositionOffset;
	float nearRainDistance;
	float rainDepthTextureScale;
	float splashDelta;
	float minDistanceM;
	float padding2;
};
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};


#line 95 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct ParticleGeometryOutput
{
	vec4 position;
	vec4 clip_pos;
	vec3 dir;
	float strength;
	vec3 light;
	float betaMie;
	vec2 texCoords;
	flat uint type;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t cubeTexture[24];
	uint64_t depthTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 199 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 viewportCoordToTexRegionCoord(vec2 iViewportCoord, vec4 iViewportToTexRegionScaleBias)
{
return iViewportCoord*iViewportToTexRegionScaleBias.xy+iViewportToTexRegionScaleBias.zw;
}
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/quaternion.sl"
vec4 quat_from_axis_angle_radians(vec3 axis, float angle)
{
vec4 qr;
float half_angle=angle*0.5;
qr.x=axis.x*sin(half_angle);
qr.y=axis.y*sin(half_angle);
qr.z=axis.z*sin(half_angle);
qr.w=cos(half_angle);
return qr;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/quaternion.sl"
vec4 quat_conj(vec4 q)
{
return vec4(-q.x,-q.y,-q.z,q.w);
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/quaternion.sl"
vec4 quat_mult(vec4 q1, vec4 q2)
{
vec4 qr;
qr.w=(q1.w*q2.w)-(q1.x*q2.x)-(q1.y*q2.y)-(q1.z*q2.z);
qr.x=(q1.w*q2.x)+(q1.x*q2.w)+(q1.y*q2.z)-(q1.z*q2.y);
qr.y=(q1.w*q2.y)-(q1.x*q2.z)+(q1.y*q2.w)+(q1.z*q2.x);
qr.z=(q1.w*q2.z)+(q1.x*q2.y)-(q1.y*q2.x)+(q1.z*q2.w);
return qr;
}
#line 53 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/quaternion.sl"
vec4 quat_vec(vec4 q, vec3 v)
{
vec4 qr;
qr.w=-(q.x*v.x)-(q.y*v.y)-(q.z*v.z);
qr.x=(q.w*v.x)+(q.y*v.z)-(q.z*v.y);
qr.y=(q.w*v.y)+(q.z*v.x)-(q.x*v.z);
qr.z=(q.w*v.z)+(q.x*v.y)-(q.y*v.x);
return qr;
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/quaternion.sl"
vec3 rotate_by_quaternion(vec4 quat, vec3 position)
{
vec4 qr_conj=quat_conj(quat);
vec4 q_tmp=quat_vec(quat,position);
vec4 qr=quat_mult(q_tmp,qr_conj);
return qr.xyz;
}
#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_refract_reflect.sl"
float ReflectionFresnelSchlick(float incidentAngle, float riOld, float riNew)
{
float a=abs(riNew-riOld)/(riNew+riOld);
float R0=a*a;
float c=1.0-cos(incidentAngle);
float c2=c*c;
float oneTakeCos5=c2*c2*c;
return mix(R0,1.0,oneTakeCos5);
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_refract_reflect.sl"
float RefractionSnell(float incidentAngle, float riOld, float riNew)
{
float riRatio=riOld/riNew;
float sinOfIncidentAngle=sin(incidentAngle);
float temp=riRatio*sinOfIncidentAngle;
if(temp>1.0f)
{
return 3.1415926536*2-incidentAngle;
}
else

{
return asin(temp);
}

}
#line 551 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
vec4 PSRainParticles(ParticleGeometryOutput IN, bool reverseDepth, vec3 light)
{
if(IN.type==44)
{
discard;
}

vec2 texc=IN.texCoords;
float r=length(texc);
if(r>1.0)discard;
float ri_Air=1.00;
float ri_Water=1.33;
float incident1=0.0;
float incident2=0.0;
float loss1=0.0;
float loss2=0.0;
float refraction1=0.0;
float refraction2=0.0;
incident1=asin(r);
loss1=ReflectionFresnelSchlick(incident1,ri_Air,ri_Water);
refraction1=RefractionSnell(incident1,ri_Air,ri_Water);
incident2=refraction1;
loss2=ReflectionFresnelSchlick(incident2,ri_Water,ri_Air);
refraction2=RefractionSnell(incident2,ri_Water,ri_Air);
if(refraction2>3.1415926536)discard;
float totalAngleChange=incident1-refraction1-incident2+refraction2;
float totalLossDueToReflection=loss1+loss2;
float phi=atan(texc.y,texc.x);
if(phi<0.0)phi+=3.1415926536*2;
vec3 view_dir=-normalize(light.xyz);
vec3 globalUp=vec3(0,0,1);
vec3 right=cross(view_dir,globalUp);
vec3 up=cross(right,view_dir);
vec4 quat_1=quat_from_axis_angle_radians(view_dir,phi);
vec3 rotatedNormal=rotate_by_quaternion(quat_1,up);
vec4 quat_2=quat_from_axis_angle_radians(rotatedNormal,totalAngleChange);
vec3 finalLightLookUp=rotate_by_quaternion(quat_2,view_dir);
float refractFactor=1.0-totalLossDueToReflection;
float reflectFactor=totalLossDueToReflection;
vec3 refractLight=refractFactor*textureLod(samplerCube(cubeTexture[1 + 6]),mul(cubemapTransform,vec4(finalLightLookUp,0)).xyz,0).rgb;
vec3 reflectLight=reflectFactor*textureLod(samplerCube(cubeTexture[1 + 6]),mul(cubemapTransform,vec4(IN.dir.xyz,0)).xyz,0).rgb;
vec3 lightPS=reflectLight+refractLight;
vec4 clip_pos=IN.clip_pos/IN.clip_pos.w;
vec2 nxy=IN.dir.xy;
vec3 n=vec3(nxy,sqrt(1.0-r*r));
vec2 screen_texc=vec2(0.5*(clip_pos.x+1.0),0.5*(1.0-clip_pos.y));
vec2 depth_texc=viewportCoordToTexRegionCoord(screen_texc,viewportToTexRegionScaleBias);
float solid_depth=texture(sampler2D(depthTexture[1 + 9]),depth_texc.xy).x;
float render_depth=clip_pos.z;
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.reverseDepth=reverseDepth;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistTexture;
float solid_dist=depthToFadeDistance(solid_depth,clip_pos.xy,depthInterpretationStruct,tanHalfFov);
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistRain;
float rain_dist=depthToFadeDistance(render_depth,clip_pos.xy,depthInterpretationStruct,tanHalfFov);
float mapped_rain=IN.strength;
if(mapped_rain<=0||rain_dist>solid_dist)
{
discard;
}

float vis=mapped_rain;
vec3 normal=mul(worldView[1],vec4(n,0.0)).xyz;
vec4 result=vec4(lightPS,mix(0.0,vis,r));
return result;
}
#line 655 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
vec4 PSRainParticles(ParticleGeometryOutput IN, bool reverseDepth)
{
return PSRainParticles(IN,reverseDepth,IN.light);
}
#line 660 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
vec4 PS_RainParticles(ParticleGeometryOutput IN, bool reverseDepth)
{
return PSRainParticles(IN,reverseDepth);
}
layout(location = 0) in Block
{
ParticleGeometryOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
ParticleGeometryOutput BlockData=ioblock.BlockData;
#line 666 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
{returnObject_vec4=PS_RainParticles(BlockData,true);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/rain_PS_SnowParticles.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 10) uniform RainConstants
{
	mat4 rainMapMatrix;
	mat4 cubemapTransform;
	vec4 lightColour;
	vec3 lightDir;
	float particleWidth;
	vec3 meanFallVelocity;
	float intensity;
	float flurry;
	float flurryRate;
	float phase0;
	float phase1;
	float timeStepSeconds;
	float particleZoneSize;
	vec2 padding;
};
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 8) uniform RainPerViewConstants
{
	mat4 worldViewProj[2];
	mat4 worldView[2];
	mat4 rainDepthTransform;
	vec4 tanHalfFov;
	vec4 viewPos[2];
	vec4 offset[2];
	vec4 depthToLinFadeDistRain;
	vec4 depthToLinFadeDistTexture;
	vec4 viewportToTexRegionScaleBias;
	vec2 tanHalfFovUnused;
	vec2 screenSize;
	vec3 viewPositionOffset;
	float nearRainDistance;
	float rainDepthTextureScale;
	float splashDelta;
	float minDistanceM;
	float padding2;
};
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};

#line 95 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct ParticleGeometryOutput
{
	vec4 position;
	vec4 clip_pos;
	vec3 dir;
	float strength;
	vec3 light;
	float betaMie;
	vec2 texCoords;
	flat uint type;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t depthTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 199 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 viewportCoordToTexRegionCoord(vec2 iViewportCoord, vec4 iViewportToTexRegionScaleBias)
{
return iViewportCoord*iViewportToTexRegionScaleBias.xy+iViewportToTexRegionScaleBias.zw;
}
#line 348 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
vec4 PSSnowParticles(ParticleGeometryOutput IN, bool reverseDepth)
{
vec4 clip_pos=IN.clip_pos/IN.clip_pos.w;
vec2 screen_texc=vec2(0.5*(clip_pos.x+1.0),0.5*(1.0-clip_pos.y));
vec2 depth_texc=viewportCoordToTexRegionCoord(screen_texc,viewportToTexRegionScaleBias);
float solid_depth=texture(sampler2D(depthTexture[1 + 9]),depth_texc.xy).x;
float render_depth=clip_pos.z;
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.reverseDepth=reverseDepth;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistTexture;
float solid_dist=depthToFadeDistance(solid_depth,clip_pos.xy,depthInterpretationStruct,tanHalfFov);
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistRain;
float rain_dist=depthToFadeDistance(render_depth,clip_pos.xy,depthInterpretationStruct,tanHalfFov);
if(rain_dist>solid_dist)
{
discard;
}

float environmentBrightness=(IN.light.x+IN.light.y+IN.light.z)/3;
vec2 pos=IN.texCoords.xy;
vec3 result=IN.betaMie*lightColour.rgb+environmentBrightness*vec3(1,1,1);
float radius1=pow(length(pos.xy),.5);
float opacity=IN.strength*saturate(1.0-radius1);
return vec4(result.rgb,opacity);
}
layout(location = 0) in Block
{
ParticleGeometryOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
ParticleGeometryOutput BlockData=ioblock.BlockData;
#line 379 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
{returnObject_vec4=PSSnowParticles(BlockData,true);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/rain_PS_SnowParticles_NoCubemap.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 10) uniform RainConstants
{
	mat4 rainMapMatrix;
	mat4 cubemapTransform;
	vec4 lightColour;
	vec3 lightDir;
	float particleWidth;
	vec3 meanFallVelocity;
	float intensity;
	float flurry;
	float flurryRate;
	float phase0;
	float phase1;
	float timeStepSeconds;
	float particleZoneSize;
	vec2 padding;
};
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 8) uniform RainPerViewConstants
{
	mat4 worldViewProj[2];
	mat4 worldView[2];
	mat4 rainDepthTransform;
	vec4 tanHalfFov;
	vec4 viewPos[2];
	vec4 offset[2];
	vec4 depthToLinFadeDistRain;
	vec4 depthToLinFadeDistTexture;
	vec4 viewportToTexRegionScaleBias;
	vec2 tanHalfFovUnused;
	vec2 screenSize;
	vec3 viewPositionOffset;
	float nearRainDistance;
	float rainDepthTextureScale;
	float splashDelta;
	float minDistanceM;
	float padding2;
};
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};

#line 95 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct ParticleGeometryOutput
{
	vec4 position;
	vec4 clip_pos;
	vec3 dir;
	float strength;
	vec3 light;
	float betaMie;
	vec2 texCoords;
	flat uint type;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t depthTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 199 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 viewportCoordToTexRegionCoord(vec2 iViewportCoord, vec4 iViewportToTexRegionScaleBias)
{
return iViewportCoord*iViewportToTexRegionScaleBias.xy+iViewportToTexRegionScaleBias.zw;
}
#line 348 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
vec4 PSSnowParticles(ParticleGeometryOutput IN, bool reverseDepth)
{
vec4 clip_pos=IN.clip_pos/IN.clip_pos.w;
vec2 screen_texc=vec2(0.5*(clip_pos.x+1.0),0.5*(1.0-clip_pos.y));
vec2 depth_texc=viewportCoordToTexRegionCoord(screen_texc,viewportToTexRegionScaleBias);
float solid_depth=texture(sampler2D(depthTexture[1 + 9]),depth_texc.xy).x;
float render_depth=clip_pos.z;
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.reverseDepth=reverseDepth;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistTexture;
float solid_dist=depthToFadeDistance(solid_depth,clip_pos.xy,depthInterpretationStruct,tanHalfFov);
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistRain;
float rain_dist=depthToFadeDistance(render_depth,clip_pos.xy,depthInterpretationStruct,tanHalfFov);
if(rain_dist>solid_dist)
{
discard;
}

float environmentBrightness=(IN.light.x+IN.light.y+IN.light.z)/3;
vec2 pos=IN.texCoords.xy;
vec3 result=IN.betaMie*lightColour.rgb+environmentBrightness*vec3(1,1,1);
float radius1=pow(length(pos.xy),.5);
float opacity=IN.strength*saturate(1.0-radius1);
return vec4(result.rgb,opacity);
}
layout(location = 0) in Block
{
ParticleGeometryOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
ParticleGeometryOutput BlockData=ioblock.BlockData;
#line 384 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
{returnObject_vec4=PSSnowParticles(BlockData,true);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/rain_VS_RainParticles_Mask_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 10) uniform RainConstants
{
	mat4 rainMapMatrix;
	mat4 cubemapTransform;
	vec4 lightColour;
	vec3 lightDir;
	float particleWidth;
	vec3 meanFallVelocity;
	float intensity;
	float flurry;
	float flurryRate;
	float phase0;
	float phase1;
	float timeStepSeconds;
	float particleZoneSize;
	vec2 padding;
};
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 8) uniform RainPerViewConstants
{
	mat4 worldViewProj[2];
	mat4 worldView[2];
	mat4 rainDepthTransform;
	vec4 tanHalfFov;
	vec4 viewPos[2];
	vec4 offset[2];
	vec4 depthToLinFadeDistRain;
	vec4 depthToLinFadeDistTexture;
	vec4 viewportToTexRegionScaleBias;
	vec2 tanHalfFovUnused;
	vec2 screenSize;
	vec3 viewPositionOffset;
	float nearRainDistance;
	float rainDepthTextureScale;
	float splashDelta;
	float minDistanceM;
	float padding2;
};



#line 44 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct RandomResult
{
	uvec4 state;
	float value;
};
#line 95 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct ParticleGeometryOutput
{
	vec4 position;
	vec4 clip_pos;
	vec3 dir;
	float strength;
	vec3 light;
	float betaMie;
	vec2 texCoords;
	flat uint type;
};
layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t precipitationVolumeTexture[24];
	uint64_t rainDepthTexture[24];
	uint64_t rainDepthTextureMS[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint TausStep(uint z, int S1, int S2, int S3, uint m)
{
uint b=(((z<<S1)^z)>>S2);
return (((z&m)<<S3)^b);
}
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint LCGStep(uint z, uint A, uint C)
{
return (A*z+C);
}
#line 57 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
RandomResult Random(uvec4 state)
{
state.x=TausStep(state.x,13,19,12,0xfffffffe);
state.y=TausStep(state.y,2,25,4,0xfffffff8);
state.z=TausStep(state.z,3,11,17,0xfffffff0);
state.w=LCGStep(state.w,1664525,uint(1013904223));
RandomResult result;
result.state=state;
result.value=2.3283064365387e-10*float(state.x^state.y^state.z^state.w);
return result;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
vec3 WrapParticleZone(vec3 pos, float zoneSize)
{
const vec3 c=vec3(0.5,0.5,0.5);
vec3 box=pos/(2.0*zoneSize)+c;
pos=(fract(box)-c)*2.0*zoneSize;
return pos;
}
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
float ms_depth(vec2 depth_texc)
{
uvec2 texsize;
uint numberOfSamples;
ivec2 ivrainDepthTextureMS = textureSize(sampler2DMS(rainDepthTextureMS[0]));
texsize.x = ivrainDepthTextureMS.x;texsize.y = ivrainDepthTextureMS.y;;
ivec2 pos=ivec2(depth_texc*vec2(texsize));
float depth=texelFetch(sampler2DMS(rainDepthTextureMS[0]),ivec2(pos),int(0)).x;
return depth;
}
#line 421 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
ParticleGeometryOutput VS_RainParticles(uint vertex_id, bool rainMaskEnabled, bool msaa)
{
uint particle_id=vertex_id/6;
uint vertex_index=vertex_id-(particle_id*6);
#line 427 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

ParticleGeometryOutput p;
uvec4 state=uvec4(163+typed_mod(particle_id,71),83117+particle_id/51,195+particle_id/1001,9019+typed_mod(particle_id,507));
RandomResult r1=Random(state);
RandomResult r2=Random(r1.state);
RandomResult r3=Random(r2.state);
RandomResult r4=Random(r3.state);
RandomResult r5=Random(r4.state);
RandomResult r6=Random(r5.state);
vec3 p_pos=2.0*vec3(r4.value,r2.value,r3.value);
p_pos-=vec3(1.0,1.0,1.0);
p.type=typed_mod(particle_id,uint(32));
vec3 x=vec3(r5.value-0.5,r2.value-0.5,r1.value-0.5);
vec3 y=vec3(r4.value-0.5,r6.value-0.5,r3.value-0.5);
float time0=3.1415926536*70.0*(phase0+r6.value);
float time1=3.1415926536*70.0*(phase1+r6.value);
vec3 position0;
vec3 position1;
vec3 flurry_offset0=0.5*(x*sin(time0)+y*cos(time0));
vec3 flurry_offset1=0.5*(x*sin(time1)+y*cos(time1));
vec3 position=vec3(p_pos)*particleZoneSize-offset[0].xyz;
position=WrapParticleZone(position,particleZoneSize/2);
position0=position+flurry*flurry_offset0;
position0=WrapParticleZone(position0,particleZoneSize/2);
if(timeStepSeconds==0.0)position1=position-vec3(0,0,abs(viewPositionOffset.z))+flurry*flurry_offset1;else
position1=position-viewPositionOffset.xyz+flurry*flurry_offset1;
vec3 map_texc=mul(rainMapMatrix,vec4(viewPos[1].xyz,1.0)).xyz;
#line 460 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

map_texc.y=1.0-map_texc.y;
#line 463 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

float mapped_rain=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).x,0.25);
float cloudBaseAndDensity=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).y,0.25);
mapped_rain=(mapped_rain*4*cloudBaseAndDensity);
vec3 in_depth_space=vec3(1.0,1.0,1.0);
float depth=1.0;
if(rainMaskEnabled)
{
in_depth_space=0.5*mul(rainDepthTransform,vec4(position0.xyz+viewPos[1].xyz,1.0)).xyz+vec3(0.5,0.5,0.0);
if(msaa)
{
float temp_depth=ms_depth(vec2(in_depth_space.x,in_depth_space.y));
depth=temp_depth*rainDepthTextureScale*0.5;
}
else

{
depth=textureLod(sampler2D(rainDepthTexture[1 + 9]),vec2(in_depth_space.x,in_depth_space.y),0).x*rainDepthTextureScale*0.5;
}

}

int maxtype=int(16.0*mapped_rain);
vec3 vel=(position1-position0);
float fade=saturate(4.0*mapped_rain);
float w=particleWidth;
uint corner_id=typed_mod((vertex_index+uint(vertex_index==2)-1*uint(vertex_index>2)),4);
vec3 eyeVec=normalize(-position0.xyz);
vec3 v1=cross(eyeVec,vec3(0,0,1));
vec3 v2=cross(eyeVec,vec3(0,1,0));
float width=w*fade;
float height=w+length(vel);
float dist=length(position0.xyz);
fade*=max(.05,saturate(2.0*width/height));
float pixelSize=width*500.0/dist;
if(pixelSize<1.0)
{
width*=1.0/pixelSize;
fade*=pixelSize/1.0;
}

vec3 pos;
vec3 dir;
vel=normalize(vel);
vec3 eyeOnVelVecPlane=-((dot(eyeVec,vel))*vel);
vec3 projectedVelVec=normalize(vel-eyeOnVelVecPlane);
vec3 sideVec=normalize(cross(projectedVelVec,eyeVec));
vec2 trans=2.0*vec2((typed_mod(corner_id,2)),(corner_id/2))-vec2(1.0,1.0);
dir=normalize(normalize(eyeVec)+trans.x*sideVec+trans.y*vel);
pos=position0.xyz+trans.x*(sideVec*width)+trans.y*(vel*height);
float distM=length(position0.xyz);
p.position=mul(worldViewProj[1],vec4(pos,1.0));
p.clip_pos=p.position;
p.dir=dir;
p.strength=fade*saturate((distM-minDistanceM)/0.05);
p.light=eyeVec;
p.betaMie=0.0;
p.texCoords=trans;
p.type=typed_mod(p.type,maxtype);
if(rainMaskEnabled&&in_depth_space.x>0.0&&in_depth_space.y>0.0&&in_depth_space.x<1.0&&in_depth_space.y<1.0)
{
if(in_depth_space.z>depth)
{
p.type=44;
}

}

return p;
}
layout(location = 0) out Block
{
ParticleGeometryOutput BlockData;
} ioblock;
void main()
{
uint vertex_id=gl_VertexID;
#line 642 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
{
ioblock.BlockData=VS_RainParticles(vertex_id,true,false);
gl_Position=VS_RainParticles(vertex_id,true,false).position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/rain_VS_RainParticles_Mask_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 10) uniform RainConstants
{
	mat4 rainMapMatrix;
	mat4 cubemapTransform;
	vec4 lightColour;
	vec3 lightDir;
	float particleWidth;
	vec3 meanFallVelocity;
	float intensity;
	float flurry;
	float flurryRate;
	float phase0;
	float phase1;
	float timeStepSeconds;
	float particleZoneSize;
	vec2 padding;
};
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 8) uniform RainPerViewConstants
{
	mat4 worldViewProj[2];
	mat4 worldView[2];
	mat4 rainDepthTransform;
	vec4 tanHalfFov;
	vec4 viewPos[2];
	vec4 offset[2];
	vec4 depthToLinFadeDistRain;
	vec4 depthToLinFadeDistTexture;
	vec4 viewportToTexRegionScaleBias;
	vec2 tanHalfFovUnused;
	vec2 screenSize;
	vec3 viewPositionOffset;
	float nearRainDistance;
	float rainDepthTextureScale;
	float splashDelta;
	float minDistanceM;
	float padding2;
};



#line 44 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct RandomResult
{
	uvec4 state;
	float value;
};
#line 95 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct ParticleGeometryOutput
{
	vec4 position;
	vec4 clip_pos;
	vec3 dir;
	float strength;
	vec3 light;
	float betaMie;
	vec2 texCoords;
	flat uint type;
};
layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t precipitationVolumeTexture[24];
	uint64_t rainDepthTexture[24];
	uint64_t rainDepthTextureMS[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint TausStep(uint z, int S1, int S2, int S3, uint m)
{
uint b=(((z<<S1)^z)>>S2);
return (((z&m)<<S3)^b);
}
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint LCGStep(uint z, uint A, uint C)
{
return (A*z+C);
}
#line 57 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
RandomResult Random(uvec4 state)
{
state.x=TausStep(state.x,13,19,12,0xfffffffe);
state.y=TausStep(state.y,2,25,4,0xfffffff8);
state.z=TausStep(state.z,3,11,17,0xfffffff0);
state.w=LCGStep(state.w,1664525,uint(1013904223));
RandomResult result;
result.state=state;
result.value=2.3283064365387e-10*float(state.x^state.y^state.z^state.w);
return result;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
vec3 WrapParticleZone(vec3 pos, float zoneSize)
{
const vec3 c=vec3(0.5,0.5,0.5);
vec3 box=pos/(2.0*zoneSize)+c;
pos=(fract(box)-c)*2.0*zoneSize;
return pos;
}
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
float ms_depth(vec2 depth_texc)
{
uvec2 texsize;
uint numberOfSamples;
ivec2 ivrainDepthTextureMS = textureSize(sampler2DMS(rainDepthTextureMS[0]));
texsize.x = ivrainDepthTextureMS.x;texsize.y = ivrainDepthTextureMS.y;;
ivec2 pos=ivec2(depth_texc*vec2(texsize));
float depth=texelFetch(sampler2DMS(rainDepthTextureMS[0]),ivec2(pos),int(0)).x;
return depth;
}
#line 421 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
ParticleGeometryOutput VS_RainParticles(uint vertex_id, bool rainMaskEnabled, bool msaa)
{
uint particle_id=vertex_id/6;
uint vertex_index=vertex_id-(particle_id*6);
#line 427 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

ParticleGeometryOutput p;
uvec4 state=uvec4(163+typed_mod(particle_id,71),83117+particle_id/51,195+particle_id/1001,9019+typed_mod(particle_id,507));
RandomResult r1=Random(state);
RandomResult r2=Random(r1.state);
RandomResult r3=Random(r2.state);
RandomResult r4=Random(r3.state);
RandomResult r5=Random(r4.state);
RandomResult r6=Random(r5.state);
vec3 p_pos=2.0*vec3(r4.value,r2.value,r3.value);
p_pos-=vec3(1.0,1.0,1.0);
p.type=typed_mod(particle_id,uint(32));
vec3 x=vec3(r5.value-0.5,r2.value-0.5,r1.value-0.5);
vec3 y=vec3(r4.value-0.5,r6.value-0.5,r3.value-0.5);
float time0=3.1415926536*70.0*(phase0+r6.value);
float time1=3.1415926536*70.0*(phase1+r6.value);
vec3 position0;
vec3 position1;
vec3 flurry_offset0=0.5*(x*sin(time0)+y*cos(time0));
vec3 flurry_offset1=0.5*(x*sin(time1)+y*cos(time1));
vec3 position=vec3(p_pos)*particleZoneSize-offset[0].xyz;
position=WrapParticleZone(position,particleZoneSize/2);
position0=position+flurry*flurry_offset0;
position0=WrapParticleZone(position0,particleZoneSize/2);
if(timeStepSeconds==0.0)position1=position-vec3(0,0,abs(viewPositionOffset.z))+flurry*flurry_offset1;else
position1=position-viewPositionOffset.xyz+flurry*flurry_offset1;
vec3 map_texc=mul(rainMapMatrix,vec4(viewPos[1].xyz,1.0)).xyz;
#line 460 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

map_texc.y=1.0-map_texc.y;
#line 463 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

float mapped_rain=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).x,0.25);
float cloudBaseAndDensity=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).y,0.25);
mapped_rain=(mapped_rain*4*cloudBaseAndDensity);
vec3 in_depth_space=vec3(1.0,1.0,1.0);
float depth=1.0;
if(rainMaskEnabled)
{
in_depth_space=0.5*mul(rainDepthTransform,vec4(position0.xyz+viewPos[1].xyz,1.0)).xyz+vec3(0.5,0.5,0.0);
if(msaa)
{
float temp_depth=ms_depth(vec2(in_depth_space.x,in_depth_space.y));
depth=temp_depth*rainDepthTextureScale*0.5;
}
else

{
depth=textureLod(sampler2D(rainDepthTexture[1 + 9]),vec2(in_depth_space.x,in_depth_space.y),0).x*rainDepthTextureScale*0.5;
}

}

int maxtype=int(16.0*mapped_rain);
vec3 vel=(position1-position0);
float fade=saturate(4.0*mapped_rain);
float w=particleWidth;
uint corner_id=typed_mod((vertex_index+uint(vertex_index==2)-1*uint(vertex_index>2)),4);
vec3 eyeVec=normalize(-position0.xyz);
vec3 v1=cross(eyeVec,vec3(0,0,1));
vec3 v2=cross(eyeVec,vec3(0,1,0));
float width=w*fade;
float height=w+length(vel);
float dist=length(position0.xyz);
fade*=max(.05,saturate(2.0*width/height));
float pixelSize=width*500.0/dist;
if(pixelSize<1.0)
{
width*=1.0/pixelSize;
fade*=pixelSize/1.0;
}

vec3 pos;
vec3 dir;
vel=normalize(vel);
vec3 eyeOnVelVecPlane=-((dot(eyeVec,vel))*vel);
vec3 projectedVelVec=normalize(vel-eyeOnVelVecPlane);
vec3 sideVec=normalize(cross(projectedVelVec,eyeVec));
vec2 trans=2.0*vec2((typed_mod(corner_id,2)),(corner_id/2))-vec2(1.0,1.0);
dir=normalize(normalize(eyeVec)+trans.x*sideVec+trans.y*vel);
pos=position0.xyz+trans.x*(sideVec*width)+trans.y*(vel*height);
float distM=length(position0.xyz);
p.position=mul(worldViewProj[1],vec4(pos,1.0));
p.clip_pos=p.position;
p.dir=dir;
p.strength=fade*saturate((distM-minDistanceM)/0.05);
p.light=eyeVec;
p.betaMie=0.0;
p.texCoords=trans;
p.type=typed_mod(p.type,maxtype);
if(rainMaskEnabled&&in_depth_space.x>0.0&&in_depth_space.y>0.0&&in_depth_space.x<1.0&&in_depth_space.y<1.0)
{
if(in_depth_space.z>depth)
{
p.type=44;
}

}

return p;
}
layout(location = 0) out Block
{
ParticleGeometryOutput BlockData;
} ioblock;
void main()
{
uint vertex_id=gl_VertexID;
#line 642 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
{
ioblock.BlockData=VS_RainParticles(vertex_id,true,false);
gl_Position=VS_RainParticles(vertex_id,true,false).position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/rain_VS_RainParticles_Mask_MSAA_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 10) uniform RainConstants
{
	mat4 rainMapMatrix;
	mat4 cubemapTransform;
	vec4 lightColour;
	vec3 lightDir;
	float particleWidth;
	vec3 meanFallVelocity;
	float intensity;
	float flurry;
	float flurryRate;
	float phase0;
	float phase1;
	float timeStepSeconds;
	float particleZoneSize;
	vec2 padding;
};
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 8) uniform RainPerViewConstants
{
	mat4 worldViewProj[2];
	mat4 worldView[2];
	mat4 rainDepthTransform;
	vec4 tanHalfFov;
	vec4 viewPos[2];
	vec4 offset[2];
	vec4 depthToLinFadeDistRain;
	vec4 depthToLinFadeDistTexture;
	vec4 viewportToTexRegionScaleBias;
	vec2 tanHalfFovUnused;
	vec2 screenSize;
	vec3 viewPositionOffset;
	float nearRainDistance;
	float rainDepthTextureScale;
	float splashDelta;
	float minDistanceM;
	float padding2;
};



#line 44 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct RandomResult
{
	uvec4 state;
	float value;
};
#line 95 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct ParticleGeometryOutput
{
	vec4 position;
	vec4 clip_pos;
	vec3 dir;
	float strength;
	vec3 light;
	float betaMie;
	vec2 texCoords;
	flat uint type;
};
layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t precipitationVolumeTexture[24];
	uint64_t rainDepthTexture[24];
	uint64_t rainDepthTextureMS[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint TausStep(uint z, int S1, int S2, int S3, uint m)
{
uint b=(((z<<S1)^z)>>S2);
return (((z&m)<<S3)^b);
}
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint LCGStep(uint z, uint A, uint C)
{
return (A*z+C);
}
#line 57 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
RandomResult Random(uvec4 state)
{
state.x=TausStep(state.x,13,19,12,0xfffffffe);
state.y=TausStep(state.y,2,25,4,0xfffffff8);
state.z=TausStep(state.z,3,11,17,0xfffffff0);
state.w=LCGStep(state.w,1664525,uint(1013904223));
RandomResult result;
result.state=state;
result.value=2.3283064365387e-10*float(state.x^state.y^state.z^state.w);
return result;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
vec3 WrapParticleZone(vec3 pos, float zoneSize)
{
const vec3 c=vec3(0.5,0.5,0.5);
vec3 box=pos/(2.0*zoneSize)+c;
pos=(fract(box)-c)*2.0*zoneSize;
return pos;
}
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
float ms_depth(vec2 depth_texc)
{
uvec2 texsize;
uint numberOfSamples;
ivec2 ivrainDepthTextureMS = textureSize(sampler2DMS(rainDepthTextureMS[0]));
texsize.x = ivrainDepthTextureMS.x;texsize.y = ivrainDepthTextureMS.y;;
ivec2 pos=ivec2(depth_texc*vec2(texsize));
float depth=texelFetch(sampler2DMS(rainDepthTextureMS[0]),ivec2(pos),int(0)).x;
return depth;
}
#line 421 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
ParticleGeometryOutput VS_RainParticles(uint vertex_id, bool rainMaskEnabled, bool msaa)
{
uint particle_id=vertex_id/6;
uint vertex_index=vertex_id-(particle_id*6);
#line 427 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

ParticleGeometryOutput p;
uvec4 state=uvec4(163+typed_mod(particle_id,71),83117+particle_id/51,195+particle_id/1001,9019+typed_mod(particle_id,507));
RandomResult r1=Random(state);
RandomResult r2=Random(r1.state);
RandomResult r3=Random(r2.state);
RandomResult r4=Random(r3.state);
RandomResult r5=Random(r4.state);
RandomResult r6=Random(r5.state);
vec3 p_pos=2.0*vec3(r4.value,r2.value,r3.value);
p_pos-=vec3(1.0,1.0,1.0);
p.type=typed_mod(particle_id,uint(32));
vec3 x=vec3(r5.value-0.5,r2.value-0.5,r1.value-0.5);
vec3 y=vec3(r4.value-0.5,r6.value-0.5,r3.value-0.5);
float time0=3.1415926536*70.0*(phase0+r6.value);
float time1=3.1415926536*70.0*(phase1+r6.value);
vec3 position0;
vec3 position1;
vec3 flurry_offset0=0.5*(x*sin(time0)+y*cos(time0));
vec3 flurry_offset1=0.5*(x*sin(time1)+y*cos(time1));
vec3 position=vec3(p_pos)*particleZoneSize-offset[0].xyz;
position=WrapParticleZone(position,particleZoneSize/2);
position0=position+flurry*flurry_offset0;
position0=WrapParticleZone(position0,particleZoneSize/2);
if(timeStepSeconds==0.0)position1=position-vec3(0,0,abs(viewPositionOffset.z))+flurry*flurry_offset1;else
position1=position-viewPositionOffset.xyz+flurry*flurry_offset1;
vec3 map_texc=mul(rainMapMatrix,vec4(viewPos[1].xyz,1.0)).xyz;
#line 460 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

map_texc.y=1.0-map_texc.y;
#line 463 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

float mapped_rain=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).x,0.25);
float cloudBaseAndDensity=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).y,0.25);
mapped_rain=(mapped_rain*4*cloudBaseAndDensity);
vec3 in_depth_space=vec3(1.0,1.0,1.0);
float depth=1.0;
if(rainMaskEnabled)
{
in_depth_space=0.5*mul(rainDepthTransform,vec4(position0.xyz+viewPos[1].xyz,1.0)).xyz+vec3(0.5,0.5,0.0);
if(msaa)
{
float temp_depth=ms_depth(vec2(in_depth_space.x,in_depth_space.y));
depth=temp_depth*rainDepthTextureScale*0.5;
}
else

{
depth=textureLod(sampler2D(rainDepthTexture[1 + 9]),vec2(in_depth_space.x,in_depth_space.y),0).x*rainDepthTextureScale*0.5;
}

}

int maxtype=int(16.0*mapped_rain);
vec3 vel=(position1-position0);
float fade=saturate(4.0*mapped_rain);
float w=particleWidth;
uint corner_id=typed_mod((vertex_index+uint(vertex_index==2)-1*uint(vertex_index>2)),4);
vec3 eyeVec=normalize(-position0.xyz);
vec3 v1=cross(eyeVec,vec3(0,0,1));
vec3 v2=cross(eyeVec,vec3(0,1,0));
float width=w*fade;
float height=w+length(vel);
float dist=length(position0.xyz);
fade*=max(.05,saturate(2.0*width/height));
float pixelSize=width*500.0/dist;
if(pixelSize<1.0)
{
width*=1.0/pixelSize;
fade*=pixelSize/1.0;
}

vec3 pos;
vec3 dir;
vel=normalize(vel);
vec3 eyeOnVelVecPlane=-((dot(eyeVec,vel))*vel);
vec3 projectedVelVec=normalize(vel-eyeOnVelVecPlane);
vec3 sideVec=normalize(cross(projectedVelVec,eyeVec));
vec2 trans=2.0*vec2((typed_mod(corner_id,2)),(corner_id/2))-vec2(1.0,1.0);
dir=normalize(normalize(eyeVec)+trans.x*sideVec+trans.y*vel);
pos=position0.xyz+trans.x*(sideVec*width)+trans.y*(vel*height);
float distM=length(position0.xyz);
p.position=mul(worldViewProj[1],vec4(pos,1.0));
p.clip_pos=p.position;
p.dir=dir;
p.strength=fade*saturate((distM-minDistanceM)/0.05);
p.light=eyeVec;
p.betaMie=0.0;
p.texCoords=trans;
p.type=typed_mod(p.type,maxtype);
if(rainMaskEnabled&&in_depth_space.x>0.0&&in_depth_space.y>0.0&&in_depth_space.x<1.0&&in_depth_space.y<1.0)
{
if(in_depth_space.z>depth)
{
p.type=44;
}

}

return p;
}
layout(location = 0) out Block
{
ParticleGeometryOutput BlockData;
} ioblock;
void main()
{
uint vertex_id=gl_VertexID;
#line 651 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
{
ioblock.BlockData=VS_RainParticles(vertex_id,true,true);
gl_Position=VS_RainParticles(vertex_id,true,true).position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/rain_VS_RainParticles_Mask_MSAA_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 10) uniform RainConstants
{
	mat4 rainMapMatrix;
	mat4 cubemapTransform;
	vec4 lightColour;
	vec3 lightDir;
	float particleWidth;
	vec3 meanFallVelocity;
	float intensity;
	float flurry;
	float flurryRate;
	float phase0;
	float phase1;
	float timeStepSeconds;
	float particleZoneSize;
	vec2 padding;
};
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 8) uniform RainPerViewConstants
{
	mat4 worldViewProj[2];
	mat4 worldView[2];
	mat4 rainDepthTransform;
	vec4 tanHalfFov;
	vec4 viewPos[2];
	vec4 offset[2];
	vec4 depthToLinFadeDistRain;
	vec4 depthToLinFadeDistTexture;
	vec4 viewportToTexRegionScaleBias;
	vec2 tanHalfFovUnused;
	vec2 screenSize;
	vec3 viewPositionOffset;
	float nearRainDistance;
	float rainDepthTextureScale;
	float splashDelta;
	float minDistanceM;
	float padding2;
};



#line 44 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct RandomResult
{
	uvec4 state;
	float value;
};
#line 95 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct ParticleGeometryOutput
{
	vec4 position;
	vec4 clip_pos;
	vec3 dir;
	float strength;
	vec3 light;
	float betaMie;
	vec2 texCoords;
	flat uint type;
};
layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t precipitationVolumeTexture[24];
	uint64_t rainDepthTexture[24];
	uint64_t rainDepthTextureMS[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint TausStep(uint z, int S1, int S2, int S3, uint m)
{
uint b=(((z<<S1)^z)>>S2);
return (((z&m)<<S3)^b);
}
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint LCGStep(uint z, uint A, uint C)
{
return (A*z+C);
}
#line 57 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
RandomResult Random(uvec4 state)
{
state.x=TausStep(state.x,13,19,12,0xfffffffe);
state.y=TausStep(state.y,2,25,4,0xfffffff8);
state.z=TausStep(state.z,3,11,17,0xfffffff0);
state.w=LCGStep(state.w,1664525,uint(1013904223));
RandomResult result;
result.state=state;
result.value=2.3283064365387e-10*float(state.x^state.y^state.z^state.w);
return result;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
vec3 WrapParticleZone(vec3 pos, float zoneSize)
{
const vec3 c=vec3(0.5,0.5,0.5);
vec3 box=pos/(2.0*zoneSize)+c;
pos=(fract(box)-c)*2.0*zoneSize;
return pos;
}
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
float ms_depth(vec2 depth_texc)
{
uvec2 texsize;
uint numberOfSamples;
ivec2 ivrainDepthTextureMS = textureSize(sampler2DMS(rainDepthTextureMS[0]));
texsize.x = ivrainDepthTextureMS.x;texsize.y = ivrainDepthTextureMS.y;;
ivec2 pos=ivec2(depth_texc*vec2(texsize));
float depth=texelFetch(sampler2DMS(rainDepthTextureMS[0]),ivec2(pos),int(0)).x;
return depth;
}
#line 421 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
ParticleGeometryOutput VS_RainParticles(uint vertex_id, bool rainMaskEnabled, bool msaa)
{
uint particle_id=vertex_id/6;
uint vertex_index=vertex_id-(particle_id*6);
#line 427 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

ParticleGeometryOutput p;
uvec4 state=uvec4(163+typed_mod(particle_id,71),83117+particle_id/51,195+particle_id/1001,9019+typed_mod(particle_id,507));
RandomResult r1=Random(state);
RandomResult r2=Random(r1.state);
RandomResult r3=Random(r2.state);
RandomResult r4=Random(r3.state);
RandomResult r5=Random(r4.state);
RandomResult r6=Random(r5.state);
vec3 p_pos=2.0*vec3(r4.value,r2.value,r3.value);
p_pos-=vec3(1.0,1.0,1.0);
p.type=typed_mod(particle_id,uint(32));
vec3 x=vec3(r5.value-0.5,r2.value-0.5,r1.value-0.5);
vec3 y=vec3(r4.value-0.5,r6.value-0.5,r3.value-0.5);
float time0=3.1415926536*70.0*(phase0+r6.value);
float time1=3.1415926536*70.0*(phase1+r6.value);
vec3 position0;
vec3 position1;
vec3 flurry_offset0=0.5*(x*sin(time0)+y*cos(time0));
vec3 flurry_offset1=0.5*(x*sin(time1)+y*cos(time1));
vec3 position=vec3(p_pos)*particleZoneSize-offset[0].xyz;
position=WrapParticleZone(position,particleZoneSize/2);
position0=position+flurry*flurry_offset0;
position0=WrapParticleZone(position0,particleZoneSize/2);
if(timeStepSeconds==0.0)position1=position-vec3(0,0,abs(viewPositionOffset.z))+flurry*flurry_offset1;else
position1=position-viewPositionOffset.xyz+flurry*flurry_offset1;
vec3 map_texc=mul(rainMapMatrix,vec4(viewPos[1].xyz,1.0)).xyz;
#line 460 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

map_texc.y=1.0-map_texc.y;
#line 463 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

float mapped_rain=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).x,0.25);
float cloudBaseAndDensity=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).y,0.25);
mapped_rain=(mapped_rain*4*cloudBaseAndDensity);
vec3 in_depth_space=vec3(1.0,1.0,1.0);
float depth=1.0;
if(rainMaskEnabled)
{
in_depth_space=0.5*mul(rainDepthTransform,vec4(position0.xyz+viewPos[1].xyz,1.0)).xyz+vec3(0.5,0.5,0.0);
if(msaa)
{
float temp_depth=ms_depth(vec2(in_depth_space.x,in_depth_space.y));
depth=temp_depth*rainDepthTextureScale*0.5;
}
else

{
depth=textureLod(sampler2D(rainDepthTexture[1 + 9]),vec2(in_depth_space.x,in_depth_space.y),0).x*rainDepthTextureScale*0.5;
}

}

int maxtype=int(16.0*mapped_rain);
vec3 vel=(position1-position0);
float fade=saturate(4.0*mapped_rain);
float w=particleWidth;
uint corner_id=typed_mod((vertex_index+uint(vertex_index==2)-1*uint(vertex_index>2)),4);
vec3 eyeVec=normalize(-position0.xyz);
vec3 v1=cross(eyeVec,vec3(0,0,1));
vec3 v2=cross(eyeVec,vec3(0,1,0));
float width=w*fade;
float height=w+length(vel);
float dist=length(position0.xyz);
fade*=max(.05,saturate(2.0*width/height));
float pixelSize=width*500.0/dist;
if(pixelSize<1.0)
{
width*=1.0/pixelSize;
fade*=pixelSize/1.0;
}

vec3 pos;
vec3 dir;
vel=normalize(vel);
vec3 eyeOnVelVecPlane=-((dot(eyeVec,vel))*vel);
vec3 projectedVelVec=normalize(vel-eyeOnVelVecPlane);
vec3 sideVec=normalize(cross(projectedVelVec,eyeVec));
vec2 trans=2.0*vec2((typed_mod(corner_id,2)),(corner_id/2))-vec2(1.0,1.0);
dir=normalize(normalize(eyeVec)+trans.x*sideVec+trans.y*vel);
pos=position0.xyz+trans.x*(sideVec*width)+trans.y*(vel*height);
float distM=length(position0.xyz);
p.position=mul(worldViewProj[1],vec4(pos,1.0));
p.clip_pos=p.position;
p.dir=dir;
p.strength=fade*saturate((distM-minDistanceM)/0.05);
p.light=eyeVec;
p.betaMie=0.0;
p.texCoords=trans;
p.type=typed_mod(p.type,maxtype);
if(rainMaskEnabled&&in_depth_space.x>0.0&&in_depth_space.y>0.0&&in_depth_space.x<1.0&&in_depth_space.y<1.0)
{
if(in_depth_space.z>depth)
{
p.type=44;
}

}

return p;
}
layout(location = 0) out Block
{
ParticleGeometryOutput BlockData;
} ioblock;
void main()
{
uint vertex_id=gl_VertexID;
#line 651 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
{
ioblock.BlockData=VS_RainParticles(vertex_id,true,true);
gl_Position=VS_RainParticles(vertex_id,true,true).position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/rain_VS_RainParticles_NoMask_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 10) uniform RainConstants
{
	mat4 rainMapMatrix;
	mat4 cubemapTransform;
	vec4 lightColour;
	vec3 lightDir;
	float particleWidth;
	vec3 meanFallVelocity;
	float intensity;
	float flurry;
	float flurryRate;
	float phase0;
	float phase1;
	float timeStepSeconds;
	float particleZoneSize;
	vec2 padding;
};
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 8) uniform RainPerViewConstants
{
	mat4 worldViewProj[2];
	mat4 worldView[2];
	mat4 rainDepthTransform;
	vec4 tanHalfFov;
	vec4 viewPos[2];
	vec4 offset[2];
	vec4 depthToLinFadeDistRain;
	vec4 depthToLinFadeDistTexture;
	vec4 viewportToTexRegionScaleBias;
	vec2 tanHalfFovUnused;
	vec2 screenSize;
	vec3 viewPositionOffset;
	float nearRainDistance;
	float rainDepthTextureScale;
	float splashDelta;
	float minDistanceM;
	float padding2;
};



#line 44 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct RandomResult
{
	uvec4 state;
	float value;
};
#line 95 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct ParticleGeometryOutput
{
	vec4 position;
	vec4 clip_pos;
	vec3 dir;
	float strength;
	vec3 light;
	float betaMie;
	vec2 texCoords;
	flat uint type;
};
layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t precipitationVolumeTexture[24];
	uint64_t rainDepthTexture[24];
	uint64_t rainDepthTextureMS[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint TausStep(uint z, int S1, int S2, int S3, uint m)
{
uint b=(((z<<S1)^z)>>S2);
return (((z&m)<<S3)^b);
}
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint LCGStep(uint z, uint A, uint C)
{
return (A*z+C);
}
#line 57 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
RandomResult Random(uvec4 state)
{
state.x=TausStep(state.x,13,19,12,0xfffffffe);
state.y=TausStep(state.y,2,25,4,0xfffffff8);
state.z=TausStep(state.z,3,11,17,0xfffffff0);
state.w=LCGStep(state.w,1664525,uint(1013904223));
RandomResult result;
result.state=state;
result.value=2.3283064365387e-10*float(state.x^state.y^state.z^state.w);
return result;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
vec3 WrapParticleZone(vec3 pos, float zoneSize)
{
const vec3 c=vec3(0.5,0.5,0.5);
vec3 box=pos/(2.0*zoneSize)+c;
pos=(fract(box)-c)*2.0*zoneSize;
return pos;
}
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
float ms_depth(vec2 depth_texc)
{
uvec2 texsize;
uint numberOfSamples;
ivec2 ivrainDepthTextureMS = textureSize(sampler2DMS(rainDepthTextureMS[0]));
texsize.x = ivrainDepthTextureMS.x;texsize.y = ivrainDepthTextureMS.y;;
ivec2 pos=ivec2(depth_texc*vec2(texsize));
float depth=texelFetch(sampler2DMS(rainDepthTextureMS[0]),ivec2(pos),int(0)).x;
return depth;
}
#line 421 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
ParticleGeometryOutput VS_RainParticles(uint vertex_id, bool rainMaskEnabled, bool msaa)
{
uint particle_id=vertex_id/6;
uint vertex_index=vertex_id-(particle_id*6);
#line 427 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

ParticleGeometryOutput p;
uvec4 state=uvec4(163+typed_mod(particle_id,71),83117+particle_id/51,195+particle_id/1001,9019+typed_mod(particle_id,507));
RandomResult r1=Random(state);
RandomResult r2=Random(r1.state);
RandomResult r3=Random(r2.state);
RandomResult r4=Random(r3.state);
RandomResult r5=Random(r4.state);
RandomResult r6=Random(r5.state);
vec3 p_pos=2.0*vec3(r4.value,r2.value,r3.value);
p_pos-=vec3(1.0,1.0,1.0);
p.type=typed_mod(particle_id,uint(32));
vec3 x=vec3(r5.value-0.5,r2.value-0.5,r1.value-0.5);
vec3 y=vec3(r4.value-0.5,r6.value-0.5,r3.value-0.5);
float time0=3.1415926536*70.0*(phase0+r6.value);
float time1=3.1415926536*70.0*(phase1+r6.value);
vec3 position0;
vec3 position1;
vec3 flurry_offset0=0.5*(x*sin(time0)+y*cos(time0));
vec3 flurry_offset1=0.5*(x*sin(time1)+y*cos(time1));
vec3 position=vec3(p_pos)*particleZoneSize-offset[0].xyz;
position=WrapParticleZone(position,particleZoneSize/2);
position0=position+flurry*flurry_offset0;
position0=WrapParticleZone(position0,particleZoneSize/2);
if(timeStepSeconds==0.0)position1=position-vec3(0,0,abs(viewPositionOffset.z))+flurry*flurry_offset1;else
position1=position-viewPositionOffset.xyz+flurry*flurry_offset1;
vec3 map_texc=mul(rainMapMatrix,vec4(viewPos[1].xyz,1.0)).xyz;
#line 460 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

map_texc.y=1.0-map_texc.y;
#line 463 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

float mapped_rain=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).x,0.25);
float cloudBaseAndDensity=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).y,0.25);
mapped_rain=(mapped_rain*4*cloudBaseAndDensity);
vec3 in_depth_space=vec3(1.0,1.0,1.0);
float depth=1.0;
if(rainMaskEnabled)
{
in_depth_space=0.5*mul(rainDepthTransform,vec4(position0.xyz+viewPos[1].xyz,1.0)).xyz+vec3(0.5,0.5,0.0);
if(msaa)
{
float temp_depth=ms_depth(vec2(in_depth_space.x,in_depth_space.y));
depth=temp_depth*rainDepthTextureScale*0.5;
}
else

{
depth=textureLod(sampler2D(rainDepthTexture[1 + 9]),vec2(in_depth_space.x,in_depth_space.y),0).x*rainDepthTextureScale*0.5;
}

}

int maxtype=int(16.0*mapped_rain);
vec3 vel=(position1-position0);
float fade=saturate(4.0*mapped_rain);
float w=particleWidth;
uint corner_id=typed_mod((vertex_index+uint(vertex_index==2)-1*uint(vertex_index>2)),4);
vec3 eyeVec=normalize(-position0.xyz);
vec3 v1=cross(eyeVec,vec3(0,0,1));
vec3 v2=cross(eyeVec,vec3(0,1,0));
float width=w*fade;
float height=w+length(vel);
float dist=length(position0.xyz);
fade*=max(.05,saturate(2.0*width/height));
float pixelSize=width*500.0/dist;
if(pixelSize<1.0)
{
width*=1.0/pixelSize;
fade*=pixelSize/1.0;
}

vec3 pos;
vec3 dir;
vel=normalize(vel);
vec3 eyeOnVelVecPlane=-((dot(eyeVec,vel))*vel);
vec3 projectedVelVec=normalize(vel-eyeOnVelVecPlane);
vec3 sideVec=normalize(cross(projectedVelVec,eyeVec));
vec2 trans=2.0*vec2((typed_mod(corner_id,2)),(corner_id/2))-vec2(1.0,1.0);
dir=normalize(normalize(eyeVec)+trans.x*sideVec+trans.y*vel);
pos=position0.xyz+trans.x*(sideVec*width)+trans.y*(vel*height);
float distM=length(position0.xyz);
p.position=mul(worldViewProj[1],vec4(pos,1.0));
p.clip_pos=p.position;
p.dir=dir;
p.strength=fade*saturate((distM-minDistanceM)/0.05);
p.light=eyeVec;
p.betaMie=0.0;
p.texCoords=trans;
p.type=typed_mod(p.type,maxtype);
if(rainMaskEnabled&&in_depth_space.x>0.0&&in_depth_space.y>0.0&&in_depth_space.x<1.0&&in_depth_space.y<1.0)
{
if(in_depth_space.z>depth)
{
p.type=44;
}

}

return p;
}
layout(location = 0) out Block
{
ParticleGeometryOutput BlockData;
} ioblock;
void main()
{
uint vertex_id=gl_VertexID;
#line 637 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
{
ioblock.BlockData=VS_RainParticles(vertex_id,false,false);
gl_Position=VS_RainParticles(vertex_id,false,false).position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/rain_VS_RainParticles_NoMask_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 10) uniform RainConstants
{
	mat4 rainMapMatrix;
	mat4 cubemapTransform;
	vec4 lightColour;
	vec3 lightDir;
	float particleWidth;
	vec3 meanFallVelocity;
	float intensity;
	float flurry;
	float flurryRate;
	float phase0;
	float phase1;
	float timeStepSeconds;
	float particleZoneSize;
	vec2 padding;
};
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 8) uniform RainPerViewConstants
{
	mat4 worldViewProj[2];
	mat4 worldView[2];
	mat4 rainDepthTransform;
	vec4 tanHalfFov;
	vec4 viewPos[2];
	vec4 offset[2];
	vec4 depthToLinFadeDistRain;
	vec4 depthToLinFadeDistTexture;
	vec4 viewportToTexRegionScaleBias;
	vec2 tanHalfFovUnused;
	vec2 screenSize;
	vec3 viewPositionOffset;
	float nearRainDistance;
	float rainDepthTextureScale;
	float splashDelta;
	float minDistanceM;
	float padding2;
};



#line 44 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct RandomResult
{
	uvec4 state;
	float value;
};
#line 95 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct ParticleGeometryOutput
{
	vec4 position;
	vec4 clip_pos;
	vec3 dir;
	float strength;
	vec3 light;
	float betaMie;
	vec2 texCoords;
	flat uint type;
};
layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t precipitationVolumeTexture[24];
	uint64_t rainDepthTexture[24];
	uint64_t rainDepthTextureMS[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint TausStep(uint z, int S1, int S2, int S3, uint m)
{
uint b=(((z<<S1)^z)>>S2);
return (((z&m)<<S3)^b);
}
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint LCGStep(uint z, uint A, uint C)
{
return (A*z+C);
}
#line 57 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
RandomResult Random(uvec4 state)
{
state.x=TausStep(state.x,13,19,12,0xfffffffe);
state.y=TausStep(state.y,2,25,4,0xfffffff8);
state.z=TausStep(state.z,3,11,17,0xfffffff0);
state.w=LCGStep(state.w,1664525,uint(1013904223));
RandomResult result;
result.state=state;
result.value=2.3283064365387e-10*float(state.x^state.y^state.z^state.w);
return result;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
vec3 WrapParticleZone(vec3 pos, float zoneSize)
{
const vec3 c=vec3(0.5,0.5,0.5);
vec3 box=pos/(2.0*zoneSize)+c;
pos=(fract(box)-c)*2.0*zoneSize;
return pos;
}
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
float ms_depth(vec2 depth_texc)
{
uvec2 texsize;
uint numberOfSamples;
ivec2 ivrainDepthTextureMS = textureSize(sampler2DMS(rainDepthTextureMS[0]));
texsize.x = ivrainDepthTextureMS.x;texsize.y = ivrainDepthTextureMS.y;;
ivec2 pos=ivec2(depth_texc*vec2(texsize));
float depth=texelFetch(sampler2DMS(rainDepthTextureMS[0]),ivec2(pos),int(0)).x;
return depth;
}
#line 421 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
ParticleGeometryOutput VS_RainParticles(uint vertex_id, bool rainMaskEnabled, bool msaa)
{
uint particle_id=vertex_id/6;
uint vertex_index=vertex_id-(particle_id*6);
#line 427 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

ParticleGeometryOutput p;
uvec4 state=uvec4(163+typed_mod(particle_id,71),83117+particle_id/51,195+particle_id/1001,9019+typed_mod(particle_id,507));
RandomResult r1=Random(state);
RandomResult r2=Random(r1.state);
RandomResult r3=Random(r2.state);
RandomResult r4=Random(r3.state);
RandomResult r5=Random(r4.state);
RandomResult r6=Random(r5.state);
vec3 p_pos=2.0*vec3(r4.value,r2.value,r3.value);
p_pos-=vec3(1.0,1.0,1.0);
p.type=typed_mod(particle_id,uint(32));
vec3 x=vec3(r5.value-0.5,r2.value-0.5,r1.value-0.5);
vec3 y=vec3(r4.value-0.5,r6.value-0.5,r3.value-0.5);
float time0=3.1415926536*70.0*(phase0+r6.value);
float time1=3.1415926536*70.0*(phase1+r6.value);
vec3 position0;
vec3 position1;
vec3 flurry_offset0=0.5*(x*sin(time0)+y*cos(time0));
vec3 flurry_offset1=0.5*(x*sin(time1)+y*cos(time1));
vec3 position=vec3(p_pos)*particleZoneSize-offset[0].xyz;
position=WrapParticleZone(position,particleZoneSize/2);
position0=position+flurry*flurry_offset0;
position0=WrapParticleZone(position0,particleZoneSize/2);
if(timeStepSeconds==0.0)position1=position-vec3(0,0,abs(viewPositionOffset.z))+flurry*flurry_offset1;else
position1=position-viewPositionOffset.xyz+flurry*flurry_offset1;
vec3 map_texc=mul(rainMapMatrix,vec4(viewPos[1].xyz,1.0)).xyz;
#line 460 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

map_texc.y=1.0-map_texc.y;
#line 463 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

float mapped_rain=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).x,0.25);
float cloudBaseAndDensity=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).y,0.25);
mapped_rain=(mapped_rain*4*cloudBaseAndDensity);
vec3 in_depth_space=vec3(1.0,1.0,1.0);
float depth=1.0;
if(rainMaskEnabled)
{
in_depth_space=0.5*mul(rainDepthTransform,vec4(position0.xyz+viewPos[1].xyz,1.0)).xyz+vec3(0.5,0.5,0.0);
if(msaa)
{
float temp_depth=ms_depth(vec2(in_depth_space.x,in_depth_space.y));
depth=temp_depth*rainDepthTextureScale*0.5;
}
else

{
depth=textureLod(sampler2D(rainDepthTexture[1 + 9]),vec2(in_depth_space.x,in_depth_space.y),0).x*rainDepthTextureScale*0.5;
}

}

int maxtype=int(16.0*mapped_rain);
vec3 vel=(position1-position0);
float fade=saturate(4.0*mapped_rain);
float w=particleWidth;
uint corner_id=typed_mod((vertex_index+uint(vertex_index==2)-1*uint(vertex_index>2)),4);
vec3 eyeVec=normalize(-position0.xyz);
vec3 v1=cross(eyeVec,vec3(0,0,1));
vec3 v2=cross(eyeVec,vec3(0,1,0));
float width=w*fade;
float height=w+length(vel);
float dist=length(position0.xyz);
fade*=max(.05,saturate(2.0*width/height));
float pixelSize=width*500.0/dist;
if(pixelSize<1.0)
{
width*=1.0/pixelSize;
fade*=pixelSize/1.0;
}

vec3 pos;
vec3 dir;
vel=normalize(vel);
vec3 eyeOnVelVecPlane=-((dot(eyeVec,vel))*vel);
vec3 projectedVelVec=normalize(vel-eyeOnVelVecPlane);
vec3 sideVec=normalize(cross(projectedVelVec,eyeVec));
vec2 trans=2.0*vec2((typed_mod(corner_id,2)),(corner_id/2))-vec2(1.0,1.0);
dir=normalize(normalize(eyeVec)+trans.x*sideVec+trans.y*vel);
pos=position0.xyz+trans.x*(sideVec*width)+trans.y*(vel*height);
float distM=length(position0.xyz);
p.position=mul(worldViewProj[1],vec4(pos,1.0));
p.clip_pos=p.position;
p.dir=dir;
p.strength=fade*saturate((distM-minDistanceM)/0.05);
p.light=eyeVec;
p.betaMie=0.0;
p.texCoords=trans;
p.type=typed_mod(p.type,maxtype);
if(rainMaskEnabled&&in_depth_space.x>0.0&&in_depth_space.y>0.0&&in_depth_space.x<1.0&&in_depth_space.y<1.0)
{
if(in_depth_space.z>depth)
{
p.type=44;
}

}

return p;
}
layout(location = 0) out Block
{
ParticleGeometryOutput BlockData;
} ioblock;
void main()
{
uint vertex_id=gl_VertexID;
#line 637 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
{
ioblock.BlockData=VS_RainParticles(vertex_id,false,false);
gl_Position=VS_RainParticles(vertex_id,false,false).position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/rain_VS_RainParticles_NoMask_MSAA_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 10) uniform RainConstants
{
	mat4 rainMapMatrix;
	mat4 cubemapTransform;
	vec4 lightColour;
	vec3 lightDir;
	float particleWidth;
	vec3 meanFallVelocity;
	float intensity;
	float flurry;
	float flurryRate;
	float phase0;
	float phase1;
	float timeStepSeconds;
	float particleZoneSize;
	vec2 padding;
};
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 8) uniform RainPerViewConstants
{
	mat4 worldViewProj[2];
	mat4 worldView[2];
	mat4 rainDepthTransform;
	vec4 tanHalfFov;
	vec4 viewPos[2];
	vec4 offset[2];
	vec4 depthToLinFadeDistRain;
	vec4 depthToLinFadeDistTexture;
	vec4 viewportToTexRegionScaleBias;
	vec2 tanHalfFovUnused;
	vec2 screenSize;
	vec3 viewPositionOffset;
	float nearRainDistance;
	float rainDepthTextureScale;
	float splashDelta;
	float minDistanceM;
	float padding2;
};



#line 44 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct RandomResult
{
	uvec4 state;
	float value;
};
#line 95 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct ParticleGeometryOutput
{
	vec4 position;
	vec4 clip_pos;
	vec3 dir;
	float strength;
	vec3 light;
	float betaMie;
	vec2 texCoords;
	flat uint type;
};
layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t precipitationVolumeTexture[24];
	uint64_t rainDepthTexture[24];
	uint64_t rainDepthTextureMS[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint TausStep(uint z, int S1, int S2, int S3, uint m)
{
uint b=(((z<<S1)^z)>>S2);
return (((z&m)<<S3)^b);
}
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint LCGStep(uint z, uint A, uint C)
{
return (A*z+C);
}
#line 57 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
RandomResult Random(uvec4 state)
{
state.x=TausStep(state.x,13,19,12,0xfffffffe);
state.y=TausStep(state.y,2,25,4,0xfffffff8);
state.z=TausStep(state.z,3,11,17,0xfffffff0);
state.w=LCGStep(state.w,1664525,uint(1013904223));
RandomResult result;
result.state=state;
result.value=2.3283064365387e-10*float(state.x^state.y^state.z^state.w);
return result;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
vec3 WrapParticleZone(vec3 pos, float zoneSize)
{
const vec3 c=vec3(0.5,0.5,0.5);
vec3 box=pos/(2.0*zoneSize)+c;
pos=(fract(box)-c)*2.0*zoneSize;
return pos;
}
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
float ms_depth(vec2 depth_texc)
{
uvec2 texsize;
uint numberOfSamples;
ivec2 ivrainDepthTextureMS = textureSize(sampler2DMS(rainDepthTextureMS[0]));
texsize.x = ivrainDepthTextureMS.x;texsize.y = ivrainDepthTextureMS.y;;
ivec2 pos=ivec2(depth_texc*vec2(texsize));
float depth=texelFetch(sampler2DMS(rainDepthTextureMS[0]),ivec2(pos),int(0)).x;
return depth;
}
#line 421 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
ParticleGeometryOutput VS_RainParticles(uint vertex_id, bool rainMaskEnabled, bool msaa)
{
uint particle_id=vertex_id/6;
uint vertex_index=vertex_id-(particle_id*6);
#line 427 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

ParticleGeometryOutput p;
uvec4 state=uvec4(163+typed_mod(particle_id,71),83117+particle_id/51,195+particle_id/1001,9019+typed_mod(particle_id,507));
RandomResult r1=Random(state);
RandomResult r2=Random(r1.state);
RandomResult r3=Random(r2.state);
RandomResult r4=Random(r3.state);
RandomResult r5=Random(r4.state);
RandomResult r6=Random(r5.state);
vec3 p_pos=2.0*vec3(r4.value,r2.value,r3.value);
p_pos-=vec3(1.0,1.0,1.0);
p.type=typed_mod(particle_id,uint(32));
vec3 x=vec3(r5.value-0.5,r2.value-0.5,r1.value-0.5);
vec3 y=vec3(r4.value-0.5,r6.value-0.5,r3.value-0.5);
float time0=3.1415926536*70.0*(phase0+r6.value);
float time1=3.1415926536*70.0*(phase1+r6.value);
vec3 position0;
vec3 position1;
vec3 flurry_offset0=0.5*(x*sin(time0)+y*cos(time0));
vec3 flurry_offset1=0.5*(x*sin(time1)+y*cos(time1));
vec3 position=vec3(p_pos)*particleZoneSize-offset[0].xyz;
position=WrapParticleZone(position,particleZoneSize/2);
position0=position+flurry*flurry_offset0;
position0=WrapParticleZone(position0,particleZoneSize/2);
if(timeStepSeconds==0.0)position1=position-vec3(0,0,abs(viewPositionOffset.z))+flurry*flurry_offset1;else
position1=position-viewPositionOffset.xyz+flurry*flurry_offset1;
vec3 map_texc=mul(rainMapMatrix,vec4(viewPos[1].xyz,1.0)).xyz;
#line 460 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

map_texc.y=1.0-map_texc.y;
#line 463 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

float mapped_rain=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).x,0.25);
float cloudBaseAndDensity=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).y,0.25);
mapped_rain=(mapped_rain*4*cloudBaseAndDensity);
vec3 in_depth_space=vec3(1.0,1.0,1.0);
float depth=1.0;
if(rainMaskEnabled)
{
in_depth_space=0.5*mul(rainDepthTransform,vec4(position0.xyz+viewPos[1].xyz,1.0)).xyz+vec3(0.5,0.5,0.0);
if(msaa)
{
float temp_depth=ms_depth(vec2(in_depth_space.x,in_depth_space.y));
depth=temp_depth*rainDepthTextureScale*0.5;
}
else

{
depth=textureLod(sampler2D(rainDepthTexture[1 + 9]),vec2(in_depth_space.x,in_depth_space.y),0).x*rainDepthTextureScale*0.5;
}

}

int maxtype=int(16.0*mapped_rain);
vec3 vel=(position1-position0);
float fade=saturate(4.0*mapped_rain);
float w=particleWidth;
uint corner_id=typed_mod((vertex_index+uint(vertex_index==2)-1*uint(vertex_index>2)),4);
vec3 eyeVec=normalize(-position0.xyz);
vec3 v1=cross(eyeVec,vec3(0,0,1));
vec3 v2=cross(eyeVec,vec3(0,1,0));
float width=w*fade;
float height=w+length(vel);
float dist=length(position0.xyz);
fade*=max(.05,saturate(2.0*width/height));
float pixelSize=width*500.0/dist;
if(pixelSize<1.0)
{
width*=1.0/pixelSize;
fade*=pixelSize/1.0;
}

vec3 pos;
vec3 dir;
vel=normalize(vel);
vec3 eyeOnVelVecPlane=-((dot(eyeVec,vel))*vel);
vec3 projectedVelVec=normalize(vel-eyeOnVelVecPlane);
vec3 sideVec=normalize(cross(projectedVelVec,eyeVec));
vec2 trans=2.0*vec2((typed_mod(corner_id,2)),(corner_id/2))-vec2(1.0,1.0);
dir=normalize(normalize(eyeVec)+trans.x*sideVec+trans.y*vel);
pos=position0.xyz+trans.x*(sideVec*width)+trans.y*(vel*height);
float distM=length(position0.xyz);
p.position=mul(worldViewProj[1],vec4(pos,1.0));
p.clip_pos=p.position;
p.dir=dir;
p.strength=fade*saturate((distM-minDistanceM)/0.05);
p.light=eyeVec;
p.betaMie=0.0;
p.texCoords=trans;
p.type=typed_mod(p.type,maxtype);
if(rainMaskEnabled&&in_depth_space.x>0.0&&in_depth_space.y>0.0&&in_depth_space.x<1.0&&in_depth_space.y<1.0)
{
if(in_depth_space.z>depth)
{
p.type=44;
}

}

return p;
}
layout(location = 0) out Block
{
ParticleGeometryOutput BlockData;
} ioblock;
void main()
{
uint vertex_id=gl_VertexID;
#line 646 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
{
ioblock.BlockData=VS_RainParticles(vertex_id,false,true);
gl_Position=VS_RainParticles(vertex_id,false,true).position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/rain_VS_RainParticles_NoMask_MSAA_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 10) uniform RainConstants
{
	mat4 rainMapMatrix;
	mat4 cubemapTransform;
	vec4 lightColour;
	vec3 lightDir;
	float particleWidth;
	vec3 meanFallVelocity;
	float intensity;
	float flurry;
	float flurryRate;
	float phase0;
	float phase1;
	float timeStepSeconds;
	float particleZoneSize;
	vec2 padding;
};
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 8) uniform RainPerViewConstants
{
	mat4 worldViewProj[2];
	mat4 worldView[2];
	mat4 rainDepthTransform;
	vec4 tanHalfFov;
	vec4 viewPos[2];
	vec4 offset[2];
	vec4 depthToLinFadeDistRain;
	vec4 depthToLinFadeDistTexture;
	vec4 viewportToTexRegionScaleBias;
	vec2 tanHalfFovUnused;
	vec2 screenSize;
	vec3 viewPositionOffset;
	float nearRainDistance;
	float rainDepthTextureScale;
	float splashDelta;
	float minDistanceM;
	float padding2;
};



#line 44 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct RandomResult
{
	uvec4 state;
	float value;
};
#line 95 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct ParticleGeometryOutput
{
	vec4 position;
	vec4 clip_pos;
	vec3 dir;
	float strength;
	vec3 light;
	float betaMie;
	vec2 texCoords;
	flat uint type;
};
layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t precipitationVolumeTexture[24];
	uint64_t rainDepthTexture[24];
	uint64_t rainDepthTextureMS[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint TausStep(uint z, int S1, int S2, int S3, uint m)
{
uint b=(((z<<S1)^z)>>S2);
return (((z&m)<<S3)^b);
}
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint LCGStep(uint z, uint A, uint C)
{
return (A*z+C);
}
#line 57 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
RandomResult Random(uvec4 state)
{
state.x=TausStep(state.x,13,19,12,0xfffffffe);
state.y=TausStep(state.y,2,25,4,0xfffffff8);
state.z=TausStep(state.z,3,11,17,0xfffffff0);
state.w=LCGStep(state.w,1664525,uint(1013904223));
RandomResult result;
result.state=state;
result.value=2.3283064365387e-10*float(state.x^state.y^state.z^state.w);
return result;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
vec3 WrapParticleZone(vec3 pos, float zoneSize)
{
const vec3 c=vec3(0.5,0.5,0.5);
vec3 box=pos/(2.0*zoneSize)+c;
pos=(fract(box)-c)*2.0*zoneSize;
return pos;
}
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
float ms_depth(vec2 depth_texc)
{
uvec2 texsize;
uint numberOfSamples;
ivec2 ivrainDepthTextureMS = textureSize(sampler2DMS(rainDepthTextureMS[0]));
texsize.x = ivrainDepthTextureMS.x;texsize.y = ivrainDepthTextureMS.y;;
ivec2 pos=ivec2(depth_texc*vec2(texsize));
float depth=texelFetch(sampler2DMS(rainDepthTextureMS[0]),ivec2(pos),int(0)).x;
return depth;
}
#line 421 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
ParticleGeometryOutput VS_RainParticles(uint vertex_id, bool rainMaskEnabled, bool msaa)
{
uint particle_id=vertex_id/6;
uint vertex_index=vertex_id-(particle_id*6);
#line 427 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

ParticleGeometryOutput p;
uvec4 state=uvec4(163+typed_mod(particle_id,71),83117+particle_id/51,195+particle_id/1001,9019+typed_mod(particle_id,507));
RandomResult r1=Random(state);
RandomResult r2=Random(r1.state);
RandomResult r3=Random(r2.state);
RandomResult r4=Random(r3.state);
RandomResult r5=Random(r4.state);
RandomResult r6=Random(r5.state);
vec3 p_pos=2.0*vec3(r4.value,r2.value,r3.value);
p_pos-=vec3(1.0,1.0,1.0);
p.type=typed_mod(particle_id,uint(32));
vec3 x=vec3(r5.value-0.5,r2.value-0.5,r1.value-0.5);
vec3 y=vec3(r4.value-0.5,r6.value-0.5,r3.value-0.5);
float time0=3.1415926536*70.0*(phase0+r6.value);
float time1=3.1415926536*70.0*(phase1+r6.value);
vec3 position0;
vec3 position1;
vec3 flurry_offset0=0.5*(x*sin(time0)+y*cos(time0));
vec3 flurry_offset1=0.5*(x*sin(time1)+y*cos(time1));
vec3 position=vec3(p_pos)*particleZoneSize-offset[0].xyz;
position=WrapParticleZone(position,particleZoneSize/2);
position0=position+flurry*flurry_offset0;
position0=WrapParticleZone(position0,particleZoneSize/2);
if(timeStepSeconds==0.0)position1=position-vec3(0,0,abs(viewPositionOffset.z))+flurry*flurry_offset1;else
position1=position-viewPositionOffset.xyz+flurry*flurry_offset1;
vec3 map_texc=mul(rainMapMatrix,vec4(viewPos[1].xyz,1.0)).xyz;
#line 460 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

map_texc.y=1.0-map_texc.y;
#line 463 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

float mapped_rain=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).x,0.25);
float cloudBaseAndDensity=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).y,0.25);
mapped_rain=(mapped_rain*4*cloudBaseAndDensity);
vec3 in_depth_space=vec3(1.0,1.0,1.0);
float depth=1.0;
if(rainMaskEnabled)
{
in_depth_space=0.5*mul(rainDepthTransform,vec4(position0.xyz+viewPos[1].xyz,1.0)).xyz+vec3(0.5,0.5,0.0);
if(msaa)
{
float temp_depth=ms_depth(vec2(in_depth_space.x,in_depth_space.y));
depth=temp_depth*rainDepthTextureScale*0.5;
}
else

{
depth=textureLod(sampler2D(rainDepthTexture[1 + 9]),vec2(in_depth_space.x,in_depth_space.y),0).x*rainDepthTextureScale*0.5;
}

}

int maxtype=int(16.0*mapped_rain);
vec3 vel=(position1-position0);
float fade=saturate(4.0*mapped_rain);
float w=particleWidth;
uint corner_id=typed_mod((vertex_index+uint(vertex_index==2)-1*uint(vertex_index>2)),4);
vec3 eyeVec=normalize(-position0.xyz);
vec3 v1=cross(eyeVec,vec3(0,0,1));
vec3 v2=cross(eyeVec,vec3(0,1,0));
float width=w*fade;
float height=w+length(vel);
float dist=length(position0.xyz);
fade*=max(.05,saturate(2.0*width/height));
float pixelSize=width*500.0/dist;
if(pixelSize<1.0)
{
width*=1.0/pixelSize;
fade*=pixelSize/1.0;
}

vec3 pos;
vec3 dir;
vel=normalize(vel);
vec3 eyeOnVelVecPlane=-((dot(eyeVec,vel))*vel);
vec3 projectedVelVec=normalize(vel-eyeOnVelVecPlane);
vec3 sideVec=normalize(cross(projectedVelVec,eyeVec));
vec2 trans=2.0*vec2((typed_mod(corner_id,2)),(corner_id/2))-vec2(1.0,1.0);
dir=normalize(normalize(eyeVec)+trans.x*sideVec+trans.y*vel);
pos=position0.xyz+trans.x*(sideVec*width)+trans.y*(vel*height);
float distM=length(position0.xyz);
p.position=mul(worldViewProj[1],vec4(pos,1.0));
p.clip_pos=p.position;
p.dir=dir;
p.strength=fade*saturate((distM-minDistanceM)/0.05);
p.light=eyeVec;
p.betaMie=0.0;
p.texCoords=trans;
p.type=typed_mod(p.type,maxtype);
if(rainMaskEnabled&&in_depth_space.x>0.0&&in_depth_space.y>0.0&&in_depth_space.x<1.0&&in_depth_space.y<1.0)
{
if(in_depth_space.z>depth)
{
p.type=44;
}

}

return p;
}
layout(location = 0) out Block
{
ParticleGeometryOutput BlockData;
} ioblock;
void main()
{
uint vertex_id=gl_VertexID;
#line 646 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
{
ioblock.BlockData=VS_RainParticles(vertex_id,false,true);
gl_Position=VS_RainParticles(vertex_id,false,true).position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/rain_VS_SnowParticles_Mask_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 10) uniform RainConstants
{
	mat4 rainMapMatrix;
	mat4 cubemapTransform;
	vec4 lightColour;
	vec3 lightDir;
	float particleWidth;
	vec3 meanFallVelocity;
	float intensity;
	float flurry;
	float flurryRate;
	float phase0;
	float phase1;
	float timeStepSeconds;
	float particleZoneSize;
	vec2 padding;
};
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 8) uniform RainPerViewConstants
{
	mat4 worldViewProj[2];
	mat4 worldView[2];
	mat4 rainDepthTransform;
	vec4 tanHalfFov;
	vec4 viewPos[2];
	vec4 offset[2];
	vec4 depthToLinFadeDistRain;
	vec4 depthToLinFadeDistTexture;
	vec4 viewportToTexRegionScaleBias;
	vec2 tanHalfFovUnused;
	vec2 screenSize;
	vec3 viewPositionOffset;
	float nearRainDistance;
	float rainDepthTextureScale;
	float splashDelta;
	float minDistanceM;
	float padding2;
};




#line 44 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct RandomResult
{
	uvec4 state;
	float value;
};
#line 95 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct ParticleGeometryOutput
{
	vec4 position;
	vec4 clip_pos;
	vec3 dir;
	float strength;
	vec3 light;
	float betaMie;
	vec2 texCoords;
	flat uint type;
};
layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t precipitationVolumeTexture[24];
	uint64_t cubeTexture[24];
	uint64_t rainDepthTexture[24];
	uint64_t rainDepthTextureMS[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float HenyeyGreenstein(float g, float cos0)
{
float g2=g*g;
float u=1.0+g2-2.0*g*cos0;
return (1.0-g2)*pow(u,-1.5)/(4.0*3.1415926536);
}
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint TausStep(uint z, int S1, int S2, int S3, uint m)
{
uint b=(((z<<S1)^z)>>S2);
return (((z&m)<<S3)^b);
}
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint LCGStep(uint z, uint A, uint C)
{
return (A*z+C);
}
#line 57 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
RandomResult Random(uvec4 state)
{
state.x=TausStep(state.x,13,19,12,0xfffffffe);
state.y=TausStep(state.y,2,25,4,0xfffffff8);
state.z=TausStep(state.z,3,11,17,0xfffffff0);
state.w=LCGStep(state.w,1664525,uint(1013904223));
RandomResult result;
result.state=state;
result.value=2.3283064365387e-10*float(state.x^state.y^state.z^state.w);
return result;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
vec3 WrapParticleZone(vec3 pos, float zoneSize)
{
const vec3 c=vec3(0.5,0.5,0.5);
vec3 box=pos/(2.0*zoneSize)+c;
pos=(fract(box)-c)*2.0*zoneSize;
return pos;
}
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
float ms_depth(vec2 depth_texc)
{
uvec2 texsize;
uint numberOfSamples;
ivec2 ivrainDepthTextureMS = textureSize(sampler2DMS(rainDepthTextureMS[0]));
texsize.x = ivrainDepthTextureMS.x;texsize.y = ivrainDepthTextureMS.y;;
ivec2 pos=ivec2(depth_texc*vec2(texsize));
float depth=texelFetch(sampler2DMS(rainDepthTextureMS[0]),ivec2(pos),int(0)).x;
return depth;
}
#line 228 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
ParticleGeometryOutput VS_SnowParticles(uint vertex_id, bool rainMaskEnabled, bool msaa)
{
uint particle_id=vertex_id/6;
uint vertex_index=vertex_id-(particle_id*6);
#line 217 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

ParticleGeometryOutput p;
uvec4 state=uvec4(63+typed_mod(particle_id,71),83117+particle_id/51,195+particle_id/1001,9019+typed_mod(particle_id,507));
RandomResult r1=Random(state);
RandomResult r2=Random(r1.state);
RandomResult r3=Random(r2.state);
RandomResult r4=Random(r3.state);
RandomResult r5=Random(r4.state);
RandomResult r6=Random(r5.state);
vec3 p_pos=2.0*vec3(r4.value,r2.value,r3.value);
p_pos-=vec3(1.0,1.0,1.0);
p.type=typed_mod(particle_id,uint(32));
#line 233 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

vec3 x=vec3(r5.value-0.5,r2.value-0.5,r1.value-0.5);
vec3 y=vec3(r4.value-0.5,r6.value-0.5,r3.value-0.5);
float time0=3.1415926536*70.0*(phase0+r6.value);
float time1=3.1415926536*70.0*(phase1+r6.value);
vec3 flurry_offset0=0.5*(x*sin(time0)+y*cos(time0));
vec3 flurry_offset1=0.5*(x*sin(time1)+y*cos(time1));
vec3 position=vec3(p_pos)*particleZoneSize-offset[0].xyz;
position=WrapParticleZone(position,particleZoneSize/2);
vec3 position0=position+flurry*flurry_offset0;
vec3 position1;
if(timeStepSeconds==0.0)position1=position-vec3(0,0,abs(viewPositionOffset.z))+flurry*flurry_offset1;else
position1=position-viewPositionOffset.xyz+flurry*flurry_offset1;
vec3 map_texc=mul(rainMapMatrix,vec4(viewPos[1].xyz,1.0)).xyz;
#line 252 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

map_texc.y=1.0-map_texc.y;
#line 255 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

float mapped_rain=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).x,0.25);
float cloudBaseAndDensity=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).y,0.25);
mapped_rain=(mapped_rain*4*cloudBaseAndDensity);
vec3 in_depth_space=vec3(1.0,1.0,1.0);
float depth=1.0;
if(rainMaskEnabled)
{
in_depth_space=0.5*mul(rainDepthTransform,vec4(position0.xyz+viewPos[1].xyz,1.0)).xyz+vec3(0.5,0.5,0.0);
if(msaa)
{
depth=ms_depth(vec2(in_depth_space.x,in_depth_space.y))*rainDepthTextureScale*0.5;
}
else

{
depth=textureLod(sampler2D(rainDepthTexture[1 + 9]),vec2(in_depth_space.x,in_depth_space.y),0).x*rainDepthTextureScale*0.5;
}

}

int maxtype=int(16.0*mapped_rain);
p.type=typed_mod(p.type,maxtype);
p.strength=saturate(4.0*mapped_rain);
if(in_depth_space.x>0&&in_depth_space.y>0&&in_depth_space.x<1.0&&in_depth_space.y<1.0&&depth>in_depth_space.z)
{

}

vec3 pos;
vec3 vel=position1-position0;
float fade=p.strength;
float w=particleWidth;
vec3 dir;
uint corner_id=typed_mod((vertex_index+uint(vertex_index==2)-1*uint(vertex_index>2)),4);

{
vec3 eyeVec=normalize(-position0.xyz);
float width=w*fade;
vec3 v1=cross(eyeVec,vec3(0,0,1));
vec3 v2=cross(eyeVec,vec3(0,1,0));
vel=vel+0.000001*vec3(0,0,1);
float height=w+0.5*length(vel);
float dist=length(position0.xyz);
fade*=max(.025,saturate(1.0*width/height));
float pixelSize=width*500.0/dist;
if(pixelSize<1.0)
{
width*=1.0/pixelSize;
fade*=pixelSize/1.0;
}

vel=normalize(vel);
vec3 eyeOnVelVecPlane=-((dot(eyeVec,vel))*vel);
vec3 projectedVelVec=normalize(vel-eyeOnVelVecPlane);
vec3 sideVec=normalize(cross(projectedVelVec,eyeVec));
vec2 trans=2.0*vec2((typed_mod(corner_id,2)),(corner_id/2))-vec2(1.0,1.0);
p.texCoords=trans;
dir=normalize(normalize(eyeVec)+trans.x*sideVec+trans.y*vel);
pos=position0.xyz+trans.x*(sideVec*width)+trans.y*(vel*height);
pos=position0.xyz+trans.x*(sideVec*width)+trans.y*(vel*height);
}

p.strength=fade;
float distM=length(position0.xyz);
p.strength*=saturate((distM-minDistanceM)/0.05);
p.position=mul(worldViewProj[1],vec4(pos,1.0));
p.clip_pos=p.position;
p.dir=dir;
p.betaMie=HenyeyGreenstein(0.5,dot(dir,lightDir));
p.light=textureLod(samplerCube(cubeTexture[1 + 6]),mul(cubemapTransform,vec4(-dir.xyz,0)).xyz,0).rgb;
#line 343 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

return p;
}
layout(location = 0) out Block
{
ParticleGeometryOutput BlockData;
} ioblock;
void main()
{
uint vertex_id=gl_VertexID;
#line 406 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
{
ioblock.BlockData=VS_SnowParticles(vertex_id,true,false);
gl_Position=VS_SnowParticles(vertex_id,true,false).position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/rain_VS_SnowParticles_Mask_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 10) uniform RainConstants
{
	mat4 rainMapMatrix;
	mat4 cubemapTransform;
	vec4 lightColour;
	vec3 lightDir;
	float particleWidth;
	vec3 meanFallVelocity;
	float intensity;
	float flurry;
	float flurryRate;
	float phase0;
	float phase1;
	float timeStepSeconds;
	float particleZoneSize;
	vec2 padding;
};
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 8) uniform RainPerViewConstants
{
	mat4 worldViewProj[2];
	mat4 worldView[2];
	mat4 rainDepthTransform;
	vec4 tanHalfFov;
	vec4 viewPos[2];
	vec4 offset[2];
	vec4 depthToLinFadeDistRain;
	vec4 depthToLinFadeDistTexture;
	vec4 viewportToTexRegionScaleBias;
	vec2 tanHalfFovUnused;
	vec2 screenSize;
	vec3 viewPositionOffset;
	float nearRainDistance;
	float rainDepthTextureScale;
	float splashDelta;
	float minDistanceM;
	float padding2;
};




#line 44 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct RandomResult
{
	uvec4 state;
	float value;
};
#line 95 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct ParticleGeometryOutput
{
	vec4 position;
	vec4 clip_pos;
	vec3 dir;
	float strength;
	vec3 light;
	float betaMie;
	vec2 texCoords;
	flat uint type;
};
layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t precipitationVolumeTexture[24];
	uint64_t cubeTexture[24];
	uint64_t rainDepthTexture[24];
	uint64_t rainDepthTextureMS[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float HenyeyGreenstein(float g, float cos0)
{
float g2=g*g;
float u=1.0+g2-2.0*g*cos0;
return (1.0-g2)*pow(u,-1.5)/(4.0*3.1415926536);
}
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint TausStep(uint z, int S1, int S2, int S3, uint m)
{
uint b=(((z<<S1)^z)>>S2);
return (((z&m)<<S3)^b);
}
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint LCGStep(uint z, uint A, uint C)
{
return (A*z+C);
}
#line 57 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
RandomResult Random(uvec4 state)
{
state.x=TausStep(state.x,13,19,12,0xfffffffe);
state.y=TausStep(state.y,2,25,4,0xfffffff8);
state.z=TausStep(state.z,3,11,17,0xfffffff0);
state.w=LCGStep(state.w,1664525,uint(1013904223));
RandomResult result;
result.state=state;
result.value=2.3283064365387e-10*float(state.x^state.y^state.z^state.w);
return result;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
vec3 WrapParticleZone(vec3 pos, float zoneSize)
{
const vec3 c=vec3(0.5,0.5,0.5);
vec3 box=pos/(2.0*zoneSize)+c;
pos=(fract(box)-c)*2.0*zoneSize;
return pos;
}
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
float ms_depth(vec2 depth_texc)
{
uvec2 texsize;
uint numberOfSamples;
ivec2 ivrainDepthTextureMS = textureSize(sampler2DMS(rainDepthTextureMS[0]));
texsize.x = ivrainDepthTextureMS.x;texsize.y = ivrainDepthTextureMS.y;;
ivec2 pos=ivec2(depth_texc*vec2(texsize));
float depth=texelFetch(sampler2DMS(rainDepthTextureMS[0]),ivec2(pos),int(0)).x;
return depth;
}
#line 228 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
ParticleGeometryOutput VS_SnowParticles(uint vertex_id, bool rainMaskEnabled, bool msaa)
{
uint particle_id=vertex_id/6;
uint vertex_index=vertex_id-(particle_id*6);
#line 217 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

ParticleGeometryOutput p;
uvec4 state=uvec4(63+typed_mod(particle_id,71),83117+particle_id/51,195+particle_id/1001,9019+typed_mod(particle_id,507));
RandomResult r1=Random(state);
RandomResult r2=Random(r1.state);
RandomResult r3=Random(r2.state);
RandomResult r4=Random(r3.state);
RandomResult r5=Random(r4.state);
RandomResult r6=Random(r5.state);
vec3 p_pos=2.0*vec3(r4.value,r2.value,r3.value);
p_pos-=vec3(1.0,1.0,1.0);
p.type=typed_mod(particle_id,uint(32));
#line 233 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

vec3 x=vec3(r5.value-0.5,r2.value-0.5,r1.value-0.5);
vec3 y=vec3(r4.value-0.5,r6.value-0.5,r3.value-0.5);
float time0=3.1415926536*70.0*(phase0+r6.value);
float time1=3.1415926536*70.0*(phase1+r6.value);
vec3 flurry_offset0=0.5*(x*sin(time0)+y*cos(time0));
vec3 flurry_offset1=0.5*(x*sin(time1)+y*cos(time1));
vec3 position=vec3(p_pos)*particleZoneSize-offset[0].xyz;
position=WrapParticleZone(position,particleZoneSize/2);
vec3 position0=position+flurry*flurry_offset0;
vec3 position1;
if(timeStepSeconds==0.0)position1=position-vec3(0,0,abs(viewPositionOffset.z))+flurry*flurry_offset1;else
position1=position-viewPositionOffset.xyz+flurry*flurry_offset1;
vec3 map_texc=mul(rainMapMatrix,vec4(viewPos[1].xyz,1.0)).xyz;
#line 252 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

map_texc.y=1.0-map_texc.y;
#line 255 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

float mapped_rain=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).x,0.25);
float cloudBaseAndDensity=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).y,0.25);
mapped_rain=(mapped_rain*4*cloudBaseAndDensity);
vec3 in_depth_space=vec3(1.0,1.0,1.0);
float depth=1.0;
if(rainMaskEnabled)
{
in_depth_space=0.5*mul(rainDepthTransform,vec4(position0.xyz+viewPos[1].xyz,1.0)).xyz+vec3(0.5,0.5,0.0);
if(msaa)
{
depth=ms_depth(vec2(in_depth_space.x,in_depth_space.y))*rainDepthTextureScale*0.5;
}
else

{
depth=textureLod(sampler2D(rainDepthTexture[1 + 9]),vec2(in_depth_space.x,in_depth_space.y),0).x*rainDepthTextureScale*0.5;
}

}

int maxtype=int(16.0*mapped_rain);
p.type=typed_mod(p.type,maxtype);
p.strength=saturate(4.0*mapped_rain);
if(in_depth_space.x>0&&in_depth_space.y>0&&in_depth_space.x<1.0&&in_depth_space.y<1.0&&depth>in_depth_space.z)
{

}

vec3 pos;
vec3 vel=position1-position0;
float fade=p.strength;
float w=particleWidth;
vec3 dir;
uint corner_id=typed_mod((vertex_index+uint(vertex_index==2)-1*uint(vertex_index>2)),4);

{
vec3 eyeVec=normalize(-position0.xyz);
float width=w*fade;
vec3 v1=cross(eyeVec,vec3(0,0,1));
vec3 v2=cross(eyeVec,vec3(0,1,0));
vel=vel+0.000001*vec3(0,0,1);
float height=w+0.5*length(vel);
float dist=length(position0.xyz);
fade*=max(.025,saturate(1.0*width/height));
float pixelSize=width*500.0/dist;
if(pixelSize<1.0)
{
width*=1.0/pixelSize;
fade*=pixelSize/1.0;
}

vel=normalize(vel);
vec3 eyeOnVelVecPlane=-((dot(eyeVec,vel))*vel);
vec3 projectedVelVec=normalize(vel-eyeOnVelVecPlane);
vec3 sideVec=normalize(cross(projectedVelVec,eyeVec));
vec2 trans=2.0*vec2((typed_mod(corner_id,2)),(corner_id/2))-vec2(1.0,1.0);
p.texCoords=trans;
dir=normalize(normalize(eyeVec)+trans.x*sideVec+trans.y*vel);
pos=position0.xyz+trans.x*(sideVec*width)+trans.y*(vel*height);
pos=position0.xyz+trans.x*(sideVec*width)+trans.y*(vel*height);
}

p.strength=fade;
float distM=length(position0.xyz);
p.strength*=saturate((distM-minDistanceM)/0.05);
p.position=mul(worldViewProj[1],vec4(pos,1.0));
p.clip_pos=p.position;
p.dir=dir;
p.betaMie=HenyeyGreenstein(0.5,dot(dir,lightDir));
p.light=textureLod(samplerCube(cubeTexture[1 + 6]),mul(cubemapTransform,vec4(-dir.xyz,0)).xyz,0).rgb;
#line 343 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

return p;
}
layout(location = 0) out Block
{
ParticleGeometryOutput BlockData;
} ioblock;
void main()
{
uint vertex_id=gl_VertexID;
#line 406 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
{
ioblock.BlockData=VS_SnowParticles(vertex_id,true,false);
gl_Position=VS_SnowParticles(vertex_id,true,false).position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/rain_VS_SnowParticles_Mask_MSAA_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 10) uniform RainConstants
{
	mat4 rainMapMatrix;
	mat4 cubemapTransform;
	vec4 lightColour;
	vec3 lightDir;
	float particleWidth;
	vec3 meanFallVelocity;
	float intensity;
	float flurry;
	float flurryRate;
	float phase0;
	float phase1;
	float timeStepSeconds;
	float particleZoneSize;
	vec2 padding;
};
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 8) uniform RainPerViewConstants
{
	mat4 worldViewProj[2];
	mat4 worldView[2];
	mat4 rainDepthTransform;
	vec4 tanHalfFov;
	vec4 viewPos[2];
	vec4 offset[2];
	vec4 depthToLinFadeDistRain;
	vec4 depthToLinFadeDistTexture;
	vec4 viewportToTexRegionScaleBias;
	vec2 tanHalfFovUnused;
	vec2 screenSize;
	vec3 viewPositionOffset;
	float nearRainDistance;
	float rainDepthTextureScale;
	float splashDelta;
	float minDistanceM;
	float padding2;
};




#line 44 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct RandomResult
{
	uvec4 state;
	float value;
};
#line 95 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct ParticleGeometryOutput
{
	vec4 position;
	vec4 clip_pos;
	vec3 dir;
	float strength;
	vec3 light;
	float betaMie;
	vec2 texCoords;
	flat uint type;
};
layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t precipitationVolumeTexture[24];
	uint64_t cubeTexture[24];
	uint64_t rainDepthTexture[24];
	uint64_t rainDepthTextureMS[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float HenyeyGreenstein(float g, float cos0)
{
float g2=g*g;
float u=1.0+g2-2.0*g*cos0;
return (1.0-g2)*pow(u,-1.5)/(4.0*3.1415926536);
}
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint TausStep(uint z, int S1, int S2, int S3, uint m)
{
uint b=(((z<<S1)^z)>>S2);
return (((z&m)<<S3)^b);
}
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint LCGStep(uint z, uint A, uint C)
{
return (A*z+C);
}
#line 57 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
RandomResult Random(uvec4 state)
{
state.x=TausStep(state.x,13,19,12,0xfffffffe);
state.y=TausStep(state.y,2,25,4,0xfffffff8);
state.z=TausStep(state.z,3,11,17,0xfffffff0);
state.w=LCGStep(state.w,1664525,uint(1013904223));
RandomResult result;
result.state=state;
result.value=2.3283064365387e-10*float(state.x^state.y^state.z^state.w);
return result;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
vec3 WrapParticleZone(vec3 pos, float zoneSize)
{
const vec3 c=vec3(0.5,0.5,0.5);
vec3 box=pos/(2.0*zoneSize)+c;
pos=(fract(box)-c)*2.0*zoneSize;
return pos;
}
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
float ms_depth(vec2 depth_texc)
{
uvec2 texsize;
uint numberOfSamples;
ivec2 ivrainDepthTextureMS = textureSize(sampler2DMS(rainDepthTextureMS[0]));
texsize.x = ivrainDepthTextureMS.x;texsize.y = ivrainDepthTextureMS.y;;
ivec2 pos=ivec2(depth_texc*vec2(texsize));
float depth=texelFetch(sampler2DMS(rainDepthTextureMS[0]),ivec2(pos),int(0)).x;
return depth;
}
#line 228 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
ParticleGeometryOutput VS_SnowParticles(uint vertex_id, bool rainMaskEnabled, bool msaa)
{
uint particle_id=vertex_id/6;
uint vertex_index=vertex_id-(particle_id*6);
#line 217 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

ParticleGeometryOutput p;
uvec4 state=uvec4(63+typed_mod(particle_id,71),83117+particle_id/51,195+particle_id/1001,9019+typed_mod(particle_id,507));
RandomResult r1=Random(state);
RandomResult r2=Random(r1.state);
RandomResult r3=Random(r2.state);
RandomResult r4=Random(r3.state);
RandomResult r5=Random(r4.state);
RandomResult r6=Random(r5.state);
vec3 p_pos=2.0*vec3(r4.value,r2.value,r3.value);
p_pos-=vec3(1.0,1.0,1.0);
p.type=typed_mod(particle_id,uint(32));
#line 233 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

vec3 x=vec3(r5.value-0.5,r2.value-0.5,r1.value-0.5);
vec3 y=vec3(r4.value-0.5,r6.value-0.5,r3.value-0.5);
float time0=3.1415926536*70.0*(phase0+r6.value);
float time1=3.1415926536*70.0*(phase1+r6.value);
vec3 flurry_offset0=0.5*(x*sin(time0)+y*cos(time0));
vec3 flurry_offset1=0.5*(x*sin(time1)+y*cos(time1));
vec3 position=vec3(p_pos)*particleZoneSize-offset[0].xyz;
position=WrapParticleZone(position,particleZoneSize/2);
vec3 position0=position+flurry*flurry_offset0;
vec3 position1;
if(timeStepSeconds==0.0)position1=position-vec3(0,0,abs(viewPositionOffset.z))+flurry*flurry_offset1;else
position1=position-viewPositionOffset.xyz+flurry*flurry_offset1;
vec3 map_texc=mul(rainMapMatrix,vec4(viewPos[1].xyz,1.0)).xyz;
#line 252 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

map_texc.y=1.0-map_texc.y;
#line 255 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

float mapped_rain=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).x,0.25);
float cloudBaseAndDensity=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).y,0.25);
mapped_rain=(mapped_rain*4*cloudBaseAndDensity);
vec3 in_depth_space=vec3(1.0,1.0,1.0);
float depth=1.0;
if(rainMaskEnabled)
{
in_depth_space=0.5*mul(rainDepthTransform,vec4(position0.xyz+viewPos[1].xyz,1.0)).xyz+vec3(0.5,0.5,0.0);
if(msaa)
{
depth=ms_depth(vec2(in_depth_space.x,in_depth_space.y))*rainDepthTextureScale*0.5;
}
else

{
depth=textureLod(sampler2D(rainDepthTexture[1 + 9]),vec2(in_depth_space.x,in_depth_space.y),0).x*rainDepthTextureScale*0.5;
}

}

int maxtype=int(16.0*mapped_rain);
p.type=typed_mod(p.type,maxtype);
p.strength=saturate(4.0*mapped_rain);
if(in_depth_space.x>0&&in_depth_space.y>0&&in_depth_space.x<1.0&&in_depth_space.y<1.0&&depth>in_depth_space.z)
{

}

vec3 pos;
vec3 vel=position1-position0;
float fade=p.strength;
float w=particleWidth;
vec3 dir;
uint corner_id=typed_mod((vertex_index+uint(vertex_index==2)-1*uint(vertex_index>2)),4);

{
vec3 eyeVec=normalize(-position0.xyz);
float width=w*fade;
vec3 v1=cross(eyeVec,vec3(0,0,1));
vec3 v2=cross(eyeVec,vec3(0,1,0));
vel=vel+0.000001*vec3(0,0,1);
float height=w+0.5*length(vel);
float dist=length(position0.xyz);
fade*=max(.025,saturate(1.0*width/height));
float pixelSize=width*500.0/dist;
if(pixelSize<1.0)
{
width*=1.0/pixelSize;
fade*=pixelSize/1.0;
}

vel=normalize(vel);
vec3 eyeOnVelVecPlane=-((dot(eyeVec,vel))*vel);
vec3 projectedVelVec=normalize(vel-eyeOnVelVecPlane);
vec3 sideVec=normalize(cross(projectedVelVec,eyeVec));
vec2 trans=2.0*vec2((typed_mod(corner_id,2)),(corner_id/2))-vec2(1.0,1.0);
p.texCoords=trans;
dir=normalize(normalize(eyeVec)+trans.x*sideVec+trans.y*vel);
pos=position0.xyz+trans.x*(sideVec*width)+trans.y*(vel*height);
pos=position0.xyz+trans.x*(sideVec*width)+trans.y*(vel*height);
}

p.strength=fade;
float distM=length(position0.xyz);
p.strength*=saturate((distM-minDistanceM)/0.05);
p.position=mul(worldViewProj[1],vec4(pos,1.0));
p.clip_pos=p.position;
p.dir=dir;
p.betaMie=HenyeyGreenstein(0.5,dot(dir,lightDir));
p.light=textureLod(samplerCube(cubeTexture[1 + 6]),mul(cubemapTransform,vec4(-dir.xyz,0)).xyz,0).rgb;
#line 343 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

return p;
}
layout(location = 0) out Block
{
ParticleGeometryOutput BlockData;
} ioblock;
void main()
{
uint vertex_id=gl_VertexID;
#line 415 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
{
ioblock.BlockData=VS_SnowParticles(vertex_id,true,true);
gl_Position=VS_SnowParticles(vertex_id,true,true).position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/rain_VS_SnowParticles_Mask_MSAA_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 10) uniform RainConstants
{
	mat4 rainMapMatrix;
	mat4 cubemapTransform;
	vec4 lightColour;
	vec3 lightDir;
	float particleWidth;
	vec3 meanFallVelocity;
	float intensity;
	float flurry;
	float flurryRate;
	float phase0;
	float phase1;
	float timeStepSeconds;
	float particleZoneSize;
	vec2 padding;
};
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 8) uniform RainPerViewConstants
{
	mat4 worldViewProj[2];
	mat4 worldView[2];
	mat4 rainDepthTransform;
	vec4 tanHalfFov;
	vec4 viewPos[2];
	vec4 offset[2];
	vec4 depthToLinFadeDistRain;
	vec4 depthToLinFadeDistTexture;
	vec4 viewportToTexRegionScaleBias;
	vec2 tanHalfFovUnused;
	vec2 screenSize;
	vec3 viewPositionOffset;
	float nearRainDistance;
	float rainDepthTextureScale;
	float splashDelta;
	float minDistanceM;
	float padding2;
};




#line 44 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct RandomResult
{
	uvec4 state;
	float value;
};
#line 95 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct ParticleGeometryOutput
{
	vec4 position;
	vec4 clip_pos;
	vec3 dir;
	float strength;
	vec3 light;
	float betaMie;
	vec2 texCoords;
	flat uint type;
};
layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t precipitationVolumeTexture[24];
	uint64_t cubeTexture[24];
	uint64_t rainDepthTexture[24];
	uint64_t rainDepthTextureMS[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float HenyeyGreenstein(float g, float cos0)
{
float g2=g*g;
float u=1.0+g2-2.0*g*cos0;
return (1.0-g2)*pow(u,-1.5)/(4.0*3.1415926536);
}
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint TausStep(uint z, int S1, int S2, int S3, uint m)
{
uint b=(((z<<S1)^z)>>S2);
return (((z&m)<<S3)^b);
}
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint LCGStep(uint z, uint A, uint C)
{
return (A*z+C);
}
#line 57 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
RandomResult Random(uvec4 state)
{
state.x=TausStep(state.x,13,19,12,0xfffffffe);
state.y=TausStep(state.y,2,25,4,0xfffffff8);
state.z=TausStep(state.z,3,11,17,0xfffffff0);
state.w=LCGStep(state.w,1664525,uint(1013904223));
RandomResult result;
result.state=state;
result.value=2.3283064365387e-10*float(state.x^state.y^state.z^state.w);
return result;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
vec3 WrapParticleZone(vec3 pos, float zoneSize)
{
const vec3 c=vec3(0.5,0.5,0.5);
vec3 box=pos/(2.0*zoneSize)+c;
pos=(fract(box)-c)*2.0*zoneSize;
return pos;
}
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
float ms_depth(vec2 depth_texc)
{
uvec2 texsize;
uint numberOfSamples;
ivec2 ivrainDepthTextureMS = textureSize(sampler2DMS(rainDepthTextureMS[0]));
texsize.x = ivrainDepthTextureMS.x;texsize.y = ivrainDepthTextureMS.y;;
ivec2 pos=ivec2(depth_texc*vec2(texsize));
float depth=texelFetch(sampler2DMS(rainDepthTextureMS[0]),ivec2(pos),int(0)).x;
return depth;
}
#line 228 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
ParticleGeometryOutput VS_SnowParticles(uint vertex_id, bool rainMaskEnabled, bool msaa)
{
uint particle_id=vertex_id/6;
uint vertex_index=vertex_id-(particle_id*6);
#line 217 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

ParticleGeometryOutput p;
uvec4 state=uvec4(63+typed_mod(particle_id,71),83117+particle_id/51,195+particle_id/1001,9019+typed_mod(particle_id,507));
RandomResult r1=Random(state);
RandomResult r2=Random(r1.state);
RandomResult r3=Random(r2.state);
RandomResult r4=Random(r3.state);
RandomResult r5=Random(r4.state);
RandomResult r6=Random(r5.state);
vec3 p_pos=2.0*vec3(r4.value,r2.value,r3.value);
p_pos-=vec3(1.0,1.0,1.0);
p.type=typed_mod(particle_id,uint(32));
#line 233 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

vec3 x=vec3(r5.value-0.5,r2.value-0.5,r1.value-0.5);
vec3 y=vec3(r4.value-0.5,r6.value-0.5,r3.value-0.5);
float time0=3.1415926536*70.0*(phase0+r6.value);
float time1=3.1415926536*70.0*(phase1+r6.value);
vec3 flurry_offset0=0.5*(x*sin(time0)+y*cos(time0));
vec3 flurry_offset1=0.5*(x*sin(time1)+y*cos(time1));
vec3 position=vec3(p_pos)*particleZoneSize-offset[0].xyz;
position=WrapParticleZone(position,particleZoneSize/2);
vec3 position0=position+flurry*flurry_offset0;
vec3 position1;
if(timeStepSeconds==0.0)position1=position-vec3(0,0,abs(viewPositionOffset.z))+flurry*flurry_offset1;else
position1=position-viewPositionOffset.xyz+flurry*flurry_offset1;
vec3 map_texc=mul(rainMapMatrix,vec4(viewPos[1].xyz,1.0)).xyz;
#line 252 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

map_texc.y=1.0-map_texc.y;
#line 255 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

float mapped_rain=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).x,0.25);
float cloudBaseAndDensity=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).y,0.25);
mapped_rain=(mapped_rain*4*cloudBaseAndDensity);
vec3 in_depth_space=vec3(1.0,1.0,1.0);
float depth=1.0;
if(rainMaskEnabled)
{
in_depth_space=0.5*mul(rainDepthTransform,vec4(position0.xyz+viewPos[1].xyz,1.0)).xyz+vec3(0.5,0.5,0.0);
if(msaa)
{
depth=ms_depth(vec2(in_depth_space.x,in_depth_space.y))*rainDepthTextureScale*0.5;
}
else

{
depth=textureLod(sampler2D(rainDepthTexture[1 + 9]),vec2(in_depth_space.x,in_depth_space.y),0).x*rainDepthTextureScale*0.5;
}

}

int maxtype=int(16.0*mapped_rain);
p.type=typed_mod(p.type,maxtype);
p.strength=saturate(4.0*mapped_rain);
if(in_depth_space.x>0&&in_depth_space.y>0&&in_depth_space.x<1.0&&in_depth_space.y<1.0&&depth>in_depth_space.z)
{

}

vec3 pos;
vec3 vel=position1-position0;
float fade=p.strength;
float w=particleWidth;
vec3 dir;
uint corner_id=typed_mod((vertex_index+uint(vertex_index==2)-1*uint(vertex_index>2)),4);

{
vec3 eyeVec=normalize(-position0.xyz);
float width=w*fade;
vec3 v1=cross(eyeVec,vec3(0,0,1));
vec3 v2=cross(eyeVec,vec3(0,1,0));
vel=vel+0.000001*vec3(0,0,1);
float height=w+0.5*length(vel);
float dist=length(position0.xyz);
fade*=max(.025,saturate(1.0*width/height));
float pixelSize=width*500.0/dist;
if(pixelSize<1.0)
{
width*=1.0/pixelSize;
fade*=pixelSize/1.0;
}

vel=normalize(vel);
vec3 eyeOnVelVecPlane=-((dot(eyeVec,vel))*vel);
vec3 projectedVelVec=normalize(vel-eyeOnVelVecPlane);
vec3 sideVec=normalize(cross(projectedVelVec,eyeVec));
vec2 trans=2.0*vec2((typed_mod(corner_id,2)),(corner_id/2))-vec2(1.0,1.0);
p.texCoords=trans;
dir=normalize(normalize(eyeVec)+trans.x*sideVec+trans.y*vel);
pos=position0.xyz+trans.x*(sideVec*width)+trans.y*(vel*height);
pos=position0.xyz+trans.x*(sideVec*width)+trans.y*(vel*height);
}

p.strength=fade;
float distM=length(position0.xyz);
p.strength*=saturate((distM-minDistanceM)/0.05);
p.position=mul(worldViewProj[1],vec4(pos,1.0));
p.clip_pos=p.position;
p.dir=dir;
p.betaMie=HenyeyGreenstein(0.5,dot(dir,lightDir));
p.light=textureLod(samplerCube(cubeTexture[1 + 6]),mul(cubemapTransform,vec4(-dir.xyz,0)).xyz,0).rgb;
#line 343 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

return p;
}
layout(location = 0) out Block
{
ParticleGeometryOutput BlockData;
} ioblock;
void main()
{
uint vertex_id=gl_VertexID;
#line 415 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
{
ioblock.BlockData=VS_SnowParticles(vertex_id,true,true);
gl_Position=VS_SnowParticles(vertex_id,true,true).position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/rain_VS_SnowParticles_NoMask_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 10) uniform RainConstants
{
	mat4 rainMapMatrix;
	mat4 cubemapTransform;
	vec4 lightColour;
	vec3 lightDir;
	float particleWidth;
	vec3 meanFallVelocity;
	float intensity;
	float flurry;
	float flurryRate;
	float phase0;
	float phase1;
	float timeStepSeconds;
	float particleZoneSize;
	vec2 padding;
};
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 8) uniform RainPerViewConstants
{
	mat4 worldViewProj[2];
	mat4 worldView[2];
	mat4 rainDepthTransform;
	vec4 tanHalfFov;
	vec4 viewPos[2];
	vec4 offset[2];
	vec4 depthToLinFadeDistRain;
	vec4 depthToLinFadeDistTexture;
	vec4 viewportToTexRegionScaleBias;
	vec2 tanHalfFovUnused;
	vec2 screenSize;
	vec3 viewPositionOffset;
	float nearRainDistance;
	float rainDepthTextureScale;
	float splashDelta;
	float minDistanceM;
	float padding2;
};




#line 44 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct RandomResult
{
	uvec4 state;
	float value;
};
#line 95 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct ParticleGeometryOutput
{
	vec4 position;
	vec4 clip_pos;
	vec3 dir;
	float strength;
	vec3 light;
	float betaMie;
	vec2 texCoords;
	flat uint type;
};
layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t precipitationVolumeTexture[24];
	uint64_t cubeTexture[24];
	uint64_t rainDepthTexture[24];
	uint64_t rainDepthTextureMS[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float HenyeyGreenstein(float g, float cos0)
{
float g2=g*g;
float u=1.0+g2-2.0*g*cos0;
return (1.0-g2)*pow(u,-1.5)/(4.0*3.1415926536);
}
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint TausStep(uint z, int S1, int S2, int S3, uint m)
{
uint b=(((z<<S1)^z)>>S2);
return (((z&m)<<S3)^b);
}
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint LCGStep(uint z, uint A, uint C)
{
return (A*z+C);
}
#line 57 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
RandomResult Random(uvec4 state)
{
state.x=TausStep(state.x,13,19,12,0xfffffffe);
state.y=TausStep(state.y,2,25,4,0xfffffff8);
state.z=TausStep(state.z,3,11,17,0xfffffff0);
state.w=LCGStep(state.w,1664525,uint(1013904223));
RandomResult result;
result.state=state;
result.value=2.3283064365387e-10*float(state.x^state.y^state.z^state.w);
return result;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
vec3 WrapParticleZone(vec3 pos, float zoneSize)
{
const vec3 c=vec3(0.5,0.5,0.5);
vec3 box=pos/(2.0*zoneSize)+c;
pos=(fract(box)-c)*2.0*zoneSize;
return pos;
}
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
float ms_depth(vec2 depth_texc)
{
uvec2 texsize;
uint numberOfSamples;
ivec2 ivrainDepthTextureMS = textureSize(sampler2DMS(rainDepthTextureMS[0]));
texsize.x = ivrainDepthTextureMS.x;texsize.y = ivrainDepthTextureMS.y;;
ivec2 pos=ivec2(depth_texc*vec2(texsize));
float depth=texelFetch(sampler2DMS(rainDepthTextureMS[0]),ivec2(pos),int(0)).x;
return depth;
}
#line 228 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
ParticleGeometryOutput VS_SnowParticles(uint vertex_id, bool rainMaskEnabled, bool msaa)
{
uint particle_id=vertex_id/6;
uint vertex_index=vertex_id-(particle_id*6);
#line 217 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

ParticleGeometryOutput p;
uvec4 state=uvec4(63+typed_mod(particle_id,71),83117+particle_id/51,195+particle_id/1001,9019+typed_mod(particle_id,507));
RandomResult r1=Random(state);
RandomResult r2=Random(r1.state);
RandomResult r3=Random(r2.state);
RandomResult r4=Random(r3.state);
RandomResult r5=Random(r4.state);
RandomResult r6=Random(r5.state);
vec3 p_pos=2.0*vec3(r4.value,r2.value,r3.value);
p_pos-=vec3(1.0,1.0,1.0);
p.type=typed_mod(particle_id,uint(32));
#line 233 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

vec3 x=vec3(r5.value-0.5,r2.value-0.5,r1.value-0.5);
vec3 y=vec3(r4.value-0.5,r6.value-0.5,r3.value-0.5);
float time0=3.1415926536*70.0*(phase0+r6.value);
float time1=3.1415926536*70.0*(phase1+r6.value);
vec3 flurry_offset0=0.5*(x*sin(time0)+y*cos(time0));
vec3 flurry_offset1=0.5*(x*sin(time1)+y*cos(time1));
vec3 position=vec3(p_pos)*particleZoneSize-offset[0].xyz;
position=WrapParticleZone(position,particleZoneSize/2);
vec3 position0=position+flurry*flurry_offset0;
vec3 position1;
if(timeStepSeconds==0.0)position1=position-vec3(0,0,abs(viewPositionOffset.z))+flurry*flurry_offset1;else
position1=position-viewPositionOffset.xyz+flurry*flurry_offset1;
vec3 map_texc=mul(rainMapMatrix,vec4(viewPos[1].xyz,1.0)).xyz;
#line 252 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

map_texc.y=1.0-map_texc.y;
#line 255 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

float mapped_rain=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).x,0.25);
float cloudBaseAndDensity=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).y,0.25);
mapped_rain=(mapped_rain*4*cloudBaseAndDensity);
vec3 in_depth_space=vec3(1.0,1.0,1.0);
float depth=1.0;
if(rainMaskEnabled)
{
in_depth_space=0.5*mul(rainDepthTransform,vec4(position0.xyz+viewPos[1].xyz,1.0)).xyz+vec3(0.5,0.5,0.0);
if(msaa)
{
depth=ms_depth(vec2(in_depth_space.x,in_depth_space.y))*rainDepthTextureScale*0.5;
}
else

{
depth=textureLod(sampler2D(rainDepthTexture[1 + 9]),vec2(in_depth_space.x,in_depth_space.y),0).x*rainDepthTextureScale*0.5;
}

}

int maxtype=int(16.0*mapped_rain);
p.type=typed_mod(p.type,maxtype);
p.strength=saturate(4.0*mapped_rain);
if(in_depth_space.x>0&&in_depth_space.y>0&&in_depth_space.x<1.0&&in_depth_space.y<1.0&&depth>in_depth_space.z)
{

}

vec3 pos;
vec3 vel=position1-position0;
float fade=p.strength;
float w=particleWidth;
vec3 dir;
uint corner_id=typed_mod((vertex_index+uint(vertex_index==2)-1*uint(vertex_index>2)),4);

{
vec3 eyeVec=normalize(-position0.xyz);
float width=w*fade;
vec3 v1=cross(eyeVec,vec3(0,0,1));
vec3 v2=cross(eyeVec,vec3(0,1,0));
vel=vel+0.000001*vec3(0,0,1);
float height=w+0.5*length(vel);
float dist=length(position0.xyz);
fade*=max(.025,saturate(1.0*width/height));
float pixelSize=width*500.0/dist;
if(pixelSize<1.0)
{
width*=1.0/pixelSize;
fade*=pixelSize/1.0;
}

vel=normalize(vel);
vec3 eyeOnVelVecPlane=-((dot(eyeVec,vel))*vel);
vec3 projectedVelVec=normalize(vel-eyeOnVelVecPlane);
vec3 sideVec=normalize(cross(projectedVelVec,eyeVec));
vec2 trans=2.0*vec2((typed_mod(corner_id,2)),(corner_id/2))-vec2(1.0,1.0);
p.texCoords=trans;
dir=normalize(normalize(eyeVec)+trans.x*sideVec+trans.y*vel);
pos=position0.xyz+trans.x*(sideVec*width)+trans.y*(vel*height);
pos=position0.xyz+trans.x*(sideVec*width)+trans.y*(vel*height);
}

p.strength=fade;
float distM=length(position0.xyz);
p.strength*=saturate((distM-minDistanceM)/0.05);
p.position=mul(worldViewProj[1],vec4(pos,1.0));
p.clip_pos=p.position;
p.dir=dir;
p.betaMie=HenyeyGreenstein(0.5,dot(dir,lightDir));
p.light=textureLod(samplerCube(cubeTexture[1 + 6]),mul(cubemapTransform,vec4(-dir.xyz,0)).xyz,0).rgb;
#line 343 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

return p;
}
layout(location = 0) out Block
{
ParticleGeometryOutput BlockData;
} ioblock;
void main()
{
uint vertex_id=gl_VertexID;
#line 401 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
{
ioblock.BlockData=VS_SnowParticles(vertex_id,false,false);
gl_Position=VS_SnowParticles(vertex_id,false,false).position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/rain_VS_SnowParticles_NoMask_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 10) uniform RainConstants
{
	mat4 rainMapMatrix;
	mat4 cubemapTransform;
	vec4 lightColour;
	vec3 lightDir;
	float particleWidth;
	vec3 meanFallVelocity;
	float intensity;
	float flurry;
	float flurryRate;
	float phase0;
	float phase1;
	float timeStepSeconds;
	float particleZoneSize;
	vec2 padding;
};
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 8) uniform RainPerViewConstants
{
	mat4 worldViewProj[2];
	mat4 worldView[2];
	mat4 rainDepthTransform;
	vec4 tanHalfFov;
	vec4 viewPos[2];
	vec4 offset[2];
	vec4 depthToLinFadeDistRain;
	vec4 depthToLinFadeDistTexture;
	vec4 viewportToTexRegionScaleBias;
	vec2 tanHalfFovUnused;
	vec2 screenSize;
	vec3 viewPositionOffset;
	float nearRainDistance;
	float rainDepthTextureScale;
	float splashDelta;
	float minDistanceM;
	float padding2;
};




#line 44 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct RandomResult
{
	uvec4 state;
	float value;
};
#line 95 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct ParticleGeometryOutput
{
	vec4 position;
	vec4 clip_pos;
	vec3 dir;
	float strength;
	vec3 light;
	float betaMie;
	vec2 texCoords;
	flat uint type;
};
layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t precipitationVolumeTexture[24];
	uint64_t cubeTexture[24];
	uint64_t rainDepthTexture[24];
	uint64_t rainDepthTextureMS[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float HenyeyGreenstein(float g, float cos0)
{
float g2=g*g;
float u=1.0+g2-2.0*g*cos0;
return (1.0-g2)*pow(u,-1.5)/(4.0*3.1415926536);
}
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint TausStep(uint z, int S1, int S2, int S3, uint m)
{
uint b=(((z<<S1)^z)>>S2);
return (((z&m)<<S3)^b);
}
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint LCGStep(uint z, uint A, uint C)
{
return (A*z+C);
}
#line 57 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
RandomResult Random(uvec4 state)
{
state.x=TausStep(state.x,13,19,12,0xfffffffe);
state.y=TausStep(state.y,2,25,4,0xfffffff8);
state.z=TausStep(state.z,3,11,17,0xfffffff0);
state.w=LCGStep(state.w,1664525,uint(1013904223));
RandomResult result;
result.state=state;
result.value=2.3283064365387e-10*float(state.x^state.y^state.z^state.w);
return result;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
vec3 WrapParticleZone(vec3 pos, float zoneSize)
{
const vec3 c=vec3(0.5,0.5,0.5);
vec3 box=pos/(2.0*zoneSize)+c;
pos=(fract(box)-c)*2.0*zoneSize;
return pos;
}
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
float ms_depth(vec2 depth_texc)
{
uvec2 texsize;
uint numberOfSamples;
ivec2 ivrainDepthTextureMS = textureSize(sampler2DMS(rainDepthTextureMS[0]));
texsize.x = ivrainDepthTextureMS.x;texsize.y = ivrainDepthTextureMS.y;;
ivec2 pos=ivec2(depth_texc*vec2(texsize));
float depth=texelFetch(sampler2DMS(rainDepthTextureMS[0]),ivec2(pos),int(0)).x;
return depth;
}
#line 228 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
ParticleGeometryOutput VS_SnowParticles(uint vertex_id, bool rainMaskEnabled, bool msaa)
{
uint particle_id=vertex_id/6;
uint vertex_index=vertex_id-(particle_id*6);
#line 217 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

ParticleGeometryOutput p;
uvec4 state=uvec4(63+typed_mod(particle_id,71),83117+particle_id/51,195+particle_id/1001,9019+typed_mod(particle_id,507));
RandomResult r1=Random(state);
RandomResult r2=Random(r1.state);
RandomResult r3=Random(r2.state);
RandomResult r4=Random(r3.state);
RandomResult r5=Random(r4.state);
RandomResult r6=Random(r5.state);
vec3 p_pos=2.0*vec3(r4.value,r2.value,r3.value);
p_pos-=vec3(1.0,1.0,1.0);
p.type=typed_mod(particle_id,uint(32));
#line 233 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

vec3 x=vec3(r5.value-0.5,r2.value-0.5,r1.value-0.5);
vec3 y=vec3(r4.value-0.5,r6.value-0.5,r3.value-0.5);
float time0=3.1415926536*70.0*(phase0+r6.value);
float time1=3.1415926536*70.0*(phase1+r6.value);
vec3 flurry_offset0=0.5*(x*sin(time0)+y*cos(time0));
vec3 flurry_offset1=0.5*(x*sin(time1)+y*cos(time1));
vec3 position=vec3(p_pos)*particleZoneSize-offset[0].xyz;
position=WrapParticleZone(position,particleZoneSize/2);
vec3 position0=position+flurry*flurry_offset0;
vec3 position1;
if(timeStepSeconds==0.0)position1=position-vec3(0,0,abs(viewPositionOffset.z))+flurry*flurry_offset1;else
position1=position-viewPositionOffset.xyz+flurry*flurry_offset1;
vec3 map_texc=mul(rainMapMatrix,vec4(viewPos[1].xyz,1.0)).xyz;
#line 252 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

map_texc.y=1.0-map_texc.y;
#line 255 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

float mapped_rain=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).x,0.25);
float cloudBaseAndDensity=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).y,0.25);
mapped_rain=(mapped_rain*4*cloudBaseAndDensity);
vec3 in_depth_space=vec3(1.0,1.0,1.0);
float depth=1.0;
if(rainMaskEnabled)
{
in_depth_space=0.5*mul(rainDepthTransform,vec4(position0.xyz+viewPos[1].xyz,1.0)).xyz+vec3(0.5,0.5,0.0);
if(msaa)
{
depth=ms_depth(vec2(in_depth_space.x,in_depth_space.y))*rainDepthTextureScale*0.5;
}
else

{
depth=textureLod(sampler2D(rainDepthTexture[1 + 9]),vec2(in_depth_space.x,in_depth_space.y),0).x*rainDepthTextureScale*0.5;
}

}

int maxtype=int(16.0*mapped_rain);
p.type=typed_mod(p.type,maxtype);
p.strength=saturate(4.0*mapped_rain);
if(in_depth_space.x>0&&in_depth_space.y>0&&in_depth_space.x<1.0&&in_depth_space.y<1.0&&depth>in_depth_space.z)
{

}

vec3 pos;
vec3 vel=position1-position0;
float fade=p.strength;
float w=particleWidth;
vec3 dir;
uint corner_id=typed_mod((vertex_index+uint(vertex_index==2)-1*uint(vertex_index>2)),4);

{
vec3 eyeVec=normalize(-position0.xyz);
float width=w*fade;
vec3 v1=cross(eyeVec,vec3(0,0,1));
vec3 v2=cross(eyeVec,vec3(0,1,0));
vel=vel+0.000001*vec3(0,0,1);
float height=w+0.5*length(vel);
float dist=length(position0.xyz);
fade*=max(.025,saturate(1.0*width/height));
float pixelSize=width*500.0/dist;
if(pixelSize<1.0)
{
width*=1.0/pixelSize;
fade*=pixelSize/1.0;
}

vel=normalize(vel);
vec3 eyeOnVelVecPlane=-((dot(eyeVec,vel))*vel);
vec3 projectedVelVec=normalize(vel-eyeOnVelVecPlane);
vec3 sideVec=normalize(cross(projectedVelVec,eyeVec));
vec2 trans=2.0*vec2((typed_mod(corner_id,2)),(corner_id/2))-vec2(1.0,1.0);
p.texCoords=trans;
dir=normalize(normalize(eyeVec)+trans.x*sideVec+trans.y*vel);
pos=position0.xyz+trans.x*(sideVec*width)+trans.y*(vel*height);
pos=position0.xyz+trans.x*(sideVec*width)+trans.y*(vel*height);
}

p.strength=fade;
float distM=length(position0.xyz);
p.strength*=saturate((distM-minDistanceM)/0.05);
p.position=mul(worldViewProj[1],vec4(pos,1.0));
p.clip_pos=p.position;
p.dir=dir;
p.betaMie=HenyeyGreenstein(0.5,dot(dir,lightDir));
p.light=textureLod(samplerCube(cubeTexture[1 + 6]),mul(cubemapTransform,vec4(-dir.xyz,0)).xyz,0).rgb;
#line 343 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

return p;
}
layout(location = 0) out Block
{
ParticleGeometryOutput BlockData;
} ioblock;
void main()
{
uint vertex_id=gl_VertexID;
#line 401 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
{
ioblock.BlockData=VS_SnowParticles(vertex_id,false,false);
gl_Position=VS_SnowParticles(vertex_id,false,false).position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/rain_VS_SnowParticles_NoMask_MSAA_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 10) uniform RainConstants
{
	mat4 rainMapMatrix;
	mat4 cubemapTransform;
	vec4 lightColour;
	vec3 lightDir;
	float particleWidth;
	vec3 meanFallVelocity;
	float intensity;
	float flurry;
	float flurryRate;
	float phase0;
	float phase1;
	float timeStepSeconds;
	float particleZoneSize;
	vec2 padding;
};
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 8) uniform RainPerViewConstants
{
	mat4 worldViewProj[2];
	mat4 worldView[2];
	mat4 rainDepthTransform;
	vec4 tanHalfFov;
	vec4 viewPos[2];
	vec4 offset[2];
	vec4 depthToLinFadeDistRain;
	vec4 depthToLinFadeDistTexture;
	vec4 viewportToTexRegionScaleBias;
	vec2 tanHalfFovUnused;
	vec2 screenSize;
	vec3 viewPositionOffset;
	float nearRainDistance;
	float rainDepthTextureScale;
	float splashDelta;
	float minDistanceM;
	float padding2;
};




#line 44 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct RandomResult
{
	uvec4 state;
	float value;
};
#line 95 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct ParticleGeometryOutput
{
	vec4 position;
	vec4 clip_pos;
	vec3 dir;
	float strength;
	vec3 light;
	float betaMie;
	vec2 texCoords;
	flat uint type;
};
layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t precipitationVolumeTexture[24];
	uint64_t cubeTexture[24];
	uint64_t rainDepthTexture[24];
	uint64_t rainDepthTextureMS[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float HenyeyGreenstein(float g, float cos0)
{
float g2=g*g;
float u=1.0+g2-2.0*g*cos0;
return (1.0-g2)*pow(u,-1.5)/(4.0*3.1415926536);
}
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint TausStep(uint z, int S1, int S2, int S3, uint m)
{
uint b=(((z<<S1)^z)>>S2);
return (((z&m)<<S3)^b);
}
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint LCGStep(uint z, uint A, uint C)
{
return (A*z+C);
}
#line 57 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
RandomResult Random(uvec4 state)
{
state.x=TausStep(state.x,13,19,12,0xfffffffe);
state.y=TausStep(state.y,2,25,4,0xfffffff8);
state.z=TausStep(state.z,3,11,17,0xfffffff0);
state.w=LCGStep(state.w,1664525,uint(1013904223));
RandomResult result;
result.state=state;
result.value=2.3283064365387e-10*float(state.x^state.y^state.z^state.w);
return result;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
vec3 WrapParticleZone(vec3 pos, float zoneSize)
{
const vec3 c=vec3(0.5,0.5,0.5);
vec3 box=pos/(2.0*zoneSize)+c;
pos=(fract(box)-c)*2.0*zoneSize;
return pos;
}
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
float ms_depth(vec2 depth_texc)
{
uvec2 texsize;
uint numberOfSamples;
ivec2 ivrainDepthTextureMS = textureSize(sampler2DMS(rainDepthTextureMS[0]));
texsize.x = ivrainDepthTextureMS.x;texsize.y = ivrainDepthTextureMS.y;;
ivec2 pos=ivec2(depth_texc*vec2(texsize));
float depth=texelFetch(sampler2DMS(rainDepthTextureMS[0]),ivec2(pos),int(0)).x;
return depth;
}
#line 228 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
ParticleGeometryOutput VS_SnowParticles(uint vertex_id, bool rainMaskEnabled, bool msaa)
{
uint particle_id=vertex_id/6;
uint vertex_index=vertex_id-(particle_id*6);
#line 217 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

ParticleGeometryOutput p;
uvec4 state=uvec4(63+typed_mod(particle_id,71),83117+particle_id/51,195+particle_id/1001,9019+typed_mod(particle_id,507));
RandomResult r1=Random(state);
RandomResult r2=Random(r1.state);
RandomResult r3=Random(r2.state);
RandomResult r4=Random(r3.state);
RandomResult r5=Random(r4.state);
RandomResult r6=Random(r5.state);
vec3 p_pos=2.0*vec3(r4.value,r2.value,r3.value);
p_pos-=vec3(1.0,1.0,1.0);
p.type=typed_mod(particle_id,uint(32));
#line 233 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

vec3 x=vec3(r5.value-0.5,r2.value-0.5,r1.value-0.5);
vec3 y=vec3(r4.value-0.5,r6.value-0.5,r3.value-0.5);
float time0=3.1415926536*70.0*(phase0+r6.value);
float time1=3.1415926536*70.0*(phase1+r6.value);
vec3 flurry_offset0=0.5*(x*sin(time0)+y*cos(time0));
vec3 flurry_offset1=0.5*(x*sin(time1)+y*cos(time1));
vec3 position=vec3(p_pos)*particleZoneSize-offset[0].xyz;
position=WrapParticleZone(position,particleZoneSize/2);
vec3 position0=position+flurry*flurry_offset0;
vec3 position1;
if(timeStepSeconds==0.0)position1=position-vec3(0,0,abs(viewPositionOffset.z))+flurry*flurry_offset1;else
position1=position-viewPositionOffset.xyz+flurry*flurry_offset1;
vec3 map_texc=mul(rainMapMatrix,vec4(viewPos[1].xyz,1.0)).xyz;
#line 252 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

map_texc.y=1.0-map_texc.y;
#line 255 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

float mapped_rain=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).x,0.25);
float cloudBaseAndDensity=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).y,0.25);
mapped_rain=(mapped_rain*4*cloudBaseAndDensity);
vec3 in_depth_space=vec3(1.0,1.0,1.0);
float depth=1.0;
if(rainMaskEnabled)
{
in_depth_space=0.5*mul(rainDepthTransform,vec4(position0.xyz+viewPos[1].xyz,1.0)).xyz+vec3(0.5,0.5,0.0);
if(msaa)
{
depth=ms_depth(vec2(in_depth_space.x,in_depth_space.y))*rainDepthTextureScale*0.5;
}
else

{
depth=textureLod(sampler2D(rainDepthTexture[1 + 9]),vec2(in_depth_space.x,in_depth_space.y),0).x*rainDepthTextureScale*0.5;
}

}

int maxtype=int(16.0*mapped_rain);
p.type=typed_mod(p.type,maxtype);
p.strength=saturate(4.0*mapped_rain);
if(in_depth_space.x>0&&in_depth_space.y>0&&in_depth_space.x<1.0&&in_depth_space.y<1.0&&depth>in_depth_space.z)
{

}

vec3 pos;
vec3 vel=position1-position0;
float fade=p.strength;
float w=particleWidth;
vec3 dir;
uint corner_id=typed_mod((vertex_index+uint(vertex_index==2)-1*uint(vertex_index>2)),4);

{
vec3 eyeVec=normalize(-position0.xyz);
float width=w*fade;
vec3 v1=cross(eyeVec,vec3(0,0,1));
vec3 v2=cross(eyeVec,vec3(0,1,0));
vel=vel+0.000001*vec3(0,0,1);
float height=w+0.5*length(vel);
float dist=length(position0.xyz);
fade*=max(.025,saturate(1.0*width/height));
float pixelSize=width*500.0/dist;
if(pixelSize<1.0)
{
width*=1.0/pixelSize;
fade*=pixelSize/1.0;
}

vel=normalize(vel);
vec3 eyeOnVelVecPlane=-((dot(eyeVec,vel))*vel);
vec3 projectedVelVec=normalize(vel-eyeOnVelVecPlane);
vec3 sideVec=normalize(cross(projectedVelVec,eyeVec));
vec2 trans=2.0*vec2((typed_mod(corner_id,2)),(corner_id/2))-vec2(1.0,1.0);
p.texCoords=trans;
dir=normalize(normalize(eyeVec)+trans.x*sideVec+trans.y*vel);
pos=position0.xyz+trans.x*(sideVec*width)+trans.y*(vel*height);
pos=position0.xyz+trans.x*(sideVec*width)+trans.y*(vel*height);
}

p.strength=fade;
float distM=length(position0.xyz);
p.strength*=saturate((distM-minDistanceM)/0.05);
p.position=mul(worldViewProj[1],vec4(pos,1.0));
p.clip_pos=p.position;
p.dir=dir;
p.betaMie=HenyeyGreenstein(0.5,dot(dir,lightDir));
p.light=textureLod(samplerCube(cubeTexture[1 + 6]),mul(cubemapTransform,vec4(-dir.xyz,0)).xyz,0).rgb;
#line 343 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

return p;
}
layout(location = 0) out Block
{
ParticleGeometryOutput BlockData;
} ioblock;
void main()
{
uint vertex_id=gl_VertexID;
#line 410 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
{
ioblock.BlockData=VS_SnowParticles(vertex_id,false,true);
gl_Position=VS_SnowParticles(vertex_id,false,true).position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/rain_VS_SnowParticles_NoMask_MSAA_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 10) uniform RainConstants
{
	mat4 rainMapMatrix;
	mat4 cubemapTransform;
	vec4 lightColour;
	vec3 lightDir;
	float particleWidth;
	vec3 meanFallVelocity;
	float intensity;
	float flurry;
	float flurryRate;
	float phase0;
	float phase1;
	float timeStepSeconds;
	float particleZoneSize;
	vec2 padding;
};
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/rain_constants.sl"
layout(std140, binding = 8) uniform RainPerViewConstants
{
	mat4 worldViewProj[2];
	mat4 worldView[2];
	mat4 rainDepthTransform;
	vec4 tanHalfFov;
	vec4 viewPos[2];
	vec4 offset[2];
	vec4 depthToLinFadeDistRain;
	vec4 depthToLinFadeDistTexture;
	vec4 viewportToTexRegionScaleBias;
	vec2 tanHalfFovUnused;
	vec2 screenSize;
	vec3 viewPositionOffset;
	float nearRainDistance;
	float rainDepthTextureScale;
	float splashDelta;
	float minDistanceM;
	float padding2;
};




#line 44 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct RandomResult
{
	uvec4 state;
	float value;
};
#line 95 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
struct ParticleGeometryOutput
{
	vec4 position;
	vec4 clip_pos;
	vec3 dir;
	float strength;
	vec3 light;
	float betaMie;
	vec2 texCoords;
	flat uint type;
};
layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t precipitationVolumeTexture[24];
	uint64_t cubeTexture[24];
	uint64_t rainDepthTexture[24];
	uint64_t rainDepthTextureMS[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float HenyeyGreenstein(float g, float cos0)
{
float g2=g*g;
float u=1.0+g2-2.0*g*cos0;
return (1.0-g2)*pow(u,-1.5)/(4.0*3.1415926536);
}
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint TausStep(uint z, int S1, int S2, int S3, uint m)
{
uint b=(((z<<S1)^z)>>S2);
return (((z&m)<<S3)^b);
}
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
uint LCGStep(uint z, uint A, uint C)
{
return (A*z+C);
}
#line 57 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
RandomResult Random(uvec4 state)
{
state.x=TausStep(state.x,13,19,12,0xfffffffe);
state.y=TausStep(state.y,2,25,4,0xfffffff8);
state.z=TausStep(state.z,3,11,17,0xfffffff0);
state.w=LCGStep(state.w,1664525,uint(1013904223));
RandomResult result;
result.state=state;
result.value=2.3283064365387e-10*float(state.x^state.y^state.z^state.w);
return result;
}
#line 97 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
vec3 WrapParticleZone(vec3 pos, float zoneSize)
{
const vec3 c=vec3(0.5,0.5,0.5);
vec3 box=pos/(2.0*zoneSize)+c;
pos=(fract(box)-c)*2.0*zoneSize;
return pos;
}
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
float ms_depth(vec2 depth_texc)
{
uvec2 texsize;
uint numberOfSamples;
ivec2 ivrainDepthTextureMS = textureSize(sampler2DMS(rainDepthTextureMS[0]));
texsize.x = ivrainDepthTextureMS.x;texsize.y = ivrainDepthTextureMS.y;;
ivec2 pos=ivec2(depth_texc*vec2(texsize));
float depth=texelFetch(sampler2DMS(rainDepthTextureMS[0]),ivec2(pos),int(0)).x;
return depth;
}
#line 228 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
ParticleGeometryOutput VS_SnowParticles(uint vertex_id, bool rainMaskEnabled, bool msaa)
{
uint particle_id=vertex_id/6;
uint vertex_index=vertex_id-(particle_id*6);
#line 217 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

ParticleGeometryOutput p;
uvec4 state=uvec4(63+typed_mod(particle_id,71),83117+particle_id/51,195+particle_id/1001,9019+typed_mod(particle_id,507));
RandomResult r1=Random(state);
RandomResult r2=Random(r1.state);
RandomResult r3=Random(r2.state);
RandomResult r4=Random(r3.state);
RandomResult r5=Random(r4.state);
RandomResult r6=Random(r5.state);
vec3 p_pos=2.0*vec3(r4.value,r2.value,r3.value);
p_pos-=vec3(1.0,1.0,1.0);
p.type=typed_mod(particle_id,uint(32));
#line 233 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

vec3 x=vec3(r5.value-0.5,r2.value-0.5,r1.value-0.5);
vec3 y=vec3(r4.value-0.5,r6.value-0.5,r3.value-0.5);
float time0=3.1415926536*70.0*(phase0+r6.value);
float time1=3.1415926536*70.0*(phase1+r6.value);
vec3 flurry_offset0=0.5*(x*sin(time0)+y*cos(time0));
vec3 flurry_offset1=0.5*(x*sin(time1)+y*cos(time1));
vec3 position=vec3(p_pos)*particleZoneSize-offset[0].xyz;
position=WrapParticleZone(position,particleZoneSize/2);
vec3 position0=position+flurry*flurry_offset0;
vec3 position1;
if(timeStepSeconds==0.0)position1=position-vec3(0,0,abs(viewPositionOffset.z))+flurry*flurry_offset1;else
position1=position-viewPositionOffset.xyz+flurry*flurry_offset1;
vec3 map_texc=mul(rainMapMatrix,vec4(viewPos[1].xyz,1.0)).xyz;
#line 252 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

map_texc.y=1.0-map_texc.y;
#line 255 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

float mapped_rain=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).x,0.25);
float cloudBaseAndDensity=max(textureLod(sampler3D(precipitationVolumeTexture[1 + 6]),map_texc,0).y,0.25);
mapped_rain=(mapped_rain*4*cloudBaseAndDensity);
vec3 in_depth_space=vec3(1.0,1.0,1.0);
float depth=1.0;
if(rainMaskEnabled)
{
in_depth_space=0.5*mul(rainDepthTransform,vec4(position0.xyz+viewPos[1].xyz,1.0)).xyz+vec3(0.5,0.5,0.0);
if(msaa)
{
depth=ms_depth(vec2(in_depth_space.x,in_depth_space.y))*rainDepthTextureScale*0.5;
}
else

{
depth=textureLod(sampler2D(rainDepthTexture[1 + 9]),vec2(in_depth_space.x,in_depth_space.y),0).x*rainDepthTextureScale*0.5;
}

}

int maxtype=int(16.0*mapped_rain);
p.type=typed_mod(p.type,maxtype);
p.strength=saturate(4.0*mapped_rain);
if(in_depth_space.x>0&&in_depth_space.y>0&&in_depth_space.x<1.0&&in_depth_space.y<1.0&&depth>in_depth_space.z)
{

}

vec3 pos;
vec3 vel=position1-position0;
float fade=p.strength;
float w=particleWidth;
vec3 dir;
uint corner_id=typed_mod((vertex_index+uint(vertex_index==2)-1*uint(vertex_index>2)),4);

{
vec3 eyeVec=normalize(-position0.xyz);
float width=w*fade;
vec3 v1=cross(eyeVec,vec3(0,0,1));
vec3 v2=cross(eyeVec,vec3(0,1,0));
vel=vel+0.000001*vec3(0,0,1);
float height=w+0.5*length(vel);
float dist=length(position0.xyz);
fade*=max(.025,saturate(1.0*width/height));
float pixelSize=width*500.0/dist;
if(pixelSize<1.0)
{
width*=1.0/pixelSize;
fade*=pixelSize/1.0;
}

vel=normalize(vel);
vec3 eyeOnVelVecPlane=-((dot(eyeVec,vel))*vel);
vec3 projectedVelVec=normalize(vel-eyeOnVelVecPlane);
vec3 sideVec=normalize(cross(projectedVelVec,eyeVec));
vec2 trans=2.0*vec2((typed_mod(corner_id,2)),(corner_id/2))-vec2(1.0,1.0);
p.texCoords=trans;
dir=normalize(normalize(eyeVec)+trans.x*sideVec+trans.y*vel);
pos=position0.xyz+trans.x*(sideVec*width)+trans.y*(vel*height);
pos=position0.xyz+trans.x*(sideVec*width)+trans.y*(vel*height);
}

p.strength=fade;
float distM=length(position0.xyz);
p.strength*=saturate((distM-minDistanceM)/0.05);
p.position=mul(worldViewProj[1],vec4(pos,1.0));
p.clip_pos=p.position;
p.dir=dir;
p.betaMie=HenyeyGreenstein(0.5,dot(dir,lightDir));
p.light=textureLod(samplerCube(cubeTexture[1 + 6]),mul(cubemapTransform,vec4(-dir.xyz,0)).xyz,0).rgb;
#line 343 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"

return p;
}
layout(location = 0) out Block
{
ParticleGeometryOutput BlockData;
} ioblock;
void main()
{
uint vertex_id=gl_VertexID;
#line 410 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/rain.sfx"
{
ioblock.BlockData=VS_SnowParticles(vertex_id,false,true);
gl_Position=VS_SnowParticles(vertex_id,false,true).position;
}
}