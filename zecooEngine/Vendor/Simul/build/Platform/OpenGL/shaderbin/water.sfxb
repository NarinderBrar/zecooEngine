#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_CS_PrecomputeGroupSpeeds_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 121 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 4) uniform cbProfileBuffers
{
	float g_zetaMax;
	float g_zetaMin;
	float g_period;
	float g_integrationSteps;
	float g_time;
	float g_windSpeed;
	int g_totalWaveNumbers;
	float g_dt;
	uvec2 g_waveGridBound;
	int g_waveGroup;
	int g_waveGridDimension;
};
layout(std430, binding = 17) buffer g_WaveSpectrum_ssbo
{
	vec2 g_WaveSpectrum[]; 
};
layout(std430, binding = 1) buffer g_GroupSpeeds_ssbo
{
	float g_GroupSpeeds[]; 
};
#line 157 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
float spectrum(float zeta, float windSpeed)
{
float A=pow(1.1,1.5*zeta);
float B=exp(-1.8038897788076411*pow(4.f,zeta)/pow(windSpeed,4.f));
return 0.139098f*sqrt(A*B);
}
layout(local_size_x=1, local_size_y=1, local_size_z=1) in;
void main()
{
uvec3 sub_pos = gl_GlobalInvocationID;
#line 145 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
float zetaMin=g_WaveSpectrum[sub_pos.x].x;
float zetaMax=g_WaveSpectrum[sub_pos.x].y;
const float g=9.81f;
float dx=(zetaMax-zetaMin)/g_integrationSteps;
float x=(zetaMin+0.5f*dx);
vec2 result=vec2(0.0f,0.0f);
for(int i=0;i<g_integrationSteps;i++)
{
float waveLength=pow(2,x);
float waveNumber=6.28318530718f/waveLength;
float cg=0.5*sqrt(g/waveNumber);
float density=spectrum(x,g_windSpeed);
result+=dx*vec2(cg*density,density);
x+=dx;
}

g_GroupSpeeds[sub_pos.x]=2.0*result[0]/result[1];
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_CS_TraceFlowRaysBase_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 160 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 7) uniform cbFlowRayBuffer
{
	float g_stepSize;
	float g_maxDepth;
	float g_baseDirection;
	float g_baseWaveSpeed;
};

layout(rgba32f, binding = 5) uniform image2D g_RightFlowRayBuffer;
layout(rgba32f, binding = 6) uniform image2D g_OutputFlowRayBuffer;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t g_contourMap[24];
};
#line 175 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
void CS_TraceFlowRays(uvec3 sub_pos, bool base)
{
vec4 result=vec4(0.0,0.0,0.0,0.0);
vec4 tag=vec4(0.0,0.0,0.0,0.0);
vec2 position=vec2((sub_pos.x)/256.0,1.0);
vec2 direction=vec2(0.0,-1.0);
int count=1;
int arrayPosition=2;
vec4 contourSample=vec4(0.0,0.0,0.0,1000.0);
float waveNumber=6.28318530718f/20.0;
float minDepth=tan(1.0)/waveNumber;
float stepSize=g_stepSize/4.0;
float baseVelocity=tanh(waveNumber*minDepth);
float previousVelocity=baseVelocity;
float refracted=0.0;
float modifier=0.0;
if(base)
{
imageStore(g_OutputFlowRayBuffer,ivec2(uvec2(sub_pos.x,1)),vec4(vec4(position.xy,previousVelocity,modifier)));
while(count<511&&position.y<=1.0&&position.x<=1.0&&position.y>=0.0&&position.x>=0.0&&contourSample.w>=0.0)
{
contourSample=textureLod(sampler2D(g_contourMap[1 + 7]),position,0);
if(contourSample.w<=minDepth)
{
previousVelocity=baseVelocity*tanh(waveNumber*contourSample.w);
break;
}

position+=stepSize*direction;
count++;
}

if(count==511)
{
imageStore(g_OutputFlowRayBuffer,ivec2(uvec2(sub_pos.x,2)),vec4(vec4(position.xy,previousVelocity,count)));
tag.y=arrayPosition;
imageStore(g_OutputFlowRayBuffer,ivec2(uvec2(sub_pos.x,0)),vec4(tag));
return ;
}

tag.x=count;
}
else

{
position+=vec2(1.0/512.0,0.0);
imageStore(g_OutputFlowRayBuffer,ivec2(uvec2(sub_pos.x,1)),vec4(vec4(position.xy,previousVelocity,0.0)));
int startPointLeft=int(imageLoad(g_RightFlowRayBuffer,ivec2(uvec2(sub_pos.x,0)).xy).x);
int startPointRight=int(imageLoad(g_RightFlowRayBuffer,ivec2(uvec2(sub_pos.x+1,0)).xy).x);
if(startPointLeft==511&&startPointRight==511)
{
imageStore(g_OutputFlowRayBuffer,ivec2(uvec2(sub_pos.x,2)),vec4(vec4(position.xy,previousVelocity,511)));
tag.y=arrayPosition;
imageStore(g_OutputFlowRayBuffer,ivec2(uvec2(sub_pos.x,0)),vec4(tag));
return ;
}

count=min(startPointLeft,startPointRight);
float difference=1.0/128.0;
bool foundBreak=false;
bool equalArrayLocation=false;
int leftArrayPosition=2;
int rightArrayPosition=2;
vec2 leftRayPosition=imageLoad(g_RightFlowRayBuffer,ivec2(uvec2(sub_pos.x,1)).xy).xy;
;
vec2 rightRayPosition=imageLoad(g_RightFlowRayBuffer,ivec2(uvec2(sub_pos.x+1,1)).xy).xy;
;
if(startPointLeft>startPointRight)
{
while(!foundBreak&&!equalArrayLocation)
{
modifier=1.0;
difference=length((leftRayPosition+(stepSize*direction*count))-imageLoad(g_RightFlowRayBuffer,ivec2(uvec2(sub_pos.x+1,rightArrayPosition)).xy).xy);
foundBreak=difference>1.0/128.0;
if(!foundBreak)
{
equalArrayLocation=(count==startPointLeft);
rightArrayPosition++;
count++;
}
else

{
leftRayPosition+=(stepSize*direction*count);
rightRayPosition=imageLoad(g_RightFlowRayBuffer,ivec2(uvec2(sub_pos.x+1,rightArrayPosition)).xy).xy;
}

}

}
else
if(startPointLeft<startPointRight)
{
while(!foundBreak&&!equalArrayLocation)
{
modifier=1.0;
difference=length(imageLoad(g_RightFlowRayBuffer,ivec2(uvec2(sub_pos.x,leftArrayPosition)).xy).xy-(rightRayPosition+(stepSize*direction*count)));
foundBreak=difference>1.0/128.0;
if(!foundBreak)
{
equalArrayLocation=(count==startPointLeft);
leftArrayPosition++;
count++;
}
else

{
leftRayPosition=imageLoad(g_RightFlowRayBuffer,ivec2(uvec2(sub_pos.x,leftArrayPosition)).xy).xy;
rightRayPosition+=(stepSize*direction*count);
}

}

}

while(!foundBreak&&(count!=511))
{
modifier=0.0;
leftRayPosition=imageLoad(g_RightFlowRayBuffer,ivec2(uvec2(sub_pos.x,leftArrayPosition)).xy).xy;
rightRayPosition=imageLoad(g_RightFlowRayBuffer,ivec2(uvec2(sub_pos.x+1,rightArrayPosition)).xy).xy;
difference=length(leftRayPosition-rightRayPosition);
foundBreak=difference>1.0/128.0;
if(!foundBreak)
{
rightArrayPosition++;
leftArrayPosition++;
count++;
}

}

if(count==511)
{
tag.x=-1;
imageStore(g_OutputFlowRayBuffer,ivec2(uvec2(sub_pos.x,0)),vec4(tag));
return ;
}

position=(leftRayPosition+rightRayPosition)/2.0;
direction=normalize(normalize(leftRayPosition-imageLoad(g_RightFlowRayBuffer,ivec2(uvec2(sub_pos.x,leftArrayPosition-1)).xy).xy)+normalize(rightRayPosition-imageLoad(g_RightFlowRayBuffer,ivec2(uvec2(sub_pos.x+1,rightArrayPosition-1)).xy).xy));
previousVelocity=(imageLoad(g_RightFlowRayBuffer,ivec2(uvec2(sub_pos.x,leftArrayPosition)).xy).z+imageLoad(g_RightFlowRayBuffer,ivec2(uvec2(sub_pos.x+1,rightArrayPosition)).xy).z)/2.0;
tag.x=count;
imageStore(g_OutputFlowRayBuffer,ivec2(uvec2(sub_pos.x,arrayPosition)),vec4(vec4(position.xy,previousVelocity,modifier)));
position+=stepSize*direction;
count++;
arrayPosition++;
imageStore(g_OutputFlowRayBuffer,ivec2(uvec2(sub_pos.x,arrayPosition)),vec4(vec4(position.xy,previousVelocity,modifier)));
}

while(arrayPosition<511&&position.y<=1.0&&position.x<=1.0&&position.y>=0.0&&position.x>=0.0&&contourSample.w>=0.0)
{
contourSample=textureLod(sampler2D(g_contourMap[1 + 7]),position,0);
imageStore(g_OutputFlowRayBuffer,ivec2(uvec2(sub_pos.x,arrayPosition)),vec4(vec4(position.xy,previousVelocity,modifier)));
modifier=0.0;
if(contourSample.w<=minDepth)
{
float newVelocity=baseVelocity*tanh(waveNumber*contourSample.w);
if(newVelocity!=previousVelocity)
{
if((newVelocity>previousVelocity))
{
contourSample.xy*=-1.0;
modifier+=1.0;
}

previousVelocity=newVelocity;
}

}
else

{
previousVelocity=baseVelocity;
modifier=0.0;
}

position+=stepSize*direction;
count++;
arrayPosition++;
}

contourSample=textureLod(sampler2D(g_contourMap[1 + 9]),position,0);
imageStore(g_OutputFlowRayBuffer,ivec2(uvec2(sub_pos.x,arrayPosition)),vec4(vec4(position.x,position.y,0.0,count)));
tag.y=arrayPosition;
imageStore(g_OutputFlowRayBuffer,ivec2(uvec2(sub_pos.x,0)),vec4(tag));
}
layout(local_size_x=8, local_size_y=1, local_size_z=1) in;
void main()
{
uvec3 sub_pos = gl_GlobalInvocationID;
#line 427 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
CS_TraceFlowRays(sub_pos,true);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_CS_TraceFlowRaysSub_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 160 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 7) uniform cbFlowRayBuffer
{
	float g_stepSize;
	float g_maxDepth;
	float g_baseDirection;
	float g_baseWaveSpeed;
};

layout(rgba32f, binding = 5) uniform image2D g_RightFlowRayBuffer;
layout(rgba32f, binding = 6) uniform image2D g_OutputFlowRayBuffer;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t g_contourMap[24];
};
#line 175 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
void CS_TraceFlowRays(uvec3 sub_pos, bool base)
{
vec4 result=vec4(0.0,0.0,0.0,0.0);
vec4 tag=vec4(0.0,0.0,0.0,0.0);
vec2 position=vec2((sub_pos.x)/256.0,1.0);
vec2 direction=vec2(0.0,-1.0);
int count=1;
int arrayPosition=2;
vec4 contourSample=vec4(0.0,0.0,0.0,1000.0);
float waveNumber=6.28318530718f/20.0;
float minDepth=tan(1.0)/waveNumber;
float stepSize=g_stepSize/4.0;
float baseVelocity=tanh(waveNumber*minDepth);
float previousVelocity=baseVelocity;
float refracted=0.0;
float modifier=0.0;
if(base)
{
imageStore(g_OutputFlowRayBuffer,ivec2(uvec2(sub_pos.x,1)),vec4(vec4(position.xy,previousVelocity,modifier)));
while(count<511&&position.y<=1.0&&position.x<=1.0&&position.y>=0.0&&position.x>=0.0&&contourSample.w>=0.0)
{
contourSample=textureLod(sampler2D(g_contourMap[1 + 7]),position,0);
if(contourSample.w<=minDepth)
{
previousVelocity=baseVelocity*tanh(waveNumber*contourSample.w);
break;
}

position+=stepSize*direction;
count++;
}

if(count==511)
{
imageStore(g_OutputFlowRayBuffer,ivec2(uvec2(sub_pos.x,2)),vec4(vec4(position.xy,previousVelocity,count)));
tag.y=arrayPosition;
imageStore(g_OutputFlowRayBuffer,ivec2(uvec2(sub_pos.x,0)),vec4(tag));
return ;
}

tag.x=count;
}
else

{
position+=vec2(1.0/512.0,0.0);
imageStore(g_OutputFlowRayBuffer,ivec2(uvec2(sub_pos.x,1)),vec4(vec4(position.xy,previousVelocity,0.0)));
int startPointLeft=int(imageLoad(g_RightFlowRayBuffer,ivec2(uvec2(sub_pos.x,0)).xy).x);
int startPointRight=int(imageLoad(g_RightFlowRayBuffer,ivec2(uvec2(sub_pos.x+1,0)).xy).x);
if(startPointLeft==511&&startPointRight==511)
{
imageStore(g_OutputFlowRayBuffer,ivec2(uvec2(sub_pos.x,2)),vec4(vec4(position.xy,previousVelocity,511)));
tag.y=arrayPosition;
imageStore(g_OutputFlowRayBuffer,ivec2(uvec2(sub_pos.x,0)),vec4(tag));
return ;
}

count=min(startPointLeft,startPointRight);
float difference=1.0/128.0;
bool foundBreak=false;
bool equalArrayLocation=false;
int leftArrayPosition=2;
int rightArrayPosition=2;
vec2 leftRayPosition=imageLoad(g_RightFlowRayBuffer,ivec2(uvec2(sub_pos.x,1)).xy).xy;
;
vec2 rightRayPosition=imageLoad(g_RightFlowRayBuffer,ivec2(uvec2(sub_pos.x+1,1)).xy).xy;
;
if(startPointLeft>startPointRight)
{
while(!foundBreak&&!equalArrayLocation)
{
modifier=1.0;
difference=length((leftRayPosition+(stepSize*direction*count))-imageLoad(g_RightFlowRayBuffer,ivec2(uvec2(sub_pos.x+1,rightArrayPosition)).xy).xy);
foundBreak=difference>1.0/128.0;
if(!foundBreak)
{
equalArrayLocation=(count==startPointLeft);
rightArrayPosition++;
count++;
}
else

{
leftRayPosition+=(stepSize*direction*count);
rightRayPosition=imageLoad(g_RightFlowRayBuffer,ivec2(uvec2(sub_pos.x+1,rightArrayPosition)).xy).xy;
}

}

}
else
if(startPointLeft<startPointRight)
{
while(!foundBreak&&!equalArrayLocation)
{
modifier=1.0;
difference=length(imageLoad(g_RightFlowRayBuffer,ivec2(uvec2(sub_pos.x,leftArrayPosition)).xy).xy-(rightRayPosition+(stepSize*direction*count)));
foundBreak=difference>1.0/128.0;
if(!foundBreak)
{
equalArrayLocation=(count==startPointLeft);
leftArrayPosition++;
count++;
}
else

{
leftRayPosition=imageLoad(g_RightFlowRayBuffer,ivec2(uvec2(sub_pos.x,leftArrayPosition)).xy).xy;
rightRayPosition+=(stepSize*direction*count);
}

}

}

while(!foundBreak&&(count!=511))
{
modifier=0.0;
leftRayPosition=imageLoad(g_RightFlowRayBuffer,ivec2(uvec2(sub_pos.x,leftArrayPosition)).xy).xy;
rightRayPosition=imageLoad(g_RightFlowRayBuffer,ivec2(uvec2(sub_pos.x+1,rightArrayPosition)).xy).xy;
difference=length(leftRayPosition-rightRayPosition);
foundBreak=difference>1.0/128.0;
if(!foundBreak)
{
rightArrayPosition++;
leftArrayPosition++;
count++;
}

}

if(count==511)
{
tag.x=-1;
imageStore(g_OutputFlowRayBuffer,ivec2(uvec2(sub_pos.x,0)),vec4(tag));
return ;
}

position=(leftRayPosition+rightRayPosition)/2.0;
direction=normalize(normalize(leftRayPosition-imageLoad(g_RightFlowRayBuffer,ivec2(uvec2(sub_pos.x,leftArrayPosition-1)).xy).xy)+normalize(rightRayPosition-imageLoad(g_RightFlowRayBuffer,ivec2(uvec2(sub_pos.x+1,rightArrayPosition-1)).xy).xy));
previousVelocity=(imageLoad(g_RightFlowRayBuffer,ivec2(uvec2(sub_pos.x,leftArrayPosition)).xy).z+imageLoad(g_RightFlowRayBuffer,ivec2(uvec2(sub_pos.x+1,rightArrayPosition)).xy).z)/2.0;
tag.x=count;
imageStore(g_OutputFlowRayBuffer,ivec2(uvec2(sub_pos.x,arrayPosition)),vec4(vec4(position.xy,previousVelocity,modifier)));
position+=stepSize*direction;
count++;
arrayPosition++;
imageStore(g_OutputFlowRayBuffer,ivec2(uvec2(sub_pos.x,arrayPosition)),vec4(vec4(position.xy,previousVelocity,modifier)));
}

while(arrayPosition<511&&position.y<=1.0&&position.x<=1.0&&position.y>=0.0&&position.x>=0.0&&contourSample.w>=0.0)
{
contourSample=textureLod(sampler2D(g_contourMap[1 + 7]),position,0);
imageStore(g_OutputFlowRayBuffer,ivec2(uvec2(sub_pos.x,arrayPosition)),vec4(vec4(position.xy,previousVelocity,modifier)));
modifier=0.0;
if(contourSample.w<=minDepth)
{
float newVelocity=baseVelocity*tanh(waveNumber*contourSample.w);
if(newVelocity!=previousVelocity)
{
if((newVelocity>previousVelocity))
{
contourSample.xy*=-1.0;
modifier+=1.0;
}

previousVelocity=newVelocity;
}

}
else

{
previousVelocity=baseVelocity;
modifier=0.0;
}

position+=stepSize*direction;
count++;
arrayPosition++;
}

contourSample=textureLod(sampler2D(g_contourMap[1 + 9]),position,0);
imageStore(g_OutputFlowRayBuffer,ivec2(uvec2(sub_pos.x,arrayPosition)),vec4(vec4(position.x,position.y,0.0,count)));
tag.y=arrayPosition;
imageStore(g_OutputFlowRayBuffer,ivec2(uvec2(sub_pos.x,0)),vec4(tag));
}
layout(local_size_x=8, local_size_y=1, local_size_z=1) in;
void main()
{
uvec3 sub_pos = gl_GlobalInvocationID;
#line 433 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
CS_TraceFlowRays(sub_pos,false);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_CS_UpdateAmplitudeGrid_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 121 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 4) uniform cbProfileBuffers
{
	float g_zetaMax;
	float g_zetaMin;
	float g_period;
	float g_integrationSteps;
	float g_time;
	float g_windSpeed;
	int g_totalWaveNumbers;
	float g_dt;
	uvec2 g_waveGridBound;
	int g_waveGroup;
	int g_waveGridDimension;
};

layout(r32f, binding = 0) uniform image3D g_OutputAmplitude;
layout(std430, binding = 1) buffer g_GroupSpeeds_ssbo
{
	float g_GroupSpeeds[]; 
};
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t g_InputAmplitude[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 142 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
vec3 convertPosToTexc(vec3 pos, uvec3 dims)
{
return (vec3(pos)+vec3(0.5,0.5,0.5))/vec3(dims);
}
layout(local_size_x=8, local_size_y=8, local_size_z=1) in;
void main()
{
uvec3 sub_pos = gl_GlobalInvocationID;
#line 566 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
uvec3 dims;
ivec3 ivg_InputAmplitude = textureSize(sampler3D(g_InputAmplitude[0]),0);
dims.x = ivg_InputAmplitude.x;dims.y = ivg_InputAmplitude.y;dims.z = ivg_InputAmplitude.z;;
vec3 pos=(sub_pos);
if((pos.x==g_waveGridBound.x)||(pos.y==g_waveGridBound.y)||(pos.x-dims.x==g_waveGridBound.x)||(pos.y-dims.y==g_waveGridBound.y)||(pos.x==g_waveGridBound.x-1)||(pos.y==g_waveGridBound.y-1)||(pos.x-dims.x==g_waveGridBound.x+1)||(pos.y-dims.y==g_waveGridBound.y+1))
{
imageStore(g_OutputAmplitude,ivec3(sub_pos),vec4(0.0f));
return ;
}

float gamma=saturate(g_dt*2.0*pow(g_GroupSpeeds[0],2.0)*(1.0/dims.z));
vec3 texc=convertPosToTexc(pos,dims).xyz;
vec3 traceBackTexc=convertPosToTexc(pos,dims);
float angle=(pos.z/dims.z)*6.28318530718f;
vec2 angleVec=vec2(cos(angle),sin(angle));
vec2 vel=g_dt*g_GroupSpeeds[0]*angleVec;
traceBackTexc.xy-=vel/(dims.x+dims.y);
float result=(textureLod(sampler3D(g_InputAmplitude[1 + 7]),traceBackTexc,0).x*(1-gamma))+(gamma*0.45*(textureLod(sampler3D(g_InputAmplitude[1 + 7]),vec3(traceBackTexc.x,traceBackTexc.y,traceBackTexc.z-(1.0/dims.z)),0).x+textureLod(sampler3D(g_InputAmplitude[1 + 7]),vec3(traceBackTexc.x,traceBackTexc.y,traceBackTexc.z+(1.0/dims.z)),0).x));
imageStore(g_OutputAmplitude,ivec3(sub_pos),vec4(min(result,1.5f)));
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_CS_UpdateAmplitudeGridProbeEffect_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 3) uniform cbWaterProbe
{
	float g_probeUVScale;
	float g_probeUVOffset;
	float g_surfaceHeight;
	float g_probeWaveAmplitude;
	vec2 g_center;
	float g_probeWindDirection;
	float g_probeWindDependancy;
	float g_probeProfileUVScale;
	float g_waveGridScale;
	bool g_enableWaveGrid;
	float cvbhdxiobacyi;
};
#line 121 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 4) uniform cbProfileBuffers
{
	float g_zetaMax;
	float g_zetaMin;
	float g_period;
	float g_integrationSteps;
	float g_time;
	float g_windSpeed;
	int g_totalWaveNumbers;
	float g_dt;
	uvec2 g_waveGridBound;
	int g_waveGroup;
	int g_waveGridDimension;
};
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/debug_constants.sl"
layout(std140, binding = 7) uniform DebugConstants
{
	mat4 debugWorldViewProj;
	vec4 rect;
	vec4 multiplier;
	vec4 quaternion;
	uint latitudes;
	uint longitudes;
	float radius;
	float sideview;
	vec4 viewport;
	vec4 debugColour;
	vec4 debugDepthToLinFadeDistParams;
	vec4 debugTanHalfFov;
	uvec4 texSize;
	uvec2 queryPos;
	float debugGamma;
	float debugDepth;
	float displayLod;
	float displayLevel;
	vec2 dc_pad1;
};
layout(r32f, binding = 0) uniform image3D g_OutputAmplitude;
layout(std430, binding = 18) buffer g_ProbePos_ssbo
{
	vec4 g_ProbePos[]; 
};
layout(std430, binding = 19) buffer g_ProbeVelocity_ssbo
{
	vec4 g_ProbeVelocity[]; 
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
layout(local_size_x=8, local_size_y=8, local_size_z=1) in;
void main()
{
uvec3 sub_pos = gl_GlobalInvocationID;
#line 444 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
vec2 profile16Directons[16]={vec2(1.0f,0.0f),vec2(0.92f,0.38f),vec2(0.707f,0.707f),vec2(0.38f,0.92f),vec2(0.0f,1.0f),vec2(-0.38f,0.92f),vec2(-0.707f,0.707f),vec2(-0.92f,0.38f),vec2(-1.0f,0.0f),vec2(-0.92f,-0.38f),vec2(-0.707f,-0.707f),vec2(-0.38f,-0.92f),vec2(0.0f,-1.0f),vec2(0.38f,-0.92f),vec2(0.707f,-0.707f),vec2(0.92f,-0.38f)};
vec3 velocity=g_ProbeVelocity[sub_pos.x].xyz;
vec3 position=g_ProbePos[sub_pos.x].yxz;
float radius=g_ProbePos[sub_pos.x].w/2.0;
float dEnergy=abs(g_ProbeVelocity[sub_pos.x].w);
vec2 direction=normalize(velocity.yx);
int radius_i=int(radius);
if(radius==0)return ;
if(radius>0)
{
if(dEnergy==0.0)return ;
if((position.z>g_surfaceHeight+(radius*2.0))||(position.z<g_surfaceHeight-(radius*2.0)))return ;
ivec2 uv_local=ivec2(position.xy*g_waveGridScale)+ivec2(g_waveGridDimension,g_waveGridDimension)-ivec2(g_center.yx*0.50f);
int xOrigin=uv_local.x;
int yOrigin=uv_local.y;
if(radius>0.5)
{
xOrigin-=radius_i;
yOrigin-=radius_i;
}

float downwardAmp=max(normalize(-velocity).z,0.0);
float energy=sqrt((2.0/(9.81*1000.0))*(dEnergy/(16.0*radius*radius*3.1415926536f)));
for(int x=xOrigin;x<=uv_local.x+radius_i;x++)
{
for(int y=yOrigin;y<=uv_local.y+radius_i;y++)
{
vec3 positionDirection=vec3((position.xy-g_center.yx)*0.512f,(g_surfaceHeight-position.z)/2.0)+vec3(g_waveGridDimension,g_waveGridDimension,0)-vec3(float(x),float(y),0);
float distance=length(positionDirection);
if((distance>radius&&!((uv_local.x==x)&&(uv_local.y==y)))||(radius-distance>4.0))continue;
for(int i=0;i<16;i++)
{
float angle=(float(i)/16.0)*6.28318530718f;
vec2 angleVec=normalize(profile16Directons[i]);
float currentAmplitude=imageLoad(g_OutputAmplitude,ivec3(ivec3(typed_mod(x,g_waveGridDimension),typed_mod(y,g_waveGridDimension),i)).xyz).x;
imageStore(g_OutputAmplitude,ivec3(ivec3(typed_mod(x,g_waveGridDimension),typed_mod(y,g_waveGridDimension),i)),vec4(currentAmplitude+((downwardAmp+(saturate(dot(normalize(velocity).yx,normalize(angleVec)))))*energy)));
}

}

}

}
else

{
radius*=-1.0;
if((position.z>g_surfaceHeight+(radius*2.0))||(position.z<g_surfaceHeight-(radius*2.0)))return ;
float dampen=abs(((radius*2.0)-abs(position.z-g_surfaceHeight))/(radius*2.0));
ivec2 uv_local=ivec2(position.xy*g_waveGridScale)+ivec2(g_waveGridDimension,g_waveGridDimension)-ivec2(g_center.yx*0.50f);
int xOrigin=uv_local.x;
int yOrigin=uv_local.y;
if(radius>0.5)
{
xOrigin-=radius_i;
yOrigin-=radius_i;
}

for(int x=xOrigin;x<=uv_local.x+radius_i;x++)
{
for(int y=yOrigin;y<=uv_local.y+radius_i;y++)
{
float distance=length(vec3((position.xy-g_center.yx)*0.512f,(g_surfaceHeight-position.z)/2.0)+vec3(g_waveGridDimension,g_waveGridDimension,0)-vec3((x),(y),0));
if((distance>radius&&!((uv_local.x==x)&&(uv_local.y==y))))continue;
for(int i=0;i<16;i++)
{
float angle=(float(i)/16.0)*6.28318530718f;
vec2 angleVec=normalize(profile16Directons[i]);
imageStore(g_OutputAmplitude,ivec3(ivec3(typed_mod(x,g_waveGridDimension),typed_mod(y,g_waveGridDimension),i)),vec4(dampen*(abs(velocity.z)+(saturate(dot(direction,normalize(angleVec))+1.0)*length(velocity.yx)))));
}

}

}

}

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_CS_UpdateBuoyancyDepthValues_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 3) uniform cbWaterProbe
{
	float g_probeUVScale;
	float g_probeUVOffset;
	float g_surfaceHeight;
	float g_probeWaveAmplitude;
	vec2 g_center;
	float g_probeWindDirection;
	float g_probeWindDependancy;
	float g_probeProfileUVScale;
	float g_waveGridScale;
	bool g_enableWaveGrid;
	float cvbhdxiobacyi;
};
#line 147 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 5) uniform cbMeshObjectBuffers
{
	float g_buoyancyUVScale;
	float g_buoyancyUVOffset;
	float g_buoyancySurfaceHeight;
	float g_buoyancyWaveAmplitude;
	vec2 g_buoyancyCenter;
	float g_buoyancyWindDirection;
	float g_buoyancyWindDependancy;
	float g_buoyancyProfileUVScale;
	float g_buoyancyWaveGridScale;
	bool g_buoyancyEnableWaveGrid;
	float gnuhjfidobn;
	mat4 g_meshMat;
	vec3 g_location;
	int g_ID;
	vec4 g_rotation;
	vec3 g_scale;
	float vufiepadnu;
};


layout(std430, binding = 20) buffer g_BuoyancyObjectPos_ssbo
{
	vec3 g_BuoyancyObjectPos[]; 
};
layout(std430, binding = 3) buffer g_BuoyancyObjectOutputs_ssbo
{
	float g_BuoyancyObjectOutputs[]; 
};
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t g_ProfileBuffers[24];
	uint64_t g_InputAmplitude[24];
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
layout(local_size_x=64, local_size_y=1, local_size_z=1) in;
void main()
{
uvec3 sub_pos = gl_GlobalInvocationID;
#line 859 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
float profileOffsets[16]={0.54f,0.18f,0.61f,0.28f,0.09f,0.71f,0.99f,0.43f,0.11f,0.85f,0.24f,0.67f,0.31f,0.86f,0.13f,0.01f};
vec2 profile32Directons[32]={vec2(1.0f,0.0f),vec2(0.98f,0.19f),vec2(0.92f,0.38f),vec2(0.83f,0.55f),vec2(0.707f,0.707f),vec2(0.55f,0.83f),vec2(0.38f,0.92f),vec2(0.19f,0.98f),vec2(0.0f,1.0f),vec2(-0.19f,0.98f),vec2(-0.38f,0.92f),vec2(-0.55f,0.83f),vec2(-0.707f,0.707f),vec2(-0.83f,0.55f),vec2(-0.92f,0.38f),vec2(-0.98f,0.19f),vec2(-1.0f,-0.0f),vec2(-0.98f,-0.19f),vec2(-0.92f,-0.38f),vec2(-0.83f,-0.55f),vec2(-0.707f,-0.707f),vec2(-0.55f,-0.83f),vec2(-0.38f,-0.92f),vec2(-0.19f,-0.98f),vec2(0.0f,-1.0f),vec2(0.19f,-0.98f),vec2(0.38f,-0.92f),vec2(0.55f,-0.83f),vec2(0.707f,-0.707f),vec2(0.83f,-0.55f),vec2(0.92f,-0.38f),vec2(0.98f,-0.19f),};
uint dirNum=16;
uint N=2*dirNum;
float dx=dirNum*6.28318530718f/N;
uint ID=sub_pos.x;
uint i;
vec3 vertexPos=g_BuoyancyObjectPos[ID].yxz;
vertexPos*=g_scale.yxz*0.01;
float4 pos_local=float4(vertexPos,1);
pos_local=mul(g_meshMat,pos_local);
vec2 uv_local=((pos_local.xy*g_buoyancyUVScale))-g_buoyancyCenter.yx*g_buoyancyUVScale;
vec3 displacement=vec3(0.0,0.0,0.0);
vec2 displacementValue=vec2(0.0,0.0);
vec2 waveGridAmp=vec2(0.0,0.0);
vec2 windDirection=normalize(vec2(sin(g_buoyancyWindDirection),cos(g_buoyancyWindDirection)));
for(i=0;i<N;i++)
{
float angle=((i)/(N))*6.28318530718f;
vec2 texcDir=normalize(profile32Directons[i]);
vec2 texc=texcDir*uv_local*g_buoyancyProfileUVScale;
float baseAmplitude=pow(((dot(windDirection,texcDir)+1.0)+((dot(-windDirection,texcDir)+1.0)*(1.0-g_buoyancyWindDependancy)))/2.0,4.0);
vec2 baseWaveAmp=(g_buoyancyWaveAmplitude*baseAmplitude*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,0.0),2).xy)/2.0);
if(g_enableWaveGrid)
{
waveGridAmp=(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,1.0),2).xy*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(uv_local.x/5.0,uv_local.y/5.0,(i+0.5)/N),0).x);
}

displacementValue=dx*(waveGridAmp+baseWaveAmp);
displacement+=vec3(displacementValue.x*texcDir.x,displacementValue.x*texcDir.y,displacementValue.y);
}

displacement*=0.1;
float height=(displacement.z+g_buoyancySurfaceHeight)-pos_local.z;
g_BuoyancyObjectOutputs[ID]=height;
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_CS_UpdateProbeValuesBoundless_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 3) uniform cbWaterProbe
{
	float g_probeUVScale;
	float g_probeUVOffset;
	float g_surfaceHeight;
	float g_probeWaveAmplitude;
	vec2 g_center;
	float g_probeWindDirection;
	float g_probeWindDependancy;
	float g_probeProfileUVScale;
	float g_waveGridScale;
	bool g_enableWaveGrid;
	float cvbhdxiobacyi;
};


layout(std430, binding = 18) buffer g_ProbePos_ssbo
{
	vec4 g_ProbePos[]; 
};
layout(std430, binding = 2) buffer g_ProbeOutputs_ssbo
{
	vec4 g_ProbeOutputs[]; 
};
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t g_ProfileBuffers[24];
	uint64_t g_InputAmplitude[24];
};
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
layout(local_size_x=64, local_size_y=1, local_size_z=1) in;
void main()
{
uvec3 sub_pos = gl_GlobalInvocationID;
#line 753 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
float profileOffsets[16]={0.54f,0.18f,0.61f,0.28f,0.09f,0.71f,0.99f,0.43f,0.11f,0.85f,0.24f,0.67f,0.31f,0.86f,0.13f,0.01f};
vec2 profile32Directons[32]={vec2(1.0f,0.0f),vec2(0.98f,0.19f),vec2(0.92f,0.38f),vec2(0.83f,0.55f),vec2(0.707f,0.707f),vec2(0.55f,0.83f),vec2(0.38f,0.92f),vec2(0.19f,0.98f),vec2(0.0f,1.0f),vec2(-0.19f,0.98f),vec2(-0.38f,0.92f),vec2(-0.55f,0.83f),vec2(-0.707f,0.707f),vec2(-0.83f,0.55f),vec2(-0.92f,0.38f),vec2(-0.98f,0.19f),vec2(-1.0f,-0.0f),vec2(-0.98f,-0.19f),vec2(-0.92f,-0.38f),vec2(-0.83f,-0.55f),vec2(-0.707f,-0.707f),vec2(-0.55f,-0.83f),vec2(-0.38f,-0.92f),vec2(-0.19f,-0.98f),vec2(0.0f,-1.0f),vec2(0.19f,-0.98f),vec2(0.38f,-0.92f),vec2(0.55f,-0.83f),vec2(0.707f,-0.707f),vec2(0.83f,-0.55f),vec2(0.92f,-0.38f),vec2(0.98f,-0.19f),};
uint dirNum=16;
uint N=2*dirNum;
float dx=dirNum*6.28318530718f/N;
uint i;
vec2 uv_local=((g_ProbePos[sub_pos.x].yx*g_probeUVScale))-g_center.yx*g_probeUVScale;
vec3 displacement=vec3(0.0,0.0,0.0);
vec2 windDirection=normalize(vec2(sin(g_probeWindDirection),cos(g_probeWindDirection)));
for(i=0;i<N;i++)
{
float angle=((i)/(N))*6.28318530718f;
vec2 texcDir=normalize(profile32Directons[i]);
vec2 texc=texcDir*uv_local*g_probeProfileUVScale;
float baseAmplitude=pow(((dot(windDirection,texcDir)+1.0)+((dot(-windDirection,texcDir)+1.0)*(1.0-g_probeWindDependancy)))/2.0,4.0);
vec2 displacementValue=vec2(0.0,0.0);
vec2 waveGridAmp=vec2(0.0,0.0);
vec2 baseWaveAmp=(g_probeWaveAmplitude*baseAmplitude*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,0.0f),2).xy)/2.0);
if(g_enableWaveGrid)
{
waveGridAmp=(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,1.0f),2).xy*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(uv_local.x/5.0,uv_local.y/5.0,(i+0.5)/N),0).x);
}

displacementValue=dx*(waveGridAmp+baseWaveAmp);
displacement+=vec3(displacementValue.x*texcDir.x,displacementValue.x*texcDir.y,displacementValue.y);
}

displacement*=0.1;
float height=(displacement.z+g_surfaceHeight)-g_ProbePos[sub_pos.x].z;
g_ProbeOutputs[sub_pos.x]=vec4(height,displacement);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_PS_BoundedWaterSurfDepth.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 1) uniform cbShading
{
	vec3 g_SunDir;
	float g_Shineness;
	vec3 g_SunColor;
	float g_ShoreExtent;
	float g_oceanHeight;
	float g_vrRightEye;
	vec2 g_viewportPixelScale;
	int g_noOfReflectionSteps;
	int g_pixelStep;
	float g_reverseFace;
	bool g_enableFoam;
	float g_UVScale;
	float g_UVOffset;
	float g_WorldScale;
	float g_SunRadius;
	vec2 g_DepthScale;
	vec2 g_screenScale;
	vec4 g_DepthToLinFadeParams;
	vec4 g_HalfTan;
	vec3 g_ShoreDepthTextureLocation;
	float g_ShoreWidth;
	float gkfpdngkpfdp;
	float g_reflectionDistance;
	bool g_vrEnable;
	float g_reflectionBrightness;
};
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};
#line 140 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct PS_WATER_OUTPUTS
{
	vec4 Depth;
	vec4 Scattering;
	vec4 Absorption;
	vec4 Normals;
	vec4 RefractColour;
};





layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t g_texColour[24];
	uint64_t g_texDepth[24];
	uint64_t g_maskTexture[24];
	uint64_t g_ProfileBuffers[24];
	uint64_t g_InputAmplitude[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 1947 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
PS_WATER_OUTPUTS PS_WaterSurfDepth(VS_OUTPUT In, bool frontFacing, bool enableFoam, bool enableRefraction, bool waveGrid)
{
float profileOffsets[16]={0.54f,0.18f,0.61f,0.28f,0.09f,0.71f,0.99f,0.43f,0.11f,0.85f,0.24f,0.67f,0.31f,0.86f,0.13f,0.01f};
vec2 profile32Directons[32]={vec2(1.0f,0.0f),vec2(0.98f,0.19f),vec2(0.92f,0.38f),vec2(0.83f,0.55f),vec2(0.707f,0.707f),vec2(0.55f,0.83f),vec2(0.38f,0.92f),vec2(0.19f,0.98f),vec2(0.0f,1.0f),vec2(-0.19f,0.98f),vec2(-0.38f,0.92f),vec2(-0.55f,0.83f),vec2(-0.707f,0.707f),vec2(-0.83f,0.55f),vec2(-0.92f,0.38f),vec2(-0.98f,0.19f),vec2(-1.0f,-0.0f),vec2(-0.98f,-0.19f),vec2(-0.92f,-0.38f),vec2(-0.83f,-0.55f),vec2(-0.707f,-0.707f),vec2(-0.55f,-0.83f),vec2(-0.38f,-0.92f),vec2(-0.19f,-0.98f),vec2(0.0f,-1.0f),vec2(0.19f,-0.98f),vec2(0.38f,-0.92f),vec2(0.55f,-0.83f),vec2(0.707f,-0.707f),vec2(0.83f,-0.55f),vec2(0.92f,-0.38f),vec2(0.98f,-0.19f),};
PS_WATER_OUTPUTS Output;
vec3 eye_vec=g_LocalEye-In.LocalPos;
float surfaceDepth=length(eye_vec)/300000.0;
bool noWaveGrid=false;
bool maskInvert=false;
bool noSurfaceScattering=false;
float maskedDepth=0.0;
if(enableRefraction)
{
if(length(eye_vec)>100.0)
{
enableRefraction=false;
}

}

if(length(eye_vec.xy)>128.0)
{
noWaveGrid=true;
}

DepthInterpretationStruct dis;
dis.reverseDepth=true;
dis.depthToLinFadeDistParams=g_DepthToLinFadeParams;
vec2 TexCoord=((vec2(In.SurePosition.x/In.SurePosition.w,In.SurePosition.y/-In.SurePosition.w)+vec2(1.0,1.0))/2.0);
vec2 baseTexCoord=TexCoord;
float actualDepth=0.0;
float offset=0.0;
vec3 refract_vec=vec3(0.0,0.0,0.0);
vec3 viewNormal=vec3(0.0,0.0,0.0);
vec3 eyeViewVec=vec3(0.0,0.0,1.0);
float backfaceOccluded=0.0;
float foamValue=0.0;
float surfaceFoamValue=0.0;
float finalDepth;
float eyeDepth;
float subsurfaceSample;
float subsurfaceDepth;
vec3 normal=normalize(vec3(0.01,0.01,1.0f));
vec3 grad=vec3(0.0,0.0,0.0);
if(In.vecColour.x==0.0)
{
vec3 tx=vec3(0.0,0.0,0.0);
vec3 ty=vec3(0.0,0.0,0.0);
uint dirNum=16;
uint N=2*dirNum;
float dx=dirNum*6.28318530718f/N;
vec2 foamtemp=vec2(0.0,0.0);
vec2 foamtempWaveGrid=vec2(0.0,0.0);
vec2 windDirection=normalize(vec2(sin(g_windDirection),cos(g_windDirection)));
uint i;
for(i=0;i<N;i++)
{
float angle=((i)/(N))*6.28318530718f;
vec2 texcDir=normalize(profile32Directons[i]);
vec2 texc=texcDir*In.texCoords*g_profileUVScale;
vec2 gradientValue=vec2(0.0,0.0);
vec2 waveGridAmp=vec2(0.0,0.0);
float baseAmplitude=pow(((dot(windDirection,texcDir)+1.0)+((dot(-windDirection,texcDir)+1.0)*(1.0-g_windDependency)))/2.0,4.0);
vec2 windWaves=g_amplitude*In.vecColour.w*(texture(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,0.0f)).zw)*(baseAmplitude/2.0);
if(waveGrid&&!noWaveGrid)
{
waveGridAmp=(texture(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,1.0f)).zw*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(In.texCoords.x/5.0,In.texCoords.y/5.0,(i+0.5)/N),0).x);
}

gradientValue=dx*(waveGridAmp+windWaves);
tx+=texcDir.x*vec3((-gradientValue.y),0.0,-gradientValue.y);
ty+=texcDir.y*vec3(0.0,(-gradientValue.y),-gradientValue.y);
foamtemp+=dx*vec2(abs(texcDir.x)*windWaves.x,abs(texcDir.y)*windWaves.x);
foamtempWaveGrid+=dx*vec2(abs(texcDir.x)*waveGridAmp.x,abs(texcDir.y)*waveGridAmp.x);
}

vec2 temp=saturate(normalize(vec3(-foamtemp.xy,16.0)).xy);
vec2 temp2=saturate(normalize(vec3(-foamtempWaveGrid.xy,16.0)).xy);
surfaceFoamValue=max(pow(temp.x+temp.y,2.0)-(0.5-g_foamStrength),0.0)+max(pow(temp2.x+temp2.y,2.0)-0.05,0.0);
normal=normalize(vec3(tx.xy+ty.xy,float(N/4.0)));
}

float tempsample=texture(sampler2D(g_texDepth[1 + 9]),TexCoord*g_DepthScale+vec2(g_vrRightEye*0.5,0)).x;
float fulldepth=depthToFadeDistance(tempsample,vec2(In.SurePosition.x/In.SurePosition.w,In.SurePosition.y/-In.SurePosition.w),dis,g_HalfTan);
vec4 maskValue=texture(sampler2D(g_maskTexture[1 + 9]),TexCoord*g_DepthScale+vec2(g_vrRightEye*0.5,0))/300000.0;
if(frontFacing)
{
if((maskValue.x+maskValue.y>fulldepth&&maskValue.x<surfaceDepth)||(maskValue.y<0.0))
{
Output.Scattering=vec4(g_scattering,0.0);
Output.Absorption=vec4(g_absorption,0.0);
Output.RefractColour=vec4(maskValue.y,0.0,0.0,0.0);
Output.Normals=vec4(0.001,0.001,1.0,0.0);
Output.Depth=vec4(0.0,0.0,0.0,0.0);
return Output;
}

if(maskValue.x+maskValue.y>surfaceDepth&&maskValue.x<fulldepth)
{
if(maskValue.x<surfaceDepth)
{
maskInvert=true;
noSurfaceScattering=true;
maskedDepth=(maskValue.x+maskValue.y)-surfaceDepth;
}
else

{
maskedDepth=maskValue.y-max(maskValue.x+maskValue.y-fulldepth,0.0);
}

}

actualDepth=saturate(fulldepth-surfaceDepth-maskedDepth);
if(!maskInvert)
{
if(actualDepth>0.0)
{
if(enableRefraction)
{
viewNormal=mul(vec4(normal,0.0),g_matWorldViewProj).xyz;
refract_vec=normalize(refract(eyeViewVec,viewNormal,1.0/1.33));
float cosangle=acos(dot(eyeViewVec,refract_vec)/(length(eyeViewVec)*length(refract_vec)));
offset=tan(cosangle)*(actualDepth/(fulldepth-maskedDepth))*(1.0-saturate((g_LocalEye.z-In.LocalPos.z-35.0)/5.0));
TexCoord+=offset*(normalize(refract_vec.xy)*g_screenScale);
TexCoord=abs(TexCoord);
}

if(TexCoord.y>=1.0)TexCoord.y=2.0-TexCoord.y;
if(TexCoord.x>=1.0)TexCoord.x=2.0-TexCoord.x;
}
else

{
Output.Scattering=vec4(g_scattering,0.0);
Output.Absorption=vec4(g_absorption,0.0);
Output.RefractColour=vec4(0.0,0.0,0.0,0.0);
Output.Normals=vec4(0.001,0.001,1.0,0.0);
Output.Depth=vec4(0.0,0.0,0.0,0.0);
actualDepth=0.0;
return Output;
}

}

}
else

{
if(((maskValue.y>fulldepth||maskValue.y>surfaceDepth)&&maskValue.x==0.0)||(maskValue.y<0.0&&abs(maskValue.y)<fulldepth))
{
Output.Scattering=vec4(g_scattering,0.0);
Output.Absorption=vec4(g_absorption,0.0);
Output.RefractColour=vec4(maskValue.y,0.0,0.0,0.0);
Output.Normals=vec4(0.001,0.001,1.0,0.0);
Output.Depth=vec4(0.0,0.0,0.0,0.0);
return Output;
}

if(maskValue.y>0.0&&maskValue.x<fulldepth&&maskValue.x<surfaceDepth)
{
maskedDepth=maskValue.y-max((maskValue.x+maskValue.y)-min(surfaceDepth,fulldepth),0.0);
if(maskValue.x==0.0)
{
noSurfaceScattering=true;
}

if(maskValue.x!=0.0&&maskValue.x+maskValue.y>fulldepth)
{

}

}

actualDepth=min(fulldepth,surfaceDepth)-maskedDepth;
if(enableRefraction)
{
if(actualDepth==surfaceDepth-maskedDepth)
{
viewNormal=mul(vec4(-normal,0.0),g_matWorldViewProj).xyz;
refract_vec=normalize(refract(eyeViewVec,viewNormal,1.0/1.33));
float cosangle=acos(dot(-eyeViewVec,refract_vec)/(length(eyeViewVec)*length(refract_vec)));
offset=tan(cosangle)*((fulldepth-surfaceDepth)/fulldepth)*(1.0-saturate((g_LocalEye.z-In.LocalPos.z-35.0)/5.0));
TexCoord+=offset*(normalize(refract_vec.xy)*g_screenScale);
TexCoord=abs(TexCoord);
}

if(TexCoord.y>=1.0)TexCoord.y=2.0-TexCoord.y;
if(TexCoord.x>=1.0)TexCoord.x=2.0-TexCoord.x;
}

}

if(enableRefraction)
{
subsurfaceSample=texture(sampler2D(g_texDepth[1 + 9]),TexCoord*g_DepthScale+vec2(g_vrRightEye*0.5,0)).x;
subsurfaceDepth=depthToFadeDistance(subsurfaceSample,vec2(In.SurePosition.x/In.SurePosition.w,In.SurePosition.y/-In.SurePosition.w),dis,g_HalfTan);
if(subsurfaceDepth<surfaceDepth)
{
TexCoord=baseTexCoord;
subsurfaceDepth=fulldepth;
}

}
else

{
subsurfaceDepth=fulldepth;
}

if(frontFacing)
{
if(subsurfaceDepth>surfaceDepth)
{
finalDepth=(subsurfaceDepth-surfaceDepth-maskedDepth)*(maskInvert?-1:1);
}
else

{
finalDepth=0.0;
}

}
else

{
finalDepth=-min(actualDepth,surfaceDepth);
if(subsurfaceDepth-maskedDepth>actualDepth)
{
backfaceOccluded=1.0;
}

}

eyeDepth=min(((g_LocalEye.z-g_boundedLocation.z)/300000.0)-(((maskInvert||noSurfaceScattering)?1:0)*(normalize(eye_vec)*(maskValue.x+maskValue.y)).z),0.0);
float4 refractColour=texture(sampler2D(g_texColour[1 + 9]),TexCoord*g_DepthScale+vec2(g_vrRightEye*0.5,0));
Output.Scattering=vec4(g_scattering,enableFoam?1:0);
Output.Absorption=vec4(g_absorption,surfaceFoamValue);
Output.RefractColour=refractColour;
Output.Normals=vec4((maskInvert?vec3(0.01,0.01,0.01):normal),backfaceOccluded);
Output.Depth=vec4(finalDepth,actualDepth,eyeDepth,surfaceDepth*(noSurfaceScattering?-1:1));
return Output;
}
layout(location = 0) in Block
{
VS_OUTPUT BlockData;
} ioblock;
layout(location = 0) out vec4 Depth;

layout(location = 1) out vec4 Scattering;

layout(location = 2) out vec4 Absorption;

layout(location = 3) out vec4 Normals;

layout(location = 4) out vec4 RefractColour;

void main()
{
VS_OUTPUT BlockData=ioblock.BlockData;
bool frontFacing=gl_FrontFacing;
#line 2324 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
bool faceDirection=(g_reverseFace!=0.0)?!frontFacing:frontFacing;
PS_WATER_OUTPUTS tmp =  PS_WaterSurfDepth(BlockData,faceDirection,false,false,false);
Depth = tmp.Depth;
Scattering = tmp.Scattering;
Absorption = tmp.Absorption;
Normals = tmp.Normals;
RefractColour = tmp.RefractColour;

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_PS_BoundedWaterSurfDepthRefraction.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 1) uniform cbShading
{
	vec3 g_SunDir;
	float g_Shineness;
	vec3 g_SunColor;
	float g_ShoreExtent;
	float g_oceanHeight;
	float g_vrRightEye;
	vec2 g_viewportPixelScale;
	int g_noOfReflectionSteps;
	int g_pixelStep;
	float g_reverseFace;
	bool g_enableFoam;
	float g_UVScale;
	float g_UVOffset;
	float g_WorldScale;
	float g_SunRadius;
	vec2 g_DepthScale;
	vec2 g_screenScale;
	vec4 g_DepthToLinFadeParams;
	vec4 g_HalfTan;
	vec3 g_ShoreDepthTextureLocation;
	float g_ShoreWidth;
	float gkfpdngkpfdp;
	float g_reflectionDistance;
	bool g_vrEnable;
	float g_reflectionBrightness;
};
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};
#line 140 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct PS_WATER_OUTPUTS
{
	vec4 Depth;
	vec4 Scattering;
	vec4 Absorption;
	vec4 Normals;
	vec4 RefractColour;
};





layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t g_texColour[24];
	uint64_t g_texDepth[24];
	uint64_t g_maskTexture[24];
	uint64_t g_ProfileBuffers[24];
	uint64_t g_InputAmplitude[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 1947 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
PS_WATER_OUTPUTS PS_WaterSurfDepth(VS_OUTPUT In, bool frontFacing, bool enableFoam, bool enableRefraction, bool waveGrid)
{
float profileOffsets[16]={0.54f,0.18f,0.61f,0.28f,0.09f,0.71f,0.99f,0.43f,0.11f,0.85f,0.24f,0.67f,0.31f,0.86f,0.13f,0.01f};
vec2 profile32Directons[32]={vec2(1.0f,0.0f),vec2(0.98f,0.19f),vec2(0.92f,0.38f),vec2(0.83f,0.55f),vec2(0.707f,0.707f),vec2(0.55f,0.83f),vec2(0.38f,0.92f),vec2(0.19f,0.98f),vec2(0.0f,1.0f),vec2(-0.19f,0.98f),vec2(-0.38f,0.92f),vec2(-0.55f,0.83f),vec2(-0.707f,0.707f),vec2(-0.83f,0.55f),vec2(-0.92f,0.38f),vec2(-0.98f,0.19f),vec2(-1.0f,-0.0f),vec2(-0.98f,-0.19f),vec2(-0.92f,-0.38f),vec2(-0.83f,-0.55f),vec2(-0.707f,-0.707f),vec2(-0.55f,-0.83f),vec2(-0.38f,-0.92f),vec2(-0.19f,-0.98f),vec2(0.0f,-1.0f),vec2(0.19f,-0.98f),vec2(0.38f,-0.92f),vec2(0.55f,-0.83f),vec2(0.707f,-0.707f),vec2(0.83f,-0.55f),vec2(0.92f,-0.38f),vec2(0.98f,-0.19f),};
PS_WATER_OUTPUTS Output;
vec3 eye_vec=g_LocalEye-In.LocalPos;
float surfaceDepth=length(eye_vec)/300000.0;
bool noWaveGrid=false;
bool maskInvert=false;
bool noSurfaceScattering=false;
float maskedDepth=0.0;
if(enableRefraction)
{
if(length(eye_vec)>100.0)
{
enableRefraction=false;
}

}

if(length(eye_vec.xy)>128.0)
{
noWaveGrid=true;
}

DepthInterpretationStruct dis;
dis.reverseDepth=true;
dis.depthToLinFadeDistParams=g_DepthToLinFadeParams;
vec2 TexCoord=((vec2(In.SurePosition.x/In.SurePosition.w,In.SurePosition.y/-In.SurePosition.w)+vec2(1.0,1.0))/2.0);
vec2 baseTexCoord=TexCoord;
float actualDepth=0.0;
float offset=0.0;
vec3 refract_vec=vec3(0.0,0.0,0.0);
vec3 viewNormal=vec3(0.0,0.0,0.0);
vec3 eyeViewVec=vec3(0.0,0.0,1.0);
float backfaceOccluded=0.0;
float foamValue=0.0;
float surfaceFoamValue=0.0;
float finalDepth;
float eyeDepth;
float subsurfaceSample;
float subsurfaceDepth;
vec3 normal=normalize(vec3(0.01,0.01,1.0f));
vec3 grad=vec3(0.0,0.0,0.0);
if(In.vecColour.x==0.0)
{
vec3 tx=vec3(0.0,0.0,0.0);
vec3 ty=vec3(0.0,0.0,0.0);
uint dirNum=16;
uint N=2*dirNum;
float dx=dirNum*6.28318530718f/N;
vec2 foamtemp=vec2(0.0,0.0);
vec2 foamtempWaveGrid=vec2(0.0,0.0);
vec2 windDirection=normalize(vec2(sin(g_windDirection),cos(g_windDirection)));
uint i;
for(i=0;i<N;i++)
{
float angle=((i)/(N))*6.28318530718f;
vec2 texcDir=normalize(profile32Directons[i]);
vec2 texc=texcDir*In.texCoords*g_profileUVScale;
vec2 gradientValue=vec2(0.0,0.0);
vec2 waveGridAmp=vec2(0.0,0.0);
float baseAmplitude=pow(((dot(windDirection,texcDir)+1.0)+((dot(-windDirection,texcDir)+1.0)*(1.0-g_windDependency)))/2.0,4.0);
vec2 windWaves=g_amplitude*In.vecColour.w*(texture(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,0.0f)).zw)*(baseAmplitude/2.0);
if(waveGrid&&!noWaveGrid)
{
waveGridAmp=(texture(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,1.0f)).zw*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(In.texCoords.x/5.0,In.texCoords.y/5.0,(i+0.5)/N),0).x);
}

gradientValue=dx*(waveGridAmp+windWaves);
tx+=texcDir.x*vec3((-gradientValue.y),0.0,-gradientValue.y);
ty+=texcDir.y*vec3(0.0,(-gradientValue.y),-gradientValue.y);
foamtemp+=dx*vec2(abs(texcDir.x)*windWaves.x,abs(texcDir.y)*windWaves.x);
foamtempWaveGrid+=dx*vec2(abs(texcDir.x)*waveGridAmp.x,abs(texcDir.y)*waveGridAmp.x);
}

vec2 temp=saturate(normalize(vec3(-foamtemp.xy,16.0)).xy);
vec2 temp2=saturate(normalize(vec3(-foamtempWaveGrid.xy,16.0)).xy);
surfaceFoamValue=max(pow(temp.x+temp.y,2.0)-(0.5-g_foamStrength),0.0)+max(pow(temp2.x+temp2.y,2.0)-0.05,0.0);
normal=normalize(vec3(tx.xy+ty.xy,float(N/4.0)));
}

float tempsample=texture(sampler2D(g_texDepth[1 + 9]),TexCoord*g_DepthScale+vec2(g_vrRightEye*0.5,0)).x;
float fulldepth=depthToFadeDistance(tempsample,vec2(In.SurePosition.x/In.SurePosition.w,In.SurePosition.y/-In.SurePosition.w),dis,g_HalfTan);
vec4 maskValue=texture(sampler2D(g_maskTexture[1 + 9]),TexCoord*g_DepthScale+vec2(g_vrRightEye*0.5,0))/300000.0;
if(frontFacing)
{
if((maskValue.x+maskValue.y>fulldepth&&maskValue.x<surfaceDepth)||(maskValue.y<0.0))
{
Output.Scattering=vec4(g_scattering,0.0);
Output.Absorption=vec4(g_absorption,0.0);
Output.RefractColour=vec4(maskValue.y,0.0,0.0,0.0);
Output.Normals=vec4(0.001,0.001,1.0,0.0);
Output.Depth=vec4(0.0,0.0,0.0,0.0);
return Output;
}

if(maskValue.x+maskValue.y>surfaceDepth&&maskValue.x<fulldepth)
{
if(maskValue.x<surfaceDepth)
{
maskInvert=true;
noSurfaceScattering=true;
maskedDepth=(maskValue.x+maskValue.y)-surfaceDepth;
}
else

{
maskedDepth=maskValue.y-max(maskValue.x+maskValue.y-fulldepth,0.0);
}

}

actualDepth=saturate(fulldepth-surfaceDepth-maskedDepth);
if(!maskInvert)
{
if(actualDepth>0.0)
{
if(enableRefraction)
{
viewNormal=mul(vec4(normal,0.0),g_matWorldViewProj).xyz;
refract_vec=normalize(refract(eyeViewVec,viewNormal,1.0/1.33));
float cosangle=acos(dot(eyeViewVec,refract_vec)/(length(eyeViewVec)*length(refract_vec)));
offset=tan(cosangle)*(actualDepth/(fulldepth-maskedDepth))*(1.0-saturate((g_LocalEye.z-In.LocalPos.z-35.0)/5.0));
TexCoord+=offset*(normalize(refract_vec.xy)*g_screenScale);
TexCoord=abs(TexCoord);
}

if(TexCoord.y>=1.0)TexCoord.y=2.0-TexCoord.y;
if(TexCoord.x>=1.0)TexCoord.x=2.0-TexCoord.x;
}
else

{
Output.Scattering=vec4(g_scattering,0.0);
Output.Absorption=vec4(g_absorption,0.0);
Output.RefractColour=vec4(0.0,0.0,0.0,0.0);
Output.Normals=vec4(0.001,0.001,1.0,0.0);
Output.Depth=vec4(0.0,0.0,0.0,0.0);
actualDepth=0.0;
return Output;
}

}

}
else

{
if(((maskValue.y>fulldepth||maskValue.y>surfaceDepth)&&maskValue.x==0.0)||(maskValue.y<0.0&&abs(maskValue.y)<fulldepth))
{
Output.Scattering=vec4(g_scattering,0.0);
Output.Absorption=vec4(g_absorption,0.0);
Output.RefractColour=vec4(maskValue.y,0.0,0.0,0.0);
Output.Normals=vec4(0.001,0.001,1.0,0.0);
Output.Depth=vec4(0.0,0.0,0.0,0.0);
return Output;
}

if(maskValue.y>0.0&&maskValue.x<fulldepth&&maskValue.x<surfaceDepth)
{
maskedDepth=maskValue.y-max((maskValue.x+maskValue.y)-min(surfaceDepth,fulldepth),0.0);
if(maskValue.x==0.0)
{
noSurfaceScattering=true;
}

if(maskValue.x!=0.0&&maskValue.x+maskValue.y>fulldepth)
{

}

}

actualDepth=min(fulldepth,surfaceDepth)-maskedDepth;
if(enableRefraction)
{
if(actualDepth==surfaceDepth-maskedDepth)
{
viewNormal=mul(vec4(-normal,0.0),g_matWorldViewProj).xyz;
refract_vec=normalize(refract(eyeViewVec,viewNormal,1.0/1.33));
float cosangle=acos(dot(-eyeViewVec,refract_vec)/(length(eyeViewVec)*length(refract_vec)));
offset=tan(cosangle)*((fulldepth-surfaceDepth)/fulldepth)*(1.0-saturate((g_LocalEye.z-In.LocalPos.z-35.0)/5.0));
TexCoord+=offset*(normalize(refract_vec.xy)*g_screenScale);
TexCoord=abs(TexCoord);
}

if(TexCoord.y>=1.0)TexCoord.y=2.0-TexCoord.y;
if(TexCoord.x>=1.0)TexCoord.x=2.0-TexCoord.x;
}

}

if(enableRefraction)
{
subsurfaceSample=texture(sampler2D(g_texDepth[1 + 9]),TexCoord*g_DepthScale+vec2(g_vrRightEye*0.5,0)).x;
subsurfaceDepth=depthToFadeDistance(subsurfaceSample,vec2(In.SurePosition.x/In.SurePosition.w,In.SurePosition.y/-In.SurePosition.w),dis,g_HalfTan);
if(subsurfaceDepth<surfaceDepth)
{
TexCoord=baseTexCoord;
subsurfaceDepth=fulldepth;
}

}
else

{
subsurfaceDepth=fulldepth;
}

if(frontFacing)
{
if(subsurfaceDepth>surfaceDepth)
{
finalDepth=(subsurfaceDepth-surfaceDepth-maskedDepth)*(maskInvert?-1:1);
}
else

{
finalDepth=0.0;
}

}
else

{
finalDepth=-min(actualDepth,surfaceDepth);
if(subsurfaceDepth-maskedDepth>actualDepth)
{
backfaceOccluded=1.0;
}

}

eyeDepth=min(((g_LocalEye.z-g_boundedLocation.z)/300000.0)-(((maskInvert||noSurfaceScattering)?1:0)*(normalize(eye_vec)*(maskValue.x+maskValue.y)).z),0.0);
float4 refractColour=texture(sampler2D(g_texColour[1 + 9]),TexCoord*g_DepthScale+vec2(g_vrRightEye*0.5,0));
Output.Scattering=vec4(g_scattering,enableFoam?1:0);
Output.Absorption=vec4(g_absorption,surfaceFoamValue);
Output.RefractColour=refractColour;
Output.Normals=vec4((maskInvert?vec3(0.01,0.01,0.01):normal),backfaceOccluded);
Output.Depth=vec4(finalDepth,actualDepth,eyeDepth,surfaceDepth*(noSurfaceScattering?-1:1));
return Output;
}
layout(location = 0) in Block
{
VS_OUTPUT BlockData;
} ioblock;
layout(location = 0) out vec4 Depth;

layout(location = 1) out vec4 Scattering;

layout(location = 2) out vec4 Absorption;

layout(location = 3) out vec4 Normals;

layout(location = 4) out vec4 RefractColour;

void main()
{
VS_OUTPUT BlockData=ioblock.BlockData;
bool frontFacing=gl_FrontFacing;
#line 2342 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
bool faceDirection=(g_reverseFace!=0.0)?!frontFacing:frontFacing;
PS_WATER_OUTPUTS tmp =  PS_WaterSurfDepth(BlockData,faceDirection,false,true,false);
Depth = tmp.Depth;
Scattering = tmp.Scattering;
Absorption = tmp.Absorption;
Normals = tmp.Normals;
RefractColour = tmp.RefractColour;

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_PS_BoundlessWaterSurfDepth.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 1) uniform cbShading
{
	vec3 g_SunDir;
	float g_Shineness;
	vec3 g_SunColor;
	float g_ShoreExtent;
	float g_oceanHeight;
	float g_vrRightEye;
	vec2 g_viewportPixelScale;
	int g_noOfReflectionSteps;
	int g_pixelStep;
	float g_reverseFace;
	bool g_enableFoam;
	float g_UVScale;
	float g_UVOffset;
	float g_WorldScale;
	float g_SunRadius;
	vec2 g_DepthScale;
	vec2 g_screenScale;
	vec4 g_DepthToLinFadeParams;
	vec4 g_HalfTan;
	vec3 g_ShoreDepthTextureLocation;
	float g_ShoreWidth;
	float gkfpdngkpfdp;
	float g_reflectionDistance;
	bool g_vrEnable;
	float g_reflectionBrightness;
};
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};
#line 140 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct PS_WATER_OUTPUTS
{
	vec4 Depth;
	vec4 Scattering;
	vec4 Absorption;
	vec4 Normals;
	vec4 RefractColour;
};





layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t g_texColour[24];
	uint64_t g_texDepth[24];
	uint64_t g_maskTexture[24];
	uint64_t g_ProfileBuffers[24];
	uint64_t g_InputAmplitude[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 1947 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
PS_WATER_OUTPUTS PS_WaterSurfDepth(VS_OUTPUT In, bool frontFacing, bool enableFoam, bool enableRefraction, bool waveGrid)
{
float profileOffsets[16]={0.54f,0.18f,0.61f,0.28f,0.09f,0.71f,0.99f,0.43f,0.11f,0.85f,0.24f,0.67f,0.31f,0.86f,0.13f,0.01f};
vec2 profile32Directons[32]={vec2(1.0f,0.0f),vec2(0.98f,0.19f),vec2(0.92f,0.38f),vec2(0.83f,0.55f),vec2(0.707f,0.707f),vec2(0.55f,0.83f),vec2(0.38f,0.92f),vec2(0.19f,0.98f),vec2(0.0f,1.0f),vec2(-0.19f,0.98f),vec2(-0.38f,0.92f),vec2(-0.55f,0.83f),vec2(-0.707f,0.707f),vec2(-0.83f,0.55f),vec2(-0.92f,0.38f),vec2(-0.98f,0.19f),vec2(-1.0f,-0.0f),vec2(-0.98f,-0.19f),vec2(-0.92f,-0.38f),vec2(-0.83f,-0.55f),vec2(-0.707f,-0.707f),vec2(-0.55f,-0.83f),vec2(-0.38f,-0.92f),vec2(-0.19f,-0.98f),vec2(0.0f,-1.0f),vec2(0.19f,-0.98f),vec2(0.38f,-0.92f),vec2(0.55f,-0.83f),vec2(0.707f,-0.707f),vec2(0.83f,-0.55f),vec2(0.92f,-0.38f),vec2(0.98f,-0.19f),};
PS_WATER_OUTPUTS Output;
vec3 eye_vec=g_LocalEye-In.LocalPos;
float surfaceDepth=length(eye_vec)/300000.0;
bool noWaveGrid=false;
bool maskInvert=false;
bool noSurfaceScattering=false;
float maskedDepth=0.0;
if(enableRefraction)
{
if(length(eye_vec)>100.0)
{
enableRefraction=false;
}

}

if(length(eye_vec.xy)>128.0)
{
noWaveGrid=true;
}

DepthInterpretationStruct dis;
dis.reverseDepth=true;
dis.depthToLinFadeDistParams=g_DepthToLinFadeParams;
vec2 TexCoord=((vec2(In.SurePosition.x/In.SurePosition.w,In.SurePosition.y/-In.SurePosition.w)+vec2(1.0,1.0))/2.0);
vec2 baseTexCoord=TexCoord;
float actualDepth=0.0;
float offset=0.0;
vec3 refract_vec=vec3(0.0,0.0,0.0);
vec3 viewNormal=vec3(0.0,0.0,0.0);
vec3 eyeViewVec=vec3(0.0,0.0,1.0);
float backfaceOccluded=0.0;
float foamValue=0.0;
float surfaceFoamValue=0.0;
float finalDepth;
float eyeDepth;
float subsurfaceSample;
float subsurfaceDepth;
vec3 normal=normalize(vec3(0.01,0.01,1.0f));
vec3 grad=vec3(0.0,0.0,0.0);
if(In.vecColour.x==0.0)
{
vec3 tx=vec3(0.0,0.0,0.0);
vec3 ty=vec3(0.0,0.0,0.0);
uint dirNum=16;
uint N=2*dirNum;
float dx=dirNum*6.28318530718f/N;
vec2 foamtemp=vec2(0.0,0.0);
vec2 foamtempWaveGrid=vec2(0.0,0.0);
vec2 windDirection=normalize(vec2(sin(g_windDirection),cos(g_windDirection)));
uint i;
for(i=0;i<N;i++)
{
float angle=((i)/(N))*6.28318530718f;
vec2 texcDir=normalize(profile32Directons[i]);
vec2 texc=texcDir*In.texCoords*g_profileUVScale;
vec2 gradientValue=vec2(0.0,0.0);
vec2 waveGridAmp=vec2(0.0,0.0);
float baseAmplitude=pow(((dot(windDirection,texcDir)+1.0)+((dot(-windDirection,texcDir)+1.0)*(1.0-g_windDependency)))/2.0,4.0);
vec2 windWaves=g_amplitude*In.vecColour.w*(texture(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,0.0f)).zw)*(baseAmplitude/2.0);
if(waveGrid&&!noWaveGrid)
{
waveGridAmp=(texture(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,1.0f)).zw*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(In.texCoords.x/5.0,In.texCoords.y/5.0,(i+0.5)/N),0).x);
}

gradientValue=dx*(waveGridAmp+windWaves);
tx+=texcDir.x*vec3((-gradientValue.y),0.0,-gradientValue.y);
ty+=texcDir.y*vec3(0.0,(-gradientValue.y),-gradientValue.y);
foamtemp+=dx*vec2(abs(texcDir.x)*windWaves.x,abs(texcDir.y)*windWaves.x);
foamtempWaveGrid+=dx*vec2(abs(texcDir.x)*waveGridAmp.x,abs(texcDir.y)*waveGridAmp.x);
}

vec2 temp=saturate(normalize(vec3(-foamtemp.xy,16.0)).xy);
vec2 temp2=saturate(normalize(vec3(-foamtempWaveGrid.xy,16.0)).xy);
surfaceFoamValue=max(pow(temp.x+temp.y,2.0)-(0.5-g_foamStrength),0.0)+max(pow(temp2.x+temp2.y,2.0)-0.05,0.0);
normal=normalize(vec3(tx.xy+ty.xy,float(N/4.0)));
}

float tempsample=texture(sampler2D(g_texDepth[1 + 9]),TexCoord*g_DepthScale+vec2(g_vrRightEye*0.5,0)).x;
float fulldepth=depthToFadeDistance(tempsample,vec2(In.SurePosition.x/In.SurePosition.w,In.SurePosition.y/-In.SurePosition.w),dis,g_HalfTan);
vec4 maskValue=texture(sampler2D(g_maskTexture[1 + 9]),TexCoord*g_DepthScale+vec2(g_vrRightEye*0.5,0))/300000.0;
if(frontFacing)
{
if((maskValue.x+maskValue.y>fulldepth&&maskValue.x<surfaceDepth)||(maskValue.y<0.0))
{
Output.Scattering=vec4(g_scattering,0.0);
Output.Absorption=vec4(g_absorption,0.0);
Output.RefractColour=vec4(maskValue.y,0.0,0.0,0.0);
Output.Normals=vec4(0.001,0.001,1.0,0.0);
Output.Depth=vec4(0.0,0.0,0.0,0.0);
return Output;
}

if(maskValue.x+maskValue.y>surfaceDepth&&maskValue.x<fulldepth)
{
if(maskValue.x<surfaceDepth)
{
maskInvert=true;
noSurfaceScattering=true;
maskedDepth=(maskValue.x+maskValue.y)-surfaceDepth;
}
else

{
maskedDepth=maskValue.y-max(maskValue.x+maskValue.y-fulldepth,0.0);
}

}

actualDepth=saturate(fulldepth-surfaceDepth-maskedDepth);
if(!maskInvert)
{
if(actualDepth>0.0)
{
if(enableRefraction)
{
viewNormal=mul(vec4(normal,0.0),g_matWorldViewProj).xyz;
refract_vec=normalize(refract(eyeViewVec,viewNormal,1.0/1.33));
float cosangle=acos(dot(eyeViewVec,refract_vec)/(length(eyeViewVec)*length(refract_vec)));
offset=tan(cosangle)*(actualDepth/(fulldepth-maskedDepth))*(1.0-saturate((g_LocalEye.z-In.LocalPos.z-35.0)/5.0));
TexCoord+=offset*(normalize(refract_vec.xy)*g_screenScale);
TexCoord=abs(TexCoord);
}

if(TexCoord.y>=1.0)TexCoord.y=2.0-TexCoord.y;
if(TexCoord.x>=1.0)TexCoord.x=2.0-TexCoord.x;
}
else

{
Output.Scattering=vec4(g_scattering,0.0);
Output.Absorption=vec4(g_absorption,0.0);
Output.RefractColour=vec4(0.0,0.0,0.0,0.0);
Output.Normals=vec4(0.001,0.001,1.0,0.0);
Output.Depth=vec4(0.0,0.0,0.0,0.0);
actualDepth=0.0;
return Output;
}

}

}
else

{
if(((maskValue.y>fulldepth||maskValue.y>surfaceDepth)&&maskValue.x==0.0)||(maskValue.y<0.0&&abs(maskValue.y)<fulldepth))
{
Output.Scattering=vec4(g_scattering,0.0);
Output.Absorption=vec4(g_absorption,0.0);
Output.RefractColour=vec4(maskValue.y,0.0,0.0,0.0);
Output.Normals=vec4(0.001,0.001,1.0,0.0);
Output.Depth=vec4(0.0,0.0,0.0,0.0);
return Output;
}

if(maskValue.y>0.0&&maskValue.x<fulldepth&&maskValue.x<surfaceDepth)
{
maskedDepth=maskValue.y-max((maskValue.x+maskValue.y)-min(surfaceDepth,fulldepth),0.0);
if(maskValue.x==0.0)
{
noSurfaceScattering=true;
}

if(maskValue.x!=0.0&&maskValue.x+maskValue.y>fulldepth)
{

}

}

actualDepth=min(fulldepth,surfaceDepth)-maskedDepth;
if(enableRefraction)
{
if(actualDepth==surfaceDepth-maskedDepth)
{
viewNormal=mul(vec4(-normal,0.0),g_matWorldViewProj).xyz;
refract_vec=normalize(refract(eyeViewVec,viewNormal,1.0/1.33));
float cosangle=acos(dot(-eyeViewVec,refract_vec)/(length(eyeViewVec)*length(refract_vec)));
offset=tan(cosangle)*((fulldepth-surfaceDepth)/fulldepth)*(1.0-saturate((g_LocalEye.z-In.LocalPos.z-35.0)/5.0));
TexCoord+=offset*(normalize(refract_vec.xy)*g_screenScale);
TexCoord=abs(TexCoord);
}

if(TexCoord.y>=1.0)TexCoord.y=2.0-TexCoord.y;
if(TexCoord.x>=1.0)TexCoord.x=2.0-TexCoord.x;
}

}

if(enableRefraction)
{
subsurfaceSample=texture(sampler2D(g_texDepth[1 + 9]),TexCoord*g_DepthScale+vec2(g_vrRightEye*0.5,0)).x;
subsurfaceDepth=depthToFadeDistance(subsurfaceSample,vec2(In.SurePosition.x/In.SurePosition.w,In.SurePosition.y/-In.SurePosition.w),dis,g_HalfTan);
if(subsurfaceDepth<surfaceDepth)
{
TexCoord=baseTexCoord;
subsurfaceDepth=fulldepth;
}

}
else

{
subsurfaceDepth=fulldepth;
}

if(frontFacing)
{
if(subsurfaceDepth>surfaceDepth)
{
finalDepth=(subsurfaceDepth-surfaceDepth-maskedDepth)*(maskInvert?-1:1);
}
else

{
finalDepth=0.0;
}

}
else

{
finalDepth=-min(actualDepth,surfaceDepth);
if(subsurfaceDepth-maskedDepth>actualDepth)
{
backfaceOccluded=1.0;
}

}

eyeDepth=min(((g_LocalEye.z-g_boundedLocation.z)/300000.0)-(((maskInvert||noSurfaceScattering)?1:0)*(normalize(eye_vec)*(maskValue.x+maskValue.y)).z),0.0);
float4 refractColour=texture(sampler2D(g_texColour[1 + 9]),TexCoord*g_DepthScale+vec2(g_vrRightEye*0.5,0));
Output.Scattering=vec4(g_scattering,enableFoam?1:0);
Output.Absorption=vec4(g_absorption,surfaceFoamValue);
Output.RefractColour=refractColour;
Output.Normals=vec4((maskInvert?vec3(0.01,0.01,0.01):normal),backfaceOccluded);
Output.Depth=vec4(finalDepth,actualDepth,eyeDepth,surfaceDepth*(noSurfaceScattering?-1:1));
return Output;
}
layout(location = 0) in Block
{
VS_OUTPUT BlockData;
} ioblock;
layout(location = 0) out vec4 Depth;

layout(location = 1) out vec4 Scattering;

layout(location = 2) out vec4 Absorption;

layout(location = 3) out vec4 Normals;

layout(location = 4) out vec4 RefractColour;

void main()
{
VS_OUTPUT BlockData=ioblock.BlockData;
bool frontFacing=gl_FrontFacing;
#line 2312 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
bool faceDirection=(g_reverseFace!=0.0)?!frontFacing:frontFacing;
PS_WATER_OUTPUTS tmp =  PS_WaterSurfDepth(BlockData,faceDirection,g_enableFoam,false,false);
Depth = tmp.Depth;
Scattering = tmp.Scattering;
Absorption = tmp.Absorption;
Normals = tmp.Normals;
RefractColour = tmp.RefractColour;

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_PS_BoundlessWaterSurfDepthRefraction.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 1) uniform cbShading
{
	vec3 g_SunDir;
	float g_Shineness;
	vec3 g_SunColor;
	float g_ShoreExtent;
	float g_oceanHeight;
	float g_vrRightEye;
	vec2 g_viewportPixelScale;
	int g_noOfReflectionSteps;
	int g_pixelStep;
	float g_reverseFace;
	bool g_enableFoam;
	float g_UVScale;
	float g_UVOffset;
	float g_WorldScale;
	float g_SunRadius;
	vec2 g_DepthScale;
	vec2 g_screenScale;
	vec4 g_DepthToLinFadeParams;
	vec4 g_HalfTan;
	vec3 g_ShoreDepthTextureLocation;
	float g_ShoreWidth;
	float gkfpdngkpfdp;
	float g_reflectionDistance;
	bool g_vrEnable;
	float g_reflectionBrightness;
};
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};
#line 140 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct PS_WATER_OUTPUTS
{
	vec4 Depth;
	vec4 Scattering;
	vec4 Absorption;
	vec4 Normals;
	vec4 RefractColour;
};





layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t g_texColour[24];
	uint64_t g_texDepth[24];
	uint64_t g_maskTexture[24];
	uint64_t g_ProfileBuffers[24];
	uint64_t g_InputAmplitude[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 1947 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
PS_WATER_OUTPUTS PS_WaterSurfDepth(VS_OUTPUT In, bool frontFacing, bool enableFoam, bool enableRefraction, bool waveGrid)
{
float profileOffsets[16]={0.54f,0.18f,0.61f,0.28f,0.09f,0.71f,0.99f,0.43f,0.11f,0.85f,0.24f,0.67f,0.31f,0.86f,0.13f,0.01f};
vec2 profile32Directons[32]={vec2(1.0f,0.0f),vec2(0.98f,0.19f),vec2(0.92f,0.38f),vec2(0.83f,0.55f),vec2(0.707f,0.707f),vec2(0.55f,0.83f),vec2(0.38f,0.92f),vec2(0.19f,0.98f),vec2(0.0f,1.0f),vec2(-0.19f,0.98f),vec2(-0.38f,0.92f),vec2(-0.55f,0.83f),vec2(-0.707f,0.707f),vec2(-0.83f,0.55f),vec2(-0.92f,0.38f),vec2(-0.98f,0.19f),vec2(-1.0f,-0.0f),vec2(-0.98f,-0.19f),vec2(-0.92f,-0.38f),vec2(-0.83f,-0.55f),vec2(-0.707f,-0.707f),vec2(-0.55f,-0.83f),vec2(-0.38f,-0.92f),vec2(-0.19f,-0.98f),vec2(0.0f,-1.0f),vec2(0.19f,-0.98f),vec2(0.38f,-0.92f),vec2(0.55f,-0.83f),vec2(0.707f,-0.707f),vec2(0.83f,-0.55f),vec2(0.92f,-0.38f),vec2(0.98f,-0.19f),};
PS_WATER_OUTPUTS Output;
vec3 eye_vec=g_LocalEye-In.LocalPos;
float surfaceDepth=length(eye_vec)/300000.0;
bool noWaveGrid=false;
bool maskInvert=false;
bool noSurfaceScattering=false;
float maskedDepth=0.0;
if(enableRefraction)
{
if(length(eye_vec)>100.0)
{
enableRefraction=false;
}

}

if(length(eye_vec.xy)>128.0)
{
noWaveGrid=true;
}

DepthInterpretationStruct dis;
dis.reverseDepth=true;
dis.depthToLinFadeDistParams=g_DepthToLinFadeParams;
vec2 TexCoord=((vec2(In.SurePosition.x/In.SurePosition.w,In.SurePosition.y/-In.SurePosition.w)+vec2(1.0,1.0))/2.0);
vec2 baseTexCoord=TexCoord;
float actualDepth=0.0;
float offset=0.0;
vec3 refract_vec=vec3(0.0,0.0,0.0);
vec3 viewNormal=vec3(0.0,0.0,0.0);
vec3 eyeViewVec=vec3(0.0,0.0,1.0);
float backfaceOccluded=0.0;
float foamValue=0.0;
float surfaceFoamValue=0.0;
float finalDepth;
float eyeDepth;
float subsurfaceSample;
float subsurfaceDepth;
vec3 normal=normalize(vec3(0.01,0.01,1.0f));
vec3 grad=vec3(0.0,0.0,0.0);
if(In.vecColour.x==0.0)
{
vec3 tx=vec3(0.0,0.0,0.0);
vec3 ty=vec3(0.0,0.0,0.0);
uint dirNum=16;
uint N=2*dirNum;
float dx=dirNum*6.28318530718f/N;
vec2 foamtemp=vec2(0.0,0.0);
vec2 foamtempWaveGrid=vec2(0.0,0.0);
vec2 windDirection=normalize(vec2(sin(g_windDirection),cos(g_windDirection)));
uint i;
for(i=0;i<N;i++)
{
float angle=((i)/(N))*6.28318530718f;
vec2 texcDir=normalize(profile32Directons[i]);
vec2 texc=texcDir*In.texCoords*g_profileUVScale;
vec2 gradientValue=vec2(0.0,0.0);
vec2 waveGridAmp=vec2(0.0,0.0);
float baseAmplitude=pow(((dot(windDirection,texcDir)+1.0)+((dot(-windDirection,texcDir)+1.0)*(1.0-g_windDependency)))/2.0,4.0);
vec2 windWaves=g_amplitude*In.vecColour.w*(texture(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,0.0f)).zw)*(baseAmplitude/2.0);
if(waveGrid&&!noWaveGrid)
{
waveGridAmp=(texture(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,1.0f)).zw*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(In.texCoords.x/5.0,In.texCoords.y/5.0,(i+0.5)/N),0).x);
}

gradientValue=dx*(waveGridAmp+windWaves);
tx+=texcDir.x*vec3((-gradientValue.y),0.0,-gradientValue.y);
ty+=texcDir.y*vec3(0.0,(-gradientValue.y),-gradientValue.y);
foamtemp+=dx*vec2(abs(texcDir.x)*windWaves.x,abs(texcDir.y)*windWaves.x);
foamtempWaveGrid+=dx*vec2(abs(texcDir.x)*waveGridAmp.x,abs(texcDir.y)*waveGridAmp.x);
}

vec2 temp=saturate(normalize(vec3(-foamtemp.xy,16.0)).xy);
vec2 temp2=saturate(normalize(vec3(-foamtempWaveGrid.xy,16.0)).xy);
surfaceFoamValue=max(pow(temp.x+temp.y,2.0)-(0.5-g_foamStrength),0.0)+max(pow(temp2.x+temp2.y,2.0)-0.05,0.0);
normal=normalize(vec3(tx.xy+ty.xy,float(N/4.0)));
}

float tempsample=texture(sampler2D(g_texDepth[1 + 9]),TexCoord*g_DepthScale+vec2(g_vrRightEye*0.5,0)).x;
float fulldepth=depthToFadeDistance(tempsample,vec2(In.SurePosition.x/In.SurePosition.w,In.SurePosition.y/-In.SurePosition.w),dis,g_HalfTan);
vec4 maskValue=texture(sampler2D(g_maskTexture[1 + 9]),TexCoord*g_DepthScale+vec2(g_vrRightEye*0.5,0))/300000.0;
if(frontFacing)
{
if((maskValue.x+maskValue.y>fulldepth&&maskValue.x<surfaceDepth)||(maskValue.y<0.0))
{
Output.Scattering=vec4(g_scattering,0.0);
Output.Absorption=vec4(g_absorption,0.0);
Output.RefractColour=vec4(maskValue.y,0.0,0.0,0.0);
Output.Normals=vec4(0.001,0.001,1.0,0.0);
Output.Depth=vec4(0.0,0.0,0.0,0.0);
return Output;
}

if(maskValue.x+maskValue.y>surfaceDepth&&maskValue.x<fulldepth)
{
if(maskValue.x<surfaceDepth)
{
maskInvert=true;
noSurfaceScattering=true;
maskedDepth=(maskValue.x+maskValue.y)-surfaceDepth;
}
else

{
maskedDepth=maskValue.y-max(maskValue.x+maskValue.y-fulldepth,0.0);
}

}

actualDepth=saturate(fulldepth-surfaceDepth-maskedDepth);
if(!maskInvert)
{
if(actualDepth>0.0)
{
if(enableRefraction)
{
viewNormal=mul(vec4(normal,0.0),g_matWorldViewProj).xyz;
refract_vec=normalize(refract(eyeViewVec,viewNormal,1.0/1.33));
float cosangle=acos(dot(eyeViewVec,refract_vec)/(length(eyeViewVec)*length(refract_vec)));
offset=tan(cosangle)*(actualDepth/(fulldepth-maskedDepth))*(1.0-saturate((g_LocalEye.z-In.LocalPos.z-35.0)/5.0));
TexCoord+=offset*(normalize(refract_vec.xy)*g_screenScale);
TexCoord=abs(TexCoord);
}

if(TexCoord.y>=1.0)TexCoord.y=2.0-TexCoord.y;
if(TexCoord.x>=1.0)TexCoord.x=2.0-TexCoord.x;
}
else

{
Output.Scattering=vec4(g_scattering,0.0);
Output.Absorption=vec4(g_absorption,0.0);
Output.RefractColour=vec4(0.0,0.0,0.0,0.0);
Output.Normals=vec4(0.001,0.001,1.0,0.0);
Output.Depth=vec4(0.0,0.0,0.0,0.0);
actualDepth=0.0;
return Output;
}

}

}
else

{
if(((maskValue.y>fulldepth||maskValue.y>surfaceDepth)&&maskValue.x==0.0)||(maskValue.y<0.0&&abs(maskValue.y)<fulldepth))
{
Output.Scattering=vec4(g_scattering,0.0);
Output.Absorption=vec4(g_absorption,0.0);
Output.RefractColour=vec4(maskValue.y,0.0,0.0,0.0);
Output.Normals=vec4(0.001,0.001,1.0,0.0);
Output.Depth=vec4(0.0,0.0,0.0,0.0);
return Output;
}

if(maskValue.y>0.0&&maskValue.x<fulldepth&&maskValue.x<surfaceDepth)
{
maskedDepth=maskValue.y-max((maskValue.x+maskValue.y)-min(surfaceDepth,fulldepth),0.0);
if(maskValue.x==0.0)
{
noSurfaceScattering=true;
}

if(maskValue.x!=0.0&&maskValue.x+maskValue.y>fulldepth)
{

}

}

actualDepth=min(fulldepth,surfaceDepth)-maskedDepth;
if(enableRefraction)
{
if(actualDepth==surfaceDepth-maskedDepth)
{
viewNormal=mul(vec4(-normal,0.0),g_matWorldViewProj).xyz;
refract_vec=normalize(refract(eyeViewVec,viewNormal,1.0/1.33));
float cosangle=acos(dot(-eyeViewVec,refract_vec)/(length(eyeViewVec)*length(refract_vec)));
offset=tan(cosangle)*((fulldepth-surfaceDepth)/fulldepth)*(1.0-saturate((g_LocalEye.z-In.LocalPos.z-35.0)/5.0));
TexCoord+=offset*(normalize(refract_vec.xy)*g_screenScale);
TexCoord=abs(TexCoord);
}

if(TexCoord.y>=1.0)TexCoord.y=2.0-TexCoord.y;
if(TexCoord.x>=1.0)TexCoord.x=2.0-TexCoord.x;
}

}

if(enableRefraction)
{
subsurfaceSample=texture(sampler2D(g_texDepth[1 + 9]),TexCoord*g_DepthScale+vec2(g_vrRightEye*0.5,0)).x;
subsurfaceDepth=depthToFadeDistance(subsurfaceSample,vec2(In.SurePosition.x/In.SurePosition.w,In.SurePosition.y/-In.SurePosition.w),dis,g_HalfTan);
if(subsurfaceDepth<surfaceDepth)
{
TexCoord=baseTexCoord;
subsurfaceDepth=fulldepth;
}

}
else

{
subsurfaceDepth=fulldepth;
}

if(frontFacing)
{
if(subsurfaceDepth>surfaceDepth)
{
finalDepth=(subsurfaceDepth-surfaceDepth-maskedDepth)*(maskInvert?-1:1);
}
else

{
finalDepth=0.0;
}

}
else

{
finalDepth=-min(actualDepth,surfaceDepth);
if(subsurfaceDepth-maskedDepth>actualDepth)
{
backfaceOccluded=1.0;
}

}

eyeDepth=min(((g_LocalEye.z-g_boundedLocation.z)/300000.0)-(((maskInvert||noSurfaceScattering)?1:0)*(normalize(eye_vec)*(maskValue.x+maskValue.y)).z),0.0);
float4 refractColour=texture(sampler2D(g_texColour[1 + 9]),TexCoord*g_DepthScale+vec2(g_vrRightEye*0.5,0));
Output.Scattering=vec4(g_scattering,enableFoam?1:0);
Output.Absorption=vec4(g_absorption,surfaceFoamValue);
Output.RefractColour=refractColour;
Output.Normals=vec4((maskInvert?vec3(0.01,0.01,0.01):normal),backfaceOccluded);
Output.Depth=vec4(finalDepth,actualDepth,eyeDepth,surfaceDepth*(noSurfaceScattering?-1:1));
return Output;
}
layout(location = 0) in Block
{
VS_OUTPUT BlockData;
} ioblock;
layout(location = 0) out vec4 Depth;

layout(location = 1) out vec4 Scattering;

layout(location = 2) out vec4 Absorption;

layout(location = 3) out vec4 Normals;

layout(location = 4) out vec4 RefractColour;

void main()
{
VS_OUTPUT BlockData=ioblock.BlockData;
bool frontFacing=gl_FrontFacing;
#line 2330 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
bool faceDirection=(g_reverseFace!=0.0)?!frontFacing:frontFacing;
PS_WATER_OUTPUTS tmp =  PS_WaterSurfDepth(BlockData,faceDirection,g_enableFoam,true,false);
Depth = tmp.Depth;
Scattering = tmp.Scattering;
Absorption = tmp.Absorption;
Normals = tmp.Normals;
RefractColour = tmp.RefractColour;

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_PS_BoundlessWaterSurfDepthRefractionWaveGrid.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 1) uniform cbShading
{
	vec3 g_SunDir;
	float g_Shineness;
	vec3 g_SunColor;
	float g_ShoreExtent;
	float g_oceanHeight;
	float g_vrRightEye;
	vec2 g_viewportPixelScale;
	int g_noOfReflectionSteps;
	int g_pixelStep;
	float g_reverseFace;
	bool g_enableFoam;
	float g_UVScale;
	float g_UVOffset;
	float g_WorldScale;
	float g_SunRadius;
	vec2 g_DepthScale;
	vec2 g_screenScale;
	vec4 g_DepthToLinFadeParams;
	vec4 g_HalfTan;
	vec3 g_ShoreDepthTextureLocation;
	float g_ShoreWidth;
	float gkfpdngkpfdp;
	float g_reflectionDistance;
	bool g_vrEnable;
	float g_reflectionBrightness;
};
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};
#line 140 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct PS_WATER_OUTPUTS
{
	vec4 Depth;
	vec4 Scattering;
	vec4 Absorption;
	vec4 Normals;
	vec4 RefractColour;
};





layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t g_texColour[24];
	uint64_t g_texDepth[24];
	uint64_t g_maskTexture[24];
	uint64_t g_ProfileBuffers[24];
	uint64_t g_InputAmplitude[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 1947 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
PS_WATER_OUTPUTS PS_WaterSurfDepth(VS_OUTPUT In, bool frontFacing, bool enableFoam, bool enableRefraction, bool waveGrid)
{
float profileOffsets[16]={0.54f,0.18f,0.61f,0.28f,0.09f,0.71f,0.99f,0.43f,0.11f,0.85f,0.24f,0.67f,0.31f,0.86f,0.13f,0.01f};
vec2 profile32Directons[32]={vec2(1.0f,0.0f),vec2(0.98f,0.19f),vec2(0.92f,0.38f),vec2(0.83f,0.55f),vec2(0.707f,0.707f),vec2(0.55f,0.83f),vec2(0.38f,0.92f),vec2(0.19f,0.98f),vec2(0.0f,1.0f),vec2(-0.19f,0.98f),vec2(-0.38f,0.92f),vec2(-0.55f,0.83f),vec2(-0.707f,0.707f),vec2(-0.83f,0.55f),vec2(-0.92f,0.38f),vec2(-0.98f,0.19f),vec2(-1.0f,-0.0f),vec2(-0.98f,-0.19f),vec2(-0.92f,-0.38f),vec2(-0.83f,-0.55f),vec2(-0.707f,-0.707f),vec2(-0.55f,-0.83f),vec2(-0.38f,-0.92f),vec2(-0.19f,-0.98f),vec2(0.0f,-1.0f),vec2(0.19f,-0.98f),vec2(0.38f,-0.92f),vec2(0.55f,-0.83f),vec2(0.707f,-0.707f),vec2(0.83f,-0.55f),vec2(0.92f,-0.38f),vec2(0.98f,-0.19f),};
PS_WATER_OUTPUTS Output;
vec3 eye_vec=g_LocalEye-In.LocalPos;
float surfaceDepth=length(eye_vec)/300000.0;
bool noWaveGrid=false;
bool maskInvert=false;
bool noSurfaceScattering=false;
float maskedDepth=0.0;
if(enableRefraction)
{
if(length(eye_vec)>100.0)
{
enableRefraction=false;
}

}

if(length(eye_vec.xy)>128.0)
{
noWaveGrid=true;
}

DepthInterpretationStruct dis;
dis.reverseDepth=true;
dis.depthToLinFadeDistParams=g_DepthToLinFadeParams;
vec2 TexCoord=((vec2(In.SurePosition.x/In.SurePosition.w,In.SurePosition.y/-In.SurePosition.w)+vec2(1.0,1.0))/2.0);
vec2 baseTexCoord=TexCoord;
float actualDepth=0.0;
float offset=0.0;
vec3 refract_vec=vec3(0.0,0.0,0.0);
vec3 viewNormal=vec3(0.0,0.0,0.0);
vec3 eyeViewVec=vec3(0.0,0.0,1.0);
float backfaceOccluded=0.0;
float foamValue=0.0;
float surfaceFoamValue=0.0;
float finalDepth;
float eyeDepth;
float subsurfaceSample;
float subsurfaceDepth;
vec3 normal=normalize(vec3(0.01,0.01,1.0f));
vec3 grad=vec3(0.0,0.0,0.0);
if(In.vecColour.x==0.0)
{
vec3 tx=vec3(0.0,0.0,0.0);
vec3 ty=vec3(0.0,0.0,0.0);
uint dirNum=16;
uint N=2*dirNum;
float dx=dirNum*6.28318530718f/N;
vec2 foamtemp=vec2(0.0,0.0);
vec2 foamtempWaveGrid=vec2(0.0,0.0);
vec2 windDirection=normalize(vec2(sin(g_windDirection),cos(g_windDirection)));
uint i;
for(i=0;i<N;i++)
{
float angle=((i)/(N))*6.28318530718f;
vec2 texcDir=normalize(profile32Directons[i]);
vec2 texc=texcDir*In.texCoords*g_profileUVScale;
vec2 gradientValue=vec2(0.0,0.0);
vec2 waveGridAmp=vec2(0.0,0.0);
float baseAmplitude=pow(((dot(windDirection,texcDir)+1.0)+((dot(-windDirection,texcDir)+1.0)*(1.0-g_windDependency)))/2.0,4.0);
vec2 windWaves=g_amplitude*In.vecColour.w*(texture(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,0.0f)).zw)*(baseAmplitude/2.0);
if(waveGrid&&!noWaveGrid)
{
waveGridAmp=(texture(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,1.0f)).zw*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(In.texCoords.x/5.0,In.texCoords.y/5.0,(i+0.5)/N),0).x);
}

gradientValue=dx*(waveGridAmp+windWaves);
tx+=texcDir.x*vec3((-gradientValue.y),0.0,-gradientValue.y);
ty+=texcDir.y*vec3(0.0,(-gradientValue.y),-gradientValue.y);
foamtemp+=dx*vec2(abs(texcDir.x)*windWaves.x,abs(texcDir.y)*windWaves.x);
foamtempWaveGrid+=dx*vec2(abs(texcDir.x)*waveGridAmp.x,abs(texcDir.y)*waveGridAmp.x);
}

vec2 temp=saturate(normalize(vec3(-foamtemp.xy,16.0)).xy);
vec2 temp2=saturate(normalize(vec3(-foamtempWaveGrid.xy,16.0)).xy);
surfaceFoamValue=max(pow(temp.x+temp.y,2.0)-(0.5-g_foamStrength),0.0)+max(pow(temp2.x+temp2.y,2.0)-0.05,0.0);
normal=normalize(vec3(tx.xy+ty.xy,float(N/4.0)));
}

float tempsample=texture(sampler2D(g_texDepth[1 + 9]),TexCoord*g_DepthScale+vec2(g_vrRightEye*0.5,0)).x;
float fulldepth=depthToFadeDistance(tempsample,vec2(In.SurePosition.x/In.SurePosition.w,In.SurePosition.y/-In.SurePosition.w),dis,g_HalfTan);
vec4 maskValue=texture(sampler2D(g_maskTexture[1 + 9]),TexCoord*g_DepthScale+vec2(g_vrRightEye*0.5,0))/300000.0;
if(frontFacing)
{
if((maskValue.x+maskValue.y>fulldepth&&maskValue.x<surfaceDepth)||(maskValue.y<0.0))
{
Output.Scattering=vec4(g_scattering,0.0);
Output.Absorption=vec4(g_absorption,0.0);
Output.RefractColour=vec4(maskValue.y,0.0,0.0,0.0);
Output.Normals=vec4(0.001,0.001,1.0,0.0);
Output.Depth=vec4(0.0,0.0,0.0,0.0);
return Output;
}

if(maskValue.x+maskValue.y>surfaceDepth&&maskValue.x<fulldepth)
{
if(maskValue.x<surfaceDepth)
{
maskInvert=true;
noSurfaceScattering=true;
maskedDepth=(maskValue.x+maskValue.y)-surfaceDepth;
}
else

{
maskedDepth=maskValue.y-max(maskValue.x+maskValue.y-fulldepth,0.0);
}

}

actualDepth=saturate(fulldepth-surfaceDepth-maskedDepth);
if(!maskInvert)
{
if(actualDepth>0.0)
{
if(enableRefraction)
{
viewNormal=mul(vec4(normal,0.0),g_matWorldViewProj).xyz;
refract_vec=normalize(refract(eyeViewVec,viewNormal,1.0/1.33));
float cosangle=acos(dot(eyeViewVec,refract_vec)/(length(eyeViewVec)*length(refract_vec)));
offset=tan(cosangle)*(actualDepth/(fulldepth-maskedDepth))*(1.0-saturate((g_LocalEye.z-In.LocalPos.z-35.0)/5.0));
TexCoord+=offset*(normalize(refract_vec.xy)*g_screenScale);
TexCoord=abs(TexCoord);
}

if(TexCoord.y>=1.0)TexCoord.y=2.0-TexCoord.y;
if(TexCoord.x>=1.0)TexCoord.x=2.0-TexCoord.x;
}
else

{
Output.Scattering=vec4(g_scattering,0.0);
Output.Absorption=vec4(g_absorption,0.0);
Output.RefractColour=vec4(0.0,0.0,0.0,0.0);
Output.Normals=vec4(0.001,0.001,1.0,0.0);
Output.Depth=vec4(0.0,0.0,0.0,0.0);
actualDepth=0.0;
return Output;
}

}

}
else

{
if(((maskValue.y>fulldepth||maskValue.y>surfaceDepth)&&maskValue.x==0.0)||(maskValue.y<0.0&&abs(maskValue.y)<fulldepth))
{
Output.Scattering=vec4(g_scattering,0.0);
Output.Absorption=vec4(g_absorption,0.0);
Output.RefractColour=vec4(maskValue.y,0.0,0.0,0.0);
Output.Normals=vec4(0.001,0.001,1.0,0.0);
Output.Depth=vec4(0.0,0.0,0.0,0.0);
return Output;
}

if(maskValue.y>0.0&&maskValue.x<fulldepth&&maskValue.x<surfaceDepth)
{
maskedDepth=maskValue.y-max((maskValue.x+maskValue.y)-min(surfaceDepth,fulldepth),0.0);
if(maskValue.x==0.0)
{
noSurfaceScattering=true;
}

if(maskValue.x!=0.0&&maskValue.x+maskValue.y>fulldepth)
{

}

}

actualDepth=min(fulldepth,surfaceDepth)-maskedDepth;
if(enableRefraction)
{
if(actualDepth==surfaceDepth-maskedDepth)
{
viewNormal=mul(vec4(-normal,0.0),g_matWorldViewProj).xyz;
refract_vec=normalize(refract(eyeViewVec,viewNormal,1.0/1.33));
float cosangle=acos(dot(-eyeViewVec,refract_vec)/(length(eyeViewVec)*length(refract_vec)));
offset=tan(cosangle)*((fulldepth-surfaceDepth)/fulldepth)*(1.0-saturate((g_LocalEye.z-In.LocalPos.z-35.0)/5.0));
TexCoord+=offset*(normalize(refract_vec.xy)*g_screenScale);
TexCoord=abs(TexCoord);
}

if(TexCoord.y>=1.0)TexCoord.y=2.0-TexCoord.y;
if(TexCoord.x>=1.0)TexCoord.x=2.0-TexCoord.x;
}

}

if(enableRefraction)
{
subsurfaceSample=texture(sampler2D(g_texDepth[1 + 9]),TexCoord*g_DepthScale+vec2(g_vrRightEye*0.5,0)).x;
subsurfaceDepth=depthToFadeDistance(subsurfaceSample,vec2(In.SurePosition.x/In.SurePosition.w,In.SurePosition.y/-In.SurePosition.w),dis,g_HalfTan);
if(subsurfaceDepth<surfaceDepth)
{
TexCoord=baseTexCoord;
subsurfaceDepth=fulldepth;
}

}
else

{
subsurfaceDepth=fulldepth;
}

if(frontFacing)
{
if(subsurfaceDepth>surfaceDepth)
{
finalDepth=(subsurfaceDepth-surfaceDepth-maskedDepth)*(maskInvert?-1:1);
}
else

{
finalDepth=0.0;
}

}
else

{
finalDepth=-min(actualDepth,surfaceDepth);
if(subsurfaceDepth-maskedDepth>actualDepth)
{
backfaceOccluded=1.0;
}

}

eyeDepth=min(((g_LocalEye.z-g_boundedLocation.z)/300000.0)-(((maskInvert||noSurfaceScattering)?1:0)*(normalize(eye_vec)*(maskValue.x+maskValue.y)).z),0.0);
float4 refractColour=texture(sampler2D(g_texColour[1 + 9]),TexCoord*g_DepthScale+vec2(g_vrRightEye*0.5,0));
Output.Scattering=vec4(g_scattering,enableFoam?1:0);
Output.Absorption=vec4(g_absorption,surfaceFoamValue);
Output.RefractColour=refractColour;
Output.Normals=vec4((maskInvert?vec3(0.01,0.01,0.01):normal),backfaceOccluded);
Output.Depth=vec4(finalDepth,actualDepth,eyeDepth,surfaceDepth*(noSurfaceScattering?-1:1));
return Output;
}
layout(location = 0) in Block
{
VS_OUTPUT BlockData;
} ioblock;
layout(location = 0) out vec4 Depth;

layout(location = 1) out vec4 Scattering;

layout(location = 2) out vec4 Absorption;

layout(location = 3) out vec4 Normals;

layout(location = 4) out vec4 RefractColour;

void main()
{
VS_OUTPUT BlockData=ioblock.BlockData;
bool frontFacing=gl_FrontFacing;
#line 2336 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
bool faceDirection=(g_reverseFace!=0.0)?!frontFacing:frontFacing;
PS_WATER_OUTPUTS tmp =  PS_WaterSurfDepth(BlockData,faceDirection,g_enableFoam,true,true);
Depth = tmp.Depth;
Scattering = tmp.Scattering;
Absorption = tmp.Absorption;
Normals = tmp.Normals;
RefractColour = tmp.RefractColour;

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_PS_BoundlessWaterSurfDepthWaveGrid.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 1) uniform cbShading
{
	vec3 g_SunDir;
	float g_Shineness;
	vec3 g_SunColor;
	float g_ShoreExtent;
	float g_oceanHeight;
	float g_vrRightEye;
	vec2 g_viewportPixelScale;
	int g_noOfReflectionSteps;
	int g_pixelStep;
	float g_reverseFace;
	bool g_enableFoam;
	float g_UVScale;
	float g_UVOffset;
	float g_WorldScale;
	float g_SunRadius;
	vec2 g_DepthScale;
	vec2 g_screenScale;
	vec4 g_DepthToLinFadeParams;
	vec4 g_HalfTan;
	vec3 g_ShoreDepthTextureLocation;
	float g_ShoreWidth;
	float gkfpdngkpfdp;
	float g_reflectionDistance;
	bool g_vrEnable;
	float g_reflectionBrightness;
};
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};
#line 140 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct PS_WATER_OUTPUTS
{
	vec4 Depth;
	vec4 Scattering;
	vec4 Absorption;
	vec4 Normals;
	vec4 RefractColour;
};





layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t g_texColour[24];
	uint64_t g_texDepth[24];
	uint64_t g_maskTexture[24];
	uint64_t g_ProfileBuffers[24];
	uint64_t g_InputAmplitude[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 1947 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
PS_WATER_OUTPUTS PS_WaterSurfDepth(VS_OUTPUT In, bool frontFacing, bool enableFoam, bool enableRefraction, bool waveGrid)
{
float profileOffsets[16]={0.54f,0.18f,0.61f,0.28f,0.09f,0.71f,0.99f,0.43f,0.11f,0.85f,0.24f,0.67f,0.31f,0.86f,0.13f,0.01f};
vec2 profile32Directons[32]={vec2(1.0f,0.0f),vec2(0.98f,0.19f),vec2(0.92f,0.38f),vec2(0.83f,0.55f),vec2(0.707f,0.707f),vec2(0.55f,0.83f),vec2(0.38f,0.92f),vec2(0.19f,0.98f),vec2(0.0f,1.0f),vec2(-0.19f,0.98f),vec2(-0.38f,0.92f),vec2(-0.55f,0.83f),vec2(-0.707f,0.707f),vec2(-0.83f,0.55f),vec2(-0.92f,0.38f),vec2(-0.98f,0.19f),vec2(-1.0f,-0.0f),vec2(-0.98f,-0.19f),vec2(-0.92f,-0.38f),vec2(-0.83f,-0.55f),vec2(-0.707f,-0.707f),vec2(-0.55f,-0.83f),vec2(-0.38f,-0.92f),vec2(-0.19f,-0.98f),vec2(0.0f,-1.0f),vec2(0.19f,-0.98f),vec2(0.38f,-0.92f),vec2(0.55f,-0.83f),vec2(0.707f,-0.707f),vec2(0.83f,-0.55f),vec2(0.92f,-0.38f),vec2(0.98f,-0.19f),};
PS_WATER_OUTPUTS Output;
vec3 eye_vec=g_LocalEye-In.LocalPos;
float surfaceDepth=length(eye_vec)/300000.0;
bool noWaveGrid=false;
bool maskInvert=false;
bool noSurfaceScattering=false;
float maskedDepth=0.0;
if(enableRefraction)
{
if(length(eye_vec)>100.0)
{
enableRefraction=false;
}

}

if(length(eye_vec.xy)>128.0)
{
noWaveGrid=true;
}

DepthInterpretationStruct dis;
dis.reverseDepth=true;
dis.depthToLinFadeDistParams=g_DepthToLinFadeParams;
vec2 TexCoord=((vec2(In.SurePosition.x/In.SurePosition.w,In.SurePosition.y/-In.SurePosition.w)+vec2(1.0,1.0))/2.0);
vec2 baseTexCoord=TexCoord;
float actualDepth=0.0;
float offset=0.0;
vec3 refract_vec=vec3(0.0,0.0,0.0);
vec3 viewNormal=vec3(0.0,0.0,0.0);
vec3 eyeViewVec=vec3(0.0,0.0,1.0);
float backfaceOccluded=0.0;
float foamValue=0.0;
float surfaceFoamValue=0.0;
float finalDepth;
float eyeDepth;
float subsurfaceSample;
float subsurfaceDepth;
vec3 normal=normalize(vec3(0.01,0.01,1.0f));
vec3 grad=vec3(0.0,0.0,0.0);
if(In.vecColour.x==0.0)
{
vec3 tx=vec3(0.0,0.0,0.0);
vec3 ty=vec3(0.0,0.0,0.0);
uint dirNum=16;
uint N=2*dirNum;
float dx=dirNum*6.28318530718f/N;
vec2 foamtemp=vec2(0.0,0.0);
vec2 foamtempWaveGrid=vec2(0.0,0.0);
vec2 windDirection=normalize(vec2(sin(g_windDirection),cos(g_windDirection)));
uint i;
for(i=0;i<N;i++)
{
float angle=((i)/(N))*6.28318530718f;
vec2 texcDir=normalize(profile32Directons[i]);
vec2 texc=texcDir*In.texCoords*g_profileUVScale;
vec2 gradientValue=vec2(0.0,0.0);
vec2 waveGridAmp=vec2(0.0,0.0);
float baseAmplitude=pow(((dot(windDirection,texcDir)+1.0)+((dot(-windDirection,texcDir)+1.0)*(1.0-g_windDependency)))/2.0,4.0);
vec2 windWaves=g_amplitude*In.vecColour.w*(texture(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,0.0f)).zw)*(baseAmplitude/2.0);
if(waveGrid&&!noWaveGrid)
{
waveGridAmp=(texture(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,1.0f)).zw*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(In.texCoords.x/5.0,In.texCoords.y/5.0,(i+0.5)/N),0).x);
}

gradientValue=dx*(waveGridAmp+windWaves);
tx+=texcDir.x*vec3((-gradientValue.y),0.0,-gradientValue.y);
ty+=texcDir.y*vec3(0.0,(-gradientValue.y),-gradientValue.y);
foamtemp+=dx*vec2(abs(texcDir.x)*windWaves.x,abs(texcDir.y)*windWaves.x);
foamtempWaveGrid+=dx*vec2(abs(texcDir.x)*waveGridAmp.x,abs(texcDir.y)*waveGridAmp.x);
}

vec2 temp=saturate(normalize(vec3(-foamtemp.xy,16.0)).xy);
vec2 temp2=saturate(normalize(vec3(-foamtempWaveGrid.xy,16.0)).xy);
surfaceFoamValue=max(pow(temp.x+temp.y,2.0)-(0.5-g_foamStrength),0.0)+max(pow(temp2.x+temp2.y,2.0)-0.05,0.0);
normal=normalize(vec3(tx.xy+ty.xy,float(N/4.0)));
}

float tempsample=texture(sampler2D(g_texDepth[1 + 9]),TexCoord*g_DepthScale+vec2(g_vrRightEye*0.5,0)).x;
float fulldepth=depthToFadeDistance(tempsample,vec2(In.SurePosition.x/In.SurePosition.w,In.SurePosition.y/-In.SurePosition.w),dis,g_HalfTan);
vec4 maskValue=texture(sampler2D(g_maskTexture[1 + 9]),TexCoord*g_DepthScale+vec2(g_vrRightEye*0.5,0))/300000.0;
if(frontFacing)
{
if((maskValue.x+maskValue.y>fulldepth&&maskValue.x<surfaceDepth)||(maskValue.y<0.0))
{
Output.Scattering=vec4(g_scattering,0.0);
Output.Absorption=vec4(g_absorption,0.0);
Output.RefractColour=vec4(maskValue.y,0.0,0.0,0.0);
Output.Normals=vec4(0.001,0.001,1.0,0.0);
Output.Depth=vec4(0.0,0.0,0.0,0.0);
return Output;
}

if(maskValue.x+maskValue.y>surfaceDepth&&maskValue.x<fulldepth)
{
if(maskValue.x<surfaceDepth)
{
maskInvert=true;
noSurfaceScattering=true;
maskedDepth=(maskValue.x+maskValue.y)-surfaceDepth;
}
else

{
maskedDepth=maskValue.y-max(maskValue.x+maskValue.y-fulldepth,0.0);
}

}

actualDepth=saturate(fulldepth-surfaceDepth-maskedDepth);
if(!maskInvert)
{
if(actualDepth>0.0)
{
if(enableRefraction)
{
viewNormal=mul(vec4(normal,0.0),g_matWorldViewProj).xyz;
refract_vec=normalize(refract(eyeViewVec,viewNormal,1.0/1.33));
float cosangle=acos(dot(eyeViewVec,refract_vec)/(length(eyeViewVec)*length(refract_vec)));
offset=tan(cosangle)*(actualDepth/(fulldepth-maskedDepth))*(1.0-saturate((g_LocalEye.z-In.LocalPos.z-35.0)/5.0));
TexCoord+=offset*(normalize(refract_vec.xy)*g_screenScale);
TexCoord=abs(TexCoord);
}

if(TexCoord.y>=1.0)TexCoord.y=2.0-TexCoord.y;
if(TexCoord.x>=1.0)TexCoord.x=2.0-TexCoord.x;
}
else

{
Output.Scattering=vec4(g_scattering,0.0);
Output.Absorption=vec4(g_absorption,0.0);
Output.RefractColour=vec4(0.0,0.0,0.0,0.0);
Output.Normals=vec4(0.001,0.001,1.0,0.0);
Output.Depth=vec4(0.0,0.0,0.0,0.0);
actualDepth=0.0;
return Output;
}

}

}
else

{
if(((maskValue.y>fulldepth||maskValue.y>surfaceDepth)&&maskValue.x==0.0)||(maskValue.y<0.0&&abs(maskValue.y)<fulldepth))
{
Output.Scattering=vec4(g_scattering,0.0);
Output.Absorption=vec4(g_absorption,0.0);
Output.RefractColour=vec4(maskValue.y,0.0,0.0,0.0);
Output.Normals=vec4(0.001,0.001,1.0,0.0);
Output.Depth=vec4(0.0,0.0,0.0,0.0);
return Output;
}

if(maskValue.y>0.0&&maskValue.x<fulldepth&&maskValue.x<surfaceDepth)
{
maskedDepth=maskValue.y-max((maskValue.x+maskValue.y)-min(surfaceDepth,fulldepth),0.0);
if(maskValue.x==0.0)
{
noSurfaceScattering=true;
}

if(maskValue.x!=0.0&&maskValue.x+maskValue.y>fulldepth)
{

}

}

actualDepth=min(fulldepth,surfaceDepth)-maskedDepth;
if(enableRefraction)
{
if(actualDepth==surfaceDepth-maskedDepth)
{
viewNormal=mul(vec4(-normal,0.0),g_matWorldViewProj).xyz;
refract_vec=normalize(refract(eyeViewVec,viewNormal,1.0/1.33));
float cosangle=acos(dot(-eyeViewVec,refract_vec)/(length(eyeViewVec)*length(refract_vec)));
offset=tan(cosangle)*((fulldepth-surfaceDepth)/fulldepth)*(1.0-saturate((g_LocalEye.z-In.LocalPos.z-35.0)/5.0));
TexCoord+=offset*(normalize(refract_vec.xy)*g_screenScale);
TexCoord=abs(TexCoord);
}

if(TexCoord.y>=1.0)TexCoord.y=2.0-TexCoord.y;
if(TexCoord.x>=1.0)TexCoord.x=2.0-TexCoord.x;
}

}

if(enableRefraction)
{
subsurfaceSample=texture(sampler2D(g_texDepth[1 + 9]),TexCoord*g_DepthScale+vec2(g_vrRightEye*0.5,0)).x;
subsurfaceDepth=depthToFadeDistance(subsurfaceSample,vec2(In.SurePosition.x/In.SurePosition.w,In.SurePosition.y/-In.SurePosition.w),dis,g_HalfTan);
if(subsurfaceDepth<surfaceDepth)
{
TexCoord=baseTexCoord;
subsurfaceDepth=fulldepth;
}

}
else

{
subsurfaceDepth=fulldepth;
}

if(frontFacing)
{
if(subsurfaceDepth>surfaceDepth)
{
finalDepth=(subsurfaceDepth-surfaceDepth-maskedDepth)*(maskInvert?-1:1);
}
else

{
finalDepth=0.0;
}

}
else

{
finalDepth=-min(actualDepth,surfaceDepth);
if(subsurfaceDepth-maskedDepth>actualDepth)
{
backfaceOccluded=1.0;
}

}

eyeDepth=min(((g_LocalEye.z-g_boundedLocation.z)/300000.0)-(((maskInvert||noSurfaceScattering)?1:0)*(normalize(eye_vec)*(maskValue.x+maskValue.y)).z),0.0);
float4 refractColour=texture(sampler2D(g_texColour[1 + 9]),TexCoord*g_DepthScale+vec2(g_vrRightEye*0.5,0));
Output.Scattering=vec4(g_scattering,enableFoam?1:0);
Output.Absorption=vec4(g_absorption,surfaceFoamValue);
Output.RefractColour=refractColour;
Output.Normals=vec4((maskInvert?vec3(0.01,0.01,0.01):normal),backfaceOccluded);
Output.Depth=vec4(finalDepth,actualDepth,eyeDepth,surfaceDepth*(noSurfaceScattering?-1:1));
return Output;
}
layout(location = 0) in Block
{
VS_OUTPUT BlockData;
} ioblock;
layout(location = 0) out vec4 Depth;

layout(location = 1) out vec4 Scattering;

layout(location = 2) out vec4 Absorption;

layout(location = 3) out vec4 Normals;

layout(location = 4) out vec4 RefractColour;

void main()
{
VS_OUTPUT BlockData=ioblock.BlockData;
bool frontFacing=gl_FrontFacing;
#line 2318 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
bool faceDirection=(g_reverseFace!=0.0)?!frontFacing:frontFacing;
PS_WATER_OUTPUTS tmp =  PS_WaterSurfDepth(BlockData,faceDirection,g_enableFoam,false,true);
Depth = tmp.Depth;
Scattering = tmp.Scattering;
Absorption = tmp.Absorption;
Normals = tmp.Normals;
RefractColour = tmp.RefractColour;

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_PS_CopyDepthStencil.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t g_texDepth[24];
};
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out float4 returnObject_float4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 2863 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
float4 Output=textureLod(sampler2D(g_texDepth[1 + 9]),BlockData.texCoords,0);
{returnObject_float4=Output;}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_PS_CopyDepthStencilMSAA.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t g_texDepthMS[24];
};
#line 127 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
vec4 ms_depth(vec2 depth_texc)
{
uvec2 texsize;
uint numberOfSamples;
ivec2 ivg_texDepthMS = textureSize(sampler2DMS(g_texDepthMS[0]));
texsize.x = ivg_texDepthMS.x;texsize.y = ivg_texDepthMS.y;;
ivec2 pos=ivec2(depth_texc*vec2(texsize));
return texelFetch(sampler2DMS(g_texDepthMS[0]),ivec2(pos),int(0));
}
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out float4 returnObject_float4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 2874 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
float4 Output=ms_depth(BlockData.texCoords);
{returnObject_float4=Output;}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_PS_GenerateContourMap.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 153 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 6) uniform cbContourBuffer
{
	vec2 g_offsets;
	float g_waterHeight;
	float jnvuid9fsp;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t g_shoreDepthTexture[24];
};
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 642 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
vec4 result=vec4(0.0,0.0,0.0,0.0);
float depth=clamp((texture(sampler2D(g_shoreDepthTexture[1 + 9]),BlockData.texCoords,0).x*0.01)-g_waterHeight,-1.0,40.0);
result.w=depth;
if(depth<=0){returnObject_vec4=vec4(0.0,0.0,0.0,-1.0);}
float dzdx=(texture(sampler2D(g_shoreDepthTexture[1 + 9]),BlockData.texCoords+vec2(g_offsets.x,0.0),0).x-textureLod(sampler2D(g_shoreDepthTexture[1 + 9]),BlockData.texCoords-vec2(g_offsets.x,0.0),0).x)/2.0;
float dzdy=(texture(sampler2D(g_shoreDepthTexture[1 + 9]),BlockData.texCoords+vec2(0.0,g_offsets.y),0).x-textureLod(sampler2D(g_shoreDepthTexture[1 + 9]),BlockData.texCoords-vec2(0.0,g_offsets.y),0).x)/2.0;
if(dzdx+dzdy==0){returnObject_vec4=vec4(0.0,0.0,0.0,depth);}
vec3 normal=normalize(vec3(dzdx,dzdy,1.0));
{returnObject_vec4=vec4(normal,depth);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_PS_MaskObjectBackface.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 147 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 5) uniform cbMeshObjectBuffers
{
	float g_buoyancyUVScale;
	float g_buoyancyUVOffset;
	float g_buoyancySurfaceHeight;
	float g_buoyancyWaveAmplitude;
	vec2 g_buoyancyCenter;
	float g_buoyancyWindDirection;
	float g_buoyancyWindDependancy;
	float g_buoyancyProfileUVScale;
	float g_buoyancyWaveGridScale;
	bool g_buoyancyEnableWaveGrid;
	float gnuhjfidobn;
	mat4 g_meshMat;
	vec3 g_location;
	int g_ID;
	vec4 g_rotation;
	vec3 g_scale;
	float vufiepadnu;
};
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t g_maskFrontfaceTexture[24];
};
layout(location = 0) in Block
{
VS_OUTPUT BlockData;
} ioblock;
layout(location = 0) out float4 returnObject_float4;

void main()
{
VS_OUTPUT BlockData=ioblock.BlockData;
#line 710 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
vec2 TexCoord=((vec2(BlockData.SurePosition.x/BlockData.SurePosition.w,BlockData.SurePosition.y/-BlockData.SurePosition.w)+vec2(1.0,1.0))/2.0);
float objectDepth=length(g_LocalEye-BlockData.LocalPos);
vec3 depth=texture(sampler2D(g_maskFrontfaceTexture[1 + 9]),TexCoord).xyz;
if(depth.z!=(g_ID))discard;
if(depth.x>objectDepth||depth.y==1.0)
{
depth.x=0.0;
}

if(depth.x>0.0)objectDepth-=depth.x;
{returnObject_float4=float4(depth.x,objectDepth,0.0,1.0);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_PS_MaskObjectFrontface.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 147 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 5) uniform cbMeshObjectBuffers
{
	float g_buoyancyUVScale;
	float g_buoyancyUVOffset;
	float g_buoyancySurfaceHeight;
	float g_buoyancyWaveAmplitude;
	vec2 g_buoyancyCenter;
	float g_buoyancyWindDirection;
	float g_buoyancyWindDependancy;
	float g_buoyancyProfileUVScale;
	float g_buoyancyWaveGridScale;
	bool g_buoyancyEnableWaveGrid;
	float gnuhjfidobn;
	mat4 g_meshMat;
	vec3 g_location;
	int g_ID;
	vec4 g_rotation;
	vec3 g_scale;
	float vufiepadnu;
};
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t g_maskTexture[24];
};
layout(location = 0) in Block
{
VS_OUTPUT BlockData;
} ioblock;
layout(location = 0) out float4 returnObject_float4;

void main()
{
VS_OUTPUT BlockData=ioblock.BlockData;
bool frontFacing=gl_FrontFacing;
#line 689 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
vec2 TexCoord=((vec2(BlockData.SurePosition.x/BlockData.SurePosition.w,BlockData.SurePosition.y/-BlockData.SurePosition.w)+vec2(1.0,1.0))/2.0);
vec2 existingDepth=texture(sampler2D(g_maskTexture[1 + 9]),TexCoord).xy;
float depth=length(g_LocalEye-BlockData.LocalPos);
if(existingDepth.x<depth&&existingDepth.x!=0.0)depth=0.0;
if(frontFacing){returnObject_float4=float4(depth,0.0,g_ID,1.0);}else
{returnObject_float4=float4(depth,1.0,g_ID,1.0);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_PS_MaskObjectPlane.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t g_maskFrontfaceTexture[24];
};
layout(location = 0) in Block
{
VS_OUTPUT BlockData;
} ioblock;
layout(location = 0) out float4 returnObject_float4;

void main()
{
VS_OUTPUT BlockData=ioblock.BlockData;
#line 737 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
vec2 TexCoord=((vec2(BlockData.SurePosition.x/BlockData.SurePosition.w,BlockData.SurePosition.y/-BlockData.SurePosition.w)+vec2(1.0,1.0))/2.0);
float objectDepth=length(g_LocalEye-BlockData.LocalPos);
vec3 depth=texture(sampler2D(g_maskFrontfaceTexture[1 + 9]),TexCoord).xyz;
{returnObject_float4=float4(0.0,-objectDepth,0.0,1.0);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_PS_PrecomputeProfileBuffer.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 121 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 4) uniform cbProfileBuffers
{
	float g_zetaMax;
	float g_zetaMin;
	float g_period;
	float g_integrationSteps;
	float g_time;
	float g_windSpeed;
	int g_totalWaveNumbers;
	float g_dt;
	uvec2 g_waveGridBound;
	int g_waveGroup;
	int g_waveGridDimension;
};
#line 157 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
float spectrum(float zeta, float windSpeed)
{
float A=pow(1.1,1.5*zeta);
float B=exp(-1.8038897788076411*pow(4.f,zeta)/pow(windSpeed,4.f));
return 0.139098f*sqrt(A*B);
}
#line 163 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
vec4 gerstner_wave(float phase, float knum)
{
float s=sin(phase);
float c=cos(phase);
return vec4(-s,c,-knum*c,-knum*s);
}
#line 170 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
float cubic_bump(float x)
{
if(abs(x)>=1)return 0.0f;else
return x*x*(2*abs(x)-3)+1;
}
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 606 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
const float g=9.81;
float p=(BlockData.texCoords.x*g_period);
float dx=(g_zetaMax-g_zetaMin)/g_integrationSteps;
float x=g_zetaMin;
float weight1=BlockData.texCoords.x;
float weight2=1-weight1;
float bump1=cubic_bump(weight1);
float bump2=cubic_bump(weight2);
vec4 result=vec4(0,0,0,0);
for(int i=0;i<=g_integrationSteps;i++)
{
float waveLength=pow(2.0,x);
float waveNumber=6.28318530718f/waveLength;
float phase1=waveNumber*p-sqrt(waveNumber*g)*(g_time+5000.0);
float phase2=waveNumber*(p-g_period)-sqrt(waveNumber*g)*(g_time+5000.0);
result+=dx*waveLength*spectrum(x,g_windSpeed)*((bump1*gerstner_wave(phase1,waveNumber))+(bump2*gerstner_wave(phase2,waveNumber)));
x+=dx;
}

{returnObject_vec4=result;}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_PS_ShowTexture.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t showTexture[24];
};
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 2906 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
vec4 lookup=texture(sampler2D(showTexture[1 + 7]),BlockData.texCoords.xy);
{returnObject_vec4=vec4(lookup.rgb,1.0);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_PS_WaterSSR100.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 1) uniform cbShading
{
	vec3 g_SunDir;
	float g_Shineness;
	vec3 g_SunColor;
	float g_ShoreExtent;
	float g_oceanHeight;
	float g_vrRightEye;
	vec2 g_viewportPixelScale;
	int g_noOfReflectionSteps;
	int g_pixelStep;
	float g_reverseFace;
	bool g_enableFoam;
	float g_UVScale;
	float g_UVOffset;
	float g_WorldScale;
	float g_SunRadius;
	vec2 g_DepthScale;
	vec2 g_screenScale;
	vec4 g_DepthToLinFadeParams;
	vec4 g_HalfTan;
	vec3 g_ShoreDepthTextureLocation;
	float g_ShoreWidth;
	float gkfpdngkpfdp;
	float g_reflectionDistance;
	bool g_vrEnable;
	float g_reflectionBrightness;
};
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};




layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t g_texColour[24];
	uint64_t g_texDepth[24];
	uint64_t g_waterDepth[24];
	uint64_t g_waterNormals[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 2352 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
float4 PS_WaterSSR(posTexVertexOutput In, int maxSteps)
{
vec2 BaseTexCoords=In.texCoords*(g_vrRightEye==1.0?g_DepthScale:vec2(1.0,1.0))+vec2(g_vrRightEye*0.5,0);
if(g_vrEnable)BaseTexCoords=In.texCoords*(+vec2(g_vrRightEye*0.5,0));
float4 depthInput=texture(sampler2D(g_waterDepth[1 + 9]),BaseTexCoords);
if(depthInput.y<=0.0f||depthInput.x<=0.0f||depthInput.w>g_reflectionDistance)return float4(-1.0,-1.0,-1.0,-1.0);
float4 Output=float4(-1.0,-1.0,-1.0,-1.0);
int noSteps=min(g_noOfReflectionSteps,maxSteps);
float stepLength=clamp(abs(depthInput.w)*3000.0,0.06125,0.5);
float4 normalsInput=texture(sampler2D(g_waterNormals[1 + 3]),BaseTexCoords);
vec4 clip=vec4(((In.texCoords.x*2.0)-1.0),((1.0-In.texCoords.y)*2.0)-1.0,1.0,1.0);
vec4 view=mul(g_matInvViewProj,clip);
vec3 eye_dir=normalize(view.xyz/view.w);
vec4 surfacePos=vec4(g_LocalEye+(eye_dir*abs(depthInput.w)*300000.0),1.0);
vec4 rayPos=surfacePos;
vec4 samplePos;
vec3 reflectVec=normalize(reflect(eye_dir,normalsInput.xyz));
vec2 TexCoord;
vec2 OldTexCoord;
bool hit=false;
bool doublerefl=false;
float depthSample;
float fullDepth;
samplePos=mul(g_matWorldViewProj,rayPos);
OldTexCoord=((vec2(samplePos.x/samplePos.w,samplePos.y/-samplePos.w)+vec2(1.0,1.0))/2.0)*g_DepthScale;
samplePos=mul(g_matWorldViewProj,rayPos+vec4(reflectVec*stepLength,0.0));
TexCoord=((vec2(samplePos.x/samplePos.w,samplePos.y/-samplePos.w)+vec2(1.0,1.0))/2.0)*g_DepthScale;
if(TexCoord.y>1.0||TexCoord.y<0.0||TexCoord.x>=1.0||TexCoord.x<=0.0)return float4(-1.0,-1.0,-1.0,-1.0);
if((length(TexCoord-OldTexCoord)<length(g_viewportPixelScale)*float(g_pixelStep))||(length(TexCoord-OldTexCoord)>length(g_viewportPixelScale)*float(g_pixelStep)))stepLength*=(length(g_viewportPixelScale)*float(g_pixelStep))/length(TexCoord-OldTexCoord);
reflectVec.z=max(reflectVec.z,0.025);
reflectVec=normalize(reflectVec);
rayPos+=vec4(reflectVec*stepLength,0.0);
DepthInterpretationStruct dis;
dis.depthToLinFadeDistParams=g_DepthToLinFadeParams;
dis.reverseDepth=false;
int i;
for(i=1;i<noSteps;i++)
{
samplePos=mul(g_matWorldViewProj,rayPos);
TexCoord=((vec2(samplePos.x/samplePos.w,samplePos.y/-samplePos.w)+vec2(1.0,1.0))/2.0)*g_DepthScale;
if(TexCoord.y>1.0||TexCoord.y<0.0||TexCoord.x>=1.0||TexCoord.x<=0.0)break;
depthSample=texture(sampler2D(g_texDepth[1 + 9]),TexCoord+vec2(g_vrRightEye*0.5,0)).x;
fullDepth=depthToFadeDistance(depthSample,vec2(samplePos.x/samplePos.w,samplePos.y/-samplePos.w),dis,g_HalfTan)*300000.0;
float temp=abs(fullDepth-length(g_LocalEye-rayPos.xyz));
if(temp<=stepLength)
{
hit=true;
break;
}

stepLength*=(length(g_viewportPixelScale)*float(g_pixelStep))/length(TexCoord-OldTexCoord);
rayPos+=vec4(reflectVec*stepLength,0.0);
if(length(g_LocalEye-rayPos.xyz)>g_reflectionDistance)break;
OldTexCoord=TexCoord;
}

if(hit)
{
Output=texture(sampler2D(g_texColour[1 + 3]),TexCoord+vec2(g_vrRightEye*0.5,0))*(doublerefl?0.5:1.0);
Output.w=-1.0;
}

return Output;
}
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out float4 returnObject_float4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 2477 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
{returnObject_float4=PS_WaterSSR(BlockData,100);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_PS_WaterSSR25.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 1) uniform cbShading
{
	vec3 g_SunDir;
	float g_Shineness;
	vec3 g_SunColor;
	float g_ShoreExtent;
	float g_oceanHeight;
	float g_vrRightEye;
	vec2 g_viewportPixelScale;
	int g_noOfReflectionSteps;
	int g_pixelStep;
	float g_reverseFace;
	bool g_enableFoam;
	float g_UVScale;
	float g_UVOffset;
	float g_WorldScale;
	float g_SunRadius;
	vec2 g_DepthScale;
	vec2 g_screenScale;
	vec4 g_DepthToLinFadeParams;
	vec4 g_HalfTan;
	vec3 g_ShoreDepthTextureLocation;
	float g_ShoreWidth;
	float gkfpdngkpfdp;
	float g_reflectionDistance;
	bool g_vrEnable;
	float g_reflectionBrightness;
};
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};




layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t g_texColour[24];
	uint64_t g_texDepth[24];
	uint64_t g_waterDepth[24];
	uint64_t g_waterNormals[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 2352 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
float4 PS_WaterSSR(posTexVertexOutput In, int maxSteps)
{
vec2 BaseTexCoords=In.texCoords*(g_vrRightEye==1.0?g_DepthScale:vec2(1.0,1.0))+vec2(g_vrRightEye*0.5,0);
if(g_vrEnable)BaseTexCoords=In.texCoords*(+vec2(g_vrRightEye*0.5,0));
float4 depthInput=texture(sampler2D(g_waterDepth[1 + 9]),BaseTexCoords);
if(depthInput.y<=0.0f||depthInput.x<=0.0f||depthInput.w>g_reflectionDistance)return float4(-1.0,-1.0,-1.0,-1.0);
float4 Output=float4(-1.0,-1.0,-1.0,-1.0);
int noSteps=min(g_noOfReflectionSteps,maxSteps);
float stepLength=clamp(abs(depthInput.w)*3000.0,0.06125,0.5);
float4 normalsInput=texture(sampler2D(g_waterNormals[1 + 3]),BaseTexCoords);
vec4 clip=vec4(((In.texCoords.x*2.0)-1.0),((1.0-In.texCoords.y)*2.0)-1.0,1.0,1.0);
vec4 view=mul(g_matInvViewProj,clip);
vec3 eye_dir=normalize(view.xyz/view.w);
vec4 surfacePos=vec4(g_LocalEye+(eye_dir*abs(depthInput.w)*300000.0),1.0);
vec4 rayPos=surfacePos;
vec4 samplePos;
vec3 reflectVec=normalize(reflect(eye_dir,normalsInput.xyz));
vec2 TexCoord;
vec2 OldTexCoord;
bool hit=false;
bool doublerefl=false;
float depthSample;
float fullDepth;
samplePos=mul(g_matWorldViewProj,rayPos);
OldTexCoord=((vec2(samplePos.x/samplePos.w,samplePos.y/-samplePos.w)+vec2(1.0,1.0))/2.0)*g_DepthScale;
samplePos=mul(g_matWorldViewProj,rayPos+vec4(reflectVec*stepLength,0.0));
TexCoord=((vec2(samplePos.x/samplePos.w,samplePos.y/-samplePos.w)+vec2(1.0,1.0))/2.0)*g_DepthScale;
if(TexCoord.y>1.0||TexCoord.y<0.0||TexCoord.x>=1.0||TexCoord.x<=0.0)return float4(-1.0,-1.0,-1.0,-1.0);
if((length(TexCoord-OldTexCoord)<length(g_viewportPixelScale)*float(g_pixelStep))||(length(TexCoord-OldTexCoord)>length(g_viewportPixelScale)*float(g_pixelStep)))stepLength*=(length(g_viewportPixelScale)*float(g_pixelStep))/length(TexCoord-OldTexCoord);
reflectVec.z=max(reflectVec.z,0.025);
reflectVec=normalize(reflectVec);
rayPos+=vec4(reflectVec*stepLength,0.0);
DepthInterpretationStruct dis;
dis.depthToLinFadeDistParams=g_DepthToLinFadeParams;
dis.reverseDepth=false;
int i;
for(i=1;i<noSteps;i++)
{
samplePos=mul(g_matWorldViewProj,rayPos);
TexCoord=((vec2(samplePos.x/samplePos.w,samplePos.y/-samplePos.w)+vec2(1.0,1.0))/2.0)*g_DepthScale;
if(TexCoord.y>1.0||TexCoord.y<0.0||TexCoord.x>=1.0||TexCoord.x<=0.0)break;
depthSample=texture(sampler2D(g_texDepth[1 + 9]),TexCoord+vec2(g_vrRightEye*0.5,0)).x;
fullDepth=depthToFadeDistance(depthSample,vec2(samplePos.x/samplePos.w,samplePos.y/-samplePos.w),dis,g_HalfTan)*300000.0;
float temp=abs(fullDepth-length(g_LocalEye-rayPos.xyz));
if(temp<=stepLength)
{
hit=true;
break;
}

stepLength*=(length(g_viewportPixelScale)*float(g_pixelStep))/length(TexCoord-OldTexCoord);
rayPos+=vec4(reflectVec*stepLength,0.0);
if(length(g_LocalEye-rayPos.xyz)>g_reflectionDistance)break;
OldTexCoord=TexCoord;
}

if(hit)
{
Output=texture(sampler2D(g_texColour[1 + 3]),TexCoord+vec2(g_vrRightEye*0.5,0))*(doublerefl?0.5:1.0);
Output.w=-1.0;
}

return Output;
}
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out float4 returnObject_float4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 2491 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
{returnObject_float4=PS_WaterSSR(BlockData,25);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_PS_WaterSSR50.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 1) uniform cbShading
{
	vec3 g_SunDir;
	float g_Shineness;
	vec3 g_SunColor;
	float g_ShoreExtent;
	float g_oceanHeight;
	float g_vrRightEye;
	vec2 g_viewportPixelScale;
	int g_noOfReflectionSteps;
	int g_pixelStep;
	float g_reverseFace;
	bool g_enableFoam;
	float g_UVScale;
	float g_UVOffset;
	float g_WorldScale;
	float g_SunRadius;
	vec2 g_DepthScale;
	vec2 g_screenScale;
	vec4 g_DepthToLinFadeParams;
	vec4 g_HalfTan;
	vec3 g_ShoreDepthTextureLocation;
	float g_ShoreWidth;
	float gkfpdngkpfdp;
	float g_reflectionDistance;
	bool g_vrEnable;
	float g_reflectionBrightness;
};
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};




layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t g_texColour[24];
	uint64_t g_texDepth[24];
	uint64_t g_waterDepth[24];
	uint64_t g_waterNormals[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 2352 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
float4 PS_WaterSSR(posTexVertexOutput In, int maxSteps)
{
vec2 BaseTexCoords=In.texCoords*(g_vrRightEye==1.0?g_DepthScale:vec2(1.0,1.0))+vec2(g_vrRightEye*0.5,0);
if(g_vrEnable)BaseTexCoords=In.texCoords*(+vec2(g_vrRightEye*0.5,0));
float4 depthInput=texture(sampler2D(g_waterDepth[1 + 9]),BaseTexCoords);
if(depthInput.y<=0.0f||depthInput.x<=0.0f||depthInput.w>g_reflectionDistance)return float4(-1.0,-1.0,-1.0,-1.0);
float4 Output=float4(-1.0,-1.0,-1.0,-1.0);
int noSteps=min(g_noOfReflectionSteps,maxSteps);
float stepLength=clamp(abs(depthInput.w)*3000.0,0.06125,0.5);
float4 normalsInput=texture(sampler2D(g_waterNormals[1 + 3]),BaseTexCoords);
vec4 clip=vec4(((In.texCoords.x*2.0)-1.0),((1.0-In.texCoords.y)*2.0)-1.0,1.0,1.0);
vec4 view=mul(g_matInvViewProj,clip);
vec3 eye_dir=normalize(view.xyz/view.w);
vec4 surfacePos=vec4(g_LocalEye+(eye_dir*abs(depthInput.w)*300000.0),1.0);
vec4 rayPos=surfacePos;
vec4 samplePos;
vec3 reflectVec=normalize(reflect(eye_dir,normalsInput.xyz));
vec2 TexCoord;
vec2 OldTexCoord;
bool hit=false;
bool doublerefl=false;
float depthSample;
float fullDepth;
samplePos=mul(g_matWorldViewProj,rayPos);
OldTexCoord=((vec2(samplePos.x/samplePos.w,samplePos.y/-samplePos.w)+vec2(1.0,1.0))/2.0)*g_DepthScale;
samplePos=mul(g_matWorldViewProj,rayPos+vec4(reflectVec*stepLength,0.0));
TexCoord=((vec2(samplePos.x/samplePos.w,samplePos.y/-samplePos.w)+vec2(1.0,1.0))/2.0)*g_DepthScale;
if(TexCoord.y>1.0||TexCoord.y<0.0||TexCoord.x>=1.0||TexCoord.x<=0.0)return float4(-1.0,-1.0,-1.0,-1.0);
if((length(TexCoord-OldTexCoord)<length(g_viewportPixelScale)*float(g_pixelStep))||(length(TexCoord-OldTexCoord)>length(g_viewportPixelScale)*float(g_pixelStep)))stepLength*=(length(g_viewportPixelScale)*float(g_pixelStep))/length(TexCoord-OldTexCoord);
reflectVec.z=max(reflectVec.z,0.025);
reflectVec=normalize(reflectVec);
rayPos+=vec4(reflectVec*stepLength,0.0);
DepthInterpretationStruct dis;
dis.depthToLinFadeDistParams=g_DepthToLinFadeParams;
dis.reverseDepth=false;
int i;
for(i=1;i<noSteps;i++)
{
samplePos=mul(g_matWorldViewProj,rayPos);
TexCoord=((vec2(samplePos.x/samplePos.w,samplePos.y/-samplePos.w)+vec2(1.0,1.0))/2.0)*g_DepthScale;
if(TexCoord.y>1.0||TexCoord.y<0.0||TexCoord.x>=1.0||TexCoord.x<=0.0)break;
depthSample=texture(sampler2D(g_texDepth[1 + 9]),TexCoord+vec2(g_vrRightEye*0.5,0)).x;
fullDepth=depthToFadeDistance(depthSample,vec2(samplePos.x/samplePos.w,samplePos.y/-samplePos.w),dis,g_HalfTan)*300000.0;
float temp=abs(fullDepth-length(g_LocalEye-rayPos.xyz));
if(temp<=stepLength)
{
hit=true;
break;
}

stepLength*=(length(g_viewportPixelScale)*float(g_pixelStep))/length(TexCoord-OldTexCoord);
rayPos+=vec4(reflectVec*stepLength,0.0);
if(length(g_LocalEye-rayPos.xyz)>g_reflectionDistance)break;
OldTexCoord=TexCoord;
}

if(hit)
{
Output=texture(sampler2D(g_texColour[1 + 3]),TexCoord+vec2(g_vrRightEye*0.5,0))*(doublerefl?0.5:1.0);
Output.w=-1.0;
}

return Output;
}
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out float4 returnObject_float4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 2486 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
{returnObject_float4=PS_WaterSSR(BlockData,50);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_PS_WaterSSR75.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 1) uniform cbShading
{
	vec3 g_SunDir;
	float g_Shineness;
	vec3 g_SunColor;
	float g_ShoreExtent;
	float g_oceanHeight;
	float g_vrRightEye;
	vec2 g_viewportPixelScale;
	int g_noOfReflectionSteps;
	int g_pixelStep;
	float g_reverseFace;
	bool g_enableFoam;
	float g_UVScale;
	float g_UVOffset;
	float g_WorldScale;
	float g_SunRadius;
	vec2 g_DepthScale;
	vec2 g_screenScale;
	vec4 g_DepthToLinFadeParams;
	vec4 g_HalfTan;
	vec3 g_ShoreDepthTextureLocation;
	float g_ShoreWidth;
	float gkfpdngkpfdp;
	float g_reflectionDistance;
	bool g_vrEnable;
	float g_reflectionBrightness;
};
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};




layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t g_texColour[24];
	uint64_t g_texDepth[24];
	uint64_t g_waterDepth[24];
	uint64_t g_waterNormals[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 111 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
float depthToFadeDistance(float depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth;
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
float fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
return fadeDist;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec2 depthToFadeDistance(vec2 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec2 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
}

return fadeDist;
}
#line 149 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/depth.sl"
vec4 depthToFadeDistance(vec4 depth, vec2 xy, DepthInterpretationStruct dis, vec4 tanHalf)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
float Tx=xy.x*tanHalf.x+tanHalf.z;
float Ty=xy.y*tanHalf.y+tanHalf.w;
vec4 fadeDist=linearFadeDistanceZ*sqrt(1.0+Tx*Tx+Ty*Ty);
if(dis.reverseDepth)
{
fadeDist.x=max(fadeDist.x,step(0.0,-depth.x));
fadeDist.y=max(fadeDist.y,step(0.0,-depth.y));
fadeDist.z=max(fadeDist.z,step(0.0,-depth.z));
fadeDist.w=max(fadeDist.w,step(0.0,-depth.w));
}
else

{
fadeDist.x=max(fadeDist.x,step(1.0,depth.x));
fadeDist.y=max(fadeDist.y,step(1.0,depth.y));
fadeDist.z=max(fadeDist.z,step(1.0,depth.z));
fadeDist.w=max(fadeDist.w,step(1.0,depth.w));
}

return fadeDist;
}
#line 2352 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
float4 PS_WaterSSR(posTexVertexOutput In, int maxSteps)
{
vec2 BaseTexCoords=In.texCoords*(g_vrRightEye==1.0?g_DepthScale:vec2(1.0,1.0))+vec2(g_vrRightEye*0.5,0);
if(g_vrEnable)BaseTexCoords=In.texCoords*(+vec2(g_vrRightEye*0.5,0));
float4 depthInput=texture(sampler2D(g_waterDepth[1 + 9]),BaseTexCoords);
if(depthInput.y<=0.0f||depthInput.x<=0.0f||depthInput.w>g_reflectionDistance)return float4(-1.0,-1.0,-1.0,-1.0);
float4 Output=float4(-1.0,-1.0,-1.0,-1.0);
int noSteps=min(g_noOfReflectionSteps,maxSteps);
float stepLength=clamp(abs(depthInput.w)*3000.0,0.06125,0.5);
float4 normalsInput=texture(sampler2D(g_waterNormals[1 + 3]),BaseTexCoords);
vec4 clip=vec4(((In.texCoords.x*2.0)-1.0),((1.0-In.texCoords.y)*2.0)-1.0,1.0,1.0);
vec4 view=mul(g_matInvViewProj,clip);
vec3 eye_dir=normalize(view.xyz/view.w);
vec4 surfacePos=vec4(g_LocalEye+(eye_dir*abs(depthInput.w)*300000.0),1.0);
vec4 rayPos=surfacePos;
vec4 samplePos;
vec3 reflectVec=normalize(reflect(eye_dir,normalsInput.xyz));
vec2 TexCoord;
vec2 OldTexCoord;
bool hit=false;
bool doublerefl=false;
float depthSample;
float fullDepth;
samplePos=mul(g_matWorldViewProj,rayPos);
OldTexCoord=((vec2(samplePos.x/samplePos.w,samplePos.y/-samplePos.w)+vec2(1.0,1.0))/2.0)*g_DepthScale;
samplePos=mul(g_matWorldViewProj,rayPos+vec4(reflectVec*stepLength,0.0));
TexCoord=((vec2(samplePos.x/samplePos.w,samplePos.y/-samplePos.w)+vec2(1.0,1.0))/2.0)*g_DepthScale;
if(TexCoord.y>1.0||TexCoord.y<0.0||TexCoord.x>=1.0||TexCoord.x<=0.0)return float4(-1.0,-1.0,-1.0,-1.0);
if((length(TexCoord-OldTexCoord)<length(g_viewportPixelScale)*float(g_pixelStep))||(length(TexCoord-OldTexCoord)>length(g_viewportPixelScale)*float(g_pixelStep)))stepLength*=(length(g_viewportPixelScale)*float(g_pixelStep))/length(TexCoord-OldTexCoord);
reflectVec.z=max(reflectVec.z,0.025);
reflectVec=normalize(reflectVec);
rayPos+=vec4(reflectVec*stepLength,0.0);
DepthInterpretationStruct dis;
dis.depthToLinFadeDistParams=g_DepthToLinFadeParams;
dis.reverseDepth=false;
int i;
for(i=1;i<noSteps;i++)
{
samplePos=mul(g_matWorldViewProj,rayPos);
TexCoord=((vec2(samplePos.x/samplePos.w,samplePos.y/-samplePos.w)+vec2(1.0,1.0))/2.0)*g_DepthScale;
if(TexCoord.y>1.0||TexCoord.y<0.0||TexCoord.x>=1.0||TexCoord.x<=0.0)break;
depthSample=texture(sampler2D(g_texDepth[1 + 9]),TexCoord+vec2(g_vrRightEye*0.5,0)).x;
fullDepth=depthToFadeDistance(depthSample,vec2(samplePos.x/samplePos.w,samplePos.y/-samplePos.w),dis,g_HalfTan)*300000.0;
float temp=abs(fullDepth-length(g_LocalEye-rayPos.xyz));
if(temp<=stepLength)
{
hit=true;
break;
}

stepLength*=(length(g_viewportPixelScale)*float(g_pixelStep))/length(TexCoord-OldTexCoord);
rayPos+=vec4(reflectVec*stepLength,0.0);
if(length(g_LocalEye-rayPos.xyz)>g_reflectionDistance)break;
OldTexCoord=TexCoord;
}

if(hit)
{
Output=texture(sampler2D(g_texColour[1 + 3]),TexCoord+vec2(g_vrRightEye*0.5,0))*(doublerefl?0.5:1.0);
Output.w=-1.0;
}

return Output;
}
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out float4 returnObject_float4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 2482 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
{returnObject_float4=PS_WaterSSR(BlockData,75);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_PS_WaterSurfFinalNoReflection.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 1) uniform cbShading
{
	vec3 g_SunDir;
	float g_Shineness;
	vec3 g_SunColor;
	float g_ShoreExtent;
	float g_oceanHeight;
	float g_vrRightEye;
	vec2 g_viewportPixelScale;
	int g_noOfReflectionSteps;
	int g_pixelStep;
	float g_reverseFace;
	bool g_enableFoam;
	float g_UVScale;
	float g_UVOffset;
	float g_WorldScale;
	float g_SunRadius;
	vec2 g_DepthScale;
	vec2 g_screenScale;
	vec4 g_DepthToLinFadeParams;
	vec4 g_HalfTan;
	vec3 g_ShoreDepthTextureLocation;
	float g_ShoreWidth;
	float gkfpdngkpfdp;
	float g_reflectionDistance;
	bool g_vrEnable;
	float g_reflectionBrightness;
};
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};







layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t g_waterDepth[24];
	uint64_t g_waterAbsorption[24];
	uint64_t g_waterScattering[24];
	uint64_t g_waterNormals[24];
	uint64_t g_waterRefractColour[24];
	uint64_t g_waterReflectColour[24];
	uint64_t g_texReflectCube[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 178 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
float fresnel(vec3 incident, vec3 normal, float sourceIndex, float mediumIndex)
{
float cos_incident=clamp(-1.0,1.0,dot(incident,normal));
float R0=pow(((mediumIndex-sourceIndex)/(mediumIndex+sourceIndex)),2.0);
return R0+(1-R0)*pow(1-cos_incident,5.0);
}
#line 2500 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
float4 PS_WaterSurfFinal(posTexVertexOutput In, bool reflections)
{
vec2 TexCoords=In.texCoords;
if(g_vrEnable)TexCoords=In.texCoords*(+vec2(g_vrRightEye*0.5,0));
float4 depthInput=texture(sampler2D(g_waterDepth[1 + 9]),TexCoords);
if(depthInput.y<=0.0)discard;
float waterDepth=depthInput.x;
if(waterDepth==0.0)waterDepth=depthInput.y;
float4 Output=vec4(0.0,0.0,0.0,1.0);
float4 absorptionInput=texture(sampler2D(g_waterAbsorption[1 + 9]),TexCoords);
vec3 absorption=absorptionInput.xyz;
float4 scatteringInput=texture(sampler2D(g_waterScattering[1 + 9]),TexCoords);
vec3 scattering=scatteringInput.xyz;
float4 normalsInput=texture(sampler2D(g_waterNormals[1 + 9]),TexCoords);
float4 refractColourInput=texture(sampler2D(g_waterRefractColour[1 + 9]),TexCoords);
vec3 normal=normalsInput.xyz;
float scatterDepth=0.0;
float fadeDistance=300000.0;
float absoluteDepth=depthInput.y;
vec4 clip=vec4((In.texCoords.x*2.0)-1.0,((1.0-In.texCoords.y)*2.0)-1.0,1.0,1.0);
vec4 view=mul(g_matInvViewProj,clip);
vec3 eye_dir=normalize(view.xyz/view.w);
vec3 sun_dir=normalize(g_SunDir);
float sunAngle=dot(sun_dir,vec3(0.0,0.0,1.0))/(length(sun_dir)*length(vec3(0.0,0.0,1.0)));
const float u=4.25f;
float v=(3.0-u)/2.0;
float b=(4.0/(3.0*pow(1.33f-1.0,2.0)))*(0.5f-0.5f*(dot(eye_dir,sun_dir)));
float p=1.0-((1.0-pow(b,v+1.0)-(0.5f*(1.0-pow(b,v))))/((1.0-b)*pow(b,v)));
float A=acos(dot(sun_dir,vec3(0.0,0.0,1.0))/(length(sun_dir)*length(vec3(0.0,0.0,1.0))));
float B=acos(dot(eye_dir,-vec3(0.0,0.0,1.0))/(length(eye_dir)*length(vec3(0.0,0.0,1.0))));
const float c=1.0;
vec3 extinction=scattering+absorption;
vec3 albedo=scattering/extinction;
if(waterDepth<0.0)
{
waterDepth*=-1.0;
float eye_depth=abs(depthInput.z);
float pointDepth=0.0;
if(normalsInput.w==0.0)
{
if(eye_dir.z<0.0)
{
pointDepth=eye_depth+abs(waterDepth*dot(eye_dir,vec3(0.0,0.0,-1.0))/(length(eye_dir)*length(vec3(0.0,0.0,-1.0))));
}
else

{
pointDepth=eye_depth-abs(waterDepth*sin((3.1415926536f/2.0)-acos(dot(eye_dir,vec3(0.0,0.0,1.0))/(length(eye_dir)*length(vec3(0.0,0.0,1.0))))));
}

if(sun_dir.z>=0.0)
{
scatterDepth=pointDepth/sunAngle;
}
else

{
scatterDepth=pointDepth;
}

}
else

{
if(scatteringInput.w>0.0||absorptionInput.w>0.0)
{
refractColourInput+=vec4(absorptionInput.w*g_SunColor*clamp(dot(normal,sun_dir),0.1,1.0),0.0);
}

scatterDepth=eye_depth;
}

float sunEffect=((dot(eye_dir,sun_dir)+1.0)/2.0);
if(sun_dir.z<=0.0)sunEffect=0.0;
if(depthInput.w<=0.0)
{
scatterDepth=0.0;
}

vec3 incomingRadiance=exp(-extinction*eye_depth*fadeDistance)*g_SunColor;
vec4 mult=vec4(exp(-extinction*(waterDepth+scatterDepth)*fadeDistance).xyz*refractColourInput.xyz,1.0);
vec4 surfaceScattering=vec4(incomingRadiance*exp(-extinction),0.0);
vec4 SSS=vec4((albedo*(p/(1.0+c))*(1.0-(exp(-extinction*(1.0+c)*(fadeDistance*waterDepth))))),0.0);
SSS=max(SSS,vec4(0.0,0.0,0.0,0.0));
surfaceScattering=max(surfaceScattering,vec4(0.0,0.0,0.0,0.0));
Output+=mult;
Output+=SSS*surfaceScattering;
return max(Output,vec4(0.0,0.0,0.0,0.0));
}

if(depthInput.y<=0.0000001f)discard;
float pointDepth=abs(absoluteDepth*(dot(eye_dir,vec3(0.0,0.0,-1.0))/(length(eye_dir)*length(vec3(0.0,0.0,-1.0)))));
if((sun_dir.z>=0.0))
{
float sunAngle=dot(-sun_dir,vec3(-sun_dir.xy,0.0))/(length(-sun_dir)*length(vec3(-sun_dir.xy,0.0)));
scatterDepth=pointDepth/sin(acos(sunAngle));
}
else

{
scatterDepth=pointDepth;
}

normal.z+=max(((depthInput.w*100.0)-(1/30)),0);
normal=normalize(normal);
vec3 reflect_vec=reflect(eye_dir,normal);
vec3 refract_vec=refract(eye_dir,normal,1.0/1.33f);
float sunEffect=(dot(normal,sun_dir)+1.0)/2.0;
reflect_vec.z=max(reflect_vec.z,0.025);
vec4 refl=vec4(0.0,0.0,0.0,0.0);
if(reflections)
{
refl=texture(sampler2D(g_waterReflectColour[1 + 3]),In.texCoords);
if(refl.x<0.0)
{
refl=textureLod(samplerCube(g_texReflectCube[1 + 4]),normalize(reflect_vec.yxz),0);
;
refl*=0.75;
}

}
else

{
refl=textureLod(samplerCube(g_texReflectCube[1 + 4]),normalize(reflect_vec.yxz),0);
;
refl*=0.75;
}

refl*=g_reflectionBrightness;
float reflectFresnel=fresnel(normalize(reflect_vec),normal,1.0,1.33f);
Output+=refl*reflectFresnel;
sun_dir.z=max(sun_dir.z,0.0);
float sunScatter=saturate(dot(refract_vec,sun_dir));
float cosangle=acos(dot(reflect_vec,sun_dir)/(length(reflect_vec)*length(sun_dir)));
if((cosangle<g_SunRadius*(3.1415926536f/360.0/10.0))&&!(scatteringInput.w>0.0&&absorptionInput.w>0.0))
{
float cos_spec=dot(reflect_vec,sun_dir);
vec4 sunSpec=vec4(((g_Shineness+1.0)/(2.0*3.1415926536))*pow(saturate(cos_spec),g_Shineness)*g_SunColor*10.0,0.0);
if(reflections&&refl.w!=-1.0)Output+=sunSpec;
}

if(sun_dir.z<=0)sunScatter=0.0;
float eye_depth=abs(depthInput.z);
vec3 incomingRadiance=exp(-extinction*waterDepth*fadeDistance)*g_SunColor;
vec4 mult=vec4(exp(-extinction*(waterDepth+scatterDepth)*fadeDistance).xyz*refractColourInput.xyz,1.0);
vec4 surfaceScattering=vec4(g_SunColor*exp(-extinction),0.0);
vec4 SSS=vec4((albedo*(p/(1.0+c))*(1.0-(exp(-extinction*(1.0+c)*fadeDistance*absoluteDepth)))),0.0f);
Output+=mult;
Output+=SSS*surfaceScattering;
Output+=SSS*sunScatter*(1.0-reflectFresnel);
Output+=SSS*absorptionInput.w;
if(scatteringInput.w>0.0&&absorptionInput.w>0.0)
{
Output+=vec4(g_SunColor,0.0)*absorptionInput.w*clamp(dot(normal,sun_dir),0.1f,1.0);
}

return Output;
}
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out float4 returnObject_float4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 2737 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
{returnObject_float4=PS_WaterSurfFinal(BlockData,false);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_PS_WaterSurfFinalReflection.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 1) uniform cbShading
{
	vec3 g_SunDir;
	float g_Shineness;
	vec3 g_SunColor;
	float g_ShoreExtent;
	float g_oceanHeight;
	float g_vrRightEye;
	vec2 g_viewportPixelScale;
	int g_noOfReflectionSteps;
	int g_pixelStep;
	float g_reverseFace;
	bool g_enableFoam;
	float g_UVScale;
	float g_UVOffset;
	float g_WorldScale;
	float g_SunRadius;
	vec2 g_DepthScale;
	vec2 g_screenScale;
	vec4 g_DepthToLinFadeParams;
	vec4 g_HalfTan;
	vec3 g_ShoreDepthTextureLocation;
	float g_ShoreWidth;
	float gkfpdngkpfdp;
	float g_reflectionDistance;
	bool g_vrEnable;
	float g_reflectionBrightness;
};
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};







layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t g_waterDepth[24];
	uint64_t g_waterAbsorption[24];
	uint64_t g_waterScattering[24];
	uint64_t g_waterNormals[24];
	uint64_t g_waterRefractColour[24];
	uint64_t g_waterReflectColour[24];
	uint64_t g_texReflectCube[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 178 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
float fresnel(vec3 incident, vec3 normal, float sourceIndex, float mediumIndex)
{
float cos_incident=clamp(-1.0,1.0,dot(incident,normal));
float R0=pow(((mediumIndex-sourceIndex)/(mediumIndex+sourceIndex)),2.0);
return R0+(1-R0)*pow(1-cos_incident,5.0);
}
#line 2500 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
float4 PS_WaterSurfFinal(posTexVertexOutput In, bool reflections)
{
vec2 TexCoords=In.texCoords;
if(g_vrEnable)TexCoords=In.texCoords*(+vec2(g_vrRightEye*0.5,0));
float4 depthInput=texture(sampler2D(g_waterDepth[1 + 9]),TexCoords);
if(depthInput.y<=0.0)discard;
float waterDepth=depthInput.x;
if(waterDepth==0.0)waterDepth=depthInput.y;
float4 Output=vec4(0.0,0.0,0.0,1.0);
float4 absorptionInput=texture(sampler2D(g_waterAbsorption[1 + 9]),TexCoords);
vec3 absorption=absorptionInput.xyz;
float4 scatteringInput=texture(sampler2D(g_waterScattering[1 + 9]),TexCoords);
vec3 scattering=scatteringInput.xyz;
float4 normalsInput=texture(sampler2D(g_waterNormals[1 + 9]),TexCoords);
float4 refractColourInput=texture(sampler2D(g_waterRefractColour[1 + 9]),TexCoords);
vec3 normal=normalsInput.xyz;
float scatterDepth=0.0;
float fadeDistance=300000.0;
float absoluteDepth=depthInput.y;
vec4 clip=vec4((In.texCoords.x*2.0)-1.0,((1.0-In.texCoords.y)*2.0)-1.0,1.0,1.0);
vec4 view=mul(g_matInvViewProj,clip);
vec3 eye_dir=normalize(view.xyz/view.w);
vec3 sun_dir=normalize(g_SunDir);
float sunAngle=dot(sun_dir,vec3(0.0,0.0,1.0))/(length(sun_dir)*length(vec3(0.0,0.0,1.0)));
const float u=4.25f;
float v=(3.0-u)/2.0;
float b=(4.0/(3.0*pow(1.33f-1.0,2.0)))*(0.5f-0.5f*(dot(eye_dir,sun_dir)));
float p=1.0-((1.0-pow(b,v+1.0)-(0.5f*(1.0-pow(b,v))))/((1.0-b)*pow(b,v)));
float A=acos(dot(sun_dir,vec3(0.0,0.0,1.0))/(length(sun_dir)*length(vec3(0.0,0.0,1.0))));
float B=acos(dot(eye_dir,-vec3(0.0,0.0,1.0))/(length(eye_dir)*length(vec3(0.0,0.0,1.0))));
const float c=1.0;
vec3 extinction=scattering+absorption;
vec3 albedo=scattering/extinction;
if(waterDepth<0.0)
{
waterDepth*=-1.0;
float eye_depth=abs(depthInput.z);
float pointDepth=0.0;
if(normalsInput.w==0.0)
{
if(eye_dir.z<0.0)
{
pointDepth=eye_depth+abs(waterDepth*dot(eye_dir,vec3(0.0,0.0,-1.0))/(length(eye_dir)*length(vec3(0.0,0.0,-1.0))));
}
else

{
pointDepth=eye_depth-abs(waterDepth*sin((3.1415926536f/2.0)-acos(dot(eye_dir,vec3(0.0,0.0,1.0))/(length(eye_dir)*length(vec3(0.0,0.0,1.0))))));
}

if(sun_dir.z>=0.0)
{
scatterDepth=pointDepth/sunAngle;
}
else

{
scatterDepth=pointDepth;
}

}
else

{
if(scatteringInput.w>0.0||absorptionInput.w>0.0)
{
refractColourInput+=vec4(absorptionInput.w*g_SunColor*clamp(dot(normal,sun_dir),0.1,1.0),0.0);
}

scatterDepth=eye_depth;
}

float sunEffect=((dot(eye_dir,sun_dir)+1.0)/2.0);
if(sun_dir.z<=0.0)sunEffect=0.0;
if(depthInput.w<=0.0)
{
scatterDepth=0.0;
}

vec3 incomingRadiance=exp(-extinction*eye_depth*fadeDistance)*g_SunColor;
vec4 mult=vec4(exp(-extinction*(waterDepth+scatterDepth)*fadeDistance).xyz*refractColourInput.xyz,1.0);
vec4 surfaceScattering=vec4(incomingRadiance*exp(-extinction),0.0);
vec4 SSS=vec4((albedo*(p/(1.0+c))*(1.0-(exp(-extinction*(1.0+c)*(fadeDistance*waterDepth))))),0.0);
SSS=max(SSS,vec4(0.0,0.0,0.0,0.0));
surfaceScattering=max(surfaceScattering,vec4(0.0,0.0,0.0,0.0));
Output+=mult;
Output+=SSS*surfaceScattering;
return max(Output,vec4(0.0,0.0,0.0,0.0));
}

if(depthInput.y<=0.0000001f)discard;
float pointDepth=abs(absoluteDepth*(dot(eye_dir,vec3(0.0,0.0,-1.0))/(length(eye_dir)*length(vec3(0.0,0.0,-1.0)))));
if((sun_dir.z>=0.0))
{
float sunAngle=dot(-sun_dir,vec3(-sun_dir.xy,0.0))/(length(-sun_dir)*length(vec3(-sun_dir.xy,0.0)));
scatterDepth=pointDepth/sin(acos(sunAngle));
}
else

{
scatterDepth=pointDepth;
}

normal.z+=max(((depthInput.w*100.0)-(1/30)),0);
normal=normalize(normal);
vec3 reflect_vec=reflect(eye_dir,normal);
vec3 refract_vec=refract(eye_dir,normal,1.0/1.33f);
float sunEffect=(dot(normal,sun_dir)+1.0)/2.0;
reflect_vec.z=max(reflect_vec.z,0.025);
vec4 refl=vec4(0.0,0.0,0.0,0.0);
if(reflections)
{
refl=texture(sampler2D(g_waterReflectColour[1 + 3]),In.texCoords);
if(refl.x<0.0)
{
refl=textureLod(samplerCube(g_texReflectCube[1 + 4]),normalize(reflect_vec.yxz),0);
;
refl*=0.75;
}

}
else

{
refl=textureLod(samplerCube(g_texReflectCube[1 + 4]),normalize(reflect_vec.yxz),0);
;
refl*=0.75;
}

refl*=g_reflectionBrightness;
float reflectFresnel=fresnel(normalize(reflect_vec),normal,1.0,1.33f);
Output+=refl*reflectFresnel;
sun_dir.z=max(sun_dir.z,0.0);
float sunScatter=saturate(dot(refract_vec,sun_dir));
float cosangle=acos(dot(reflect_vec,sun_dir)/(length(reflect_vec)*length(sun_dir)));
if((cosangle<g_SunRadius*(3.1415926536f/360.0/10.0))&&!(scatteringInput.w>0.0&&absorptionInput.w>0.0))
{
float cos_spec=dot(reflect_vec,sun_dir);
vec4 sunSpec=vec4(((g_Shineness+1.0)/(2.0*3.1415926536))*pow(saturate(cos_spec),g_Shineness)*g_SunColor*10.0,0.0);
if(reflections&&refl.w!=-1.0)Output+=sunSpec;
}

if(sun_dir.z<=0)sunScatter=0.0;
float eye_depth=abs(depthInput.z);
vec3 incomingRadiance=exp(-extinction*waterDepth*fadeDistance)*g_SunColor;
vec4 mult=vec4(exp(-extinction*(waterDepth+scatterDepth)*fadeDistance).xyz*refractColourInput.xyz,1.0);
vec4 surfaceScattering=vec4(g_SunColor*exp(-extinction),0.0);
vec4 SSS=vec4((albedo*(p/(1.0+c))*(1.0-(exp(-extinction*(1.0+c)*fadeDistance*absoluteDepth)))),0.0f);
Output+=mult;
Output+=SSS*surfaceScattering;
Output+=SSS*sunScatter*(1.0-reflectFresnel);
Output+=SSS*absorptionInput.w;
if(scatteringInput.w>0.0&&absorptionInput.w>0.0)
{
Output+=vec4(g_SunColor,0.0)*absorptionInput.w*clamp(dot(normal,sun_dir),0.1f,1.0);
}

return Output;
}
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out float4 returnObject_float4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 2742 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
{returnObject_float4=PS_WaterSurfFinal(BlockData,true);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_PS_Wireframe.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};
layout(location = 0) in Block
{
VS_OUTPUT BlockData;
} ioblock;
layout(location = 0) out float4 returnObject_float4;

void main()
{
VS_OUTPUT BlockData=ioblock.BlockData;
#line 2896 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
{returnObject_float4=BlockData.vecColour;}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_VS_BoundedWaterSurf_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 1) uniform cbShading
{
	vec3 g_SunDir;
	float g_Shineness;
	vec3 g_SunColor;
	float g_ShoreExtent;
	float g_oceanHeight;
	float g_vrRightEye;
	vec2 g_viewportPixelScale;
	int g_noOfReflectionSteps;
	int g_pixelStep;
	float g_reverseFace;
	bool g_enableFoam;
	float g_UVScale;
	float g_UVOffset;
	float g_WorldScale;
	float g_SunRadius;
	vec2 g_DepthScale;
	vec2 g_screenScale;
	vec4 g_DepthToLinFadeParams;
	vec4 g_HalfTan;
	vec3 g_ShoreDepthTextureLocation;
	float g_ShoreWidth;
	float gkfpdngkpfdp;
	float g_reflectionDistance;
	bool g_vrEnable;
	float g_reflectionBrightness;
};
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};

layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t g_ProfileBuffers[24];
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
layout(location = 0) out Block
{
VS_OUTPUT BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 1584 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
float profileOffsets[16]={0.54f,0.18f,0.61f,0.28f,0.09f,0.71f,0.99f,0.43f,0.11f,0.85f,0.24f,0.67f,0.31f,0.86f,0.13f,0.01f};
vec2 profile32Directons[32]={vec2(1.0f,0.0f),vec2(0.98f,0.19f),vec2(0.92f,0.38f),vec2(0.83f,0.55f),vec2(0.707f,0.707f),vec2(0.55f,0.83f),vec2(0.38f,0.92f),vec2(0.19f,0.98f),vec2(0.0f,1.0f),vec2(-0.19f,0.98f),vec2(-0.38f,0.92f),vec2(-0.55f,0.83f),vec2(-0.707f,0.707f),vec2(-0.83f,0.55f),vec2(-0.92f,0.38f),vec2(-0.98f,0.19f),vec2(-1.0f,-0.0f),vec2(-0.98f,-0.19f),vec2(-0.92f,-0.38f),vec2(-0.83f,-0.55f),vec2(-0.707f,-0.707f),vec2(-0.55f,-0.83f),vec2(-0.38f,-0.92f),vec2(-0.19f,-0.98f),vec2(0.0f,-1.0f),vec2(0.19f,-0.98f),vec2(0.38f,-0.92f),vec2(0.55f,-0.83f),vec2(0.707f,-0.707f),vec2(0.83f,-0.55f),vec2(0.92f,-0.38f),vec2(0.98f,-0.19f),};
VS_OUTPUT Output;
uint vertexNo=IN.vertex_id;
Output.vecColour=vec4(0.0,0.0,0.0,1.0);
vec3 vPos=vec3(0.0,0.0,0.0);
uint boundingVerticies=((((2*g_boundedDensity.x)+4)+((2*g_boundedDensity.y)+4))*2);
uint xBoundingVerticies=(2*g_boundedDensity.x)+4;
uint yBoundingVerticies=(2*g_boundedDensity.y)+4;
bool noDisplacement=false;
bool noGradient=false;
if(vertexNo!=0)vertexNo--;
if(vertexNo<=6)
{
noDisplacement=true;
noGradient=true;
vPos.z=-g_boundedDimension.z;
vec2 vertexPositions[6]={vec2(0.0f,0.0f),vec2(0.0f,0.0f),vec2(g_boundedDensity.x,0.0f),vec2(0.0f,g_boundedDensity.y),vec2(g_boundedDensity.x,g_boundedDensity.y),vec2(g_boundedDensity.x,g_boundedDensity.y)};
vPos.x=vertexPositions[vertexNo].x;
vPos.y=vertexPositions[vertexNo].y;
}
else

{
vertexNo-=6;
if(vertexNo<boundingVerticies)
{
uint edgeNo=0;
noGradient=true;
if(vertexNo>=boundingVerticies/2)
{
edgeNo+=2;
vertexNo-=boundingVerticies/2;
}

if(vertexNo>=xBoundingVerticies)
{
edgeNo++;
vertexNo-=xBoundingVerticies;
}

if(typed_mod(edgeNo,2)==0)
{
vertexNo=clamp(vertexNo,1,xBoundingVerticies-2);
vPos.z=-g_boundedDimension.z*((typed_mod(vertexNo,2)));
noDisplacement=((typed_mod(vertexNo,2))==1);
vPos.x=(vertexNo-(2-(typed_mod(vertexNo,2))))/2;
vPos.x=abs((g_boundedDensity.x*(edgeNo/2))-vPos.x);
vPos.y=g_boundedDensity.y*(edgeNo/2);
}
else

{
vertexNo=clamp(vertexNo,1,yBoundingVerticies-2);
vPos.z=-g_boundedDimension.z*((typed_mod(vertexNo,2)));
noDisplacement=((typed_mod(vertexNo,2))==1);
vPos.x=g_boundedDensity.x*((edgeNo-1)/2);
vPos.y=(vertexNo-(2-(typed_mod(vertexNo,2))))/2;
vPos.y=abs((g_boundedDensity.y*(typed_mod(edgeNo,3)))-vPos.y);
}

}
else

{
vertexNo-=boundingVerticies;
uint rowVerticies=((g_boundedDensity.x*2)+4);
uint vertexRowNo=typed_mod(vertexNo,rowVerticies);
uint rowNo=(vertexNo-vertexRowNo)/rowVerticies;
vertexRowNo=clamp(vertexRowNo,1,rowVerticies-2);
vPos.x=(vertexRowNo-(2-(typed_mod(vertexRowNo,2))))/2;
vPos.y=(typed_mod((vertexRowNo+1),2))+rowNo;
}

}

vPos.xy*=g_boundedDimension.xy/g_boundedDensity;
vPos.xy-=g_boundedDimension.xy/2.0;
float rotation=-(g_boundedRotation/360.0)*3.1415926536f*2.0;
vPos.xy=vec2(vPos.x*cos(rotation)-vPos.y*sin(rotation),vPos.y*cos(rotation)+vPos.x*sin(rotation));
vPos+=g_boundedLocation.yxz;
float4 pos_local=float4(vPos,1);
vec2 uv_local=(pos_local.xy-g_objectCenter.yx)*g_UVScale;
if(!noDisplacement)
{
vec3 eye_vec=pos_local.xyz-g_LocalEye;
float dist_2d=length(eye_vec.xy);
float blend_factor=(1000-dist_2d)/(1000-200);
blend_factor=clamp(blend_factor,0,1);
vec3 displacement=vec3(0,0,0);
if(blend_factor>0)
{
const float tau=6.28318530718;
uint dirNum=16;
uint N=2*dirNum;
float dx=dirNum*6.28318530718f/N;
vec2 windDirection=normalize(vec2(sin(g_windDirection),cos(g_windDirection)));
uint i;
for(i=0;i<N;i++)
{
float angle=((i)/(N))*6.28318530718f;
vec2 texcDir=normalize(profile32Directons[i]);
vec2 texc=texcDir*uv_local*g_profileUVScale;
float baseAmplitude=pow(((dot(windDirection,texcDir)+1.0)+((dot(-windDirection,texcDir)+1.0)*(1.0-g_windDependency)))/2.0,4.0);
vec2 displacementValue=g_amplitude*dx*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,0.0f),0).xy)*(baseAmplitude/2.0);
displacement+=vec3(displacementValue.x*texcDir.x,displacementValue.x*texcDir.y,displacementValue.y);
}

displacement*=g_WorldScale;
displacement=mix(vec3(0,0,0),displacement,blend_factor);
pos_local.xyz+=displacement;
}

}

if(noGradient)Output.vecColour.x=1.0;
Output.Position=mul(g_matWorldViewProj,pos_local);
Output.LocalPos=pos_local.xyz;
Output.texCoords=uv_local;
Output.SurePosition=Output.Position;
{
ioblock.BlockData=Output;
gl_Position=Output.Position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_VS_BoundedWaterSurf_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 1) uniform cbShading
{
	vec3 g_SunDir;
	float g_Shineness;
	vec3 g_SunColor;
	float g_ShoreExtent;
	float g_oceanHeight;
	float g_vrRightEye;
	vec2 g_viewportPixelScale;
	int g_noOfReflectionSteps;
	int g_pixelStep;
	float g_reverseFace;
	bool g_enableFoam;
	float g_UVScale;
	float g_UVOffset;
	float g_WorldScale;
	float g_SunRadius;
	vec2 g_DepthScale;
	vec2 g_screenScale;
	vec4 g_DepthToLinFadeParams;
	vec4 g_HalfTan;
	vec3 g_ShoreDepthTextureLocation;
	float g_ShoreWidth;
	float gkfpdngkpfdp;
	float g_reflectionDistance;
	bool g_vrEnable;
	float g_reflectionBrightness;
};
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};

layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t g_ProfileBuffers[24];
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
layout(location = 0) out Block
{
VS_OUTPUT BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 1584 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
float profileOffsets[16]={0.54f,0.18f,0.61f,0.28f,0.09f,0.71f,0.99f,0.43f,0.11f,0.85f,0.24f,0.67f,0.31f,0.86f,0.13f,0.01f};
vec2 profile32Directons[32]={vec2(1.0f,0.0f),vec2(0.98f,0.19f),vec2(0.92f,0.38f),vec2(0.83f,0.55f),vec2(0.707f,0.707f),vec2(0.55f,0.83f),vec2(0.38f,0.92f),vec2(0.19f,0.98f),vec2(0.0f,1.0f),vec2(-0.19f,0.98f),vec2(-0.38f,0.92f),vec2(-0.55f,0.83f),vec2(-0.707f,0.707f),vec2(-0.83f,0.55f),vec2(-0.92f,0.38f),vec2(-0.98f,0.19f),vec2(-1.0f,-0.0f),vec2(-0.98f,-0.19f),vec2(-0.92f,-0.38f),vec2(-0.83f,-0.55f),vec2(-0.707f,-0.707f),vec2(-0.55f,-0.83f),vec2(-0.38f,-0.92f),vec2(-0.19f,-0.98f),vec2(0.0f,-1.0f),vec2(0.19f,-0.98f),vec2(0.38f,-0.92f),vec2(0.55f,-0.83f),vec2(0.707f,-0.707f),vec2(0.83f,-0.55f),vec2(0.92f,-0.38f),vec2(0.98f,-0.19f),};
VS_OUTPUT Output;
uint vertexNo=IN.vertex_id;
Output.vecColour=vec4(0.0,0.0,0.0,1.0);
vec3 vPos=vec3(0.0,0.0,0.0);
uint boundingVerticies=((((2*g_boundedDensity.x)+4)+((2*g_boundedDensity.y)+4))*2);
uint xBoundingVerticies=(2*g_boundedDensity.x)+4;
uint yBoundingVerticies=(2*g_boundedDensity.y)+4;
bool noDisplacement=false;
bool noGradient=false;
if(vertexNo!=0)vertexNo--;
if(vertexNo<=6)
{
noDisplacement=true;
noGradient=true;
vPos.z=-g_boundedDimension.z;
vec2 vertexPositions[6]={vec2(0.0f,0.0f),vec2(0.0f,0.0f),vec2(g_boundedDensity.x,0.0f),vec2(0.0f,g_boundedDensity.y),vec2(g_boundedDensity.x,g_boundedDensity.y),vec2(g_boundedDensity.x,g_boundedDensity.y)};
vPos.x=vertexPositions[vertexNo].x;
vPos.y=vertexPositions[vertexNo].y;
}
else

{
vertexNo-=6;
if(vertexNo<boundingVerticies)
{
uint edgeNo=0;
noGradient=true;
if(vertexNo>=boundingVerticies/2)
{
edgeNo+=2;
vertexNo-=boundingVerticies/2;
}

if(vertexNo>=xBoundingVerticies)
{
edgeNo++;
vertexNo-=xBoundingVerticies;
}

if(typed_mod(edgeNo,2)==0)
{
vertexNo=clamp(vertexNo,1,xBoundingVerticies-2);
vPos.z=-g_boundedDimension.z*((typed_mod(vertexNo,2)));
noDisplacement=((typed_mod(vertexNo,2))==1);
vPos.x=(vertexNo-(2-(typed_mod(vertexNo,2))))/2;
vPos.x=abs((g_boundedDensity.x*(edgeNo/2))-vPos.x);
vPos.y=g_boundedDensity.y*(edgeNo/2);
}
else

{
vertexNo=clamp(vertexNo,1,yBoundingVerticies-2);
vPos.z=-g_boundedDimension.z*((typed_mod(vertexNo,2)));
noDisplacement=((typed_mod(vertexNo,2))==1);
vPos.x=g_boundedDensity.x*((edgeNo-1)/2);
vPos.y=(vertexNo-(2-(typed_mod(vertexNo,2))))/2;
vPos.y=abs((g_boundedDensity.y*(typed_mod(edgeNo,3)))-vPos.y);
}

}
else

{
vertexNo-=boundingVerticies;
uint rowVerticies=((g_boundedDensity.x*2)+4);
uint vertexRowNo=typed_mod(vertexNo,rowVerticies);
uint rowNo=(vertexNo-vertexRowNo)/rowVerticies;
vertexRowNo=clamp(vertexRowNo,1,rowVerticies-2);
vPos.x=(vertexRowNo-(2-(typed_mod(vertexRowNo,2))))/2;
vPos.y=(typed_mod((vertexRowNo+1),2))+rowNo;
}

}

vPos.xy*=g_boundedDimension.xy/g_boundedDensity;
vPos.xy-=g_boundedDimension.xy/2.0;
float rotation=-(g_boundedRotation/360.0)*3.1415926536f*2.0;
vPos.xy=vec2(vPos.x*cos(rotation)-vPos.y*sin(rotation),vPos.y*cos(rotation)+vPos.x*sin(rotation));
vPos+=g_boundedLocation.yxz;
float4 pos_local=float4(vPos,1);
vec2 uv_local=(pos_local.xy-g_objectCenter.yx)*g_UVScale;
if(!noDisplacement)
{
vec3 eye_vec=pos_local.xyz-g_LocalEye;
float dist_2d=length(eye_vec.xy);
float blend_factor=(1000-dist_2d)/(1000-200);
blend_factor=clamp(blend_factor,0,1);
vec3 displacement=vec3(0,0,0);
if(blend_factor>0)
{
const float tau=6.28318530718;
uint dirNum=16;
uint N=2*dirNum;
float dx=dirNum*6.28318530718f/N;
vec2 windDirection=normalize(vec2(sin(g_windDirection),cos(g_windDirection)));
uint i;
for(i=0;i<N;i++)
{
float angle=((i)/(N))*6.28318530718f;
vec2 texcDir=normalize(profile32Directons[i]);
vec2 texc=texcDir*uv_local*g_profileUVScale;
float baseAmplitude=pow(((dot(windDirection,texcDir)+1.0)+((dot(-windDirection,texcDir)+1.0)*(1.0-g_windDependency)))/2.0,4.0);
vec2 displacementValue=g_amplitude*dx*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,0.0f),0).xy)*(baseAmplitude/2.0);
displacement+=vec3(displacementValue.x*texcDir.x,displacementValue.x*texcDir.y,displacementValue.y);
}

displacement*=g_WorldScale;
displacement=mix(vec3(0,0,0),displacement,blend_factor);
pos_local.xyz+=displacement;
}

}

if(noGradient)Output.vecColour.x=1.0;
Output.Position=mul(g_matWorldViewProj,pos_local);
Output.LocalPos=pos_local.xyz;
Output.texCoords=uv_local;
Output.SurePosition=Output.Position;
{
ioblock.BlockData=Output;
gl_Position=Output.Position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_VS_BoundedWaterSurfCustom_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 1) uniform cbShading
{
	vec3 g_SunDir;
	float g_Shineness;
	vec3 g_SunColor;
	float g_ShoreExtent;
	float g_oceanHeight;
	float g_vrRightEye;
	vec2 g_viewportPixelScale;
	int g_noOfReflectionSteps;
	int g_pixelStep;
	float g_reverseFace;
	bool g_enableFoam;
	float g_UVScale;
	float g_UVOffset;
	float g_WorldScale;
	float g_SunRadius;
	vec2 g_DepthScale;
	vec2 g_screenScale;
	vec4 g_DepthToLinFadeParams;
	vec4 g_HalfTan;
	vec3 g_ShoreDepthTextureLocation;
	float g_ShoreWidth;
	float gkfpdngkpfdp;
	float g_reflectionDistance;
	bool g_vrEnable;
	float g_reflectionBrightness;
};
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 147 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 5) uniform cbMeshObjectBuffers
{
	float g_buoyancyUVScale;
	float g_buoyancyUVOffset;
	float g_buoyancySurfaceHeight;
	float g_buoyancyWaveAmplitude;
	vec2 g_buoyancyCenter;
	float g_buoyancyWindDirection;
	float g_buoyancyWindDependancy;
	float g_buoyancyProfileUVScale;
	float g_buoyancyWaveGridScale;
	bool g_buoyancyEnableWaveGrid;
	float gnuhjfidobn;
	mat4 g_meshMat;
	vec3 g_location;
	int g_ID;
	vec4 g_rotation;
	vec3 g_scale;
	float vufiepadnu;
};
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};

#line 68 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
struct vertexOnlyInput
{
	vec3 position;
};
layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t g_ProfileBuffers[24];
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
layout(location=0) in vec3 position;

layout(location = 0) out Block
{
VS_OUTPUT BlockData;
} ioblock;
void main()
{
vertexOnlyInput IN;
IN.position=position;
#line 1812 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
float profileOffsets[16]={0.54f,0.18f,0.61f,0.28f,0.09f,0.71f,0.99f,0.43f,0.11f,0.85f,0.24f,0.67f,0.31f,0.86f,0.13f,0.01f};
vec2 profile32Directons[32]={vec2(1.0f,0.0f),vec2(0.98f,0.19f),vec2(0.92f,0.38f),vec2(0.83f,0.55f),vec2(0.707f,0.707f),vec2(0.55f,0.83f),vec2(0.38f,0.92f),vec2(0.19f,0.98f),vec2(0.0f,1.0f),vec2(-0.19f,0.98f),vec2(-0.38f,0.92f),vec2(-0.55f,0.83f),vec2(-0.707f,0.707f),vec2(-0.83f,0.55f),vec2(-0.92f,0.38f),vec2(-0.98f,0.19f),vec2(-1.0f,-0.0f),vec2(-0.98f,-0.19f),vec2(-0.92f,-0.38f),vec2(-0.83f,-0.55f),vec2(-0.707f,-0.707f),vec2(-0.55f,-0.83f),vec2(-0.38f,-0.92f),vec2(-0.19f,-0.98f),vec2(0.0f,-1.0f),vec2(0.19f,-0.98f),vec2(0.38f,-0.92f),vec2(0.55f,-0.83f),vec2(0.707f,-0.707f),vec2(0.83f,-0.55f),vec2(0.92f,-0.38f),vec2(0.98f,-0.19f),};
VS_OUTPUT Output;
Output.vecColour=vec4(0.0,0.0,0.0,1.0);
vec3 vPos=vec3(0.0,0.0,0.0);
bool noDisplacement=false;
bool noGradient=false;
float4 pos_local=float4(IN.position.xyz*vec3(g_scale.x,g_scale.y,g_scale.z),1);
pos_local=mul(g_meshMat,pos_local);
vec2 uv_local=(pos_local.xy-g_objectCenter.yx)*g_UVScale;
if(!noDisplacement)
{
vec3 eye_vec=pos_local.xyz-g_LocalEye;
float dist_2d=length(eye_vec.xy);
float blend_factor=(1000-dist_2d)/(1000-200);
blend_factor=clamp(blend_factor,0,1);
vec3 displacement=vec3(0,0,0);
if(blend_factor>0)
{
const float tau=6.28318530718;
uint dirNum=16;
uint N=2*dirNum;
float dx=dirNum*6.28318530718f/N;
vec2 windDirection=normalize(vec2(sin(g_windDirection),cos(g_windDirection)));
uint i;
for(i=0;i<N;i++)
{
float angle=((i)/(N))*6.28318530718f;
vec2 texcDir=normalize(profile32Directons[i]);
vec2 texc=texcDir*uv_local*g_profileUVScale;
float baseAmplitude=pow(((dot(windDirection,texcDir)+1.0)+((dot(-windDirection,texcDir)+1.0)*(1.0-g_windDependency)))/2.0,4.0);
vec2 displacementValue=g_amplitude*dx*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,0.0f),0).xy)*(baseAmplitude/2.0);
displacement+=vec3(displacementValue.x*texcDir.x,displacementValue.x*texcDir.y,displacementValue.y);
}

displacement*=g_WorldScale;
displacement=mix(vec3(0,0,0),displacement,blend_factor);
pos_local.xyz+=displacement;
}

}

if(noGradient)Output.vecColour.x=1.0;
Output.Position=mul(g_matWorldViewProj,pos_local);
Output.LocalPos=pos_local.xyz;
Output.texCoords=uv_local;
Output.SurePosition=Output.Position;
{
ioblock.BlockData=Output;
gl_Position=Output.Position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_VS_BoundedWaterSurfCustom_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 1) uniform cbShading
{
	vec3 g_SunDir;
	float g_Shineness;
	vec3 g_SunColor;
	float g_ShoreExtent;
	float g_oceanHeight;
	float g_vrRightEye;
	vec2 g_viewportPixelScale;
	int g_noOfReflectionSteps;
	int g_pixelStep;
	float g_reverseFace;
	bool g_enableFoam;
	float g_UVScale;
	float g_UVOffset;
	float g_WorldScale;
	float g_SunRadius;
	vec2 g_DepthScale;
	vec2 g_screenScale;
	vec4 g_DepthToLinFadeParams;
	vec4 g_HalfTan;
	vec3 g_ShoreDepthTextureLocation;
	float g_ShoreWidth;
	float gkfpdngkpfdp;
	float g_reflectionDistance;
	bool g_vrEnable;
	float g_reflectionBrightness;
};
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 147 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 5) uniform cbMeshObjectBuffers
{
	float g_buoyancyUVScale;
	float g_buoyancyUVOffset;
	float g_buoyancySurfaceHeight;
	float g_buoyancyWaveAmplitude;
	vec2 g_buoyancyCenter;
	float g_buoyancyWindDirection;
	float g_buoyancyWindDependancy;
	float g_buoyancyProfileUVScale;
	float g_buoyancyWaveGridScale;
	bool g_buoyancyEnableWaveGrid;
	float gnuhjfidobn;
	mat4 g_meshMat;
	vec3 g_location;
	int g_ID;
	vec4 g_rotation;
	vec3 g_scale;
	float vufiepadnu;
};
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};

#line 68 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
struct vertexOnlyInput
{
	vec3 position;
};
layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t g_ProfileBuffers[24];
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
layout(location=0) in vec3 position;

layout(location = 0) out Block
{
VS_OUTPUT BlockData;
} ioblock;
void main()
{
vertexOnlyInput IN;
IN.position=position;
#line 1812 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
float profileOffsets[16]={0.54f,0.18f,0.61f,0.28f,0.09f,0.71f,0.99f,0.43f,0.11f,0.85f,0.24f,0.67f,0.31f,0.86f,0.13f,0.01f};
vec2 profile32Directons[32]={vec2(1.0f,0.0f),vec2(0.98f,0.19f),vec2(0.92f,0.38f),vec2(0.83f,0.55f),vec2(0.707f,0.707f),vec2(0.55f,0.83f),vec2(0.38f,0.92f),vec2(0.19f,0.98f),vec2(0.0f,1.0f),vec2(-0.19f,0.98f),vec2(-0.38f,0.92f),vec2(-0.55f,0.83f),vec2(-0.707f,0.707f),vec2(-0.83f,0.55f),vec2(-0.92f,0.38f),vec2(-0.98f,0.19f),vec2(-1.0f,-0.0f),vec2(-0.98f,-0.19f),vec2(-0.92f,-0.38f),vec2(-0.83f,-0.55f),vec2(-0.707f,-0.707f),vec2(-0.55f,-0.83f),vec2(-0.38f,-0.92f),vec2(-0.19f,-0.98f),vec2(0.0f,-1.0f),vec2(0.19f,-0.98f),vec2(0.38f,-0.92f),vec2(0.55f,-0.83f),vec2(0.707f,-0.707f),vec2(0.83f,-0.55f),vec2(0.92f,-0.38f),vec2(0.98f,-0.19f),};
VS_OUTPUT Output;
Output.vecColour=vec4(0.0,0.0,0.0,1.0);
vec3 vPos=vec3(0.0,0.0,0.0);
bool noDisplacement=false;
bool noGradient=false;
float4 pos_local=float4(IN.position.xyz*vec3(g_scale.x,g_scale.y,g_scale.z),1);
pos_local=mul(g_meshMat,pos_local);
vec2 uv_local=(pos_local.xy-g_objectCenter.yx)*g_UVScale;
if(!noDisplacement)
{
vec3 eye_vec=pos_local.xyz-g_LocalEye;
float dist_2d=length(eye_vec.xy);
float blend_factor=(1000-dist_2d)/(1000-200);
blend_factor=clamp(blend_factor,0,1);
vec3 displacement=vec3(0,0,0);
if(blend_factor>0)
{
const float tau=6.28318530718;
uint dirNum=16;
uint N=2*dirNum;
float dx=dirNum*6.28318530718f/N;
vec2 windDirection=normalize(vec2(sin(g_windDirection),cos(g_windDirection)));
uint i;
for(i=0;i<N;i++)
{
float angle=((i)/(N))*6.28318530718f;
vec2 texcDir=normalize(profile32Directons[i]);
vec2 texc=texcDir*uv_local*g_profileUVScale;
float baseAmplitude=pow(((dot(windDirection,texcDir)+1.0)+((dot(-windDirection,texcDir)+1.0)*(1.0-g_windDependency)))/2.0,4.0);
vec2 displacementValue=g_amplitude*dx*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,0.0f),0).xy)*(baseAmplitude/2.0);
displacement+=vec3(displacementValue.x*texcDir.x,displacementValue.x*texcDir.y,displacementValue.y);
}

displacement*=g_WorldScale;
displacement=mix(vec3(0,0,0),displacement,blend_factor);
pos_local.xyz+=displacement;
}

}

if(noGradient)Output.vecColour.x=1.0;
Output.Position=mul(g_matWorldViewProj,pos_local);
Output.LocalPos=pos_local.xyz;
Output.texCoords=uv_local;
Output.SurePosition=Output.Position;
{
ioblock.BlockData=Output;
gl_Position=Output.Position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_VS_BoundlessWaterSurfNoShore_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 1) uniform cbShading
{
	vec3 g_SunDir;
	float g_Shineness;
	vec3 g_SunColor;
	float g_ShoreExtent;
	float g_oceanHeight;
	float g_vrRightEye;
	vec2 g_viewportPixelScale;
	int g_noOfReflectionSteps;
	int g_pixelStep;
	float g_reverseFace;
	bool g_enableFoam;
	float g_UVScale;
	float g_UVOffset;
	float g_WorldScale;
	float g_SunRadius;
	vec2 g_DepthScale;
	vec2 g_screenScale;
	vec4 g_DepthToLinFadeParams;
	vec4 g_HalfTan;
	vec3 g_ShoreDepthTextureLocation;
	float g_ShoreWidth;
	float gkfpdngkpfdp;
	float g_reflectionDistance;
	bool g_vrEnable;
	float g_reflectionBrightness;
};
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};



layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t g_shoreDepthTexture[24];
	uint64_t g_ProfileBuffers[24];
	uint64_t g_InputAmplitude[24];
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 972 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
VS_OUTPUT VS_BoundlessWaterSurf(idOnly IN, bool shoreEffects, bool waveGrid)
{
VS_OUTPUT Output;
float profileOffsets[16]={0.54f,0.18f,0.61f,0.28f,0.09f,0.71f,0.99f,0.43f,0.11f,0.85f,0.24f,0.67f,0.31f,0.86f,0.13f,0.01f};
vec2 profile32Directons[32]={vec2(1.0f,0.0f),vec2(0.98f,0.19f),vec2(0.92f,0.38f),vec2(0.83f,0.55f),vec2(0.707f,0.707f),vec2(0.55f,0.83f),vec2(0.38f,0.92f),vec2(0.19f,0.98f),vec2(0.0f,1.0f),vec2(-0.19f,0.98f),vec2(-0.38f,0.92f),vec2(-0.55f,0.83f),vec2(-0.707f,0.707f),vec2(-0.83f,0.55f),vec2(-0.92f,0.38f),vec2(-0.98f,0.19f),vec2(-1.0f,-0.0f),vec2(-0.98f,-0.19f),vec2(-0.92f,-0.38f),vec2(-0.83f,-0.55f),vec2(-0.707f,-0.707f),vec2(-0.55f,-0.83f),vec2(-0.38f,-0.92f),vec2(-0.19f,-0.98f),vec2(0.0f,-1.0f),vec2(0.19f,-0.98f),vec2(0.38f,-0.92f),vec2(0.55f,-0.83f),vec2(0.707f,-0.707f),vec2(0.83f,-0.55f),vec2(0.92f,-0.38f),vec2(0.98f,-0.19f),};
vec3 vPos=vec3(0.0,0.0,0.0);
vec2 cameraCenter=g_LocalEye.xy;
Output.vecColour=vec4(0.0,1.0,1.0,1.0);
float layerQuadSize;
float layerX=0.0;
float layerY=0.0;
float perlinMovement=0;
uint layerNo=0;
uint boundingVerticies=((8*g_layerDensity)+4)*4;
uint centerVerticies=(boundingVerticies*g_layerDensity)+1;
bool noDisplacement=false;
bool noGradient=false;
bool noWaveGrid=false;
if(g_verticiesPerLayer<250)noDisplacement=true;
uint vertexNo=IN.vertex_id;
if(vertexNo!=0)vertexNo--;
if(vertexNo<6)
{
noDisplacement=true;
noGradient=true;
vPos.z=-100;
layerQuadSize=(1<<(g_noOfLayers-2))*g_minQuadSize;
float externalLayerQuadSize=layerQuadSize*2.0;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX-=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY-=externalLayerQuadSize;
float layerDensity=g_layerDensity*4;
vec2 vertexPositions[6]={vec2(0.0f,0.0f),vec2(0.0f,0.0f),vec2(layerDensity,0.0f),vec2(0.0f,layerDensity),vec2(layerDensity,layerDensity),vec2(layerDensity,layerDensity)};
vPos.x=vertexPositions[vertexNo].x*2.0;
vPos.y=vertexPositions[vertexNo].y*2.0;
}
else
if(vertexNo<boundingVerticies+6)
{
vertexNo-=6;
layerQuadSize=(1<<(g_noOfLayers-2))*g_minQuadSize;
uint boundingEdgeVerticies=boundingVerticies/4;
float externalLayerQuadSize=layerQuadSize*2.0;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX+=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY+=externalLayerQuadSize;
int edgeNo=0;
if(vertexNo>=boundingEdgeVerticies*2)
{
edgeNo+=2;
vertexNo-=boundingEdgeVerticies*2;
}

if(vertexNo>=boundingEdgeVerticies)
{
edgeNo++;
vertexNo-=boundingEdgeVerticies;
}

vertexNo=clamp(vertexNo,1,boundingEdgeVerticies-2);
noDisplacement=true;
noGradient=(typed_mod(vertexNo,2)==1);
vPos.z=-1.0*((typed_mod(vertexNo,2))*100);
float layerDensity=g_layerDensity*4;
if(typed_mod(edgeNo,2)==0)
{
vPos.x=(vertexNo-(2-(typed_mod(vertexNo,2))))/2;
vPos.x=abs((layerDensity*(edgeNo/2))-vPos.x);
vPos.y=layerDensity*(edgeNo/2);
}
else

{
vPos.x=layerDensity*((typed_mod(edgeNo,3)));
vPos.y=(vertexNo-(2-(typed_mod(vertexNo,2))))/2;
vPos.y=abs((layerDensity*((edgeNo-1)/2))-vPos.y);
}

}
else

{
vertexNo-=boundingVerticies+6;
if(vertexNo<centerVerticies)
{
if(vertexNo==centerVerticies-1)vertexNo--;
layerQuadSize=(g_minQuadSize/2.0f);
float externalLayerQuadSize=layerQuadSize*2.0f;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX+=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY+=externalLayerQuadSize;
uint rowVerticies=((g_layerDensity*8)+4);
uint vertexRowNo=typed_mod(vertexNo,rowVerticies);
uint rowNo=(vertexNo-vertexRowNo)/rowVerticies;
vertexRowNo=clamp(vertexRowNo,1,rowVerticies-2);
vPos.x=(vertexRowNo-(2-typed_mod(vertexRowNo,2)))/2;
vPos.y=rowNo+(typed_mod((vertexRowNo+1),2));
}
else

{
vertexNo=vertexNo-centerVerticies;
vertexNo=typed_mod(vertexNo,(g_verticiesPerLayer+1));
if(vertexNo>0)vertexNo--;
layerNo=(((IN.vertex_id)-centerVerticies)-vertexNo)/g_verticiesPerLayer;
layerQuadSize=(1<<layerNo)*g_minQuadSize;
float externalLayerQuadSize=(1<<(layerNo+1))*g_minQuadSize;
float internalLayerQuadSize=(1<<(layerNo-1))*g_minQuadSize;
if(layerNo==0)internalLayerQuadSize=layerQuadSize/2.0;
float internalLayerX;
float internalLayerY;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX+=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY+=externalLayerQuadSize;
xSnapDifference=(cameraCenter.x-layerQuadSize*trunc(cameraCenter.x/layerQuadSize));
ySnapDifference=(cameraCenter.y-layerQuadSize*trunc(cameraCenter.y/layerQuadSize));
internalLayerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>internalLayerQuadSize)internalLayerX+=layerQuadSize;
internalLayerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>internalLayerQuadSize)internalLayerY+=layerQuadSize;
int xQuadOffset=0;
int yQuadOffset=0;
if((internalLayerX-layerX)<0.01*g_minQuadSize)
{
xQuadOffset++;
}

if((layerX-internalLayerX)<0.01*g_minQuadSize)
{
xQuadOffset--;
}

if((internalLayerY-layerY)<0.01*g_minQuadSize)
{
yQuadOffset++;
}

if((layerY-internalLayerY)<0.01*g_minQuadSize)
{
yQuadOffset--;
}

uint totalColumnVerticies=(8*g_layerDensity+4)*g_layerDensity*2;
uint columnWidth=g_layerDensity-xQuadOffset;
totalColumnVerticies+=typed_mod(layerNo,2);
if(vertexNo>=g_verticiesPerLayer-totalColumnVerticies)
{
vertexNo-=g_verticiesPerLayer-totalColumnVerticies;
if(((typed_mod(layerNo,2))==1)&&(vertexNo>0))vertexNo--;
uint sideColumnVerticies=(8*g_layerDensity)+4;
uint vertexColumnNo=typed_mod(vertexNo,sideColumnVerticies);
uint columnNo=(vertexNo-vertexColumnNo)/sideColumnVerticies;
vertexColumnNo=clamp(vertexColumnNo,1,sideColumnVerticies-2);
vPos.y=((vertexColumnNo+(typed_mod(vertexColumnNo,2)))/2)-1;
vPos.x=columnNo+(typed_mod((vertexColumnNo+1),2));
if(columnNo>=g_layerDensity-xQuadOffset)
{
vPos.x+=2*(g_layerDensity);
}

}
else

{
uint sideRowVerticies=(4*g_layerDensity)+4;
if(((typed_mod(layerNo,2))==0)&&(vertexNo==(g_verticiesPerLayer-totalColumnVerticies-1)))vertexNo--;
uint vertexRowNo=typed_mod(vertexNo,sideRowVerticies);
uint rowNo=(vertexNo-vertexRowNo)/sideRowVerticies;
vertexRowNo=clamp(vertexRowNo,1,sideRowVerticies-2);
vPos.x=(vertexRowNo-(2-typed_mod(vertexRowNo,2)))/2;
vPos.x+=columnWidth;
vPos.y=rowNo+(typed_mod((vertexRowNo+1),2));
if(rowNo>=g_layerDensity-yQuadOffset)
{
vPos.y+=2*g_layerDensity;
}

}

}

}

bool lerpDisplacement=false;
vec2 lerpSample1=vec2(0.0,0.0);
vec2 lerpSample2=vec2(0.0,0.0);
if((((vPos.x==0)||(vPos.x==((g_layerDensity)*4)))||((vPos.y==0)||(vPos.y==((g_layerDensity)*4))))&&(layerNo==g_noOfLayers-2))layerQuadSize*=1000;
if(((vPos.x==0)||(vPos.x==((g_layerDensity)*4)))&&(typed_mod(int(vPos.y),2)==1))
{
lerpDisplacement=true;
lerpSample1=vec2(vPos.x,vPos.y+1);
lerpSample2=vec2(vPos.x,vPos.y-1);
}
else
if(((vPos.y==0)||(vPos.y==((g_layerDensity)*4)))&&(typed_mod(int(vPos.x),2)==1))
{
lerpDisplacement=true;
lerpSample1=vec2(vPos.x+1,vPos.y);
lerpSample2=vec2(vPos.x-1,vPos.y);
}

vPos.xy*=layerQuadSize;
vPos.x+=layerX-(layerQuadSize*g_layerDensity*2);
vPos.y+=layerY-(layerQuadSize*g_layerDensity*2);
vPos.z+=g_oceanHeight;
float4 pos_local=float4(vPos,1);
vec2 uv_local=((pos_local.xy)*g_UVScale-g_objectCenter.yx*g_UVScale);
vec2 uv_local1=vec2(-g_objectCenter.yx*g_UVScale);
vec2 uv_local2=vec2(-g_objectCenter.yx*g_UVScale);
if(lerpDisplacement)
{
lerpSample1*=layerQuadSize;
lerpSample1.x+=layerX-(layerQuadSize*g_layerDensity*2);
lerpSample1.y+=layerY-(layerQuadSize*g_layerDensity*2);
lerpSample2*=layerQuadSize;
lerpSample2.x+=layerX-(layerQuadSize*g_layerDensity*2);
lerpSample2.y+=layerY-(layerQuadSize*g_layerDensity*2);
uv_local1+=(lerpSample1*g_UVScale);
uv_local2+=(lerpSample2*g_UVScale);
}

if(length(pos_local.xy-cameraCenter)>30000)noDisplacement=true;
if(length(pos_local.xy-cameraCenter.xy)>256)noWaveGrid=true;
if(!noDisplacement)
{
vec3 eye_vec=pos_local.xyz-g_LocalEye;
float dist_2d=length(eye_vec.xy);
float blend_factor=(1000-dist_2d)/(1000-200);
blend_factor=clamp(blend_factor,0,1);
vec3 displacement=vec3(0.0,0.0,0.0);
float shoreDepth=1.0;
float shoreDepth1=1.0;
float shoreDepth2=1.0;
vec3 detailDisplacement=vec3(0.0,0.0,0.0);
float fade=1.0;
if(shoreEffects)
{
if(lerpDisplacement)
{
vec2 shoreCoords1=(((vec2(lerpSample1.x,-lerpSample1.y)*(1.0/g_ShoreWidth))+vec2(0.5,0.5)))-(vec2(g_ShoreDepthTextureLocation.y,-g_ShoreDepthTextureLocation.x)*(1.0/g_ShoreWidth));
vec2 shoreCoords2=(((vec2(lerpSample2.x,-lerpSample2.y)*(1.0/g_ShoreWidth))+vec2(0.5,0.5)))-(vec2(g_ShoreDepthTextureLocation.y,-g_ShoreDepthTextureLocation.x)*(1.0/g_ShoreWidth));
shoreDepth1=clamp((textureLod(sampler2D(g_shoreDepthTexture[1 + 9]),shoreCoords1,0).x*0.01)-(g_ShoreDepthTextureLocation.z-g_oceanHeight),0.05,1.0);
shoreDepth2=clamp((textureLod(sampler2D(g_shoreDepthTexture[1 + 9]),shoreCoords2,0).x*0.01)-(g_ShoreDepthTextureLocation.z-g_oceanHeight),0.05,1.0);
}
else

{
vec2 shoreCoords=(((vec2(pos_local.x,-pos_local.y)*(1.0/g_ShoreWidth))+vec2(0.5,0.5)))-(vec2(g_ShoreDepthTextureLocation.y,-g_ShoreDepthTextureLocation.x)*(1.0/g_ShoreWidth));
shoreDepth=clamp((textureLod(sampler2D(g_shoreDepthTexture[1 + 9]),shoreCoords,0).x*0.01)-(g_ShoreDepthTextureLocation.z-g_oceanHeight),0.05,1.0);
}

}

if(blend_factor>0)
{
uint dirNum=16;
uint N=2*dirNum;
float dx=dirNum*6.28318530718f/N;
vec2 windDirection=normalize(vec2(sin(g_windDirection),cos(g_windDirection)));
uint i;
if(lerpDisplacement)
{
vec3 displacement1=vec3(0.0,0.0,0.0);
vec3 displacement2=vec3(0.0,0.0,0.0);
vec2 waveGridAmp1=vec2(0.0,0.0);
vec2 waveGridAmp2=vec2(0.0,0.0);
for(i=0;i<N;i++)
{
float angle=((i)/(N))*6.28318530718f;
vec2 texcDir=normalize(profile32Directons[i]);
vec2 texc1=texcDir*uv_local1*g_profileUVScale;
vec2 texc2=texcDir*uv_local2*g_profileUVScale;
vec2 displacementValue1=vec2(0.0,0.0);
vec2 displacementValue2=vec2(0.0,0.0);
float baseAmplitude=pow(((dot(windDirection,texcDir)+1.0)+((dot(-windDirection,texcDir)+1.0)*(1.0-g_windDependency)))/2.0,4.0);
vec2 baseWaveAmp1=(g_amplitude*shoreDepth1*baseAmplitude*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc1.x+texc1.y+profileOffsets[typed_mod(i,16)],0.0,0.0f),0).xy)/2.0);
vec2 baseWaveAmp2=(g_amplitude*shoreDepth2*baseAmplitude*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc2.x+texc2.y+profileOffsets[typed_mod(i,16)],0.0,0.0f),0).xy)/2.0);
if(waveGrid&&!noWaveGrid)
{
waveGridAmp1=(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc1.x+texc1.y+profileOffsets[typed_mod(i,16)],0.0,1.0f),0).xy*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(uv_local1.x/5.0,uv_local1.y/5.0,(i+0.5)/N),0).x);
waveGridAmp2=(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc2.x+texc2.y+profileOffsets[typed_mod(i,16)],0.0,1.0f),0).xy*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(uv_local2.x/5.0,uv_local2.y/5.0,(i+0.5)/N),0).x);
}

displacementValue1=dx*(waveGridAmp1+baseWaveAmp1);
displacementValue2=dx*(waveGridAmp2+baseWaveAmp2);
displacement1+=vec3(displacementValue1.x*texcDir.x,displacementValue1.x*texcDir.y,displacementValue1.y);
displacement2+=vec3(displacementValue2.x*texcDir.x,displacementValue2.x*texcDir.y,displacementValue2.y);
}

displacement=mix(displacement1,displacement2,0.5)*g_WorldScale;
}
else

{
vec2 waveGridAmp=vec2(0.0,0.0);
for(i=0;i<N;i++)
{
float angle=((i)/(N))*6.28318530718f;
vec2 texcDir=normalize(profile32Directons[i]);
vec2 texc=texcDir*uv_local*g_profileUVScale;
vec2 displacementValue=vec2(0.0,0.0);
float baseAmplitude=pow(((dot(windDirection,texcDir)+1.0)+((dot(-windDirection,texcDir)+1.0)*(1.0-g_windDependency)))/2.0,4.0);
vec2 baseWaveAmp=(g_amplitude*shoreDepth*baseAmplitude*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,0.0f),0).xy)/2.0);
if(waveGrid&&!noWaveGrid)
{
waveGridAmp=(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,1.0f),0).xy*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(uv_local.x/5.0,uv_local.y/5.0,(i+0.5)/N),0).x);
}

displacementValue=dx*(waveGridAmp+baseWaveAmp);
displacement+=vec3(displacementValue.x*texcDir.x,displacementValue.x*texcDir.y,displacementValue.y);
}

displacement*=g_WorldScale;
}

}

pos_local.xyz+=displacement.xyz;
if(shoreEffects)
{
if(lerpDisplacement)Output.vecColour.w=max(mix(shoreDepth1,shoreDepth2,0.5),0.001);else
Output.vecColour.w=max(shoreDepth,0.001);
}

}

if(noGradient)Output.vecColour.x=1.0;
Output.Position=mul(g_matWorldViewProj,pos_local);
Output.LocalPos=pos_local.xyz;
Output.texCoords=uv_local;
Output.SurePosition=Output.Position;
return Output;
}
layout(location = 0) out Block
{
VS_OUTPUT BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 1564 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
{
ioblock.BlockData=VS_BoundlessWaterSurf(IN,false,false);
gl_Position=VS_BoundlessWaterSurf(IN,false,false).Position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_VS_BoundlessWaterSurfNoShore_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 1) uniform cbShading
{
	vec3 g_SunDir;
	float g_Shineness;
	vec3 g_SunColor;
	float g_ShoreExtent;
	float g_oceanHeight;
	float g_vrRightEye;
	vec2 g_viewportPixelScale;
	int g_noOfReflectionSteps;
	int g_pixelStep;
	float g_reverseFace;
	bool g_enableFoam;
	float g_UVScale;
	float g_UVOffset;
	float g_WorldScale;
	float g_SunRadius;
	vec2 g_DepthScale;
	vec2 g_screenScale;
	vec4 g_DepthToLinFadeParams;
	vec4 g_HalfTan;
	vec3 g_ShoreDepthTextureLocation;
	float g_ShoreWidth;
	float gkfpdngkpfdp;
	float g_reflectionDistance;
	bool g_vrEnable;
	float g_reflectionBrightness;
};
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};



layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t g_shoreDepthTexture[24];
	uint64_t g_ProfileBuffers[24];
	uint64_t g_InputAmplitude[24];
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 972 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
VS_OUTPUT VS_BoundlessWaterSurf(idOnly IN, bool shoreEffects, bool waveGrid)
{
VS_OUTPUT Output;
float profileOffsets[16]={0.54f,0.18f,0.61f,0.28f,0.09f,0.71f,0.99f,0.43f,0.11f,0.85f,0.24f,0.67f,0.31f,0.86f,0.13f,0.01f};
vec2 profile32Directons[32]={vec2(1.0f,0.0f),vec2(0.98f,0.19f),vec2(0.92f,0.38f),vec2(0.83f,0.55f),vec2(0.707f,0.707f),vec2(0.55f,0.83f),vec2(0.38f,0.92f),vec2(0.19f,0.98f),vec2(0.0f,1.0f),vec2(-0.19f,0.98f),vec2(-0.38f,0.92f),vec2(-0.55f,0.83f),vec2(-0.707f,0.707f),vec2(-0.83f,0.55f),vec2(-0.92f,0.38f),vec2(-0.98f,0.19f),vec2(-1.0f,-0.0f),vec2(-0.98f,-0.19f),vec2(-0.92f,-0.38f),vec2(-0.83f,-0.55f),vec2(-0.707f,-0.707f),vec2(-0.55f,-0.83f),vec2(-0.38f,-0.92f),vec2(-0.19f,-0.98f),vec2(0.0f,-1.0f),vec2(0.19f,-0.98f),vec2(0.38f,-0.92f),vec2(0.55f,-0.83f),vec2(0.707f,-0.707f),vec2(0.83f,-0.55f),vec2(0.92f,-0.38f),vec2(0.98f,-0.19f),};
vec3 vPos=vec3(0.0,0.0,0.0);
vec2 cameraCenter=g_LocalEye.xy;
Output.vecColour=vec4(0.0,1.0,1.0,1.0);
float layerQuadSize;
float layerX=0.0;
float layerY=0.0;
float perlinMovement=0;
uint layerNo=0;
uint boundingVerticies=((8*g_layerDensity)+4)*4;
uint centerVerticies=(boundingVerticies*g_layerDensity)+1;
bool noDisplacement=false;
bool noGradient=false;
bool noWaveGrid=false;
if(g_verticiesPerLayer<250)noDisplacement=true;
uint vertexNo=IN.vertex_id;
if(vertexNo!=0)vertexNo--;
if(vertexNo<6)
{
noDisplacement=true;
noGradient=true;
vPos.z=-100;
layerQuadSize=(1<<(g_noOfLayers-2))*g_minQuadSize;
float externalLayerQuadSize=layerQuadSize*2.0;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX-=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY-=externalLayerQuadSize;
float layerDensity=g_layerDensity*4;
vec2 vertexPositions[6]={vec2(0.0f,0.0f),vec2(0.0f,0.0f),vec2(layerDensity,0.0f),vec2(0.0f,layerDensity),vec2(layerDensity,layerDensity),vec2(layerDensity,layerDensity)};
vPos.x=vertexPositions[vertexNo].x*2.0;
vPos.y=vertexPositions[vertexNo].y*2.0;
}
else
if(vertexNo<boundingVerticies+6)
{
vertexNo-=6;
layerQuadSize=(1<<(g_noOfLayers-2))*g_minQuadSize;
uint boundingEdgeVerticies=boundingVerticies/4;
float externalLayerQuadSize=layerQuadSize*2.0;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX+=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY+=externalLayerQuadSize;
int edgeNo=0;
if(vertexNo>=boundingEdgeVerticies*2)
{
edgeNo+=2;
vertexNo-=boundingEdgeVerticies*2;
}

if(vertexNo>=boundingEdgeVerticies)
{
edgeNo++;
vertexNo-=boundingEdgeVerticies;
}

vertexNo=clamp(vertexNo,1,boundingEdgeVerticies-2);
noDisplacement=true;
noGradient=(typed_mod(vertexNo,2)==1);
vPos.z=-1.0*((typed_mod(vertexNo,2))*100);
float layerDensity=g_layerDensity*4;
if(typed_mod(edgeNo,2)==0)
{
vPos.x=(vertexNo-(2-(typed_mod(vertexNo,2))))/2;
vPos.x=abs((layerDensity*(edgeNo/2))-vPos.x);
vPos.y=layerDensity*(edgeNo/2);
}
else

{
vPos.x=layerDensity*((typed_mod(edgeNo,3)));
vPos.y=(vertexNo-(2-(typed_mod(vertexNo,2))))/2;
vPos.y=abs((layerDensity*((edgeNo-1)/2))-vPos.y);
}

}
else

{
vertexNo-=boundingVerticies+6;
if(vertexNo<centerVerticies)
{
if(vertexNo==centerVerticies-1)vertexNo--;
layerQuadSize=(g_minQuadSize/2.0f);
float externalLayerQuadSize=layerQuadSize*2.0f;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX+=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY+=externalLayerQuadSize;
uint rowVerticies=((g_layerDensity*8)+4);
uint vertexRowNo=typed_mod(vertexNo,rowVerticies);
uint rowNo=(vertexNo-vertexRowNo)/rowVerticies;
vertexRowNo=clamp(vertexRowNo,1,rowVerticies-2);
vPos.x=(vertexRowNo-(2-typed_mod(vertexRowNo,2)))/2;
vPos.y=rowNo+(typed_mod((vertexRowNo+1),2));
}
else

{
vertexNo=vertexNo-centerVerticies;
vertexNo=typed_mod(vertexNo,(g_verticiesPerLayer+1));
if(vertexNo>0)vertexNo--;
layerNo=(((IN.vertex_id)-centerVerticies)-vertexNo)/g_verticiesPerLayer;
layerQuadSize=(1<<layerNo)*g_minQuadSize;
float externalLayerQuadSize=(1<<(layerNo+1))*g_minQuadSize;
float internalLayerQuadSize=(1<<(layerNo-1))*g_minQuadSize;
if(layerNo==0)internalLayerQuadSize=layerQuadSize/2.0;
float internalLayerX;
float internalLayerY;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX+=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY+=externalLayerQuadSize;
xSnapDifference=(cameraCenter.x-layerQuadSize*trunc(cameraCenter.x/layerQuadSize));
ySnapDifference=(cameraCenter.y-layerQuadSize*trunc(cameraCenter.y/layerQuadSize));
internalLayerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>internalLayerQuadSize)internalLayerX+=layerQuadSize;
internalLayerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>internalLayerQuadSize)internalLayerY+=layerQuadSize;
int xQuadOffset=0;
int yQuadOffset=0;
if((internalLayerX-layerX)<0.01*g_minQuadSize)
{
xQuadOffset++;
}

if((layerX-internalLayerX)<0.01*g_minQuadSize)
{
xQuadOffset--;
}

if((internalLayerY-layerY)<0.01*g_minQuadSize)
{
yQuadOffset++;
}

if((layerY-internalLayerY)<0.01*g_minQuadSize)
{
yQuadOffset--;
}

uint totalColumnVerticies=(8*g_layerDensity+4)*g_layerDensity*2;
uint columnWidth=g_layerDensity-xQuadOffset;
totalColumnVerticies+=typed_mod(layerNo,2);
if(vertexNo>=g_verticiesPerLayer-totalColumnVerticies)
{
vertexNo-=g_verticiesPerLayer-totalColumnVerticies;
if(((typed_mod(layerNo,2))==1)&&(vertexNo>0))vertexNo--;
uint sideColumnVerticies=(8*g_layerDensity)+4;
uint vertexColumnNo=typed_mod(vertexNo,sideColumnVerticies);
uint columnNo=(vertexNo-vertexColumnNo)/sideColumnVerticies;
vertexColumnNo=clamp(vertexColumnNo,1,sideColumnVerticies-2);
vPos.y=((vertexColumnNo+(typed_mod(vertexColumnNo,2)))/2)-1;
vPos.x=columnNo+(typed_mod((vertexColumnNo+1),2));
if(columnNo>=g_layerDensity-xQuadOffset)
{
vPos.x+=2*(g_layerDensity);
}

}
else

{
uint sideRowVerticies=(4*g_layerDensity)+4;
if(((typed_mod(layerNo,2))==0)&&(vertexNo==(g_verticiesPerLayer-totalColumnVerticies-1)))vertexNo--;
uint vertexRowNo=typed_mod(vertexNo,sideRowVerticies);
uint rowNo=(vertexNo-vertexRowNo)/sideRowVerticies;
vertexRowNo=clamp(vertexRowNo,1,sideRowVerticies-2);
vPos.x=(vertexRowNo-(2-typed_mod(vertexRowNo,2)))/2;
vPos.x+=columnWidth;
vPos.y=rowNo+(typed_mod((vertexRowNo+1),2));
if(rowNo>=g_layerDensity-yQuadOffset)
{
vPos.y+=2*g_layerDensity;
}

}

}

}

bool lerpDisplacement=false;
vec2 lerpSample1=vec2(0.0,0.0);
vec2 lerpSample2=vec2(0.0,0.0);
if((((vPos.x==0)||(vPos.x==((g_layerDensity)*4)))||((vPos.y==0)||(vPos.y==((g_layerDensity)*4))))&&(layerNo==g_noOfLayers-2))layerQuadSize*=1000;
if(((vPos.x==0)||(vPos.x==((g_layerDensity)*4)))&&(typed_mod(int(vPos.y),2)==1))
{
lerpDisplacement=true;
lerpSample1=vec2(vPos.x,vPos.y+1);
lerpSample2=vec2(vPos.x,vPos.y-1);
}
else
if(((vPos.y==0)||(vPos.y==((g_layerDensity)*4)))&&(typed_mod(int(vPos.x),2)==1))
{
lerpDisplacement=true;
lerpSample1=vec2(vPos.x+1,vPos.y);
lerpSample2=vec2(vPos.x-1,vPos.y);
}

vPos.xy*=layerQuadSize;
vPos.x+=layerX-(layerQuadSize*g_layerDensity*2);
vPos.y+=layerY-(layerQuadSize*g_layerDensity*2);
vPos.z+=g_oceanHeight;
float4 pos_local=float4(vPos,1);
vec2 uv_local=((pos_local.xy)*g_UVScale-g_objectCenter.yx*g_UVScale);
vec2 uv_local1=vec2(-g_objectCenter.yx*g_UVScale);
vec2 uv_local2=vec2(-g_objectCenter.yx*g_UVScale);
if(lerpDisplacement)
{
lerpSample1*=layerQuadSize;
lerpSample1.x+=layerX-(layerQuadSize*g_layerDensity*2);
lerpSample1.y+=layerY-(layerQuadSize*g_layerDensity*2);
lerpSample2*=layerQuadSize;
lerpSample2.x+=layerX-(layerQuadSize*g_layerDensity*2);
lerpSample2.y+=layerY-(layerQuadSize*g_layerDensity*2);
uv_local1+=(lerpSample1*g_UVScale);
uv_local2+=(lerpSample2*g_UVScale);
}

if(length(pos_local.xy-cameraCenter)>30000)noDisplacement=true;
if(length(pos_local.xy-cameraCenter.xy)>256)noWaveGrid=true;
if(!noDisplacement)
{
vec3 eye_vec=pos_local.xyz-g_LocalEye;
float dist_2d=length(eye_vec.xy);
float blend_factor=(1000-dist_2d)/(1000-200);
blend_factor=clamp(blend_factor,0,1);
vec3 displacement=vec3(0.0,0.0,0.0);
float shoreDepth=1.0;
float shoreDepth1=1.0;
float shoreDepth2=1.0;
vec3 detailDisplacement=vec3(0.0,0.0,0.0);
float fade=1.0;
if(shoreEffects)
{
if(lerpDisplacement)
{
vec2 shoreCoords1=(((vec2(lerpSample1.x,-lerpSample1.y)*(1.0/g_ShoreWidth))+vec2(0.5,0.5)))-(vec2(g_ShoreDepthTextureLocation.y,-g_ShoreDepthTextureLocation.x)*(1.0/g_ShoreWidth));
vec2 shoreCoords2=(((vec2(lerpSample2.x,-lerpSample2.y)*(1.0/g_ShoreWidth))+vec2(0.5,0.5)))-(vec2(g_ShoreDepthTextureLocation.y,-g_ShoreDepthTextureLocation.x)*(1.0/g_ShoreWidth));
shoreDepth1=clamp((textureLod(sampler2D(g_shoreDepthTexture[1 + 9]),shoreCoords1,0).x*0.01)-(g_ShoreDepthTextureLocation.z-g_oceanHeight),0.05,1.0);
shoreDepth2=clamp((textureLod(sampler2D(g_shoreDepthTexture[1 + 9]),shoreCoords2,0).x*0.01)-(g_ShoreDepthTextureLocation.z-g_oceanHeight),0.05,1.0);
}
else

{
vec2 shoreCoords=(((vec2(pos_local.x,-pos_local.y)*(1.0/g_ShoreWidth))+vec2(0.5,0.5)))-(vec2(g_ShoreDepthTextureLocation.y,-g_ShoreDepthTextureLocation.x)*(1.0/g_ShoreWidth));
shoreDepth=clamp((textureLod(sampler2D(g_shoreDepthTexture[1 + 9]),shoreCoords,0).x*0.01)-(g_ShoreDepthTextureLocation.z-g_oceanHeight),0.05,1.0);
}

}

if(blend_factor>0)
{
uint dirNum=16;
uint N=2*dirNum;
float dx=dirNum*6.28318530718f/N;
vec2 windDirection=normalize(vec2(sin(g_windDirection),cos(g_windDirection)));
uint i;
if(lerpDisplacement)
{
vec3 displacement1=vec3(0.0,0.0,0.0);
vec3 displacement2=vec3(0.0,0.0,0.0);
vec2 waveGridAmp1=vec2(0.0,0.0);
vec2 waveGridAmp2=vec2(0.0,0.0);
for(i=0;i<N;i++)
{
float angle=((i)/(N))*6.28318530718f;
vec2 texcDir=normalize(profile32Directons[i]);
vec2 texc1=texcDir*uv_local1*g_profileUVScale;
vec2 texc2=texcDir*uv_local2*g_profileUVScale;
vec2 displacementValue1=vec2(0.0,0.0);
vec2 displacementValue2=vec2(0.0,0.0);
float baseAmplitude=pow(((dot(windDirection,texcDir)+1.0)+((dot(-windDirection,texcDir)+1.0)*(1.0-g_windDependency)))/2.0,4.0);
vec2 baseWaveAmp1=(g_amplitude*shoreDepth1*baseAmplitude*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc1.x+texc1.y+profileOffsets[typed_mod(i,16)],0.0,0.0f),0).xy)/2.0);
vec2 baseWaveAmp2=(g_amplitude*shoreDepth2*baseAmplitude*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc2.x+texc2.y+profileOffsets[typed_mod(i,16)],0.0,0.0f),0).xy)/2.0);
if(waveGrid&&!noWaveGrid)
{
waveGridAmp1=(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc1.x+texc1.y+profileOffsets[typed_mod(i,16)],0.0,1.0f),0).xy*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(uv_local1.x/5.0,uv_local1.y/5.0,(i+0.5)/N),0).x);
waveGridAmp2=(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc2.x+texc2.y+profileOffsets[typed_mod(i,16)],0.0,1.0f),0).xy*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(uv_local2.x/5.0,uv_local2.y/5.0,(i+0.5)/N),0).x);
}

displacementValue1=dx*(waveGridAmp1+baseWaveAmp1);
displacementValue2=dx*(waveGridAmp2+baseWaveAmp2);
displacement1+=vec3(displacementValue1.x*texcDir.x,displacementValue1.x*texcDir.y,displacementValue1.y);
displacement2+=vec3(displacementValue2.x*texcDir.x,displacementValue2.x*texcDir.y,displacementValue2.y);
}

displacement=mix(displacement1,displacement2,0.5)*g_WorldScale;
}
else

{
vec2 waveGridAmp=vec2(0.0,0.0);
for(i=0;i<N;i++)
{
float angle=((i)/(N))*6.28318530718f;
vec2 texcDir=normalize(profile32Directons[i]);
vec2 texc=texcDir*uv_local*g_profileUVScale;
vec2 displacementValue=vec2(0.0,0.0);
float baseAmplitude=pow(((dot(windDirection,texcDir)+1.0)+((dot(-windDirection,texcDir)+1.0)*(1.0-g_windDependency)))/2.0,4.0);
vec2 baseWaveAmp=(g_amplitude*shoreDepth*baseAmplitude*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,0.0f),0).xy)/2.0);
if(waveGrid&&!noWaveGrid)
{
waveGridAmp=(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,1.0f),0).xy*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(uv_local.x/5.0,uv_local.y/5.0,(i+0.5)/N),0).x);
}

displacementValue=dx*(waveGridAmp+baseWaveAmp);
displacement+=vec3(displacementValue.x*texcDir.x,displacementValue.x*texcDir.y,displacementValue.y);
}

displacement*=g_WorldScale;
}

}

pos_local.xyz+=displacement.xyz;
if(shoreEffects)
{
if(lerpDisplacement)Output.vecColour.w=max(mix(shoreDepth1,shoreDepth2,0.5),0.001);else
Output.vecColour.w=max(shoreDepth,0.001);
}

}

if(noGradient)Output.vecColour.x=1.0;
Output.Position=mul(g_matWorldViewProj,pos_local);
Output.LocalPos=pos_local.xyz;
Output.texCoords=uv_local;
Output.SurePosition=Output.Position;
return Output;
}
layout(location = 0) out Block
{
VS_OUTPUT BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 1564 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
{
ioblock.BlockData=VS_BoundlessWaterSurf(IN,false,false);
gl_Position=VS_BoundlessWaterSurf(IN,false,false).Position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_VS_BoundlessWaterSurfNoShoreWaveGrid_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 1) uniform cbShading
{
	vec3 g_SunDir;
	float g_Shineness;
	vec3 g_SunColor;
	float g_ShoreExtent;
	float g_oceanHeight;
	float g_vrRightEye;
	vec2 g_viewportPixelScale;
	int g_noOfReflectionSteps;
	int g_pixelStep;
	float g_reverseFace;
	bool g_enableFoam;
	float g_UVScale;
	float g_UVOffset;
	float g_WorldScale;
	float g_SunRadius;
	vec2 g_DepthScale;
	vec2 g_screenScale;
	vec4 g_DepthToLinFadeParams;
	vec4 g_HalfTan;
	vec3 g_ShoreDepthTextureLocation;
	float g_ShoreWidth;
	float gkfpdngkpfdp;
	float g_reflectionDistance;
	bool g_vrEnable;
	float g_reflectionBrightness;
};
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};



layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t g_shoreDepthTexture[24];
	uint64_t g_ProfileBuffers[24];
	uint64_t g_InputAmplitude[24];
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 972 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
VS_OUTPUT VS_BoundlessWaterSurf(idOnly IN, bool shoreEffects, bool waveGrid)
{
VS_OUTPUT Output;
float profileOffsets[16]={0.54f,0.18f,0.61f,0.28f,0.09f,0.71f,0.99f,0.43f,0.11f,0.85f,0.24f,0.67f,0.31f,0.86f,0.13f,0.01f};
vec2 profile32Directons[32]={vec2(1.0f,0.0f),vec2(0.98f,0.19f),vec2(0.92f,0.38f),vec2(0.83f,0.55f),vec2(0.707f,0.707f),vec2(0.55f,0.83f),vec2(0.38f,0.92f),vec2(0.19f,0.98f),vec2(0.0f,1.0f),vec2(-0.19f,0.98f),vec2(-0.38f,0.92f),vec2(-0.55f,0.83f),vec2(-0.707f,0.707f),vec2(-0.83f,0.55f),vec2(-0.92f,0.38f),vec2(-0.98f,0.19f),vec2(-1.0f,-0.0f),vec2(-0.98f,-0.19f),vec2(-0.92f,-0.38f),vec2(-0.83f,-0.55f),vec2(-0.707f,-0.707f),vec2(-0.55f,-0.83f),vec2(-0.38f,-0.92f),vec2(-0.19f,-0.98f),vec2(0.0f,-1.0f),vec2(0.19f,-0.98f),vec2(0.38f,-0.92f),vec2(0.55f,-0.83f),vec2(0.707f,-0.707f),vec2(0.83f,-0.55f),vec2(0.92f,-0.38f),vec2(0.98f,-0.19f),};
vec3 vPos=vec3(0.0,0.0,0.0);
vec2 cameraCenter=g_LocalEye.xy;
Output.vecColour=vec4(0.0,1.0,1.0,1.0);
float layerQuadSize;
float layerX=0.0;
float layerY=0.0;
float perlinMovement=0;
uint layerNo=0;
uint boundingVerticies=((8*g_layerDensity)+4)*4;
uint centerVerticies=(boundingVerticies*g_layerDensity)+1;
bool noDisplacement=false;
bool noGradient=false;
bool noWaveGrid=false;
if(g_verticiesPerLayer<250)noDisplacement=true;
uint vertexNo=IN.vertex_id;
if(vertexNo!=0)vertexNo--;
if(vertexNo<6)
{
noDisplacement=true;
noGradient=true;
vPos.z=-100;
layerQuadSize=(1<<(g_noOfLayers-2))*g_minQuadSize;
float externalLayerQuadSize=layerQuadSize*2.0;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX-=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY-=externalLayerQuadSize;
float layerDensity=g_layerDensity*4;
vec2 vertexPositions[6]={vec2(0.0f,0.0f),vec2(0.0f,0.0f),vec2(layerDensity,0.0f),vec2(0.0f,layerDensity),vec2(layerDensity,layerDensity),vec2(layerDensity,layerDensity)};
vPos.x=vertexPositions[vertexNo].x*2.0;
vPos.y=vertexPositions[vertexNo].y*2.0;
}
else
if(vertexNo<boundingVerticies+6)
{
vertexNo-=6;
layerQuadSize=(1<<(g_noOfLayers-2))*g_minQuadSize;
uint boundingEdgeVerticies=boundingVerticies/4;
float externalLayerQuadSize=layerQuadSize*2.0;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX+=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY+=externalLayerQuadSize;
int edgeNo=0;
if(vertexNo>=boundingEdgeVerticies*2)
{
edgeNo+=2;
vertexNo-=boundingEdgeVerticies*2;
}

if(vertexNo>=boundingEdgeVerticies)
{
edgeNo++;
vertexNo-=boundingEdgeVerticies;
}

vertexNo=clamp(vertexNo,1,boundingEdgeVerticies-2);
noDisplacement=true;
noGradient=(typed_mod(vertexNo,2)==1);
vPos.z=-1.0*((typed_mod(vertexNo,2))*100);
float layerDensity=g_layerDensity*4;
if(typed_mod(edgeNo,2)==0)
{
vPos.x=(vertexNo-(2-(typed_mod(vertexNo,2))))/2;
vPos.x=abs((layerDensity*(edgeNo/2))-vPos.x);
vPos.y=layerDensity*(edgeNo/2);
}
else

{
vPos.x=layerDensity*((typed_mod(edgeNo,3)));
vPos.y=(vertexNo-(2-(typed_mod(vertexNo,2))))/2;
vPos.y=abs((layerDensity*((edgeNo-1)/2))-vPos.y);
}

}
else

{
vertexNo-=boundingVerticies+6;
if(vertexNo<centerVerticies)
{
if(vertexNo==centerVerticies-1)vertexNo--;
layerQuadSize=(g_minQuadSize/2.0f);
float externalLayerQuadSize=layerQuadSize*2.0f;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX+=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY+=externalLayerQuadSize;
uint rowVerticies=((g_layerDensity*8)+4);
uint vertexRowNo=typed_mod(vertexNo,rowVerticies);
uint rowNo=(vertexNo-vertexRowNo)/rowVerticies;
vertexRowNo=clamp(vertexRowNo,1,rowVerticies-2);
vPos.x=(vertexRowNo-(2-typed_mod(vertexRowNo,2)))/2;
vPos.y=rowNo+(typed_mod((vertexRowNo+1),2));
}
else

{
vertexNo=vertexNo-centerVerticies;
vertexNo=typed_mod(vertexNo,(g_verticiesPerLayer+1));
if(vertexNo>0)vertexNo--;
layerNo=(((IN.vertex_id)-centerVerticies)-vertexNo)/g_verticiesPerLayer;
layerQuadSize=(1<<layerNo)*g_minQuadSize;
float externalLayerQuadSize=(1<<(layerNo+1))*g_minQuadSize;
float internalLayerQuadSize=(1<<(layerNo-1))*g_minQuadSize;
if(layerNo==0)internalLayerQuadSize=layerQuadSize/2.0;
float internalLayerX;
float internalLayerY;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX+=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY+=externalLayerQuadSize;
xSnapDifference=(cameraCenter.x-layerQuadSize*trunc(cameraCenter.x/layerQuadSize));
ySnapDifference=(cameraCenter.y-layerQuadSize*trunc(cameraCenter.y/layerQuadSize));
internalLayerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>internalLayerQuadSize)internalLayerX+=layerQuadSize;
internalLayerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>internalLayerQuadSize)internalLayerY+=layerQuadSize;
int xQuadOffset=0;
int yQuadOffset=0;
if((internalLayerX-layerX)<0.01*g_minQuadSize)
{
xQuadOffset++;
}

if((layerX-internalLayerX)<0.01*g_minQuadSize)
{
xQuadOffset--;
}

if((internalLayerY-layerY)<0.01*g_minQuadSize)
{
yQuadOffset++;
}

if((layerY-internalLayerY)<0.01*g_minQuadSize)
{
yQuadOffset--;
}

uint totalColumnVerticies=(8*g_layerDensity+4)*g_layerDensity*2;
uint columnWidth=g_layerDensity-xQuadOffset;
totalColumnVerticies+=typed_mod(layerNo,2);
if(vertexNo>=g_verticiesPerLayer-totalColumnVerticies)
{
vertexNo-=g_verticiesPerLayer-totalColumnVerticies;
if(((typed_mod(layerNo,2))==1)&&(vertexNo>0))vertexNo--;
uint sideColumnVerticies=(8*g_layerDensity)+4;
uint vertexColumnNo=typed_mod(vertexNo,sideColumnVerticies);
uint columnNo=(vertexNo-vertexColumnNo)/sideColumnVerticies;
vertexColumnNo=clamp(vertexColumnNo,1,sideColumnVerticies-2);
vPos.y=((vertexColumnNo+(typed_mod(vertexColumnNo,2)))/2)-1;
vPos.x=columnNo+(typed_mod((vertexColumnNo+1),2));
if(columnNo>=g_layerDensity-xQuadOffset)
{
vPos.x+=2*(g_layerDensity);
}

}
else

{
uint sideRowVerticies=(4*g_layerDensity)+4;
if(((typed_mod(layerNo,2))==0)&&(vertexNo==(g_verticiesPerLayer-totalColumnVerticies-1)))vertexNo--;
uint vertexRowNo=typed_mod(vertexNo,sideRowVerticies);
uint rowNo=(vertexNo-vertexRowNo)/sideRowVerticies;
vertexRowNo=clamp(vertexRowNo,1,sideRowVerticies-2);
vPos.x=(vertexRowNo-(2-typed_mod(vertexRowNo,2)))/2;
vPos.x+=columnWidth;
vPos.y=rowNo+(typed_mod((vertexRowNo+1),2));
if(rowNo>=g_layerDensity-yQuadOffset)
{
vPos.y+=2*g_layerDensity;
}

}

}

}

bool lerpDisplacement=false;
vec2 lerpSample1=vec2(0.0,0.0);
vec2 lerpSample2=vec2(0.0,0.0);
if((((vPos.x==0)||(vPos.x==((g_layerDensity)*4)))||((vPos.y==0)||(vPos.y==((g_layerDensity)*4))))&&(layerNo==g_noOfLayers-2))layerQuadSize*=1000;
if(((vPos.x==0)||(vPos.x==((g_layerDensity)*4)))&&(typed_mod(int(vPos.y),2)==1))
{
lerpDisplacement=true;
lerpSample1=vec2(vPos.x,vPos.y+1);
lerpSample2=vec2(vPos.x,vPos.y-1);
}
else
if(((vPos.y==0)||(vPos.y==((g_layerDensity)*4)))&&(typed_mod(int(vPos.x),2)==1))
{
lerpDisplacement=true;
lerpSample1=vec2(vPos.x+1,vPos.y);
lerpSample2=vec2(vPos.x-1,vPos.y);
}

vPos.xy*=layerQuadSize;
vPos.x+=layerX-(layerQuadSize*g_layerDensity*2);
vPos.y+=layerY-(layerQuadSize*g_layerDensity*2);
vPos.z+=g_oceanHeight;
float4 pos_local=float4(vPos,1);
vec2 uv_local=((pos_local.xy)*g_UVScale-g_objectCenter.yx*g_UVScale);
vec2 uv_local1=vec2(-g_objectCenter.yx*g_UVScale);
vec2 uv_local2=vec2(-g_objectCenter.yx*g_UVScale);
if(lerpDisplacement)
{
lerpSample1*=layerQuadSize;
lerpSample1.x+=layerX-(layerQuadSize*g_layerDensity*2);
lerpSample1.y+=layerY-(layerQuadSize*g_layerDensity*2);
lerpSample2*=layerQuadSize;
lerpSample2.x+=layerX-(layerQuadSize*g_layerDensity*2);
lerpSample2.y+=layerY-(layerQuadSize*g_layerDensity*2);
uv_local1+=(lerpSample1*g_UVScale);
uv_local2+=(lerpSample2*g_UVScale);
}

if(length(pos_local.xy-cameraCenter)>30000)noDisplacement=true;
if(length(pos_local.xy-cameraCenter.xy)>256)noWaveGrid=true;
if(!noDisplacement)
{
vec3 eye_vec=pos_local.xyz-g_LocalEye;
float dist_2d=length(eye_vec.xy);
float blend_factor=(1000-dist_2d)/(1000-200);
blend_factor=clamp(blend_factor,0,1);
vec3 displacement=vec3(0.0,0.0,0.0);
float shoreDepth=1.0;
float shoreDepth1=1.0;
float shoreDepth2=1.0;
vec3 detailDisplacement=vec3(0.0,0.0,0.0);
float fade=1.0;
if(shoreEffects)
{
if(lerpDisplacement)
{
vec2 shoreCoords1=(((vec2(lerpSample1.x,-lerpSample1.y)*(1.0/g_ShoreWidth))+vec2(0.5,0.5)))-(vec2(g_ShoreDepthTextureLocation.y,-g_ShoreDepthTextureLocation.x)*(1.0/g_ShoreWidth));
vec2 shoreCoords2=(((vec2(lerpSample2.x,-lerpSample2.y)*(1.0/g_ShoreWidth))+vec2(0.5,0.5)))-(vec2(g_ShoreDepthTextureLocation.y,-g_ShoreDepthTextureLocation.x)*(1.0/g_ShoreWidth));
shoreDepth1=clamp((textureLod(sampler2D(g_shoreDepthTexture[1 + 9]),shoreCoords1,0).x*0.01)-(g_ShoreDepthTextureLocation.z-g_oceanHeight),0.05,1.0);
shoreDepth2=clamp((textureLod(sampler2D(g_shoreDepthTexture[1 + 9]),shoreCoords2,0).x*0.01)-(g_ShoreDepthTextureLocation.z-g_oceanHeight),0.05,1.0);
}
else

{
vec2 shoreCoords=(((vec2(pos_local.x,-pos_local.y)*(1.0/g_ShoreWidth))+vec2(0.5,0.5)))-(vec2(g_ShoreDepthTextureLocation.y,-g_ShoreDepthTextureLocation.x)*(1.0/g_ShoreWidth));
shoreDepth=clamp((textureLod(sampler2D(g_shoreDepthTexture[1 + 9]),shoreCoords,0).x*0.01)-(g_ShoreDepthTextureLocation.z-g_oceanHeight),0.05,1.0);
}

}

if(blend_factor>0)
{
uint dirNum=16;
uint N=2*dirNum;
float dx=dirNum*6.28318530718f/N;
vec2 windDirection=normalize(vec2(sin(g_windDirection),cos(g_windDirection)));
uint i;
if(lerpDisplacement)
{
vec3 displacement1=vec3(0.0,0.0,0.0);
vec3 displacement2=vec3(0.0,0.0,0.0);
vec2 waveGridAmp1=vec2(0.0,0.0);
vec2 waveGridAmp2=vec2(0.0,0.0);
for(i=0;i<N;i++)
{
float angle=((i)/(N))*6.28318530718f;
vec2 texcDir=normalize(profile32Directons[i]);
vec2 texc1=texcDir*uv_local1*g_profileUVScale;
vec2 texc2=texcDir*uv_local2*g_profileUVScale;
vec2 displacementValue1=vec2(0.0,0.0);
vec2 displacementValue2=vec2(0.0,0.0);
float baseAmplitude=pow(((dot(windDirection,texcDir)+1.0)+((dot(-windDirection,texcDir)+1.0)*(1.0-g_windDependency)))/2.0,4.0);
vec2 baseWaveAmp1=(g_amplitude*shoreDepth1*baseAmplitude*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc1.x+texc1.y+profileOffsets[typed_mod(i,16)],0.0,0.0f),0).xy)/2.0);
vec2 baseWaveAmp2=(g_amplitude*shoreDepth2*baseAmplitude*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc2.x+texc2.y+profileOffsets[typed_mod(i,16)],0.0,0.0f),0).xy)/2.0);
if(waveGrid&&!noWaveGrid)
{
waveGridAmp1=(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc1.x+texc1.y+profileOffsets[typed_mod(i,16)],0.0,1.0f),0).xy*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(uv_local1.x/5.0,uv_local1.y/5.0,(i+0.5)/N),0).x);
waveGridAmp2=(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc2.x+texc2.y+profileOffsets[typed_mod(i,16)],0.0,1.0f),0).xy*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(uv_local2.x/5.0,uv_local2.y/5.0,(i+0.5)/N),0).x);
}

displacementValue1=dx*(waveGridAmp1+baseWaveAmp1);
displacementValue2=dx*(waveGridAmp2+baseWaveAmp2);
displacement1+=vec3(displacementValue1.x*texcDir.x,displacementValue1.x*texcDir.y,displacementValue1.y);
displacement2+=vec3(displacementValue2.x*texcDir.x,displacementValue2.x*texcDir.y,displacementValue2.y);
}

displacement=mix(displacement1,displacement2,0.5)*g_WorldScale;
}
else

{
vec2 waveGridAmp=vec2(0.0,0.0);
for(i=0;i<N;i++)
{
float angle=((i)/(N))*6.28318530718f;
vec2 texcDir=normalize(profile32Directons[i]);
vec2 texc=texcDir*uv_local*g_profileUVScale;
vec2 displacementValue=vec2(0.0,0.0);
float baseAmplitude=pow(((dot(windDirection,texcDir)+1.0)+((dot(-windDirection,texcDir)+1.0)*(1.0-g_windDependency)))/2.0,4.0);
vec2 baseWaveAmp=(g_amplitude*shoreDepth*baseAmplitude*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,0.0f),0).xy)/2.0);
if(waveGrid&&!noWaveGrid)
{
waveGridAmp=(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,1.0f),0).xy*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(uv_local.x/5.0,uv_local.y/5.0,(i+0.5)/N),0).x);
}

displacementValue=dx*(waveGridAmp+baseWaveAmp);
displacement+=vec3(displacementValue.x*texcDir.x,displacementValue.x*texcDir.y,displacementValue.y);
}

displacement*=g_WorldScale;
}

}

pos_local.xyz+=displacement.xyz;
if(shoreEffects)
{
if(lerpDisplacement)Output.vecColour.w=max(mix(shoreDepth1,shoreDepth2,0.5),0.001);else
Output.vecColour.w=max(shoreDepth,0.001);
}

}

if(noGradient)Output.vecColour.x=1.0;
Output.Position=mul(g_matWorldViewProj,pos_local);
Output.LocalPos=pos_local.xyz;
Output.texCoords=uv_local;
Output.SurePosition=Output.Position;
return Output;
}
layout(location = 0) out Block
{
VS_OUTPUT BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 1574 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
{
ioblock.BlockData=VS_BoundlessWaterSurf(IN,false,true);
gl_Position=VS_BoundlessWaterSurf(IN,false,true).Position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_VS_BoundlessWaterSurfNoShoreWaveGrid_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 1) uniform cbShading
{
	vec3 g_SunDir;
	float g_Shineness;
	vec3 g_SunColor;
	float g_ShoreExtent;
	float g_oceanHeight;
	float g_vrRightEye;
	vec2 g_viewportPixelScale;
	int g_noOfReflectionSteps;
	int g_pixelStep;
	float g_reverseFace;
	bool g_enableFoam;
	float g_UVScale;
	float g_UVOffset;
	float g_WorldScale;
	float g_SunRadius;
	vec2 g_DepthScale;
	vec2 g_screenScale;
	vec4 g_DepthToLinFadeParams;
	vec4 g_HalfTan;
	vec3 g_ShoreDepthTextureLocation;
	float g_ShoreWidth;
	float gkfpdngkpfdp;
	float g_reflectionDistance;
	bool g_vrEnable;
	float g_reflectionBrightness;
};
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};



layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t g_shoreDepthTexture[24];
	uint64_t g_ProfileBuffers[24];
	uint64_t g_InputAmplitude[24];
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 972 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
VS_OUTPUT VS_BoundlessWaterSurf(idOnly IN, bool shoreEffects, bool waveGrid)
{
VS_OUTPUT Output;
float profileOffsets[16]={0.54f,0.18f,0.61f,0.28f,0.09f,0.71f,0.99f,0.43f,0.11f,0.85f,0.24f,0.67f,0.31f,0.86f,0.13f,0.01f};
vec2 profile32Directons[32]={vec2(1.0f,0.0f),vec2(0.98f,0.19f),vec2(0.92f,0.38f),vec2(0.83f,0.55f),vec2(0.707f,0.707f),vec2(0.55f,0.83f),vec2(0.38f,0.92f),vec2(0.19f,0.98f),vec2(0.0f,1.0f),vec2(-0.19f,0.98f),vec2(-0.38f,0.92f),vec2(-0.55f,0.83f),vec2(-0.707f,0.707f),vec2(-0.83f,0.55f),vec2(-0.92f,0.38f),vec2(-0.98f,0.19f),vec2(-1.0f,-0.0f),vec2(-0.98f,-0.19f),vec2(-0.92f,-0.38f),vec2(-0.83f,-0.55f),vec2(-0.707f,-0.707f),vec2(-0.55f,-0.83f),vec2(-0.38f,-0.92f),vec2(-0.19f,-0.98f),vec2(0.0f,-1.0f),vec2(0.19f,-0.98f),vec2(0.38f,-0.92f),vec2(0.55f,-0.83f),vec2(0.707f,-0.707f),vec2(0.83f,-0.55f),vec2(0.92f,-0.38f),vec2(0.98f,-0.19f),};
vec3 vPos=vec3(0.0,0.0,0.0);
vec2 cameraCenter=g_LocalEye.xy;
Output.vecColour=vec4(0.0,1.0,1.0,1.0);
float layerQuadSize;
float layerX=0.0;
float layerY=0.0;
float perlinMovement=0;
uint layerNo=0;
uint boundingVerticies=((8*g_layerDensity)+4)*4;
uint centerVerticies=(boundingVerticies*g_layerDensity)+1;
bool noDisplacement=false;
bool noGradient=false;
bool noWaveGrid=false;
if(g_verticiesPerLayer<250)noDisplacement=true;
uint vertexNo=IN.vertex_id;
if(vertexNo!=0)vertexNo--;
if(vertexNo<6)
{
noDisplacement=true;
noGradient=true;
vPos.z=-100;
layerQuadSize=(1<<(g_noOfLayers-2))*g_minQuadSize;
float externalLayerQuadSize=layerQuadSize*2.0;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX-=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY-=externalLayerQuadSize;
float layerDensity=g_layerDensity*4;
vec2 vertexPositions[6]={vec2(0.0f,0.0f),vec2(0.0f,0.0f),vec2(layerDensity,0.0f),vec2(0.0f,layerDensity),vec2(layerDensity,layerDensity),vec2(layerDensity,layerDensity)};
vPos.x=vertexPositions[vertexNo].x*2.0;
vPos.y=vertexPositions[vertexNo].y*2.0;
}
else
if(vertexNo<boundingVerticies+6)
{
vertexNo-=6;
layerQuadSize=(1<<(g_noOfLayers-2))*g_minQuadSize;
uint boundingEdgeVerticies=boundingVerticies/4;
float externalLayerQuadSize=layerQuadSize*2.0;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX+=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY+=externalLayerQuadSize;
int edgeNo=0;
if(vertexNo>=boundingEdgeVerticies*2)
{
edgeNo+=2;
vertexNo-=boundingEdgeVerticies*2;
}

if(vertexNo>=boundingEdgeVerticies)
{
edgeNo++;
vertexNo-=boundingEdgeVerticies;
}

vertexNo=clamp(vertexNo,1,boundingEdgeVerticies-2);
noDisplacement=true;
noGradient=(typed_mod(vertexNo,2)==1);
vPos.z=-1.0*((typed_mod(vertexNo,2))*100);
float layerDensity=g_layerDensity*4;
if(typed_mod(edgeNo,2)==0)
{
vPos.x=(vertexNo-(2-(typed_mod(vertexNo,2))))/2;
vPos.x=abs((layerDensity*(edgeNo/2))-vPos.x);
vPos.y=layerDensity*(edgeNo/2);
}
else

{
vPos.x=layerDensity*((typed_mod(edgeNo,3)));
vPos.y=(vertexNo-(2-(typed_mod(vertexNo,2))))/2;
vPos.y=abs((layerDensity*((edgeNo-1)/2))-vPos.y);
}

}
else

{
vertexNo-=boundingVerticies+6;
if(vertexNo<centerVerticies)
{
if(vertexNo==centerVerticies-1)vertexNo--;
layerQuadSize=(g_minQuadSize/2.0f);
float externalLayerQuadSize=layerQuadSize*2.0f;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX+=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY+=externalLayerQuadSize;
uint rowVerticies=((g_layerDensity*8)+4);
uint vertexRowNo=typed_mod(vertexNo,rowVerticies);
uint rowNo=(vertexNo-vertexRowNo)/rowVerticies;
vertexRowNo=clamp(vertexRowNo,1,rowVerticies-2);
vPos.x=(vertexRowNo-(2-typed_mod(vertexRowNo,2)))/2;
vPos.y=rowNo+(typed_mod((vertexRowNo+1),2));
}
else

{
vertexNo=vertexNo-centerVerticies;
vertexNo=typed_mod(vertexNo,(g_verticiesPerLayer+1));
if(vertexNo>0)vertexNo--;
layerNo=(((IN.vertex_id)-centerVerticies)-vertexNo)/g_verticiesPerLayer;
layerQuadSize=(1<<layerNo)*g_minQuadSize;
float externalLayerQuadSize=(1<<(layerNo+1))*g_minQuadSize;
float internalLayerQuadSize=(1<<(layerNo-1))*g_minQuadSize;
if(layerNo==0)internalLayerQuadSize=layerQuadSize/2.0;
float internalLayerX;
float internalLayerY;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX+=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY+=externalLayerQuadSize;
xSnapDifference=(cameraCenter.x-layerQuadSize*trunc(cameraCenter.x/layerQuadSize));
ySnapDifference=(cameraCenter.y-layerQuadSize*trunc(cameraCenter.y/layerQuadSize));
internalLayerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>internalLayerQuadSize)internalLayerX+=layerQuadSize;
internalLayerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>internalLayerQuadSize)internalLayerY+=layerQuadSize;
int xQuadOffset=0;
int yQuadOffset=0;
if((internalLayerX-layerX)<0.01*g_minQuadSize)
{
xQuadOffset++;
}

if((layerX-internalLayerX)<0.01*g_minQuadSize)
{
xQuadOffset--;
}

if((internalLayerY-layerY)<0.01*g_minQuadSize)
{
yQuadOffset++;
}

if((layerY-internalLayerY)<0.01*g_minQuadSize)
{
yQuadOffset--;
}

uint totalColumnVerticies=(8*g_layerDensity+4)*g_layerDensity*2;
uint columnWidth=g_layerDensity-xQuadOffset;
totalColumnVerticies+=typed_mod(layerNo,2);
if(vertexNo>=g_verticiesPerLayer-totalColumnVerticies)
{
vertexNo-=g_verticiesPerLayer-totalColumnVerticies;
if(((typed_mod(layerNo,2))==1)&&(vertexNo>0))vertexNo--;
uint sideColumnVerticies=(8*g_layerDensity)+4;
uint vertexColumnNo=typed_mod(vertexNo,sideColumnVerticies);
uint columnNo=(vertexNo-vertexColumnNo)/sideColumnVerticies;
vertexColumnNo=clamp(vertexColumnNo,1,sideColumnVerticies-2);
vPos.y=((vertexColumnNo+(typed_mod(vertexColumnNo,2)))/2)-1;
vPos.x=columnNo+(typed_mod((vertexColumnNo+1),2));
if(columnNo>=g_layerDensity-xQuadOffset)
{
vPos.x+=2*(g_layerDensity);
}

}
else

{
uint sideRowVerticies=(4*g_layerDensity)+4;
if(((typed_mod(layerNo,2))==0)&&(vertexNo==(g_verticiesPerLayer-totalColumnVerticies-1)))vertexNo--;
uint vertexRowNo=typed_mod(vertexNo,sideRowVerticies);
uint rowNo=(vertexNo-vertexRowNo)/sideRowVerticies;
vertexRowNo=clamp(vertexRowNo,1,sideRowVerticies-2);
vPos.x=(vertexRowNo-(2-typed_mod(vertexRowNo,2)))/2;
vPos.x+=columnWidth;
vPos.y=rowNo+(typed_mod((vertexRowNo+1),2));
if(rowNo>=g_layerDensity-yQuadOffset)
{
vPos.y+=2*g_layerDensity;
}

}

}

}

bool lerpDisplacement=false;
vec2 lerpSample1=vec2(0.0,0.0);
vec2 lerpSample2=vec2(0.0,0.0);
if((((vPos.x==0)||(vPos.x==((g_layerDensity)*4)))||((vPos.y==0)||(vPos.y==((g_layerDensity)*4))))&&(layerNo==g_noOfLayers-2))layerQuadSize*=1000;
if(((vPos.x==0)||(vPos.x==((g_layerDensity)*4)))&&(typed_mod(int(vPos.y),2)==1))
{
lerpDisplacement=true;
lerpSample1=vec2(vPos.x,vPos.y+1);
lerpSample2=vec2(vPos.x,vPos.y-1);
}
else
if(((vPos.y==0)||(vPos.y==((g_layerDensity)*4)))&&(typed_mod(int(vPos.x),2)==1))
{
lerpDisplacement=true;
lerpSample1=vec2(vPos.x+1,vPos.y);
lerpSample2=vec2(vPos.x-1,vPos.y);
}

vPos.xy*=layerQuadSize;
vPos.x+=layerX-(layerQuadSize*g_layerDensity*2);
vPos.y+=layerY-(layerQuadSize*g_layerDensity*2);
vPos.z+=g_oceanHeight;
float4 pos_local=float4(vPos,1);
vec2 uv_local=((pos_local.xy)*g_UVScale-g_objectCenter.yx*g_UVScale);
vec2 uv_local1=vec2(-g_objectCenter.yx*g_UVScale);
vec2 uv_local2=vec2(-g_objectCenter.yx*g_UVScale);
if(lerpDisplacement)
{
lerpSample1*=layerQuadSize;
lerpSample1.x+=layerX-(layerQuadSize*g_layerDensity*2);
lerpSample1.y+=layerY-(layerQuadSize*g_layerDensity*2);
lerpSample2*=layerQuadSize;
lerpSample2.x+=layerX-(layerQuadSize*g_layerDensity*2);
lerpSample2.y+=layerY-(layerQuadSize*g_layerDensity*2);
uv_local1+=(lerpSample1*g_UVScale);
uv_local2+=(lerpSample2*g_UVScale);
}

if(length(pos_local.xy-cameraCenter)>30000)noDisplacement=true;
if(length(pos_local.xy-cameraCenter.xy)>256)noWaveGrid=true;
if(!noDisplacement)
{
vec3 eye_vec=pos_local.xyz-g_LocalEye;
float dist_2d=length(eye_vec.xy);
float blend_factor=(1000-dist_2d)/(1000-200);
blend_factor=clamp(blend_factor,0,1);
vec3 displacement=vec3(0.0,0.0,0.0);
float shoreDepth=1.0;
float shoreDepth1=1.0;
float shoreDepth2=1.0;
vec3 detailDisplacement=vec3(0.0,0.0,0.0);
float fade=1.0;
if(shoreEffects)
{
if(lerpDisplacement)
{
vec2 shoreCoords1=(((vec2(lerpSample1.x,-lerpSample1.y)*(1.0/g_ShoreWidth))+vec2(0.5,0.5)))-(vec2(g_ShoreDepthTextureLocation.y,-g_ShoreDepthTextureLocation.x)*(1.0/g_ShoreWidth));
vec2 shoreCoords2=(((vec2(lerpSample2.x,-lerpSample2.y)*(1.0/g_ShoreWidth))+vec2(0.5,0.5)))-(vec2(g_ShoreDepthTextureLocation.y,-g_ShoreDepthTextureLocation.x)*(1.0/g_ShoreWidth));
shoreDepth1=clamp((textureLod(sampler2D(g_shoreDepthTexture[1 + 9]),shoreCoords1,0).x*0.01)-(g_ShoreDepthTextureLocation.z-g_oceanHeight),0.05,1.0);
shoreDepth2=clamp((textureLod(sampler2D(g_shoreDepthTexture[1 + 9]),shoreCoords2,0).x*0.01)-(g_ShoreDepthTextureLocation.z-g_oceanHeight),0.05,1.0);
}
else

{
vec2 shoreCoords=(((vec2(pos_local.x,-pos_local.y)*(1.0/g_ShoreWidth))+vec2(0.5,0.5)))-(vec2(g_ShoreDepthTextureLocation.y,-g_ShoreDepthTextureLocation.x)*(1.0/g_ShoreWidth));
shoreDepth=clamp((textureLod(sampler2D(g_shoreDepthTexture[1 + 9]),shoreCoords,0).x*0.01)-(g_ShoreDepthTextureLocation.z-g_oceanHeight),0.05,1.0);
}

}

if(blend_factor>0)
{
uint dirNum=16;
uint N=2*dirNum;
float dx=dirNum*6.28318530718f/N;
vec2 windDirection=normalize(vec2(sin(g_windDirection),cos(g_windDirection)));
uint i;
if(lerpDisplacement)
{
vec3 displacement1=vec3(0.0,0.0,0.0);
vec3 displacement2=vec3(0.0,0.0,0.0);
vec2 waveGridAmp1=vec2(0.0,0.0);
vec2 waveGridAmp2=vec2(0.0,0.0);
for(i=0;i<N;i++)
{
float angle=((i)/(N))*6.28318530718f;
vec2 texcDir=normalize(profile32Directons[i]);
vec2 texc1=texcDir*uv_local1*g_profileUVScale;
vec2 texc2=texcDir*uv_local2*g_profileUVScale;
vec2 displacementValue1=vec2(0.0,0.0);
vec2 displacementValue2=vec2(0.0,0.0);
float baseAmplitude=pow(((dot(windDirection,texcDir)+1.0)+((dot(-windDirection,texcDir)+1.0)*(1.0-g_windDependency)))/2.0,4.0);
vec2 baseWaveAmp1=(g_amplitude*shoreDepth1*baseAmplitude*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc1.x+texc1.y+profileOffsets[typed_mod(i,16)],0.0,0.0f),0).xy)/2.0);
vec2 baseWaveAmp2=(g_amplitude*shoreDepth2*baseAmplitude*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc2.x+texc2.y+profileOffsets[typed_mod(i,16)],0.0,0.0f),0).xy)/2.0);
if(waveGrid&&!noWaveGrid)
{
waveGridAmp1=(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc1.x+texc1.y+profileOffsets[typed_mod(i,16)],0.0,1.0f),0).xy*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(uv_local1.x/5.0,uv_local1.y/5.0,(i+0.5)/N),0).x);
waveGridAmp2=(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc2.x+texc2.y+profileOffsets[typed_mod(i,16)],0.0,1.0f),0).xy*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(uv_local2.x/5.0,uv_local2.y/5.0,(i+0.5)/N),0).x);
}

displacementValue1=dx*(waveGridAmp1+baseWaveAmp1);
displacementValue2=dx*(waveGridAmp2+baseWaveAmp2);
displacement1+=vec3(displacementValue1.x*texcDir.x,displacementValue1.x*texcDir.y,displacementValue1.y);
displacement2+=vec3(displacementValue2.x*texcDir.x,displacementValue2.x*texcDir.y,displacementValue2.y);
}

displacement=mix(displacement1,displacement2,0.5)*g_WorldScale;
}
else

{
vec2 waveGridAmp=vec2(0.0,0.0);
for(i=0;i<N;i++)
{
float angle=((i)/(N))*6.28318530718f;
vec2 texcDir=normalize(profile32Directons[i]);
vec2 texc=texcDir*uv_local*g_profileUVScale;
vec2 displacementValue=vec2(0.0,0.0);
float baseAmplitude=pow(((dot(windDirection,texcDir)+1.0)+((dot(-windDirection,texcDir)+1.0)*(1.0-g_windDependency)))/2.0,4.0);
vec2 baseWaveAmp=(g_amplitude*shoreDepth*baseAmplitude*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,0.0f),0).xy)/2.0);
if(waveGrid&&!noWaveGrid)
{
waveGridAmp=(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,1.0f),0).xy*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(uv_local.x/5.0,uv_local.y/5.0,(i+0.5)/N),0).x);
}

displacementValue=dx*(waveGridAmp+baseWaveAmp);
displacement+=vec3(displacementValue.x*texcDir.x,displacementValue.x*texcDir.y,displacementValue.y);
}

displacement*=g_WorldScale;
}

}

pos_local.xyz+=displacement.xyz;
if(shoreEffects)
{
if(lerpDisplacement)Output.vecColour.w=max(mix(shoreDepth1,shoreDepth2,0.5),0.001);else
Output.vecColour.w=max(shoreDepth,0.001);
}

}

if(noGradient)Output.vecColour.x=1.0;
Output.Position=mul(g_matWorldViewProj,pos_local);
Output.LocalPos=pos_local.xyz;
Output.texCoords=uv_local;
Output.SurePosition=Output.Position;
return Output;
}
layout(location = 0) out Block
{
VS_OUTPUT BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 1574 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
{
ioblock.BlockData=VS_BoundlessWaterSurf(IN,false,true);
gl_Position=VS_BoundlessWaterSurf(IN,false,true).Position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_VS_BoundlessWaterSurfShore_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 1) uniform cbShading
{
	vec3 g_SunDir;
	float g_Shineness;
	vec3 g_SunColor;
	float g_ShoreExtent;
	float g_oceanHeight;
	float g_vrRightEye;
	vec2 g_viewportPixelScale;
	int g_noOfReflectionSteps;
	int g_pixelStep;
	float g_reverseFace;
	bool g_enableFoam;
	float g_UVScale;
	float g_UVOffset;
	float g_WorldScale;
	float g_SunRadius;
	vec2 g_DepthScale;
	vec2 g_screenScale;
	vec4 g_DepthToLinFadeParams;
	vec4 g_HalfTan;
	vec3 g_ShoreDepthTextureLocation;
	float g_ShoreWidth;
	float gkfpdngkpfdp;
	float g_reflectionDistance;
	bool g_vrEnable;
	float g_reflectionBrightness;
};
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};



layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t g_shoreDepthTexture[24];
	uint64_t g_ProfileBuffers[24];
	uint64_t g_InputAmplitude[24];
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 972 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
VS_OUTPUT VS_BoundlessWaterSurf(idOnly IN, bool shoreEffects, bool waveGrid)
{
VS_OUTPUT Output;
float profileOffsets[16]={0.54f,0.18f,0.61f,0.28f,0.09f,0.71f,0.99f,0.43f,0.11f,0.85f,0.24f,0.67f,0.31f,0.86f,0.13f,0.01f};
vec2 profile32Directons[32]={vec2(1.0f,0.0f),vec2(0.98f,0.19f),vec2(0.92f,0.38f),vec2(0.83f,0.55f),vec2(0.707f,0.707f),vec2(0.55f,0.83f),vec2(0.38f,0.92f),vec2(0.19f,0.98f),vec2(0.0f,1.0f),vec2(-0.19f,0.98f),vec2(-0.38f,0.92f),vec2(-0.55f,0.83f),vec2(-0.707f,0.707f),vec2(-0.83f,0.55f),vec2(-0.92f,0.38f),vec2(-0.98f,0.19f),vec2(-1.0f,-0.0f),vec2(-0.98f,-0.19f),vec2(-0.92f,-0.38f),vec2(-0.83f,-0.55f),vec2(-0.707f,-0.707f),vec2(-0.55f,-0.83f),vec2(-0.38f,-0.92f),vec2(-0.19f,-0.98f),vec2(0.0f,-1.0f),vec2(0.19f,-0.98f),vec2(0.38f,-0.92f),vec2(0.55f,-0.83f),vec2(0.707f,-0.707f),vec2(0.83f,-0.55f),vec2(0.92f,-0.38f),vec2(0.98f,-0.19f),};
vec3 vPos=vec3(0.0,0.0,0.0);
vec2 cameraCenter=g_LocalEye.xy;
Output.vecColour=vec4(0.0,1.0,1.0,1.0);
float layerQuadSize;
float layerX=0.0;
float layerY=0.0;
float perlinMovement=0;
uint layerNo=0;
uint boundingVerticies=((8*g_layerDensity)+4)*4;
uint centerVerticies=(boundingVerticies*g_layerDensity)+1;
bool noDisplacement=false;
bool noGradient=false;
bool noWaveGrid=false;
if(g_verticiesPerLayer<250)noDisplacement=true;
uint vertexNo=IN.vertex_id;
if(vertexNo!=0)vertexNo--;
if(vertexNo<6)
{
noDisplacement=true;
noGradient=true;
vPos.z=-100;
layerQuadSize=(1<<(g_noOfLayers-2))*g_minQuadSize;
float externalLayerQuadSize=layerQuadSize*2.0;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX-=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY-=externalLayerQuadSize;
float layerDensity=g_layerDensity*4;
vec2 vertexPositions[6]={vec2(0.0f,0.0f),vec2(0.0f,0.0f),vec2(layerDensity,0.0f),vec2(0.0f,layerDensity),vec2(layerDensity,layerDensity),vec2(layerDensity,layerDensity)};
vPos.x=vertexPositions[vertexNo].x*2.0;
vPos.y=vertexPositions[vertexNo].y*2.0;
}
else
if(vertexNo<boundingVerticies+6)
{
vertexNo-=6;
layerQuadSize=(1<<(g_noOfLayers-2))*g_minQuadSize;
uint boundingEdgeVerticies=boundingVerticies/4;
float externalLayerQuadSize=layerQuadSize*2.0;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX+=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY+=externalLayerQuadSize;
int edgeNo=0;
if(vertexNo>=boundingEdgeVerticies*2)
{
edgeNo+=2;
vertexNo-=boundingEdgeVerticies*2;
}

if(vertexNo>=boundingEdgeVerticies)
{
edgeNo++;
vertexNo-=boundingEdgeVerticies;
}

vertexNo=clamp(vertexNo,1,boundingEdgeVerticies-2);
noDisplacement=true;
noGradient=(typed_mod(vertexNo,2)==1);
vPos.z=-1.0*((typed_mod(vertexNo,2))*100);
float layerDensity=g_layerDensity*4;
if(typed_mod(edgeNo,2)==0)
{
vPos.x=(vertexNo-(2-(typed_mod(vertexNo,2))))/2;
vPos.x=abs((layerDensity*(edgeNo/2))-vPos.x);
vPos.y=layerDensity*(edgeNo/2);
}
else

{
vPos.x=layerDensity*((typed_mod(edgeNo,3)));
vPos.y=(vertexNo-(2-(typed_mod(vertexNo,2))))/2;
vPos.y=abs((layerDensity*((edgeNo-1)/2))-vPos.y);
}

}
else

{
vertexNo-=boundingVerticies+6;
if(vertexNo<centerVerticies)
{
if(vertexNo==centerVerticies-1)vertexNo--;
layerQuadSize=(g_minQuadSize/2.0f);
float externalLayerQuadSize=layerQuadSize*2.0f;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX+=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY+=externalLayerQuadSize;
uint rowVerticies=((g_layerDensity*8)+4);
uint vertexRowNo=typed_mod(vertexNo,rowVerticies);
uint rowNo=(vertexNo-vertexRowNo)/rowVerticies;
vertexRowNo=clamp(vertexRowNo,1,rowVerticies-2);
vPos.x=(vertexRowNo-(2-typed_mod(vertexRowNo,2)))/2;
vPos.y=rowNo+(typed_mod((vertexRowNo+1),2));
}
else

{
vertexNo=vertexNo-centerVerticies;
vertexNo=typed_mod(vertexNo,(g_verticiesPerLayer+1));
if(vertexNo>0)vertexNo--;
layerNo=(((IN.vertex_id)-centerVerticies)-vertexNo)/g_verticiesPerLayer;
layerQuadSize=(1<<layerNo)*g_minQuadSize;
float externalLayerQuadSize=(1<<(layerNo+1))*g_minQuadSize;
float internalLayerQuadSize=(1<<(layerNo-1))*g_minQuadSize;
if(layerNo==0)internalLayerQuadSize=layerQuadSize/2.0;
float internalLayerX;
float internalLayerY;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX+=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY+=externalLayerQuadSize;
xSnapDifference=(cameraCenter.x-layerQuadSize*trunc(cameraCenter.x/layerQuadSize));
ySnapDifference=(cameraCenter.y-layerQuadSize*trunc(cameraCenter.y/layerQuadSize));
internalLayerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>internalLayerQuadSize)internalLayerX+=layerQuadSize;
internalLayerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>internalLayerQuadSize)internalLayerY+=layerQuadSize;
int xQuadOffset=0;
int yQuadOffset=0;
if((internalLayerX-layerX)<0.01*g_minQuadSize)
{
xQuadOffset++;
}

if((layerX-internalLayerX)<0.01*g_minQuadSize)
{
xQuadOffset--;
}

if((internalLayerY-layerY)<0.01*g_minQuadSize)
{
yQuadOffset++;
}

if((layerY-internalLayerY)<0.01*g_minQuadSize)
{
yQuadOffset--;
}

uint totalColumnVerticies=(8*g_layerDensity+4)*g_layerDensity*2;
uint columnWidth=g_layerDensity-xQuadOffset;
totalColumnVerticies+=typed_mod(layerNo,2);
if(vertexNo>=g_verticiesPerLayer-totalColumnVerticies)
{
vertexNo-=g_verticiesPerLayer-totalColumnVerticies;
if(((typed_mod(layerNo,2))==1)&&(vertexNo>0))vertexNo--;
uint sideColumnVerticies=(8*g_layerDensity)+4;
uint vertexColumnNo=typed_mod(vertexNo,sideColumnVerticies);
uint columnNo=(vertexNo-vertexColumnNo)/sideColumnVerticies;
vertexColumnNo=clamp(vertexColumnNo,1,sideColumnVerticies-2);
vPos.y=((vertexColumnNo+(typed_mod(vertexColumnNo,2)))/2)-1;
vPos.x=columnNo+(typed_mod((vertexColumnNo+1),2));
if(columnNo>=g_layerDensity-xQuadOffset)
{
vPos.x+=2*(g_layerDensity);
}

}
else

{
uint sideRowVerticies=(4*g_layerDensity)+4;
if(((typed_mod(layerNo,2))==0)&&(vertexNo==(g_verticiesPerLayer-totalColumnVerticies-1)))vertexNo--;
uint vertexRowNo=typed_mod(vertexNo,sideRowVerticies);
uint rowNo=(vertexNo-vertexRowNo)/sideRowVerticies;
vertexRowNo=clamp(vertexRowNo,1,sideRowVerticies-2);
vPos.x=(vertexRowNo-(2-typed_mod(vertexRowNo,2)))/2;
vPos.x+=columnWidth;
vPos.y=rowNo+(typed_mod((vertexRowNo+1),2));
if(rowNo>=g_layerDensity-yQuadOffset)
{
vPos.y+=2*g_layerDensity;
}

}

}

}

bool lerpDisplacement=false;
vec2 lerpSample1=vec2(0.0,0.0);
vec2 lerpSample2=vec2(0.0,0.0);
if((((vPos.x==0)||(vPos.x==((g_layerDensity)*4)))||((vPos.y==0)||(vPos.y==((g_layerDensity)*4))))&&(layerNo==g_noOfLayers-2))layerQuadSize*=1000;
if(((vPos.x==0)||(vPos.x==((g_layerDensity)*4)))&&(typed_mod(int(vPos.y),2)==1))
{
lerpDisplacement=true;
lerpSample1=vec2(vPos.x,vPos.y+1);
lerpSample2=vec2(vPos.x,vPos.y-1);
}
else
if(((vPos.y==0)||(vPos.y==((g_layerDensity)*4)))&&(typed_mod(int(vPos.x),2)==1))
{
lerpDisplacement=true;
lerpSample1=vec2(vPos.x+1,vPos.y);
lerpSample2=vec2(vPos.x-1,vPos.y);
}

vPos.xy*=layerQuadSize;
vPos.x+=layerX-(layerQuadSize*g_layerDensity*2);
vPos.y+=layerY-(layerQuadSize*g_layerDensity*2);
vPos.z+=g_oceanHeight;
float4 pos_local=float4(vPos,1);
vec2 uv_local=((pos_local.xy)*g_UVScale-g_objectCenter.yx*g_UVScale);
vec2 uv_local1=vec2(-g_objectCenter.yx*g_UVScale);
vec2 uv_local2=vec2(-g_objectCenter.yx*g_UVScale);
if(lerpDisplacement)
{
lerpSample1*=layerQuadSize;
lerpSample1.x+=layerX-(layerQuadSize*g_layerDensity*2);
lerpSample1.y+=layerY-(layerQuadSize*g_layerDensity*2);
lerpSample2*=layerQuadSize;
lerpSample2.x+=layerX-(layerQuadSize*g_layerDensity*2);
lerpSample2.y+=layerY-(layerQuadSize*g_layerDensity*2);
uv_local1+=(lerpSample1*g_UVScale);
uv_local2+=(lerpSample2*g_UVScale);
}

if(length(pos_local.xy-cameraCenter)>30000)noDisplacement=true;
if(length(pos_local.xy-cameraCenter.xy)>256)noWaveGrid=true;
if(!noDisplacement)
{
vec3 eye_vec=pos_local.xyz-g_LocalEye;
float dist_2d=length(eye_vec.xy);
float blend_factor=(1000-dist_2d)/(1000-200);
blend_factor=clamp(blend_factor,0,1);
vec3 displacement=vec3(0.0,0.0,0.0);
float shoreDepth=1.0;
float shoreDepth1=1.0;
float shoreDepth2=1.0;
vec3 detailDisplacement=vec3(0.0,0.0,0.0);
float fade=1.0;
if(shoreEffects)
{
if(lerpDisplacement)
{
vec2 shoreCoords1=(((vec2(lerpSample1.x,-lerpSample1.y)*(1.0/g_ShoreWidth))+vec2(0.5,0.5)))-(vec2(g_ShoreDepthTextureLocation.y,-g_ShoreDepthTextureLocation.x)*(1.0/g_ShoreWidth));
vec2 shoreCoords2=(((vec2(lerpSample2.x,-lerpSample2.y)*(1.0/g_ShoreWidth))+vec2(0.5,0.5)))-(vec2(g_ShoreDepthTextureLocation.y,-g_ShoreDepthTextureLocation.x)*(1.0/g_ShoreWidth));
shoreDepth1=clamp((textureLod(sampler2D(g_shoreDepthTexture[1 + 9]),shoreCoords1,0).x*0.01)-(g_ShoreDepthTextureLocation.z-g_oceanHeight),0.05,1.0);
shoreDepth2=clamp((textureLod(sampler2D(g_shoreDepthTexture[1 + 9]),shoreCoords2,0).x*0.01)-(g_ShoreDepthTextureLocation.z-g_oceanHeight),0.05,1.0);
}
else

{
vec2 shoreCoords=(((vec2(pos_local.x,-pos_local.y)*(1.0/g_ShoreWidth))+vec2(0.5,0.5)))-(vec2(g_ShoreDepthTextureLocation.y,-g_ShoreDepthTextureLocation.x)*(1.0/g_ShoreWidth));
shoreDepth=clamp((textureLod(sampler2D(g_shoreDepthTexture[1 + 9]),shoreCoords,0).x*0.01)-(g_ShoreDepthTextureLocation.z-g_oceanHeight),0.05,1.0);
}

}

if(blend_factor>0)
{
uint dirNum=16;
uint N=2*dirNum;
float dx=dirNum*6.28318530718f/N;
vec2 windDirection=normalize(vec2(sin(g_windDirection),cos(g_windDirection)));
uint i;
if(lerpDisplacement)
{
vec3 displacement1=vec3(0.0,0.0,0.0);
vec3 displacement2=vec3(0.0,0.0,0.0);
vec2 waveGridAmp1=vec2(0.0,0.0);
vec2 waveGridAmp2=vec2(0.0,0.0);
for(i=0;i<N;i++)
{
float angle=((i)/(N))*6.28318530718f;
vec2 texcDir=normalize(profile32Directons[i]);
vec2 texc1=texcDir*uv_local1*g_profileUVScale;
vec2 texc2=texcDir*uv_local2*g_profileUVScale;
vec2 displacementValue1=vec2(0.0,0.0);
vec2 displacementValue2=vec2(0.0,0.0);
float baseAmplitude=pow(((dot(windDirection,texcDir)+1.0)+((dot(-windDirection,texcDir)+1.0)*(1.0-g_windDependency)))/2.0,4.0);
vec2 baseWaveAmp1=(g_amplitude*shoreDepth1*baseAmplitude*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc1.x+texc1.y+profileOffsets[typed_mod(i,16)],0.0,0.0f),0).xy)/2.0);
vec2 baseWaveAmp2=(g_amplitude*shoreDepth2*baseAmplitude*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc2.x+texc2.y+profileOffsets[typed_mod(i,16)],0.0,0.0f),0).xy)/2.0);
if(waveGrid&&!noWaveGrid)
{
waveGridAmp1=(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc1.x+texc1.y+profileOffsets[typed_mod(i,16)],0.0,1.0f),0).xy*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(uv_local1.x/5.0,uv_local1.y/5.0,(i+0.5)/N),0).x);
waveGridAmp2=(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc2.x+texc2.y+profileOffsets[typed_mod(i,16)],0.0,1.0f),0).xy*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(uv_local2.x/5.0,uv_local2.y/5.0,(i+0.5)/N),0).x);
}

displacementValue1=dx*(waveGridAmp1+baseWaveAmp1);
displacementValue2=dx*(waveGridAmp2+baseWaveAmp2);
displacement1+=vec3(displacementValue1.x*texcDir.x,displacementValue1.x*texcDir.y,displacementValue1.y);
displacement2+=vec3(displacementValue2.x*texcDir.x,displacementValue2.x*texcDir.y,displacementValue2.y);
}

displacement=mix(displacement1,displacement2,0.5)*g_WorldScale;
}
else

{
vec2 waveGridAmp=vec2(0.0,0.0);
for(i=0;i<N;i++)
{
float angle=((i)/(N))*6.28318530718f;
vec2 texcDir=normalize(profile32Directons[i]);
vec2 texc=texcDir*uv_local*g_profileUVScale;
vec2 displacementValue=vec2(0.0,0.0);
float baseAmplitude=pow(((dot(windDirection,texcDir)+1.0)+((dot(-windDirection,texcDir)+1.0)*(1.0-g_windDependency)))/2.0,4.0);
vec2 baseWaveAmp=(g_amplitude*shoreDepth*baseAmplitude*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,0.0f),0).xy)/2.0);
if(waveGrid&&!noWaveGrid)
{
waveGridAmp=(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,1.0f),0).xy*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(uv_local.x/5.0,uv_local.y/5.0,(i+0.5)/N),0).x);
}

displacementValue=dx*(waveGridAmp+baseWaveAmp);
displacement+=vec3(displacementValue.x*texcDir.x,displacementValue.x*texcDir.y,displacementValue.y);
}

displacement*=g_WorldScale;
}

}

pos_local.xyz+=displacement.xyz;
if(shoreEffects)
{
if(lerpDisplacement)Output.vecColour.w=max(mix(shoreDepth1,shoreDepth2,0.5),0.001);else
Output.vecColour.w=max(shoreDepth,0.001);
}

}

if(noGradient)Output.vecColour.x=1.0;
Output.Position=mul(g_matWorldViewProj,pos_local);
Output.LocalPos=pos_local.xyz;
Output.texCoords=uv_local;
Output.SurePosition=Output.Position;
return Output;
}
layout(location = 0) out Block
{
VS_OUTPUT BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 1559 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
{
ioblock.BlockData=VS_BoundlessWaterSurf(IN,true,false);
gl_Position=VS_BoundlessWaterSurf(IN,true,false).Position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_VS_BoundlessWaterSurfShore_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 1) uniform cbShading
{
	vec3 g_SunDir;
	float g_Shineness;
	vec3 g_SunColor;
	float g_ShoreExtent;
	float g_oceanHeight;
	float g_vrRightEye;
	vec2 g_viewportPixelScale;
	int g_noOfReflectionSteps;
	int g_pixelStep;
	float g_reverseFace;
	bool g_enableFoam;
	float g_UVScale;
	float g_UVOffset;
	float g_WorldScale;
	float g_SunRadius;
	vec2 g_DepthScale;
	vec2 g_screenScale;
	vec4 g_DepthToLinFadeParams;
	vec4 g_HalfTan;
	vec3 g_ShoreDepthTextureLocation;
	float g_ShoreWidth;
	float gkfpdngkpfdp;
	float g_reflectionDistance;
	bool g_vrEnable;
	float g_reflectionBrightness;
};
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};



layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t g_shoreDepthTexture[24];
	uint64_t g_ProfileBuffers[24];
	uint64_t g_InputAmplitude[24];
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 972 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
VS_OUTPUT VS_BoundlessWaterSurf(idOnly IN, bool shoreEffects, bool waveGrid)
{
VS_OUTPUT Output;
float profileOffsets[16]={0.54f,0.18f,0.61f,0.28f,0.09f,0.71f,0.99f,0.43f,0.11f,0.85f,0.24f,0.67f,0.31f,0.86f,0.13f,0.01f};
vec2 profile32Directons[32]={vec2(1.0f,0.0f),vec2(0.98f,0.19f),vec2(0.92f,0.38f),vec2(0.83f,0.55f),vec2(0.707f,0.707f),vec2(0.55f,0.83f),vec2(0.38f,0.92f),vec2(0.19f,0.98f),vec2(0.0f,1.0f),vec2(-0.19f,0.98f),vec2(-0.38f,0.92f),vec2(-0.55f,0.83f),vec2(-0.707f,0.707f),vec2(-0.83f,0.55f),vec2(-0.92f,0.38f),vec2(-0.98f,0.19f),vec2(-1.0f,-0.0f),vec2(-0.98f,-0.19f),vec2(-0.92f,-0.38f),vec2(-0.83f,-0.55f),vec2(-0.707f,-0.707f),vec2(-0.55f,-0.83f),vec2(-0.38f,-0.92f),vec2(-0.19f,-0.98f),vec2(0.0f,-1.0f),vec2(0.19f,-0.98f),vec2(0.38f,-0.92f),vec2(0.55f,-0.83f),vec2(0.707f,-0.707f),vec2(0.83f,-0.55f),vec2(0.92f,-0.38f),vec2(0.98f,-0.19f),};
vec3 vPos=vec3(0.0,0.0,0.0);
vec2 cameraCenter=g_LocalEye.xy;
Output.vecColour=vec4(0.0,1.0,1.0,1.0);
float layerQuadSize;
float layerX=0.0;
float layerY=0.0;
float perlinMovement=0;
uint layerNo=0;
uint boundingVerticies=((8*g_layerDensity)+4)*4;
uint centerVerticies=(boundingVerticies*g_layerDensity)+1;
bool noDisplacement=false;
bool noGradient=false;
bool noWaveGrid=false;
if(g_verticiesPerLayer<250)noDisplacement=true;
uint vertexNo=IN.vertex_id;
if(vertexNo!=0)vertexNo--;
if(vertexNo<6)
{
noDisplacement=true;
noGradient=true;
vPos.z=-100;
layerQuadSize=(1<<(g_noOfLayers-2))*g_minQuadSize;
float externalLayerQuadSize=layerQuadSize*2.0;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX-=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY-=externalLayerQuadSize;
float layerDensity=g_layerDensity*4;
vec2 vertexPositions[6]={vec2(0.0f,0.0f),vec2(0.0f,0.0f),vec2(layerDensity,0.0f),vec2(0.0f,layerDensity),vec2(layerDensity,layerDensity),vec2(layerDensity,layerDensity)};
vPos.x=vertexPositions[vertexNo].x*2.0;
vPos.y=vertexPositions[vertexNo].y*2.0;
}
else
if(vertexNo<boundingVerticies+6)
{
vertexNo-=6;
layerQuadSize=(1<<(g_noOfLayers-2))*g_minQuadSize;
uint boundingEdgeVerticies=boundingVerticies/4;
float externalLayerQuadSize=layerQuadSize*2.0;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX+=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY+=externalLayerQuadSize;
int edgeNo=0;
if(vertexNo>=boundingEdgeVerticies*2)
{
edgeNo+=2;
vertexNo-=boundingEdgeVerticies*2;
}

if(vertexNo>=boundingEdgeVerticies)
{
edgeNo++;
vertexNo-=boundingEdgeVerticies;
}

vertexNo=clamp(vertexNo,1,boundingEdgeVerticies-2);
noDisplacement=true;
noGradient=(typed_mod(vertexNo,2)==1);
vPos.z=-1.0*((typed_mod(vertexNo,2))*100);
float layerDensity=g_layerDensity*4;
if(typed_mod(edgeNo,2)==0)
{
vPos.x=(vertexNo-(2-(typed_mod(vertexNo,2))))/2;
vPos.x=abs((layerDensity*(edgeNo/2))-vPos.x);
vPos.y=layerDensity*(edgeNo/2);
}
else

{
vPos.x=layerDensity*((typed_mod(edgeNo,3)));
vPos.y=(vertexNo-(2-(typed_mod(vertexNo,2))))/2;
vPos.y=abs((layerDensity*((edgeNo-1)/2))-vPos.y);
}

}
else

{
vertexNo-=boundingVerticies+6;
if(vertexNo<centerVerticies)
{
if(vertexNo==centerVerticies-1)vertexNo--;
layerQuadSize=(g_minQuadSize/2.0f);
float externalLayerQuadSize=layerQuadSize*2.0f;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX+=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY+=externalLayerQuadSize;
uint rowVerticies=((g_layerDensity*8)+4);
uint vertexRowNo=typed_mod(vertexNo,rowVerticies);
uint rowNo=(vertexNo-vertexRowNo)/rowVerticies;
vertexRowNo=clamp(vertexRowNo,1,rowVerticies-2);
vPos.x=(vertexRowNo-(2-typed_mod(vertexRowNo,2)))/2;
vPos.y=rowNo+(typed_mod((vertexRowNo+1),2));
}
else

{
vertexNo=vertexNo-centerVerticies;
vertexNo=typed_mod(vertexNo,(g_verticiesPerLayer+1));
if(vertexNo>0)vertexNo--;
layerNo=(((IN.vertex_id)-centerVerticies)-vertexNo)/g_verticiesPerLayer;
layerQuadSize=(1<<layerNo)*g_minQuadSize;
float externalLayerQuadSize=(1<<(layerNo+1))*g_minQuadSize;
float internalLayerQuadSize=(1<<(layerNo-1))*g_minQuadSize;
if(layerNo==0)internalLayerQuadSize=layerQuadSize/2.0;
float internalLayerX;
float internalLayerY;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX+=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY+=externalLayerQuadSize;
xSnapDifference=(cameraCenter.x-layerQuadSize*trunc(cameraCenter.x/layerQuadSize));
ySnapDifference=(cameraCenter.y-layerQuadSize*trunc(cameraCenter.y/layerQuadSize));
internalLayerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>internalLayerQuadSize)internalLayerX+=layerQuadSize;
internalLayerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>internalLayerQuadSize)internalLayerY+=layerQuadSize;
int xQuadOffset=0;
int yQuadOffset=0;
if((internalLayerX-layerX)<0.01*g_minQuadSize)
{
xQuadOffset++;
}

if((layerX-internalLayerX)<0.01*g_minQuadSize)
{
xQuadOffset--;
}

if((internalLayerY-layerY)<0.01*g_minQuadSize)
{
yQuadOffset++;
}

if((layerY-internalLayerY)<0.01*g_minQuadSize)
{
yQuadOffset--;
}

uint totalColumnVerticies=(8*g_layerDensity+4)*g_layerDensity*2;
uint columnWidth=g_layerDensity-xQuadOffset;
totalColumnVerticies+=typed_mod(layerNo,2);
if(vertexNo>=g_verticiesPerLayer-totalColumnVerticies)
{
vertexNo-=g_verticiesPerLayer-totalColumnVerticies;
if(((typed_mod(layerNo,2))==1)&&(vertexNo>0))vertexNo--;
uint sideColumnVerticies=(8*g_layerDensity)+4;
uint vertexColumnNo=typed_mod(vertexNo,sideColumnVerticies);
uint columnNo=(vertexNo-vertexColumnNo)/sideColumnVerticies;
vertexColumnNo=clamp(vertexColumnNo,1,sideColumnVerticies-2);
vPos.y=((vertexColumnNo+(typed_mod(vertexColumnNo,2)))/2)-1;
vPos.x=columnNo+(typed_mod((vertexColumnNo+1),2));
if(columnNo>=g_layerDensity-xQuadOffset)
{
vPos.x+=2*(g_layerDensity);
}

}
else

{
uint sideRowVerticies=(4*g_layerDensity)+4;
if(((typed_mod(layerNo,2))==0)&&(vertexNo==(g_verticiesPerLayer-totalColumnVerticies-1)))vertexNo--;
uint vertexRowNo=typed_mod(vertexNo,sideRowVerticies);
uint rowNo=(vertexNo-vertexRowNo)/sideRowVerticies;
vertexRowNo=clamp(vertexRowNo,1,sideRowVerticies-2);
vPos.x=(vertexRowNo-(2-typed_mod(vertexRowNo,2)))/2;
vPos.x+=columnWidth;
vPos.y=rowNo+(typed_mod((vertexRowNo+1),2));
if(rowNo>=g_layerDensity-yQuadOffset)
{
vPos.y+=2*g_layerDensity;
}

}

}

}

bool lerpDisplacement=false;
vec2 lerpSample1=vec2(0.0,0.0);
vec2 lerpSample2=vec2(0.0,0.0);
if((((vPos.x==0)||(vPos.x==((g_layerDensity)*4)))||((vPos.y==0)||(vPos.y==((g_layerDensity)*4))))&&(layerNo==g_noOfLayers-2))layerQuadSize*=1000;
if(((vPos.x==0)||(vPos.x==((g_layerDensity)*4)))&&(typed_mod(int(vPos.y),2)==1))
{
lerpDisplacement=true;
lerpSample1=vec2(vPos.x,vPos.y+1);
lerpSample2=vec2(vPos.x,vPos.y-1);
}
else
if(((vPos.y==0)||(vPos.y==((g_layerDensity)*4)))&&(typed_mod(int(vPos.x),2)==1))
{
lerpDisplacement=true;
lerpSample1=vec2(vPos.x+1,vPos.y);
lerpSample2=vec2(vPos.x-1,vPos.y);
}

vPos.xy*=layerQuadSize;
vPos.x+=layerX-(layerQuadSize*g_layerDensity*2);
vPos.y+=layerY-(layerQuadSize*g_layerDensity*2);
vPos.z+=g_oceanHeight;
float4 pos_local=float4(vPos,1);
vec2 uv_local=((pos_local.xy)*g_UVScale-g_objectCenter.yx*g_UVScale);
vec2 uv_local1=vec2(-g_objectCenter.yx*g_UVScale);
vec2 uv_local2=vec2(-g_objectCenter.yx*g_UVScale);
if(lerpDisplacement)
{
lerpSample1*=layerQuadSize;
lerpSample1.x+=layerX-(layerQuadSize*g_layerDensity*2);
lerpSample1.y+=layerY-(layerQuadSize*g_layerDensity*2);
lerpSample2*=layerQuadSize;
lerpSample2.x+=layerX-(layerQuadSize*g_layerDensity*2);
lerpSample2.y+=layerY-(layerQuadSize*g_layerDensity*2);
uv_local1+=(lerpSample1*g_UVScale);
uv_local2+=(lerpSample2*g_UVScale);
}

if(length(pos_local.xy-cameraCenter)>30000)noDisplacement=true;
if(length(pos_local.xy-cameraCenter.xy)>256)noWaveGrid=true;
if(!noDisplacement)
{
vec3 eye_vec=pos_local.xyz-g_LocalEye;
float dist_2d=length(eye_vec.xy);
float blend_factor=(1000-dist_2d)/(1000-200);
blend_factor=clamp(blend_factor,0,1);
vec3 displacement=vec3(0.0,0.0,0.0);
float shoreDepth=1.0;
float shoreDepth1=1.0;
float shoreDepth2=1.0;
vec3 detailDisplacement=vec3(0.0,0.0,0.0);
float fade=1.0;
if(shoreEffects)
{
if(lerpDisplacement)
{
vec2 shoreCoords1=(((vec2(lerpSample1.x,-lerpSample1.y)*(1.0/g_ShoreWidth))+vec2(0.5,0.5)))-(vec2(g_ShoreDepthTextureLocation.y,-g_ShoreDepthTextureLocation.x)*(1.0/g_ShoreWidth));
vec2 shoreCoords2=(((vec2(lerpSample2.x,-lerpSample2.y)*(1.0/g_ShoreWidth))+vec2(0.5,0.5)))-(vec2(g_ShoreDepthTextureLocation.y,-g_ShoreDepthTextureLocation.x)*(1.0/g_ShoreWidth));
shoreDepth1=clamp((textureLod(sampler2D(g_shoreDepthTexture[1 + 9]),shoreCoords1,0).x*0.01)-(g_ShoreDepthTextureLocation.z-g_oceanHeight),0.05,1.0);
shoreDepth2=clamp((textureLod(sampler2D(g_shoreDepthTexture[1 + 9]),shoreCoords2,0).x*0.01)-(g_ShoreDepthTextureLocation.z-g_oceanHeight),0.05,1.0);
}
else

{
vec2 shoreCoords=(((vec2(pos_local.x,-pos_local.y)*(1.0/g_ShoreWidth))+vec2(0.5,0.5)))-(vec2(g_ShoreDepthTextureLocation.y,-g_ShoreDepthTextureLocation.x)*(1.0/g_ShoreWidth));
shoreDepth=clamp((textureLod(sampler2D(g_shoreDepthTexture[1 + 9]),shoreCoords,0).x*0.01)-(g_ShoreDepthTextureLocation.z-g_oceanHeight),0.05,1.0);
}

}

if(blend_factor>0)
{
uint dirNum=16;
uint N=2*dirNum;
float dx=dirNum*6.28318530718f/N;
vec2 windDirection=normalize(vec2(sin(g_windDirection),cos(g_windDirection)));
uint i;
if(lerpDisplacement)
{
vec3 displacement1=vec3(0.0,0.0,0.0);
vec3 displacement2=vec3(0.0,0.0,0.0);
vec2 waveGridAmp1=vec2(0.0,0.0);
vec2 waveGridAmp2=vec2(0.0,0.0);
for(i=0;i<N;i++)
{
float angle=((i)/(N))*6.28318530718f;
vec2 texcDir=normalize(profile32Directons[i]);
vec2 texc1=texcDir*uv_local1*g_profileUVScale;
vec2 texc2=texcDir*uv_local2*g_profileUVScale;
vec2 displacementValue1=vec2(0.0,0.0);
vec2 displacementValue2=vec2(0.0,0.0);
float baseAmplitude=pow(((dot(windDirection,texcDir)+1.0)+((dot(-windDirection,texcDir)+1.0)*(1.0-g_windDependency)))/2.0,4.0);
vec2 baseWaveAmp1=(g_amplitude*shoreDepth1*baseAmplitude*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc1.x+texc1.y+profileOffsets[typed_mod(i,16)],0.0,0.0f),0).xy)/2.0);
vec2 baseWaveAmp2=(g_amplitude*shoreDepth2*baseAmplitude*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc2.x+texc2.y+profileOffsets[typed_mod(i,16)],0.0,0.0f),0).xy)/2.0);
if(waveGrid&&!noWaveGrid)
{
waveGridAmp1=(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc1.x+texc1.y+profileOffsets[typed_mod(i,16)],0.0,1.0f),0).xy*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(uv_local1.x/5.0,uv_local1.y/5.0,(i+0.5)/N),0).x);
waveGridAmp2=(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc2.x+texc2.y+profileOffsets[typed_mod(i,16)],0.0,1.0f),0).xy*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(uv_local2.x/5.0,uv_local2.y/5.0,(i+0.5)/N),0).x);
}

displacementValue1=dx*(waveGridAmp1+baseWaveAmp1);
displacementValue2=dx*(waveGridAmp2+baseWaveAmp2);
displacement1+=vec3(displacementValue1.x*texcDir.x,displacementValue1.x*texcDir.y,displacementValue1.y);
displacement2+=vec3(displacementValue2.x*texcDir.x,displacementValue2.x*texcDir.y,displacementValue2.y);
}

displacement=mix(displacement1,displacement2,0.5)*g_WorldScale;
}
else

{
vec2 waveGridAmp=vec2(0.0,0.0);
for(i=0;i<N;i++)
{
float angle=((i)/(N))*6.28318530718f;
vec2 texcDir=normalize(profile32Directons[i]);
vec2 texc=texcDir*uv_local*g_profileUVScale;
vec2 displacementValue=vec2(0.0,0.0);
float baseAmplitude=pow(((dot(windDirection,texcDir)+1.0)+((dot(-windDirection,texcDir)+1.0)*(1.0-g_windDependency)))/2.0,4.0);
vec2 baseWaveAmp=(g_amplitude*shoreDepth*baseAmplitude*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,0.0f),0).xy)/2.0);
if(waveGrid&&!noWaveGrid)
{
waveGridAmp=(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,1.0f),0).xy*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(uv_local.x/5.0,uv_local.y/5.0,(i+0.5)/N),0).x);
}

displacementValue=dx*(waveGridAmp+baseWaveAmp);
displacement+=vec3(displacementValue.x*texcDir.x,displacementValue.x*texcDir.y,displacementValue.y);
}

displacement*=g_WorldScale;
}

}

pos_local.xyz+=displacement.xyz;
if(shoreEffects)
{
if(lerpDisplacement)Output.vecColour.w=max(mix(shoreDepth1,shoreDepth2,0.5),0.001);else
Output.vecColour.w=max(shoreDepth,0.001);
}

}

if(noGradient)Output.vecColour.x=1.0;
Output.Position=mul(g_matWorldViewProj,pos_local);
Output.LocalPos=pos_local.xyz;
Output.texCoords=uv_local;
Output.SurePosition=Output.Position;
return Output;
}
layout(location = 0) out Block
{
VS_OUTPUT BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 1559 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
{
ioblock.BlockData=VS_BoundlessWaterSurf(IN,true,false);
gl_Position=VS_BoundlessWaterSurf(IN,true,false).Position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_VS_BoundlessWaterSurfShoreWaveGrid_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 1) uniform cbShading
{
	vec3 g_SunDir;
	float g_Shineness;
	vec3 g_SunColor;
	float g_ShoreExtent;
	float g_oceanHeight;
	float g_vrRightEye;
	vec2 g_viewportPixelScale;
	int g_noOfReflectionSteps;
	int g_pixelStep;
	float g_reverseFace;
	bool g_enableFoam;
	float g_UVScale;
	float g_UVOffset;
	float g_WorldScale;
	float g_SunRadius;
	vec2 g_DepthScale;
	vec2 g_screenScale;
	vec4 g_DepthToLinFadeParams;
	vec4 g_HalfTan;
	vec3 g_ShoreDepthTextureLocation;
	float g_ShoreWidth;
	float gkfpdngkpfdp;
	float g_reflectionDistance;
	bool g_vrEnable;
	float g_reflectionBrightness;
};
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};



layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t g_shoreDepthTexture[24];
	uint64_t g_ProfileBuffers[24];
	uint64_t g_InputAmplitude[24];
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 972 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
VS_OUTPUT VS_BoundlessWaterSurf(idOnly IN, bool shoreEffects, bool waveGrid)
{
VS_OUTPUT Output;
float profileOffsets[16]={0.54f,0.18f,0.61f,0.28f,0.09f,0.71f,0.99f,0.43f,0.11f,0.85f,0.24f,0.67f,0.31f,0.86f,0.13f,0.01f};
vec2 profile32Directons[32]={vec2(1.0f,0.0f),vec2(0.98f,0.19f),vec2(0.92f,0.38f),vec2(0.83f,0.55f),vec2(0.707f,0.707f),vec2(0.55f,0.83f),vec2(0.38f,0.92f),vec2(0.19f,0.98f),vec2(0.0f,1.0f),vec2(-0.19f,0.98f),vec2(-0.38f,0.92f),vec2(-0.55f,0.83f),vec2(-0.707f,0.707f),vec2(-0.83f,0.55f),vec2(-0.92f,0.38f),vec2(-0.98f,0.19f),vec2(-1.0f,-0.0f),vec2(-0.98f,-0.19f),vec2(-0.92f,-0.38f),vec2(-0.83f,-0.55f),vec2(-0.707f,-0.707f),vec2(-0.55f,-0.83f),vec2(-0.38f,-0.92f),vec2(-0.19f,-0.98f),vec2(0.0f,-1.0f),vec2(0.19f,-0.98f),vec2(0.38f,-0.92f),vec2(0.55f,-0.83f),vec2(0.707f,-0.707f),vec2(0.83f,-0.55f),vec2(0.92f,-0.38f),vec2(0.98f,-0.19f),};
vec3 vPos=vec3(0.0,0.0,0.0);
vec2 cameraCenter=g_LocalEye.xy;
Output.vecColour=vec4(0.0,1.0,1.0,1.0);
float layerQuadSize;
float layerX=0.0;
float layerY=0.0;
float perlinMovement=0;
uint layerNo=0;
uint boundingVerticies=((8*g_layerDensity)+4)*4;
uint centerVerticies=(boundingVerticies*g_layerDensity)+1;
bool noDisplacement=false;
bool noGradient=false;
bool noWaveGrid=false;
if(g_verticiesPerLayer<250)noDisplacement=true;
uint vertexNo=IN.vertex_id;
if(vertexNo!=0)vertexNo--;
if(vertexNo<6)
{
noDisplacement=true;
noGradient=true;
vPos.z=-100;
layerQuadSize=(1<<(g_noOfLayers-2))*g_minQuadSize;
float externalLayerQuadSize=layerQuadSize*2.0;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX-=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY-=externalLayerQuadSize;
float layerDensity=g_layerDensity*4;
vec2 vertexPositions[6]={vec2(0.0f,0.0f),vec2(0.0f,0.0f),vec2(layerDensity,0.0f),vec2(0.0f,layerDensity),vec2(layerDensity,layerDensity),vec2(layerDensity,layerDensity)};
vPos.x=vertexPositions[vertexNo].x*2.0;
vPos.y=vertexPositions[vertexNo].y*2.0;
}
else
if(vertexNo<boundingVerticies+6)
{
vertexNo-=6;
layerQuadSize=(1<<(g_noOfLayers-2))*g_minQuadSize;
uint boundingEdgeVerticies=boundingVerticies/4;
float externalLayerQuadSize=layerQuadSize*2.0;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX+=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY+=externalLayerQuadSize;
int edgeNo=0;
if(vertexNo>=boundingEdgeVerticies*2)
{
edgeNo+=2;
vertexNo-=boundingEdgeVerticies*2;
}

if(vertexNo>=boundingEdgeVerticies)
{
edgeNo++;
vertexNo-=boundingEdgeVerticies;
}

vertexNo=clamp(vertexNo,1,boundingEdgeVerticies-2);
noDisplacement=true;
noGradient=(typed_mod(vertexNo,2)==1);
vPos.z=-1.0*((typed_mod(vertexNo,2))*100);
float layerDensity=g_layerDensity*4;
if(typed_mod(edgeNo,2)==0)
{
vPos.x=(vertexNo-(2-(typed_mod(vertexNo,2))))/2;
vPos.x=abs((layerDensity*(edgeNo/2))-vPos.x);
vPos.y=layerDensity*(edgeNo/2);
}
else

{
vPos.x=layerDensity*((typed_mod(edgeNo,3)));
vPos.y=(vertexNo-(2-(typed_mod(vertexNo,2))))/2;
vPos.y=abs((layerDensity*((edgeNo-1)/2))-vPos.y);
}

}
else

{
vertexNo-=boundingVerticies+6;
if(vertexNo<centerVerticies)
{
if(vertexNo==centerVerticies-1)vertexNo--;
layerQuadSize=(g_minQuadSize/2.0f);
float externalLayerQuadSize=layerQuadSize*2.0f;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX+=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY+=externalLayerQuadSize;
uint rowVerticies=((g_layerDensity*8)+4);
uint vertexRowNo=typed_mod(vertexNo,rowVerticies);
uint rowNo=(vertexNo-vertexRowNo)/rowVerticies;
vertexRowNo=clamp(vertexRowNo,1,rowVerticies-2);
vPos.x=(vertexRowNo-(2-typed_mod(vertexRowNo,2)))/2;
vPos.y=rowNo+(typed_mod((vertexRowNo+1),2));
}
else

{
vertexNo=vertexNo-centerVerticies;
vertexNo=typed_mod(vertexNo,(g_verticiesPerLayer+1));
if(vertexNo>0)vertexNo--;
layerNo=(((IN.vertex_id)-centerVerticies)-vertexNo)/g_verticiesPerLayer;
layerQuadSize=(1<<layerNo)*g_minQuadSize;
float externalLayerQuadSize=(1<<(layerNo+1))*g_minQuadSize;
float internalLayerQuadSize=(1<<(layerNo-1))*g_minQuadSize;
if(layerNo==0)internalLayerQuadSize=layerQuadSize/2.0;
float internalLayerX;
float internalLayerY;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX+=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY+=externalLayerQuadSize;
xSnapDifference=(cameraCenter.x-layerQuadSize*trunc(cameraCenter.x/layerQuadSize));
ySnapDifference=(cameraCenter.y-layerQuadSize*trunc(cameraCenter.y/layerQuadSize));
internalLayerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>internalLayerQuadSize)internalLayerX+=layerQuadSize;
internalLayerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>internalLayerQuadSize)internalLayerY+=layerQuadSize;
int xQuadOffset=0;
int yQuadOffset=0;
if((internalLayerX-layerX)<0.01*g_minQuadSize)
{
xQuadOffset++;
}

if((layerX-internalLayerX)<0.01*g_minQuadSize)
{
xQuadOffset--;
}

if((internalLayerY-layerY)<0.01*g_minQuadSize)
{
yQuadOffset++;
}

if((layerY-internalLayerY)<0.01*g_minQuadSize)
{
yQuadOffset--;
}

uint totalColumnVerticies=(8*g_layerDensity+4)*g_layerDensity*2;
uint columnWidth=g_layerDensity-xQuadOffset;
totalColumnVerticies+=typed_mod(layerNo,2);
if(vertexNo>=g_verticiesPerLayer-totalColumnVerticies)
{
vertexNo-=g_verticiesPerLayer-totalColumnVerticies;
if(((typed_mod(layerNo,2))==1)&&(vertexNo>0))vertexNo--;
uint sideColumnVerticies=(8*g_layerDensity)+4;
uint vertexColumnNo=typed_mod(vertexNo,sideColumnVerticies);
uint columnNo=(vertexNo-vertexColumnNo)/sideColumnVerticies;
vertexColumnNo=clamp(vertexColumnNo,1,sideColumnVerticies-2);
vPos.y=((vertexColumnNo+(typed_mod(vertexColumnNo,2)))/2)-1;
vPos.x=columnNo+(typed_mod((vertexColumnNo+1),2));
if(columnNo>=g_layerDensity-xQuadOffset)
{
vPos.x+=2*(g_layerDensity);
}

}
else

{
uint sideRowVerticies=(4*g_layerDensity)+4;
if(((typed_mod(layerNo,2))==0)&&(vertexNo==(g_verticiesPerLayer-totalColumnVerticies-1)))vertexNo--;
uint vertexRowNo=typed_mod(vertexNo,sideRowVerticies);
uint rowNo=(vertexNo-vertexRowNo)/sideRowVerticies;
vertexRowNo=clamp(vertexRowNo,1,sideRowVerticies-2);
vPos.x=(vertexRowNo-(2-typed_mod(vertexRowNo,2)))/2;
vPos.x+=columnWidth;
vPos.y=rowNo+(typed_mod((vertexRowNo+1),2));
if(rowNo>=g_layerDensity-yQuadOffset)
{
vPos.y+=2*g_layerDensity;
}

}

}

}

bool lerpDisplacement=false;
vec2 lerpSample1=vec2(0.0,0.0);
vec2 lerpSample2=vec2(0.0,0.0);
if((((vPos.x==0)||(vPos.x==((g_layerDensity)*4)))||((vPos.y==0)||(vPos.y==((g_layerDensity)*4))))&&(layerNo==g_noOfLayers-2))layerQuadSize*=1000;
if(((vPos.x==0)||(vPos.x==((g_layerDensity)*4)))&&(typed_mod(int(vPos.y),2)==1))
{
lerpDisplacement=true;
lerpSample1=vec2(vPos.x,vPos.y+1);
lerpSample2=vec2(vPos.x,vPos.y-1);
}
else
if(((vPos.y==0)||(vPos.y==((g_layerDensity)*4)))&&(typed_mod(int(vPos.x),2)==1))
{
lerpDisplacement=true;
lerpSample1=vec2(vPos.x+1,vPos.y);
lerpSample2=vec2(vPos.x-1,vPos.y);
}

vPos.xy*=layerQuadSize;
vPos.x+=layerX-(layerQuadSize*g_layerDensity*2);
vPos.y+=layerY-(layerQuadSize*g_layerDensity*2);
vPos.z+=g_oceanHeight;
float4 pos_local=float4(vPos,1);
vec2 uv_local=((pos_local.xy)*g_UVScale-g_objectCenter.yx*g_UVScale);
vec2 uv_local1=vec2(-g_objectCenter.yx*g_UVScale);
vec2 uv_local2=vec2(-g_objectCenter.yx*g_UVScale);
if(lerpDisplacement)
{
lerpSample1*=layerQuadSize;
lerpSample1.x+=layerX-(layerQuadSize*g_layerDensity*2);
lerpSample1.y+=layerY-(layerQuadSize*g_layerDensity*2);
lerpSample2*=layerQuadSize;
lerpSample2.x+=layerX-(layerQuadSize*g_layerDensity*2);
lerpSample2.y+=layerY-(layerQuadSize*g_layerDensity*2);
uv_local1+=(lerpSample1*g_UVScale);
uv_local2+=(lerpSample2*g_UVScale);
}

if(length(pos_local.xy-cameraCenter)>30000)noDisplacement=true;
if(length(pos_local.xy-cameraCenter.xy)>256)noWaveGrid=true;
if(!noDisplacement)
{
vec3 eye_vec=pos_local.xyz-g_LocalEye;
float dist_2d=length(eye_vec.xy);
float blend_factor=(1000-dist_2d)/(1000-200);
blend_factor=clamp(blend_factor,0,1);
vec3 displacement=vec3(0.0,0.0,0.0);
float shoreDepth=1.0;
float shoreDepth1=1.0;
float shoreDepth2=1.0;
vec3 detailDisplacement=vec3(0.0,0.0,0.0);
float fade=1.0;
if(shoreEffects)
{
if(lerpDisplacement)
{
vec2 shoreCoords1=(((vec2(lerpSample1.x,-lerpSample1.y)*(1.0/g_ShoreWidth))+vec2(0.5,0.5)))-(vec2(g_ShoreDepthTextureLocation.y,-g_ShoreDepthTextureLocation.x)*(1.0/g_ShoreWidth));
vec2 shoreCoords2=(((vec2(lerpSample2.x,-lerpSample2.y)*(1.0/g_ShoreWidth))+vec2(0.5,0.5)))-(vec2(g_ShoreDepthTextureLocation.y,-g_ShoreDepthTextureLocation.x)*(1.0/g_ShoreWidth));
shoreDepth1=clamp((textureLod(sampler2D(g_shoreDepthTexture[1 + 9]),shoreCoords1,0).x*0.01)-(g_ShoreDepthTextureLocation.z-g_oceanHeight),0.05,1.0);
shoreDepth2=clamp((textureLod(sampler2D(g_shoreDepthTexture[1 + 9]),shoreCoords2,0).x*0.01)-(g_ShoreDepthTextureLocation.z-g_oceanHeight),0.05,1.0);
}
else

{
vec2 shoreCoords=(((vec2(pos_local.x,-pos_local.y)*(1.0/g_ShoreWidth))+vec2(0.5,0.5)))-(vec2(g_ShoreDepthTextureLocation.y,-g_ShoreDepthTextureLocation.x)*(1.0/g_ShoreWidth));
shoreDepth=clamp((textureLod(sampler2D(g_shoreDepthTexture[1 + 9]),shoreCoords,0).x*0.01)-(g_ShoreDepthTextureLocation.z-g_oceanHeight),0.05,1.0);
}

}

if(blend_factor>0)
{
uint dirNum=16;
uint N=2*dirNum;
float dx=dirNum*6.28318530718f/N;
vec2 windDirection=normalize(vec2(sin(g_windDirection),cos(g_windDirection)));
uint i;
if(lerpDisplacement)
{
vec3 displacement1=vec3(0.0,0.0,0.0);
vec3 displacement2=vec3(0.0,0.0,0.0);
vec2 waveGridAmp1=vec2(0.0,0.0);
vec2 waveGridAmp2=vec2(0.0,0.0);
for(i=0;i<N;i++)
{
float angle=((i)/(N))*6.28318530718f;
vec2 texcDir=normalize(profile32Directons[i]);
vec2 texc1=texcDir*uv_local1*g_profileUVScale;
vec2 texc2=texcDir*uv_local2*g_profileUVScale;
vec2 displacementValue1=vec2(0.0,0.0);
vec2 displacementValue2=vec2(0.0,0.0);
float baseAmplitude=pow(((dot(windDirection,texcDir)+1.0)+((dot(-windDirection,texcDir)+1.0)*(1.0-g_windDependency)))/2.0,4.0);
vec2 baseWaveAmp1=(g_amplitude*shoreDepth1*baseAmplitude*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc1.x+texc1.y+profileOffsets[typed_mod(i,16)],0.0,0.0f),0).xy)/2.0);
vec2 baseWaveAmp2=(g_amplitude*shoreDepth2*baseAmplitude*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc2.x+texc2.y+profileOffsets[typed_mod(i,16)],0.0,0.0f),0).xy)/2.0);
if(waveGrid&&!noWaveGrid)
{
waveGridAmp1=(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc1.x+texc1.y+profileOffsets[typed_mod(i,16)],0.0,1.0f),0).xy*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(uv_local1.x/5.0,uv_local1.y/5.0,(i+0.5)/N),0).x);
waveGridAmp2=(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc2.x+texc2.y+profileOffsets[typed_mod(i,16)],0.0,1.0f),0).xy*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(uv_local2.x/5.0,uv_local2.y/5.0,(i+0.5)/N),0).x);
}

displacementValue1=dx*(waveGridAmp1+baseWaveAmp1);
displacementValue2=dx*(waveGridAmp2+baseWaveAmp2);
displacement1+=vec3(displacementValue1.x*texcDir.x,displacementValue1.x*texcDir.y,displacementValue1.y);
displacement2+=vec3(displacementValue2.x*texcDir.x,displacementValue2.x*texcDir.y,displacementValue2.y);
}

displacement=mix(displacement1,displacement2,0.5)*g_WorldScale;
}
else

{
vec2 waveGridAmp=vec2(0.0,0.0);
for(i=0;i<N;i++)
{
float angle=((i)/(N))*6.28318530718f;
vec2 texcDir=normalize(profile32Directons[i]);
vec2 texc=texcDir*uv_local*g_profileUVScale;
vec2 displacementValue=vec2(0.0,0.0);
float baseAmplitude=pow(((dot(windDirection,texcDir)+1.0)+((dot(-windDirection,texcDir)+1.0)*(1.0-g_windDependency)))/2.0,4.0);
vec2 baseWaveAmp=(g_amplitude*shoreDepth*baseAmplitude*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,0.0f),0).xy)/2.0);
if(waveGrid&&!noWaveGrid)
{
waveGridAmp=(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,1.0f),0).xy*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(uv_local.x/5.0,uv_local.y/5.0,(i+0.5)/N),0).x);
}

displacementValue=dx*(waveGridAmp+baseWaveAmp);
displacement+=vec3(displacementValue.x*texcDir.x,displacementValue.x*texcDir.y,displacementValue.y);
}

displacement*=g_WorldScale;
}

}

pos_local.xyz+=displacement.xyz;
if(shoreEffects)
{
if(lerpDisplacement)Output.vecColour.w=max(mix(shoreDepth1,shoreDepth2,0.5),0.001);else
Output.vecColour.w=max(shoreDepth,0.001);
}

}

if(noGradient)Output.vecColour.x=1.0;
Output.Position=mul(g_matWorldViewProj,pos_local);
Output.LocalPos=pos_local.xyz;
Output.texCoords=uv_local;
Output.SurePosition=Output.Position;
return Output;
}
layout(location = 0) out Block
{
VS_OUTPUT BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 1569 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
{
ioblock.BlockData=VS_BoundlessWaterSurf(IN,true,true);
gl_Position=VS_BoundlessWaterSurf(IN,true,true).Position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_VS_BoundlessWaterSurfShoreWaveGrid_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 1) uniform cbShading
{
	vec3 g_SunDir;
	float g_Shineness;
	vec3 g_SunColor;
	float g_ShoreExtent;
	float g_oceanHeight;
	float g_vrRightEye;
	vec2 g_viewportPixelScale;
	int g_noOfReflectionSteps;
	int g_pixelStep;
	float g_reverseFace;
	bool g_enableFoam;
	float g_UVScale;
	float g_UVOffset;
	float g_WorldScale;
	float g_SunRadius;
	vec2 g_DepthScale;
	vec2 g_screenScale;
	vec4 g_DepthToLinFadeParams;
	vec4 g_HalfTan;
	vec3 g_ShoreDepthTextureLocation;
	float g_ShoreWidth;
	float gkfpdngkpfdp;
	float g_reflectionDistance;
	bool g_vrEnable;
	float g_reflectionBrightness;
};
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};



layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t g_shoreDepthTexture[24];
	uint64_t g_ProfileBuffers[24];
	uint64_t g_InputAmplitude[24];
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 972 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
VS_OUTPUT VS_BoundlessWaterSurf(idOnly IN, bool shoreEffects, bool waveGrid)
{
VS_OUTPUT Output;
float profileOffsets[16]={0.54f,0.18f,0.61f,0.28f,0.09f,0.71f,0.99f,0.43f,0.11f,0.85f,0.24f,0.67f,0.31f,0.86f,0.13f,0.01f};
vec2 profile32Directons[32]={vec2(1.0f,0.0f),vec2(0.98f,0.19f),vec2(0.92f,0.38f),vec2(0.83f,0.55f),vec2(0.707f,0.707f),vec2(0.55f,0.83f),vec2(0.38f,0.92f),vec2(0.19f,0.98f),vec2(0.0f,1.0f),vec2(-0.19f,0.98f),vec2(-0.38f,0.92f),vec2(-0.55f,0.83f),vec2(-0.707f,0.707f),vec2(-0.83f,0.55f),vec2(-0.92f,0.38f),vec2(-0.98f,0.19f),vec2(-1.0f,-0.0f),vec2(-0.98f,-0.19f),vec2(-0.92f,-0.38f),vec2(-0.83f,-0.55f),vec2(-0.707f,-0.707f),vec2(-0.55f,-0.83f),vec2(-0.38f,-0.92f),vec2(-0.19f,-0.98f),vec2(0.0f,-1.0f),vec2(0.19f,-0.98f),vec2(0.38f,-0.92f),vec2(0.55f,-0.83f),vec2(0.707f,-0.707f),vec2(0.83f,-0.55f),vec2(0.92f,-0.38f),vec2(0.98f,-0.19f),};
vec3 vPos=vec3(0.0,0.0,0.0);
vec2 cameraCenter=g_LocalEye.xy;
Output.vecColour=vec4(0.0,1.0,1.0,1.0);
float layerQuadSize;
float layerX=0.0;
float layerY=0.0;
float perlinMovement=0;
uint layerNo=0;
uint boundingVerticies=((8*g_layerDensity)+4)*4;
uint centerVerticies=(boundingVerticies*g_layerDensity)+1;
bool noDisplacement=false;
bool noGradient=false;
bool noWaveGrid=false;
if(g_verticiesPerLayer<250)noDisplacement=true;
uint vertexNo=IN.vertex_id;
if(vertexNo!=0)vertexNo--;
if(vertexNo<6)
{
noDisplacement=true;
noGradient=true;
vPos.z=-100;
layerQuadSize=(1<<(g_noOfLayers-2))*g_minQuadSize;
float externalLayerQuadSize=layerQuadSize*2.0;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX-=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY-=externalLayerQuadSize;
float layerDensity=g_layerDensity*4;
vec2 vertexPositions[6]={vec2(0.0f,0.0f),vec2(0.0f,0.0f),vec2(layerDensity,0.0f),vec2(0.0f,layerDensity),vec2(layerDensity,layerDensity),vec2(layerDensity,layerDensity)};
vPos.x=vertexPositions[vertexNo].x*2.0;
vPos.y=vertexPositions[vertexNo].y*2.0;
}
else
if(vertexNo<boundingVerticies+6)
{
vertexNo-=6;
layerQuadSize=(1<<(g_noOfLayers-2))*g_minQuadSize;
uint boundingEdgeVerticies=boundingVerticies/4;
float externalLayerQuadSize=layerQuadSize*2.0;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX+=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY+=externalLayerQuadSize;
int edgeNo=0;
if(vertexNo>=boundingEdgeVerticies*2)
{
edgeNo+=2;
vertexNo-=boundingEdgeVerticies*2;
}

if(vertexNo>=boundingEdgeVerticies)
{
edgeNo++;
vertexNo-=boundingEdgeVerticies;
}

vertexNo=clamp(vertexNo,1,boundingEdgeVerticies-2);
noDisplacement=true;
noGradient=(typed_mod(vertexNo,2)==1);
vPos.z=-1.0*((typed_mod(vertexNo,2))*100);
float layerDensity=g_layerDensity*4;
if(typed_mod(edgeNo,2)==0)
{
vPos.x=(vertexNo-(2-(typed_mod(vertexNo,2))))/2;
vPos.x=abs((layerDensity*(edgeNo/2))-vPos.x);
vPos.y=layerDensity*(edgeNo/2);
}
else

{
vPos.x=layerDensity*((typed_mod(edgeNo,3)));
vPos.y=(vertexNo-(2-(typed_mod(vertexNo,2))))/2;
vPos.y=abs((layerDensity*((edgeNo-1)/2))-vPos.y);
}

}
else

{
vertexNo-=boundingVerticies+6;
if(vertexNo<centerVerticies)
{
if(vertexNo==centerVerticies-1)vertexNo--;
layerQuadSize=(g_minQuadSize/2.0f);
float externalLayerQuadSize=layerQuadSize*2.0f;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX+=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY+=externalLayerQuadSize;
uint rowVerticies=((g_layerDensity*8)+4);
uint vertexRowNo=typed_mod(vertexNo,rowVerticies);
uint rowNo=(vertexNo-vertexRowNo)/rowVerticies;
vertexRowNo=clamp(vertexRowNo,1,rowVerticies-2);
vPos.x=(vertexRowNo-(2-typed_mod(vertexRowNo,2)))/2;
vPos.y=rowNo+(typed_mod((vertexRowNo+1),2));
}
else

{
vertexNo=vertexNo-centerVerticies;
vertexNo=typed_mod(vertexNo,(g_verticiesPerLayer+1));
if(vertexNo>0)vertexNo--;
layerNo=(((IN.vertex_id)-centerVerticies)-vertexNo)/g_verticiesPerLayer;
layerQuadSize=(1<<layerNo)*g_minQuadSize;
float externalLayerQuadSize=(1<<(layerNo+1))*g_minQuadSize;
float internalLayerQuadSize=(1<<(layerNo-1))*g_minQuadSize;
if(layerNo==0)internalLayerQuadSize=layerQuadSize/2.0;
float internalLayerX;
float internalLayerY;
float xSnapDifference=(cameraCenter.x-externalLayerQuadSize*trunc(cameraCenter.x/externalLayerQuadSize));
float ySnapDifference=(cameraCenter.y-externalLayerQuadSize*trunc(cameraCenter.y/externalLayerQuadSize));
layerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>layerQuadSize)layerX+=externalLayerQuadSize;
layerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>layerQuadSize)layerY+=externalLayerQuadSize;
xSnapDifference=(cameraCenter.x-layerQuadSize*trunc(cameraCenter.x/layerQuadSize));
ySnapDifference=(cameraCenter.y-layerQuadSize*trunc(cameraCenter.y/layerQuadSize));
internalLayerX=cameraCenter.x-xSnapDifference;
if(xSnapDifference>internalLayerQuadSize)internalLayerX+=layerQuadSize;
internalLayerY=cameraCenter.y-ySnapDifference;
if(ySnapDifference>internalLayerQuadSize)internalLayerY+=layerQuadSize;
int xQuadOffset=0;
int yQuadOffset=0;
if((internalLayerX-layerX)<0.01*g_minQuadSize)
{
xQuadOffset++;
}

if((layerX-internalLayerX)<0.01*g_minQuadSize)
{
xQuadOffset--;
}

if((internalLayerY-layerY)<0.01*g_minQuadSize)
{
yQuadOffset++;
}

if((layerY-internalLayerY)<0.01*g_minQuadSize)
{
yQuadOffset--;
}

uint totalColumnVerticies=(8*g_layerDensity+4)*g_layerDensity*2;
uint columnWidth=g_layerDensity-xQuadOffset;
totalColumnVerticies+=typed_mod(layerNo,2);
if(vertexNo>=g_verticiesPerLayer-totalColumnVerticies)
{
vertexNo-=g_verticiesPerLayer-totalColumnVerticies;
if(((typed_mod(layerNo,2))==1)&&(vertexNo>0))vertexNo--;
uint sideColumnVerticies=(8*g_layerDensity)+4;
uint vertexColumnNo=typed_mod(vertexNo,sideColumnVerticies);
uint columnNo=(vertexNo-vertexColumnNo)/sideColumnVerticies;
vertexColumnNo=clamp(vertexColumnNo,1,sideColumnVerticies-2);
vPos.y=((vertexColumnNo+(typed_mod(vertexColumnNo,2)))/2)-1;
vPos.x=columnNo+(typed_mod((vertexColumnNo+1),2));
if(columnNo>=g_layerDensity-xQuadOffset)
{
vPos.x+=2*(g_layerDensity);
}

}
else

{
uint sideRowVerticies=(4*g_layerDensity)+4;
if(((typed_mod(layerNo,2))==0)&&(vertexNo==(g_verticiesPerLayer-totalColumnVerticies-1)))vertexNo--;
uint vertexRowNo=typed_mod(vertexNo,sideRowVerticies);
uint rowNo=(vertexNo-vertexRowNo)/sideRowVerticies;
vertexRowNo=clamp(vertexRowNo,1,sideRowVerticies-2);
vPos.x=(vertexRowNo-(2-typed_mod(vertexRowNo,2)))/2;
vPos.x+=columnWidth;
vPos.y=rowNo+(typed_mod((vertexRowNo+1),2));
if(rowNo>=g_layerDensity-yQuadOffset)
{
vPos.y+=2*g_layerDensity;
}

}

}

}

bool lerpDisplacement=false;
vec2 lerpSample1=vec2(0.0,0.0);
vec2 lerpSample2=vec2(0.0,0.0);
if((((vPos.x==0)||(vPos.x==((g_layerDensity)*4)))||((vPos.y==0)||(vPos.y==((g_layerDensity)*4))))&&(layerNo==g_noOfLayers-2))layerQuadSize*=1000;
if(((vPos.x==0)||(vPos.x==((g_layerDensity)*4)))&&(typed_mod(int(vPos.y),2)==1))
{
lerpDisplacement=true;
lerpSample1=vec2(vPos.x,vPos.y+1);
lerpSample2=vec2(vPos.x,vPos.y-1);
}
else
if(((vPos.y==0)||(vPos.y==((g_layerDensity)*4)))&&(typed_mod(int(vPos.x),2)==1))
{
lerpDisplacement=true;
lerpSample1=vec2(vPos.x+1,vPos.y);
lerpSample2=vec2(vPos.x-1,vPos.y);
}

vPos.xy*=layerQuadSize;
vPos.x+=layerX-(layerQuadSize*g_layerDensity*2);
vPos.y+=layerY-(layerQuadSize*g_layerDensity*2);
vPos.z+=g_oceanHeight;
float4 pos_local=float4(vPos,1);
vec2 uv_local=((pos_local.xy)*g_UVScale-g_objectCenter.yx*g_UVScale);
vec2 uv_local1=vec2(-g_objectCenter.yx*g_UVScale);
vec2 uv_local2=vec2(-g_objectCenter.yx*g_UVScale);
if(lerpDisplacement)
{
lerpSample1*=layerQuadSize;
lerpSample1.x+=layerX-(layerQuadSize*g_layerDensity*2);
lerpSample1.y+=layerY-(layerQuadSize*g_layerDensity*2);
lerpSample2*=layerQuadSize;
lerpSample2.x+=layerX-(layerQuadSize*g_layerDensity*2);
lerpSample2.y+=layerY-(layerQuadSize*g_layerDensity*2);
uv_local1+=(lerpSample1*g_UVScale);
uv_local2+=(lerpSample2*g_UVScale);
}

if(length(pos_local.xy-cameraCenter)>30000)noDisplacement=true;
if(length(pos_local.xy-cameraCenter.xy)>256)noWaveGrid=true;
if(!noDisplacement)
{
vec3 eye_vec=pos_local.xyz-g_LocalEye;
float dist_2d=length(eye_vec.xy);
float blend_factor=(1000-dist_2d)/(1000-200);
blend_factor=clamp(blend_factor,0,1);
vec3 displacement=vec3(0.0,0.0,0.0);
float shoreDepth=1.0;
float shoreDepth1=1.0;
float shoreDepth2=1.0;
vec3 detailDisplacement=vec3(0.0,0.0,0.0);
float fade=1.0;
if(shoreEffects)
{
if(lerpDisplacement)
{
vec2 shoreCoords1=(((vec2(lerpSample1.x,-lerpSample1.y)*(1.0/g_ShoreWidth))+vec2(0.5,0.5)))-(vec2(g_ShoreDepthTextureLocation.y,-g_ShoreDepthTextureLocation.x)*(1.0/g_ShoreWidth));
vec2 shoreCoords2=(((vec2(lerpSample2.x,-lerpSample2.y)*(1.0/g_ShoreWidth))+vec2(0.5,0.5)))-(vec2(g_ShoreDepthTextureLocation.y,-g_ShoreDepthTextureLocation.x)*(1.0/g_ShoreWidth));
shoreDepth1=clamp((textureLod(sampler2D(g_shoreDepthTexture[1 + 9]),shoreCoords1,0).x*0.01)-(g_ShoreDepthTextureLocation.z-g_oceanHeight),0.05,1.0);
shoreDepth2=clamp((textureLod(sampler2D(g_shoreDepthTexture[1 + 9]),shoreCoords2,0).x*0.01)-(g_ShoreDepthTextureLocation.z-g_oceanHeight),0.05,1.0);
}
else

{
vec2 shoreCoords=(((vec2(pos_local.x,-pos_local.y)*(1.0/g_ShoreWidth))+vec2(0.5,0.5)))-(vec2(g_ShoreDepthTextureLocation.y,-g_ShoreDepthTextureLocation.x)*(1.0/g_ShoreWidth));
shoreDepth=clamp((textureLod(sampler2D(g_shoreDepthTexture[1 + 9]),shoreCoords,0).x*0.01)-(g_ShoreDepthTextureLocation.z-g_oceanHeight),0.05,1.0);
}

}

if(blend_factor>0)
{
uint dirNum=16;
uint N=2*dirNum;
float dx=dirNum*6.28318530718f/N;
vec2 windDirection=normalize(vec2(sin(g_windDirection),cos(g_windDirection)));
uint i;
if(lerpDisplacement)
{
vec3 displacement1=vec3(0.0,0.0,0.0);
vec3 displacement2=vec3(0.0,0.0,0.0);
vec2 waveGridAmp1=vec2(0.0,0.0);
vec2 waveGridAmp2=vec2(0.0,0.0);
for(i=0;i<N;i++)
{
float angle=((i)/(N))*6.28318530718f;
vec2 texcDir=normalize(profile32Directons[i]);
vec2 texc1=texcDir*uv_local1*g_profileUVScale;
vec2 texc2=texcDir*uv_local2*g_profileUVScale;
vec2 displacementValue1=vec2(0.0,0.0);
vec2 displacementValue2=vec2(0.0,0.0);
float baseAmplitude=pow(((dot(windDirection,texcDir)+1.0)+((dot(-windDirection,texcDir)+1.0)*(1.0-g_windDependency)))/2.0,4.0);
vec2 baseWaveAmp1=(g_amplitude*shoreDepth1*baseAmplitude*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc1.x+texc1.y+profileOffsets[typed_mod(i,16)],0.0,0.0f),0).xy)/2.0);
vec2 baseWaveAmp2=(g_amplitude*shoreDepth2*baseAmplitude*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc2.x+texc2.y+profileOffsets[typed_mod(i,16)],0.0,0.0f),0).xy)/2.0);
if(waveGrid&&!noWaveGrid)
{
waveGridAmp1=(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc1.x+texc1.y+profileOffsets[typed_mod(i,16)],0.0,1.0f),0).xy*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(uv_local1.x/5.0,uv_local1.y/5.0,(i+0.5)/N),0).x);
waveGridAmp2=(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc2.x+texc2.y+profileOffsets[typed_mod(i,16)],0.0,1.0f),0).xy*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(uv_local2.x/5.0,uv_local2.y/5.0,(i+0.5)/N),0).x);
}

displacementValue1=dx*(waveGridAmp1+baseWaveAmp1);
displacementValue2=dx*(waveGridAmp2+baseWaveAmp2);
displacement1+=vec3(displacementValue1.x*texcDir.x,displacementValue1.x*texcDir.y,displacementValue1.y);
displacement2+=vec3(displacementValue2.x*texcDir.x,displacementValue2.x*texcDir.y,displacementValue2.y);
}

displacement=mix(displacement1,displacement2,0.5)*g_WorldScale;
}
else

{
vec2 waveGridAmp=vec2(0.0,0.0);
for(i=0;i<N;i++)
{
float angle=((i)/(N))*6.28318530718f;
vec2 texcDir=normalize(profile32Directons[i]);
vec2 texc=texcDir*uv_local*g_profileUVScale;
vec2 displacementValue=vec2(0.0,0.0);
float baseAmplitude=pow(((dot(windDirection,texcDir)+1.0)+((dot(-windDirection,texcDir)+1.0)*(1.0-g_windDependency)))/2.0,4.0);
vec2 baseWaveAmp=(g_amplitude*shoreDepth*baseAmplitude*(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,0.0f),0).xy)/2.0);
if(waveGrid&&!noWaveGrid)
{
waveGridAmp=(textureLod(sampler2DArray(g_ProfileBuffers[1 + 8]),vec3(texc.x+texc.y+profileOffsets[typed_mod(i,16)],0.0,1.0f),0).xy*textureLod(sampler3D(g_InputAmplitude[1 + 6]),vec3(uv_local.x/5.0,uv_local.y/5.0,(i+0.5)/N),0).x);
}

displacementValue=dx*(waveGridAmp+baseWaveAmp);
displacement+=vec3(displacementValue.x*texcDir.x,displacementValue.x*texcDir.y,displacementValue.y);
}

displacement*=g_WorldScale;
}

}

pos_local.xyz+=displacement.xyz;
if(shoreEffects)
{
if(lerpDisplacement)Output.vecColour.w=max(mix(shoreDepth1,shoreDepth2,0.5),0.001);else
Output.vecColour.w=max(shoreDepth,0.001);
}

}

if(noGradient)Output.vecColour.x=1.0;
Output.Position=mul(g_matWorldViewProj,pos_local);
Output.LocalPos=pos_local.xyz;
Output.texCoords=uv_local;
Output.SurePosition=Output.Position;
return Output;
}
layout(location = 0) out Block
{
VS_OUTPUT BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 1569 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
{
ioblock.BlockData=VS_BoundlessWaterSurf(IN,true,true);
gl_Position=VS_BoundlessWaterSurf(IN,true,true).Position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_VS_BuoyancyObjectPoint_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 147 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 5) uniform cbMeshObjectBuffers
{
	float g_buoyancyUVScale;
	float g_buoyancyUVOffset;
	float g_buoyancySurfaceHeight;
	float g_buoyancyWaveAmplitude;
	vec2 g_buoyancyCenter;
	float g_buoyancyWindDirection;
	float g_buoyancyWindDependancy;
	float g_buoyancyProfileUVScale;
	float g_buoyancyWaveGridScale;
	bool g_buoyancyEnableWaveGrid;
	float gnuhjfidobn;
	mat4 g_meshMat;
	vec3 g_location;
	int g_ID;
	vec4 g_rotation;
	vec3 g_scale;
	float vufiepadnu;
};
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};
layout(std430, binding = 20) buffer g_BuoyancyObjectPos_ssbo
{
	vec3 g_BuoyancyObjectPos[]; 
};
layout(std430, binding = 21) buffer g_BuoyancyObjectVisualOutputs_ssbo
{
	float g_BuoyancyObjectVisualOutputs[]; 
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
layout(location = 0) out Block
{
VS_OUTPUT BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
VS_OUTPUT Output;
vec3 vPos=vec3(0.0,0.0,0.0);
vec2 cameraCenter=g_LocalEye.xy;
uint vertexID=IN.vertex_id;
vPos=g_BuoyancyObjectPos[vertexID].yxz;
vPos*=g_scale.yxz*0.01;
float4 pos_local=float4(vPos,1);
pos_local=mul(g_meshMat,pos_local);
Output.Position=mul(g_matWorldViewProj,pos_local);
Output.LocalPos=vPos;
Output.vecColour=vec4(g_BuoyancyObjectVisualOutputs[vertexID],0.0,0.0,1.0);
Output.texCoords=vec2(0.0,0.0);
Output.SurePosition=Output.Position;
{
ioblock.BlockData=Output;
gl_Position=Output.Position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_VS_BuoyancyObjectPoint_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 147 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 5) uniform cbMeshObjectBuffers
{
	float g_buoyancyUVScale;
	float g_buoyancyUVOffset;
	float g_buoyancySurfaceHeight;
	float g_buoyancyWaveAmplitude;
	vec2 g_buoyancyCenter;
	float g_buoyancyWindDirection;
	float g_buoyancyWindDependancy;
	float g_buoyancyProfileUVScale;
	float g_buoyancyWaveGridScale;
	bool g_buoyancyEnableWaveGrid;
	float gnuhjfidobn;
	mat4 g_meshMat;
	vec3 g_location;
	int g_ID;
	vec4 g_rotation;
	vec3 g_scale;
	float vufiepadnu;
};
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};
layout(std430, binding = 20) buffer g_BuoyancyObjectPos_ssbo
{
	vec3 g_BuoyancyObjectPos[]; 
};
layout(std430, binding = 21) buffer g_BuoyancyObjectVisualOutputs_ssbo
{
	float g_BuoyancyObjectVisualOutputs[]; 
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
layout(location = 0) out Block
{
VS_OUTPUT BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
VS_OUTPUT Output;
vec3 vPos=vec3(0.0,0.0,0.0);
vec2 cameraCenter=g_LocalEye.xy;
uint vertexID=IN.vertex_id;
vPos=g_BuoyancyObjectPos[vertexID].yxz;
vPos*=g_scale.yxz*0.01;
float4 pos_local=float4(vPos,1);
pos_local=mul(g_meshMat,pos_local);
Output.Position=mul(g_matWorldViewProj,pos_local);
Output.LocalPos=vPos;
Output.vecColour=vec4(g_BuoyancyObjectVisualOutputs[vertexID],0.0,0.0,1.0);
Output.texCoords=vec2(0.0,0.0);
Output.SurePosition=Output.Position;
{
ioblock.BlockData=Output;
gl_Position=Output.Position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_VS_DebugObject_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 147 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 5) uniform cbMeshObjectBuffers
{
	float g_buoyancyUVScale;
	float g_buoyancyUVOffset;
	float g_buoyancySurfaceHeight;
	float g_buoyancyWaveAmplitude;
	vec2 g_buoyancyCenter;
	float g_buoyancyWindDirection;
	float g_buoyancyWindDependancy;
	float g_buoyancyProfileUVScale;
	float g_buoyancyWaveGridScale;
	bool g_buoyancyEnableWaveGrid;
	float gnuhjfidobn;
	mat4 g_meshMat;
	vec3 g_location;
	int g_ID;
	vec4 g_rotation;
	vec3 g_scale;
	float vufiepadnu;
};
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};
#line 68 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
struct vertexOnlyInput
{
	vec3 position;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
layout(location=0) in vec3 position;

layout(location = 0) out Block
{
VS_OUTPUT BlockData;
} ioblock;
void main()
{
vertexOnlyInput IN;
IN.position=position;
#line 2880 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
VS_OUTPUT Output;
float4 pos_local=float4(IN.position.xyz*vec3(g_scale.x,g_scale.y,g_scale.z),1);
pos_local=mul(g_meshMat,pos_local);
Output.Position=mul(g_matWorldViewProj,pos_local);
Output.texCoords=vec2(0.0,0.0);
Output.LocalPos=pos_local.xyz;
Output.vecColour=vec4(100.0,0.0,0.0,10.0);
Output.SurePosition=Output.Position;
{
ioblock.BlockData=Output;
gl_Position=Output.Position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_VS_DebugObject_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 147 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 5) uniform cbMeshObjectBuffers
{
	float g_buoyancyUVScale;
	float g_buoyancyUVOffset;
	float g_buoyancySurfaceHeight;
	float g_buoyancyWaveAmplitude;
	vec2 g_buoyancyCenter;
	float g_buoyancyWindDirection;
	float g_buoyancyWindDependancy;
	float g_buoyancyProfileUVScale;
	float g_buoyancyWaveGridScale;
	bool g_buoyancyEnableWaveGrid;
	float gnuhjfidobn;
	mat4 g_meshMat;
	vec3 g_location;
	int g_ID;
	vec4 g_rotation;
	vec3 g_scale;
	float vufiepadnu;
};
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};
#line 68 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
struct vertexOnlyInput
{
	vec3 position;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
layout(location=0) in vec3 position;

layout(location = 0) out Block
{
VS_OUTPUT BlockData;
} ioblock;
void main()
{
vertexOnlyInput IN;
IN.position=position;
#line 2880 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
VS_OUTPUT Output;
float4 pos_local=float4(IN.position.xyz*vec3(g_scale.x,g_scale.y,g_scale.z),1);
pos_local=mul(g_meshMat,pos_local);
Output.Position=mul(g_matWorldViewProj,pos_local);
Output.texCoords=vec2(0.0,0.0);
Output.LocalPos=pos_local.xyz;
Output.vecColour=vec4(100.0,0.0,0.0,10.0);
Output.SurePosition=Output.Position;
{
ioblock.BlockData=Output;
gl_Position=Output.Position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_VS_FlowRaysWireframe_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 1) uniform cbShading
{
	vec3 g_SunDir;
	float g_Shineness;
	vec3 g_SunColor;
	float g_ShoreExtent;
	float g_oceanHeight;
	float g_vrRightEye;
	vec2 g_viewportPixelScale;
	int g_noOfReflectionSteps;
	int g_pixelStep;
	float g_reverseFace;
	bool g_enableFoam;
	float g_UVScale;
	float g_UVOffset;
	float g_WorldScale;
	float g_SunRadius;
	vec2 g_DepthScale;
	vec2 g_screenScale;
	vec4 g_DepthToLinFadeParams;
	vec4 g_HalfTan;
	vec3 g_ShoreDepthTextureLocation;
	float g_ShoreWidth;
	float gkfpdngkpfdp;
	float g_reflectionDistance;
	bool g_vrEnable;
	float g_reflectionBrightness;
};
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};

layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t g_FlowRayBuffer[24];
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
layout(location = 0) out Block
{
VS_OUTPUT BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
VS_OUTPUT Output;
vec3 vPos=vec3(0.0,0.0,0.0);
vec2 cameraCenter=g_LocalEye.xy;
uint vertexID=IN.vertex_id;
uint pos=(typed_mod(vertexID,512));
uint rayID=(vertexID-pos)/512;
vec4 rayValue=textureLod(sampler2D(g_FlowRayBuffer[1 + 11]),vec2(((rayID))/256.0,((pos/512.0))),0);
vPos=vec3(rayValue.x*256*(g_ShoreWidth/256.0),-rayValue.y*256*(g_ShoreWidth/256.0),g_oceanHeight);
vPos+=vec3(g_ShoreDepthTextureLocation.y-(g_ShoreWidth/2.0),g_ShoreDepthTextureLocation.x+(g_ShoreWidth/2.0),0.0);
if(pos==0)vPos.xy=g_ShoreDepthTextureLocation.xy;
if(pos==0||pos==1||pos==2||pos==512||rayValue.z==0.0)Output.vecColour=vec4(0.0,0.0,0.0,0.0);else
Output.vecColour=vec4(rayValue.xy,rayValue.w,1.0);
float4 pos_local=float4(vPos,1);
Output.Position=mul(g_matWorldViewProj,pos_local);
Output.LocalPos=vPos;
Output.texCoords=vec2(0.0,0.0);
Output.SurePosition=Output.Position;
{
ioblock.BlockData=Output;
gl_Position=Output.Position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_VS_FlowRaysWireframe_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 50 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 1) uniform cbShading
{
	vec3 g_SunDir;
	float g_Shineness;
	vec3 g_SunColor;
	float g_ShoreExtent;
	float g_oceanHeight;
	float g_vrRightEye;
	vec2 g_viewportPixelScale;
	int g_noOfReflectionSteps;
	int g_pixelStep;
	float g_reverseFace;
	bool g_enableFoam;
	float g_UVScale;
	float g_UVOffset;
	float g_WorldScale;
	float g_SunRadius;
	vec2 g_DepthScale;
	vec2 g_screenScale;
	vec4 g_DepthToLinFadeParams;
	vec4 g_HalfTan;
	vec3 g_ShoreDepthTextureLocation;
	float g_ShoreWidth;
	float gkfpdngkpfdp;
	float g_reflectionDistance;
	bool g_vrEnable;
	float g_reflectionBrightness;
};
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};

layout(std140, binding = 0) uniform _TextureHandles_h
{
	uint64_t g_FlowRayBuffer[24];
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
layout(location = 0) out Block
{
VS_OUTPUT BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
VS_OUTPUT Output;
vec3 vPos=vec3(0.0,0.0,0.0);
vec2 cameraCenter=g_LocalEye.xy;
uint vertexID=IN.vertex_id;
uint pos=(typed_mod(vertexID,512));
uint rayID=(vertexID-pos)/512;
vec4 rayValue=textureLod(sampler2D(g_FlowRayBuffer[1 + 11]),vec2(((rayID))/256.0,((pos/512.0))),0);
vPos=vec3(rayValue.x*256*(g_ShoreWidth/256.0),-rayValue.y*256*(g_ShoreWidth/256.0),g_oceanHeight);
vPos+=vec3(g_ShoreDepthTextureLocation.y-(g_ShoreWidth/2.0),g_ShoreDepthTextureLocation.x+(g_ShoreWidth/2.0),0.0);
if(pos==0)vPos.xy=g_ShoreDepthTextureLocation.xy;
if(pos==0||pos==1||pos==2||pos==512||rayValue.z==0.0)Output.vecColour=vec4(0.0,0.0,0.0,0.0);else
Output.vecColour=vec4(rayValue.xy,rayValue.w,1.0);
float4 pos_local=float4(vPos,1);
Output.Position=mul(g_matWorldViewProj,pos_local);
Output.LocalPos=vPos;
Output.texCoords=vec2(0.0,0.0);
Output.SurePosition=Output.Position;
{
ioblock.BlockData=Output;
gl_Position=Output.Position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_VS_MaskObject_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 147 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 5) uniform cbMeshObjectBuffers
{
	float g_buoyancyUVScale;
	float g_buoyancyUVOffset;
	float g_buoyancySurfaceHeight;
	float g_buoyancyWaveAmplitude;
	vec2 g_buoyancyCenter;
	float g_buoyancyWindDirection;
	float g_buoyancyWindDependancy;
	float g_buoyancyProfileUVScale;
	float g_buoyancyWaveGridScale;
	bool g_buoyancyEnableWaveGrid;
	float gnuhjfidobn;
	mat4 g_meshMat;
	vec3 g_location;
	int g_ID;
	vec4 g_rotation;
	vec3 g_scale;
	float vufiepadnu;
};
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};
#line 68 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
struct vertexOnlyInput
{
	vec3 position;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
layout(location=0) in vec3 position;

layout(location = 0) out Block
{
VS_OUTPUT BlockData;
} ioblock;
void main()
{
vertexOnlyInput IN;
IN.position=position;
#line 668 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
VS_OUTPUT Output;
float4 pos_local=float4(IN.position.yxz*vec3(-g_scale.y,g_scale.x,g_scale.z)*0.01,1);
pos_local=mul(g_meshMat,pos_local);
Output.Position=mul(g_matWorldViewProj,pos_local);
Output.texCoords=vec2(0.0,0.0);
Output.LocalPos=pos_local.xyz;
Output.vecColour=vec4(0.0,0.0,0.0,0.0);
Output.SurePosition=Output.Position;
{
ioblock.BlockData=Output;
gl_Position=Output.Position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_VS_MaskObject_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 89 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 2) uniform cbChangePerCall
{
	mat4 g_matWorldViewProj;
	mat4 g_matInvViewProj;
	mat4 g_matWorld;
	vec2 g_UVBase;
	vec2 g_objectCenter;
	vec3 g_LocalEye;
	float g_windDirection;
	vec3 g_boundedDimension;
	float g_windDependency;
	vec3 g_boundedLocation;
	float g_boundedRotation;
	vec3 g_absorption;
	uint g_totalVertices;
	vec3 g_scattering;
	float g_amplitude;
	vec3 gfkjdanolv;
	int g_waveGridLimit;
	float g_minQuadSize;
	uint g_verticiesPerLayer;
	uint g_layerDensity;
	uint g_noOfLayers;
	uvec2 g_boundedDensity;
	float g_profileUVScale;
	float g_foamStrength;
};
#line 147 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water_constants.sl"
layout(std140, binding = 5) uniform cbMeshObjectBuffers
{
	float g_buoyancyUVScale;
	float g_buoyancyUVOffset;
	float g_buoyancySurfaceHeight;
	float g_buoyancyWaveAmplitude;
	vec2 g_buoyancyCenter;
	float g_buoyancyWindDirection;
	float g_buoyancyWindDependancy;
	float g_buoyancyProfileUVScale;
	float g_buoyancyWaveGridScale;
	bool g_buoyancyEnableWaveGrid;
	float gnuhjfidobn;
	mat4 g_meshMat;
	vec3 g_location;
	int g_ID;
	vec4 g_rotation;
	vec3 g_scale;
	float vufiepadnu;
};
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/water.sl"
struct VS_OUTPUT
{
	vec4 Position;
	vec2 texCoords;
	vec3 LocalPos;
	vec4 vecColour;
	vec4 SurePosition;
};
#line 68 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
struct vertexOnlyInput
{
	vec3 position;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
layout(location=0) in vec3 position;

layout(location = 0) out Block
{
VS_OUTPUT BlockData;
} ioblock;
void main()
{
vertexOnlyInput IN;
IN.position=position;
#line 668 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
VS_OUTPUT Output;
float4 pos_local=float4(IN.position.yxz*vec3(-g_scale.y,g_scale.x,g_scale.z)*0.01,1);
pos_local=mul(g_meshMat,pos_local);
Output.Position=mul(g_matWorldViewProj,pos_local);
Output.texCoords=vec2(0.0,0.0);
Output.LocalPos=pos_local.xyz;
Output.vecColour=vec4(0.0,0.0,0.0,0.0);
Output.SurePosition=Output.Position;
{
ioblock.BlockData=Output;
gl_Position=Output.Position;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_VS_ShowTexture_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/debug_constants.sl"
layout(std140, binding = 7) uniform DebugConstants
{
	mat4 debugWorldViewProj;
	vec4 rect;
	vec4 multiplier;
	vec4 quaternion;
	uint latitudes;
	uint longitudes;
	float radius;
	float sideview;
	vec4 viewport;
	vec4 debugColour;
	vec4 debugDepthToLinFadeDistParams;
	vec4 debugTanHalfFov;
	uvec4 texSize;
	uvec2 queryPos;
	float debugGamma;
	float debugDepth;
	float displayLod;
	float displayLevel;
	vec2 dc_pad1;
};
#line 145 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput VS_ScreenQuad(idOnly IN, vec4 rect)
{
posTexVertexOutput OUT;
vec2 poss[4];
poss[0]=vec2(1.0,0.0);
poss[1]=vec2(1.0,1.0);
poss[2]=vec2(0.0,0.0);
poss[3]=vec2(0.0,1.0);
vec2 pos=poss[IN.vertex_id];
OUT.hPosition=vec4(rect.xy+rect.zw*pos,0.0,1.0);
OUT.hPosition.z=0.0;
OUT.texCoords=pos;
#line 158 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

OUT.texCoords.y=1.0-OUT.texCoords.y;
#line 160 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

return OUT;
}
layout(location = 0) out Block
{
posTexVertexOutput BlockData;
} ioblock;
void main()
{
idOnly id;
id.vertex_id=gl_VertexID;
#line 2901 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
{
ioblock.BlockData=VS_ScreenQuad(id,rect);
gl_Position=VS_ScreenQuad(id,rect).hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_VS_ShowTexture_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/debug_constants.sl"
layout(std140, binding = 7) uniform DebugConstants
{
	mat4 debugWorldViewProj;
	vec4 rect;
	vec4 multiplier;
	vec4 quaternion;
	uint latitudes;
	uint longitudes;
	float radius;
	float sideview;
	vec4 viewport;
	vec4 debugColour;
	vec4 debugDepthToLinFadeDistParams;
	vec4 debugTanHalfFov;
	uvec4 texSize;
	uvec2 queryPos;
	float debugGamma;
	float debugDepth;
	float displayLod;
	float displayLevel;
	vec2 dc_pad1;
};
#line 145 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput VS_ScreenQuad(idOnly IN, vec4 rect)
{
posTexVertexOutput OUT;
vec2 poss[4];
poss[0]=vec2(1.0,0.0);
poss[1]=vec2(1.0,1.0);
poss[2]=vec2(0.0,0.0);
poss[3]=vec2(0.0,1.0);
vec2 pos=poss[IN.vertex_id];
OUT.hPosition=vec4(rect.xy+rect.zw*pos,0.0,1.0);
OUT.hPosition.z=0.0;
OUT.texCoords=pos;
#line 158 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

OUT.texCoords.y=1.0-OUT.texCoords.y;
#line 160 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

return OUT;
}
layout(location = 0) out Block
{
posTexVertexOutput BlockData;
} ioblock;
void main()
{
idOnly id;
id.vertex_id=gl_VertexID;
#line 2901 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/water.sfx"
{
ioblock.BlockData=VS_ScreenQuad(id,rect);
gl_Position=VS_ScreenQuad(id,rect).hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_VS_SimpleFullscreen_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 119 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput SimpleFullscreen(idOnly IN)
{
posTexVertexOutput OUT;
vec2 poss[4];
poss[0]=vec2(1.0,-1.0);
poss[1]=vec2(1.0,1.0);
poss[2]=vec2(-1.0,-1.0);
poss[3]=vec2(-1.0,1.0);
vec2 pos=poss[IN.vertex_id];
OUT.hPosition=vec4(pos,0.0,1.0);
OUT.hPosition.z=0.0;
OUT.texCoords=0.5*(vec2(1.0,1.0)+vec2(pos.x,-pos.y));
#line 132 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

OUT.texCoords.y=1.0-OUT.texCoords.y;
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

return OUT;
}
layout(location = 0) out Block
{
posTexVertexOutput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput pt=SimpleFullscreen(IN);
{
ioblock.BlockData=pt;
gl_Position=pt.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/water_VS_SimpleFullscreen_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 119 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput SimpleFullscreen(idOnly IN)
{
posTexVertexOutput OUT;
vec2 poss[4];
poss[0]=vec2(1.0,-1.0);
poss[1]=vec2(1.0,1.0);
poss[2]=vec2(-1.0,-1.0);
poss[3]=vec2(-1.0,1.0);
vec2 pos=poss[IN.vertex_id];
OUT.hPosition=vec4(pos,0.0,1.0);
OUT.hPosition.z=0.0;
OUT.texCoords=0.5*(vec2(1.0,1.0)+vec2(pos.x,-pos.y));
#line 132 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

OUT.texCoords.y=1.0-OUT.texCoords.y;
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"

return OUT;
}
layout(location = 0) out Block
{
posTexVertexOutput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
posTexVertexOutput pt=SimpleFullscreen(IN);
{
ioblock.BlockData=pt;
gl_Position=pt.hPosition;
}
}