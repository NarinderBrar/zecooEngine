#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/gaussian_GaussianCol_CS_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:3557)
#pragma warning(disable:3574)
#pragma warning(disable:1)
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/image_constants.sl"
layout(std140, binding = 13) uniform ImageConstants
{
	uvec2 imageSize;
	uint g_NumApproxPasses;
	uint texelsPerThread;
	float g_HalfBoxFilterWidth;
	float g_FracHalfBoxFilterWidth;
	float g_InvFracHalfBoxFilterWidth;
	float g_RcpBoxFilterWidth;
};

layout(r32ui, binding = 0) uniform uimage2D g_rwtOutput;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t g_texInput[24];
};
shared vec3 gs_ScanData[128];
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/gaussian.sfx"
vec3 scan_warp_inclusive(uint thread_id, vec3 value, uint size)
{
uint location=2*thread_id-(thread_id&(size-1));
gs_ScanData[location]=vec3(0,0,0);
location+=size;
gs_ScanData[location]=value;
#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/gaussian.sfx"

for(uint offset=1;offset<size;offset<<=1)
{
barrier();
vec3 value=gs_ScanData[location-offset];
barrier();
gs_ScanData[location]+=value;
}

#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/gaussian.sfx"

return gs_ScanData[location];
}
#line 90 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/gaussian.sfx"
vec3 scan_warp_exclusive(uint thread_id, vec3 value, uint size)
{
return scan_warp_inclusive(thread_id,value,size)-value;
}
#line 95 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/gaussian.sfx"
vec3 scan_top_inclusive(uint thread_id, vec3 value, uint size)
{
vec3 warp_result=scan_warp_inclusive(thread_id,value,32);
barrier();
if((thread_id&(32-1))==32-1)gs_ScanData[thread_id>>5]=warp_result;
barrier();
vec3 top_value=gs_ScanData[thread_id];
gs_ScanData[thread_id]=scan_warp_exclusive(thread_id,top_value,128>>5);
barrier();
return warp_result+gs_ScanData[thread_id>>5];
}
#line 125 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/gaussian.sfx"
vec3 scan_top_exclusive(uint thread_id, vec3 value, uint size)
{
return scan_top_inclusive(thread_id,value,size)-value;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/gaussian.sfx"
void scan_inclusive(uint thread_id, uint size)
{
uint i;
uint location=thread_id*texelsPerThread;
vec3 local_data[64];
for(i=0;i<texelsPerThread;i++)local_data[i]=location+i<size?gs_ScanData[location+i]:vec3(0,0,0);
for(i=1;i<texelsPerThread;i++)local_data[i]+=local_data[i-1];
barrier();
vec3 top_value=local_data[texelsPerThread-1];
vec3 top_result=scan_top_exclusive(thread_id,top_value,128);
barrier();
for(i=0;i<texelsPerThread;i++)
{
if(location+i<size)gs_ScanData[location+i]=local_data[i]+top_result;
}

barrier();
}
#line 162 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/gaussian.sfx"
void scan_inclusive_filtering(uint thread_id, uint size)
{
int i;
uint location=thread_id*texelsPerThread;
vec3 local_data[64];
int L_pos=int(ceil(float(location)-0.5-g_HalfBoxFilterWidth))-1;
int R_pos=int(floor(float(location)-0.5+g_HalfBoxFilterWidth));
vec3 L_sum=gs_ScanData[clamp(L_pos,0,int(size)-1)]*g_FracHalfBoxFilterWidth;
vec3 R_sum=gs_ScanData[clamp(R_pos,0,int(size)-1)]*g_InvFracHalfBoxFilterWidth;
for(i=0;uint(i)<texelsPerThread;i++)
{
vec3 L_next=gs_ScanData[clamp(L_pos+1+i,0,int(size)-1)];
vec3 R_next=gs_ScanData[clamp(R_pos+1+i,0,int(size)-1)];
local_data[i]=(R_sum+R_next*g_FracHalfBoxFilterWidth)-(L_sum+L_next*g_InvFracHalfBoxFilterWidth);
local_data[i]*=g_RcpBoxFilterWidth;
L_sum+=L_next;
R_sum+=R_next;
}

barrier();
vec3 top_value=local_data[texelsPerThread-1];
vec3 top_result=scan_top_exclusive(thread_id,top_value,128);
barrier();
for(i=0;uint(i)<texelsPerThread;i++)
{
if(location+i<size)gs_ScanData[location+i]=local_data[i]+top_result;
}

barrier();
}
#line 209 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/gaussian.sfx"
vec3 box_filtering(uint location, uint size)
{
float centre=float(location)-0.5;
float minus=centre-g_HalfBoxFilterWidth;
float plus=centre+g_HalfBoxFilterWidth;
int L_a=clamp(int(ceil(minus)),0,int(size)-1);
int L_b=clamp(L_a-1,0,int(size)-1);
int R_a=clamp(int(floor(plus)),0,int(size)-1);
int R_b=clamp(R_a+1,0,int(size)-1);
vec3 L_value=mix(gs_ScanData[L_a],gs_ScanData[L_b],g_FracHalfBoxFilterWidth);
vec3 R_value=mix(gs_ScanData[R_a],gs_ScanData[R_b],g_FracHalfBoxFilterWidth);
return (R_value-L_value)*g_RcpBoxFilterWidth;
}
#line 229 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/gaussian.sfx"
uint color3_to_uint(vec3 color)
{
color=clamp(color/10.0,0,1);
uint int_r=uint(color.r*2047.0f+0.5);
uint int_g=uint(color.g*2047.0f+0.5);
uint int_b=uint(color.b*1023.0f+0.5);
return (int_r<<21)|(int_g<<10)|int_b;
}
#line 264 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/gaussian.sfx"
void input_col_color(uint group_id, uint thread_id)
{
uint col=group_id;
uint row=thread_id;
while(row<imageSize.y)
{
gs_ScanData[row]=texelFetch(sampler2D(g_texInput[0]),ivec2(ivec3(ivec2(col,row),0)).xy,int(ivec3(ivec2(col,row),0).y)).rgb;
row+=128;
}

barrier();
}
#line 278 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/gaussian.sfx"
void output_col_color(uint group_id, uint thread_id)
{
uint col=group_id;
uint row=thread_id;
while(row<imageSize.y)
{
vec3 colour=box_filtering(row,imageSize.y);
uint u=color3_to_uint(colour);
imageStore(g_rwtOutput,ivec2(uvec2(col,row)),uvec4(u));
;
row+=128;
}

}
layout(local_size_x=128, local_size_y=1, local_size_z=1) in;
void main()
{
uvec3 GroupID = gl_WorkGroupID;
uvec3 GroupThreadID = gl_LocalInvocationID;
#line 316 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/gaussian.sfx"
input_col_color(GroupID.x,GroupThreadID.x);
scan_inclusive(GroupThreadID.x,imageSize.y);
for(uint i=0;i<g_NumApproxPasses;i++)scan_inclusive_filtering(GroupThreadID.x,imageSize.y);
output_col_color(GroupID.x,GroupThreadID.x);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/gaussian_GaussianRow_CS_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:3557)
#pragma warning(disable:3574)
#pragma warning(disable:1)
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/image_constants.sl"
layout(std140, binding = 13) uniform ImageConstants
{
	uvec2 imageSize;
	uint g_NumApproxPasses;
	uint texelsPerThread;
	float g_HalfBoxFilterWidth;
	float g_FracHalfBoxFilterWidth;
	float g_InvFracHalfBoxFilterWidth;
	float g_RcpBoxFilterWidth;
};
layout(r32ui, binding = 0) uniform uimage2D g_rwtOutput;
shared vec3 gs_ScanData[128];
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/gaussian.sfx"
vec3 scan_warp_inclusive(uint thread_id, vec3 value, uint size)
{
uint location=2*thread_id-(thread_id&(size-1));
gs_ScanData[location]=vec3(0,0,0);
location+=size;
gs_ScanData[location]=value;
#line 70 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/gaussian.sfx"

for(uint offset=1;offset<size;offset<<=1)
{
barrier();
vec3 value=gs_ScanData[location-offset];
barrier();
gs_ScanData[location]+=value;
}

#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/gaussian.sfx"

return gs_ScanData[location];
}
#line 90 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/gaussian.sfx"
vec3 scan_warp_exclusive(uint thread_id, vec3 value, uint size)
{
return scan_warp_inclusive(thread_id,value,size)-value;
}
#line 95 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/gaussian.sfx"
vec3 scan_top_inclusive(uint thread_id, vec3 value, uint size)
{
vec3 warp_result=scan_warp_inclusive(thread_id,value,32);
barrier();
if((thread_id&(32-1))==32-1)gs_ScanData[thread_id>>5]=warp_result;
barrier();
vec3 top_value=gs_ScanData[thread_id];
gs_ScanData[thread_id]=scan_warp_exclusive(thread_id,top_value,128>>5);
barrier();
return warp_result+gs_ScanData[thread_id>>5];
}
#line 125 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/gaussian.sfx"
vec3 scan_top_exclusive(uint thread_id, vec3 value, uint size)
{
return scan_top_inclusive(thread_id,value,size)-value;
}
#line 130 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/gaussian.sfx"
void scan_inclusive(uint thread_id, uint size)
{
uint i;
uint location=thread_id*texelsPerThread;
vec3 local_data[64];
for(i=0;i<texelsPerThread;i++)local_data[i]=location+i<size?gs_ScanData[location+i]:vec3(0,0,0);
for(i=1;i<texelsPerThread;i++)local_data[i]+=local_data[i-1];
barrier();
vec3 top_value=local_data[texelsPerThread-1];
vec3 top_result=scan_top_exclusive(thread_id,top_value,128);
barrier();
for(i=0;i<texelsPerThread;i++)
{
if(location+i<size)gs_ScanData[location+i]=local_data[i]+top_result;
}

barrier();
}
#line 162 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/gaussian.sfx"
void scan_inclusive_filtering(uint thread_id, uint size)
{
int i;
uint location=thread_id*texelsPerThread;
vec3 local_data[64];
int L_pos=int(ceil(float(location)-0.5-g_HalfBoxFilterWidth))-1;
int R_pos=int(floor(float(location)-0.5+g_HalfBoxFilterWidth));
vec3 L_sum=gs_ScanData[clamp(L_pos,0,int(size)-1)]*g_FracHalfBoxFilterWidth;
vec3 R_sum=gs_ScanData[clamp(R_pos,0,int(size)-1)]*g_InvFracHalfBoxFilterWidth;
for(i=0;uint(i)<texelsPerThread;i++)
{
vec3 L_next=gs_ScanData[clamp(L_pos+1+i,0,int(size)-1)];
vec3 R_next=gs_ScanData[clamp(R_pos+1+i,0,int(size)-1)];
local_data[i]=(R_sum+R_next*g_FracHalfBoxFilterWidth)-(L_sum+L_next*g_InvFracHalfBoxFilterWidth);
local_data[i]*=g_RcpBoxFilterWidth;
L_sum+=L_next;
R_sum+=R_next;
}

barrier();
vec3 top_value=local_data[texelsPerThread-1];
vec3 top_result=scan_top_exclusive(thread_id,top_value,128);
barrier();
for(i=0;uint(i)<texelsPerThread;i++)
{
if(location+i<size)gs_ScanData[location+i]=local_data[i]+top_result;
}

barrier();
}
#line 209 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/gaussian.sfx"
vec3 box_filtering(uint location, uint size)
{
float centre=float(location)-0.5;
float minus=centre-g_HalfBoxFilterWidth;
float plus=centre+g_HalfBoxFilterWidth;
int L_a=clamp(int(ceil(minus)),0,int(size)-1);
int L_b=clamp(L_a-1,0,int(size)-1);
int R_a=clamp(int(floor(plus)),0,int(size)-1);
int R_b=clamp(R_a+1,0,int(size)-1);
vec3 L_value=mix(gs_ScanData[L_a],gs_ScanData[L_b],g_FracHalfBoxFilterWidth);
vec3 R_value=mix(gs_ScanData[R_a],gs_ScanData[R_b],g_FracHalfBoxFilterWidth);
return (R_value-L_value)*g_RcpBoxFilterWidth;
}
#line 229 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/gaussian.sfx"
uint color3_to_uint(vec3 color)
{
color=clamp(color/10.0,0,1);
uint int_r=uint(color.r*2047.0f+0.5);
uint int_g=uint(color.g*2047.0f+0.5);
uint int_b=uint(color.b*1023.0f+0.5);
return (int_r<<21)|(int_g<<10)|int_b;
}
#line 240 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/gaussian.sfx"
vec3 uint_to_color3(uint int_color)
{
float r=float(int_color>>21);
float g=float((int_color>>10)&0x7ff);
float b=float(int_color&0x0003ff);
return 10.0*vec3(r/2047.0f,g/2047.0f,b/1023.0f);
}
#line 249 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/gaussian.sfx"
void input_row_color(uint group_id, uint thread_id)
{
uint col=thread_id;
uint row=group_id;
while(col<imageSize.x)
{
uint int_color=imageLoad(g_rwtOutput,ivec2(ivec2(col,row)).xy).x;
gs_ScanData[col]=uint_to_color3(int_color);
col+=128;
}

barrier();
}
#line 292 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/gaussian.sfx"
void output_row_color(uint group_id, uint thread_id)
{
uint col=thread_id;
uint row=group_id;
while(col<imageSize.x)
{
vec3 colour=box_filtering(col,imageSize.x);
uint u=color3_to_uint(colour);
imageStore(g_rwtOutput,ivec2(uvec2(col,row)),uvec4(u));
;
col+=128;
}

}
layout(local_size_x=128, local_size_y=1, local_size_z=1) in;
void main()
{
uvec3 GroupID = gl_WorkGroupID;
uvec3 GroupThreadID = gl_LocalInvocationID;
#line 334 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/gaussian.sfx"
input_row_color(GroupID.x,GroupThreadID.x);
scan_inclusive(GroupThreadID.x,imageSize.x);
for(uint i=0;i<g_NumApproxPasses;i++)scan_inclusive_filtering(GroupThreadID.x,imageSize.x);
output_row_color(GroupID.x,GroupThreadID.x);
}