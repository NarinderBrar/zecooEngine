#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/test_CS_GodraysAccumulation_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 48 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/atmospherics_constants.sl"
layout(std140, binding = 12) uniform AtmosphericsPerViewConstants
{
	mat4 lightspaceToWorldMatrix;
	mat4 scatterspaceToWorldMatrix;
	mat4 worldToCloudMatrix;
	vec3 cloudOriginKm;
	float padXXXXXXX;
	vec3 cloudScaleKm;
	float padXXXXXXXX;
	vec3 viewPosition;
	float zOrigin;
	uvec3 scatteringVolumeDims;
	float godraysIntensity;
	uvec3 godraysVolumeDims;
	float q35uj64jwq;
	uvec3 amortizationOffset;
	float startZMetresZZZ;
	uvec3 amortization;
	float averageCoverage;
	uvec2 edge;
	vec2 padding;
};

layout(rgba32f, binding = 0) uniform image3D targetVolume;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t godraysTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
layout(local_size_x=16, local_size_y=16, local_size_z=1) in;
void main()
{
uvec3 p = gl_GlobalInvocationID;
#line 131 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/test.sfx"
uvec3 idx=p;
vec4 unity=vec4(1.0,1.0,1.0,1.0);
vec4 total=vec4(0.0,0.0,0.0,0.0);
;
vec3 texc=vec3(idx+uvec3(0,1,0))/vec3(godraysVolumeDims.xzy);
float elevation=3.1415926536*(.5-texc.y);
float sum=0.0;
float mean_illumination=1.0;
vec4 mi=vec4(mean_illumination,mean_illumination,mean_illumination,mean_illumination);
float fade_in=saturate(godraysIntensity*(texc.y)/1.5);
for(uint i=0;i<godraysVolumeDims.y;i++)
{
uvec3 pos=uvec3(idx.x,idx.y,i);
texc.z=float(i)/float(godraysVolumeDims.y);
float dist=texc.z;
vec3 texc_gr=vec3(texc.x,dist*cos(elevation),1.0-0.5*(1.0-dist*sin(elevation)+zOrigin));
vec4 lookup=textureLod(sampler2D(godraysTexture[1 + 1]),texc_gr.xy,0);
float light=saturate((lookup.x-texc_gr.z+0.00001)/0.00001);
total+=light;
sum+=1.0;
vec4 result=mix(mi,total/sum,fade_in*saturate(godraysVolumeDims.y-i));
imageStore(targetVolume,ivec3(pos),vec4(result));
;
}

}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/test_CS_GodraysVolume_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 19 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/atmospherics_constants.sl"
layout(std140, binding = 11) uniform AtmosphericsUniforms
{
	vec3 lightDir;
	float pad1;
	vec3 mieRayleighRatio;
	float pad1a;
	vec2 texelOffsetsX;
	float hazeEccentricity;
	float maxFadeDistanceMetres;
	vec3 fogColour;
	float fogScaleHeight;
	vec3 atmosphericsDirectionToSun;
	float atmosphericsPlanetRadiusKm;
};
#line 48 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/atmospherics_constants.sl"
layout(std140, binding = 12) uniform AtmosphericsPerViewConstants
{
	mat4 lightspaceToWorldMatrix;
	mat4 scatterspaceToWorldMatrix;
	mat4 worldToCloudMatrix;
	vec3 cloudOriginKm;
	float padXXXXXXX;
	vec3 cloudScaleKm;
	float padXXXXXXXX;
	vec3 viewPosition;
	float zOrigin;
	uvec3 scatteringVolumeDims;
	float godraysIntensity;
	uvec3 godraysVolumeDims;
	float q35uj64jwq;
	uvec3 amortizationOffset;
	float startZMetresZZZ;
	uvec3 amortization;
	float averageCoverage;
	uvec2 edge;
	vec2 padding;
};



layout(rgba32f, binding = 1) uniform image2D targetTexture;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t cloudTexture[24];
	uint64_t cubeDepthTexture[24];
	uint64_t cubeUpdateTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 53 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/atmospherics.sl"
float GetCloudIllum(uint64_t cloudTexture[24], int cloudSamplerState, vec3 texc, vec3 lightDirCloudspace, int clamp, float averageIllum)
{
vec3 l=lightDirCloudspace;
float zproject=max(0.0,-texc.z)/max(l.z,0.0001)*step(0,l.z)-max(0,texc.z-1.0)/min(l.z,-0.0001)*step(0,-l.z);
texc+=l*zproject;
if(clamp!=0)
{
float xproject=max(0.0,-texc.x)/max(l.x,0.0001)*step(0,l.x)-max(0,texc.x-1.0)/min(l.x,-0.0001)*step(0,l.x);
texc+=l*xproject;
float yproject=max(0.0,-texc.y)/max(l.y,0.0001)*step(0,l.y)-max(0,texc.y-1.0)/min(l.y,-0.0001)*step(0,l.y);
texc+=l*yproject;
}

float range=.05;
float light=saturate((textureLod(sampler3D(cloudTexture[cloudSamplerState]),texc,0).x-1.0+range)/range);
return saturate(light);
}
layout(local_size_x=16, local_size_y=16, local_size_z=1) in;
void main()
{
uvec3 p = gl_GlobalInvocationID;
#line 52 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/test.sfx"
uvec3 idx=p*amortization+amortizationOffset;
float az_texc=float(idx.x)/float(godraysVolumeDims.x);
float radial_texc=float(idx.y)/float(godraysVolumeDims.y-1);
float azimuth=az_texc*2.0*3.1415926536;
float x=radial_texc*sin(azimuth);
float y=radial_texc*cos(azimuth);
vec3 lightDirCloudspace=normalize(mul(worldToCloudMatrix,vec4(lightDir,0.0)).xyz);
vec3 viewPosKm=viewPosition/1000.0;
float maxFadeDistanceKm=maxFadeDistanceMetres*0.001;
float total=0.0;
float total_illum=1.0;
vec3 pos_w0=mul(lightspaceToWorldMatrix,vec4(x,y,0.0,1.0)).xyz;
uint i=0;
vec4 res=vec4(0,0,0,1.0);
#line 74 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/test.sfx"

vec3 wvec=vec3(lightspaceToWorldMatrix[0][2],lightspaceToWorldMatrix[1][2],lightspaceToWorldMatrix[2][2]);
#line 78 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/test.sfx"

float illum=1.0;
float shadow_distance=0.0;
for(i=0;i<godraysVolumeDims.z;i++)
{
float z_texc=float(i)/float(godraysVolumeDims.z-1);
float z=mix(1.0,-1.0,z_texc);
vec3 pos_l=vec3(x,y,z);
vec3 pos_w1=z*wvec;
vec3 pos_w=pos_w0+pos_w1;
vec3 pos_n=normalize(pos_w);
vec4 depth_lookup=textureLod(samplerCube(cubeDepthTexture[1 + 4]),pos_n,0);
;
vec4 update=textureLod(samplerCube(cubeUpdateTexture[1 + 4]),pos_n,0);
;
depth_lookup.x=mix(saturate(depth_lookup.x-0.2)/0.8,1.0,saturate(1.0-update.r)+saturate((depth_lookup.x-0.9)/0.1));
float dist=saturate(length(pos_w)/maxFadeDistanceKm);
vec3 pos_km=viewPosKm+pos_w;
vec3 posCloudspace=(pos_km-cloudOriginKm)/cloudScaleKm;

{
illum=GetCloudIllum(cloudTexture,1 + 7,posCloudspace,lightDirCloudspace,0,1.0-averageCoverage);
}

total_illum*=illum;
float t=0.1;
res=vec4(total_illum,total_illum,total_illum,1.0);
ivec3 pos=ivec3(idx.xy,godraysVolumeDims.z-1-i);
shadow_distance=mix(shadow_distance,float(i+1)/float(godraysVolumeDims.z),total_illum);
}

imageStore(targetTexture,ivec2(idx.xy),vec4(vec4(shadow_distance,shadow_distance,shadow_distance,shadow_distance)));
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/test_CS_ScatteringVolume_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 19 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/atmospherics_constants.sl"
layout(std140, binding = 11) uniform AtmosphericsUniforms
{
	vec3 lightDir;
	float pad1;
	vec3 mieRayleighRatio;
	float pad1a;
	vec2 texelOffsetsX;
	float hazeEccentricity;
	float maxFadeDistanceMetres;
	vec3 fogColour;
	float fogScaleHeight;
	vec3 atmosphericsDirectionToSun;
	float atmosphericsPlanetRadiusKm;
};
#line 48 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/atmospherics_constants.sl"
layout(std140, binding = 12) uniform AtmosphericsPerViewConstants
{
	mat4 lightspaceToWorldMatrix;
	mat4 scatterspaceToWorldMatrix;
	mat4 worldToCloudMatrix;
	vec3 cloudOriginKm;
	float padXXXXXXX;
	vec3 cloudScaleKm;
	float padXXXXXXXX;
	vec3 viewPosition;
	float zOrigin;
	uvec3 scatteringVolumeDims;
	float godraysIntensity;
	uvec3 godraysVolumeDims;
	float q35uj64jwq;
	uvec3 amortizationOffset;
	float startZMetresZZZ;
	uvec3 amortization;
	float averageCoverage;
	uvec2 edge;
	vec2 padding;
};


layout(rgba32f, binding = 0) uniform image3D targetVolume;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t inscTexture[24];
	uint64_t skylTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float CalcRayleighBeta(float cos0)
{
return (1.0+cos0*cos0);
}
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float HenyeyGreenstein(float g, float cos0)
{
float g2=g*g;
float u=1.0+g2-2.0*g*cos0;
return (1.0-g2)*pow(u,-1.5)/(4.0*3.1415926536);
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
vec3 PrecalculatedInscatterFunction(vec4 inscatter_factor, float BetaRayleigh, float BetaMie, vec3 mieRayleighRatio)
{
vec3 mr=mieRayleighRatio.xyz;
vec3 BetaTotal=(BetaRayleigh+BetaMie*mr)/(vec3(1.0,1.0,1.0)+mr);
vec3 colour=BetaTotal*inscatter_factor.rgb;
return colour;
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
vec3 InscatterFunction(vec4 inscatter_factor, float hazeEccentricity, float cos0, vec3 mieRayleighRatio)
{
float BetaRayleigh=CalcRayleighBeta(cos0);
float BetaMie=HenyeyGreenstein(hazeEccentricity,cos0);
return PrecalculatedInscatterFunction(inscatter_factor,BetaRayleigh,BetaMie,mieRayleighRatio);
}
#line 167 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/test.sfx"
vec3 IlluminationAtPosition(vec3 pos_km, vec3 dirToSun, float planetRadiusKm, vec3 range_km)
{
pos_km.z+=planetRadiusKm;
float along=dot(dirToSun,pos_km);
if(along>0.0)return vec3(1,1,1);
pos_km-=along*dirToSun;
float radius_on_cylinder_km=length(pos_km);
float dif=radius_on_cylinder_km-planetRadiusKm;
vec3 d=vec3(dif,dif,dif)+range_km;
vec3 illum=saturate(d/range_km);
return illum;
}
#line 190 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/test.sfx"
void ScatteringVolume(uvec3 p, bool godrays)
{
uvec3 idx=p*amortization+amortizationOffset;
vec2 texc=vec2(float(idx.x)/float(scatteringVolumeDims.x),float(idx.y)/float((scatteringVolumeDims.y-1)));
float azimuth=texc.x*2.0*3.1415926536;
float elevation=(1.0-texc.y)*3.1415926536;
float se=sin(elevation);
float ce=cos(elevation);
float x=sin(azimuth)*se;
float y=cos(azimuth)*se;
vec3 view=vec3(x,y,ce);
float sine=view.z;
float fade_texc_y=0.5*(1.0-sine);
vec4 colour=vec4(0,0,0,0);
vec4 last=vec4(0,0,0,0);
float cos0=dot(view.xyz,lightDir);
vec3 viewPosKm=vec3(0.0,0.0,viewPosition.z/1000.0);
float maxFadeDistanceKm=maxFadeDistanceMetres*0.001;
for(uint i=0;i<scatteringVolumeDims.z;i++)
{
float dist_texc=float(i)/float(scatteringVolumeDims.z-1);
float dist=pow(dist_texc,2.0);
float distanceKm=dist*maxFadeDistanceKm;
vec3 offsetKm=view*distanceKm;
vec3 ls_pos=mul(scatterspaceToWorldMatrix,vec4(1000.0*offsetKm,1.0)).xyz;
float r=length(ls_pos);
vec2 fade_texc=vec2(dist_texc,fade_texc_y);
vec4 insc=textureLod(sampler2D(inscTexture[1 + 9]),fade_texc,0);
vec3 skyl=textureLod(sampler2D(skylTexture[1 + 9]),fade_texc,0).rgb;
#line 226 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/test.sfx"

float illum=0;
vec3 earth_shadow_illum=IlluminationAtPosition(viewPosKm+offsetKm,atmosphericsDirectionToSun,atmosphericsPlanetRadiusKm,vec3(45.0,35.0,25.0));
vec4 next=vec4(InscatterFunction(insc,hazeEccentricity,cos0,mieRayleighRatio),1.0);
vec4 dc=max(vec4(0,0,0,0),(next-last));
dc.rgb*=earth_shadow_illum;
colour+=dc;
colour.a=1.0;
#line 235 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/test.sfx"

vec4 res=colour+vec4(skyl,0);
uvec3 pos=uvec3(idx.xy,i);
imageStore(targetVolume,ivec3(pos),vec4(res));
;
last=next;
}

}
layout(local_size_x=16, local_size_y=16, local_size_z=1) in;
void main()
{
uvec3 p = gl_GlobalInvocationID;
#line 250 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/test.sfx"
ScatteringVolume(p,false);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/test_CS_ScatteringVolume_Godrays_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 19 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/atmospherics_constants.sl"
layout(std140, binding = 11) uniform AtmosphericsUniforms
{
	vec3 lightDir;
	float pad1;
	vec3 mieRayleighRatio;
	float pad1a;
	vec2 texelOffsetsX;
	float hazeEccentricity;
	float maxFadeDistanceMetres;
	vec3 fogColour;
	float fogScaleHeight;
	vec3 atmosphericsDirectionToSun;
	float atmosphericsPlanetRadiusKm;
};
#line 48 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/atmospherics_constants.sl"
layout(std140, binding = 12) uniform AtmosphericsPerViewConstants
{
	mat4 lightspaceToWorldMatrix;
	mat4 scatterspaceToWorldMatrix;
	mat4 worldToCloudMatrix;
	vec3 cloudOriginKm;
	float padXXXXXXX;
	vec3 cloudScaleKm;
	float padXXXXXXXX;
	vec3 viewPosition;
	float zOrigin;
	uvec3 scatteringVolumeDims;
	float godraysIntensity;
	uvec3 godraysVolumeDims;
	float q35uj64jwq;
	uvec3 amortizationOffset;
	float startZMetresZZZ;
	uvec3 amortization;
	float averageCoverage;
	uvec2 edge;
	vec2 padding;
};


layout(rgba32f, binding = 0) uniform image3D targetVolume;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t inscTexture[24];
	uint64_t skylTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float CalcRayleighBeta(float cos0)
{
return (1.0+cos0*cos0);
}
#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
float HenyeyGreenstein(float g, float cos0)
{
float g2=g*g;
float u=1.0+g2-2.0*g*cos0;
return (1.0-g2)*pow(u,-1.5)/(4.0*3.1415926536);
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
vec3 PrecalculatedInscatterFunction(vec4 inscatter_factor, float BetaRayleigh, float BetaMie, vec3 mieRayleighRatio)
{
vec3 mr=mieRayleighRatio.xyz;
vec3 BetaTotal=(BetaRayleigh+BetaMie*mr)/(vec3(1.0,1.0,1.0)+mr);
vec3 colour=BetaTotal*inscatter_factor.rgb;
return colour;
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/simul_inscatter_fns.sl"
vec3 InscatterFunction(vec4 inscatter_factor, float hazeEccentricity, float cos0, vec3 mieRayleighRatio)
{
float BetaRayleigh=CalcRayleighBeta(cos0);
float BetaMie=HenyeyGreenstein(hazeEccentricity,cos0);
return PrecalculatedInscatterFunction(inscatter_factor,BetaRayleigh,BetaMie,mieRayleighRatio);
}
#line 167 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/test.sfx"
vec3 IlluminationAtPosition(vec3 pos_km, vec3 dirToSun, float planetRadiusKm, vec3 range_km)
{
pos_km.z+=planetRadiusKm;
float along=dot(dirToSun,pos_km);
if(along>0.0)return vec3(1,1,1);
pos_km-=along*dirToSun;
float radius_on_cylinder_km=length(pos_km);
float dif=radius_on_cylinder_km-planetRadiusKm;
vec3 d=vec3(dif,dif,dif)+range_km;
vec3 illum=saturate(d/range_km);
return illum;
}
#line 190 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/test.sfx"
void ScatteringVolume(uvec3 p, bool godrays)
{
uvec3 idx=p*amortization+amortizationOffset;
vec2 texc=vec2(float(idx.x)/float(scatteringVolumeDims.x),float(idx.y)/float((scatteringVolumeDims.y-1)));
float azimuth=texc.x*2.0*3.1415926536;
float elevation=(1.0-texc.y)*3.1415926536;
float se=sin(elevation);
float ce=cos(elevation);
float x=sin(azimuth)*se;
float y=cos(azimuth)*se;
vec3 view=vec3(x,y,ce);
float sine=view.z;
float fade_texc_y=0.5*(1.0-sine);
vec4 colour=vec4(0,0,0,0);
vec4 last=vec4(0,0,0,0);
float cos0=dot(view.xyz,lightDir);
vec3 viewPosKm=vec3(0.0,0.0,viewPosition.z/1000.0);
float maxFadeDistanceKm=maxFadeDistanceMetres*0.001;
for(uint i=0;i<scatteringVolumeDims.z;i++)
{
float dist_texc=float(i)/float(scatteringVolumeDims.z-1);
float dist=pow(dist_texc,2.0);
float distanceKm=dist*maxFadeDistanceKm;
vec3 offsetKm=view*distanceKm;
vec3 ls_pos=mul(scatterspaceToWorldMatrix,vec4(1000.0*offsetKm,1.0)).xyz;
float r=length(ls_pos);
vec2 fade_texc=vec2(dist_texc,fade_texc_y);
vec4 insc=textureLod(sampler2D(inscTexture[1 + 9]),fade_texc,0);
vec3 skyl=textureLod(sampler2D(skylTexture[1 + 9]),fade_texc,0).rgb;
#line 226 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/test.sfx"

float illum=0;
vec3 earth_shadow_illum=IlluminationAtPosition(viewPosKm+offsetKm,atmosphericsDirectionToSun,atmosphericsPlanetRadiusKm,vec3(45.0,35.0,25.0));
vec4 next=vec4(InscatterFunction(insc,hazeEccentricity,cos0,mieRayleighRatio),1.0);
vec4 dc=max(vec4(0,0,0,0),(next-last));
dc.rgb*=earth_shadow_illum;
colour+=dc;
colour.a=1.0;
#line 235 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/test.sfx"

vec4 res=colour+vec4(skyl,0);
uvec3 pos=uvec3(idx.xy,i);
imageStore(targetVolume,ivec3(pos),vec4(res));
;
last=next;
}

}
layout(local_size_x=16, local_size_y=16, local_size_z=1) in;
void main()
{
uvec3 p = gl_GlobalInvocationID;
#line 244 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/test.sfx"
ScatteringVolume(p,true);
}