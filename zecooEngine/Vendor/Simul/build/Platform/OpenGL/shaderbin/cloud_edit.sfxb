#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/cloud_edit_PS_DrawCrossSectionOnSphere.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/sphere_constants.sl"
layout(std140, binding = 7) uniform SphereConstants
{
	mat4 debugWorldViewProj;
	vec4 rect;
	vec4 multiplier;
	vec4 quaternion;
	vec4 quaternion2;
	uint latitudes;
	uint longitudes;
	float radius;
	float sideview;
	vec4 debugColour;
	vec3 debugViewDir;
	int slices;
	vec2 texcOffset;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t cloudVolume[24];
};
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 48 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_edit.sfx"
vec3 texc=vec3(BlockData.texCoords.xy+texcOffset,0.5);
vec4 lookup=textureLod(sampler3D(cloudVolume[1 + 7]),texc.xyz,0);
vec4 res=vec4(debugColour.rgb,lookup.z*debugColour.a);
{returnObject_vec4=res;}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/cloud_edit_PS_DrawMultipleCrossSectionsOnSphere.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/sphere_constants.sl"
layout(std140, binding = 7) uniform SphereConstants
{
	mat4 debugWorldViewProj;
	vec4 rect;
	vec4 multiplier;
	vec4 quaternion;
	vec4 quaternion2;
	uint latitudes;
	uint longitudes;
	float radius;
	float sideview;
	vec4 debugColour;
	vec3 debugViewDir;
	int slices;
	vec2 texcOffset;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t cloudVolume[24];
};
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 58 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_edit.sfx"
vec4 res=vec4(0,0,0,0);
for(int i=0;i<=slices;i++)
{
vec3 texc=vec3(BlockData.texCoords.xy+texcOffset,float(i)/float(slices));
vec4 lookup=textureLod(sampler3D(cloudVolume[1 + 7]),texc.xyz,0);
res+=vec4(debugColour.rgb,lookup.z*debugColour.a);
}

{returnObject_vec4=res*(4.0/float(slices));}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/cloud_edit_PS_DrawTextureOnSphere.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/sphere_constants.sl"
layout(std140, binding = 7) uniform SphereConstants
{
	mat4 debugWorldViewProj;
	vec4 rect;
	vec4 multiplier;
	vec4 quaternion;
	vec4 quaternion2;
	uint latitudes;
	uint longitudes;
	float radius;
	float sideview;
	vec4 debugColour;
	vec3 debugViewDir;
	int slices;
	vec2 texcOffset;
};

layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t cloudVolume[24];
};
layout(location = 0) in Block
{
posTexVertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
posTexVertexOutput BlockData=ioblock.BlockData;
#line 38 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_edit.sfx"
vec3 texc=vec3(BlockData.texCoords.xy+texcOffset,0.5);
vec4 lookup=textureLod(sampler3D(cloudVolume[1 + 7]),texc.xyz,0);
vec4 res=lookup;
{returnObject_vec4=res;}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/cloud_edit_VS_DrawTextureOnSphere_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/sphere_constants.sl"
layout(std140, binding = 7) uniform SphereConstants
{
	mat4 debugWorldViewProj;
	vec4 rect;
	vec4 multiplier;
	vec4 quaternion;
	vec4 quaternion2;
	uint latitudes;
	uint longitudes;
	float radius;
	float sideview;
	vec4 debugColour;
	vec3 debugViewDir;
	int slices;
	vec2 texcOffset;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/quaternion.sl"
vec4 quat_conj(vec4 q)
{
return vec4(-q.x,-q.y,-q.z,q.w);
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/quaternion.sl"
vec4 quat_mult(vec4 q1, vec4 q2)
{
vec4 qr;
qr.w=(q1.w*q2.w)-(q1.x*q2.x)-(q1.y*q2.y)-(q1.z*q2.z);
qr.x=(q1.w*q2.x)+(q1.x*q2.w)+(q1.y*q2.z)-(q1.z*q2.y);
qr.y=(q1.w*q2.y)-(q1.x*q2.z)+(q1.y*q2.w)+(q1.z*q2.x);
qr.z=(q1.w*q2.z)+(q1.x*q2.y)-(q1.y*q2.x)+(q1.z*q2.w);
return qr;
}
#line 53 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/quaternion.sl"
vec4 quat_vec(vec4 q, vec3 v)
{
vec4 qr;
qr.w=-(q.x*v.x)-(q.y*v.y)-(q.z*v.z);
qr.x=(q.w*v.x)+(q.y*v.z)-(q.z*v.y);
qr.y=(q.w*v.y)+(q.z*v.x)-(q.x*v.z);
qr.z=(q.w*v.z)+(q.x*v.y)-(q.y*v.x);
return qr;
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/quaternion.sl"
vec3 rotate_by_quaternion(vec4 quat, vec3 position)
{
vec4 qr_conj=quat_conj(quat);
vec4 q_tmp=quat_vec(quat,position);
vec4 qr=quat_mult(q_tmp,qr_conj);
return qr.xyz;
}
layout(location = 0) out Block
{
posTexVertexOutput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_edit.sfx"
posTexVertexOutput OUT;
vec3 poss[4];
poss[0]=vec3(1.0,-1.0,1.0);
poss[1]=vec3(1.0,1.0,1.0);
poss[3]=vec3(-1.0,1.0,1.0);
poss[2]=vec3(-1.0,-1.0,1.0);
vec3 pos;
uint vert=typed_mod(IN.vertex_id,4);

{
pos=poss[vert];
OUT.texCoords=pos.xy*0.5+vec2(0.5,0.5);
pos.xy*=sideview;
pos.z=1.0;
pos=normalize(pos);
}

pos=radius*rotate_by_quaternion(quaternion,pos);
OUT.hPosition=mul(debugWorldViewProj,vec4(pos.xyz,1.0));
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/cloud_edit_VS_DrawTextureOnSphere_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 99 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct idOnly
{
	flat uint vertex_id;
};
#line 105 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/common.sl"
struct posTexVertexOutput
{
	vec4 hPosition;
	vec2 texCoords;
};
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/sphere_constants.sl"
layout(std140, binding = 7) uniform SphereConstants
{
	mat4 debugWorldViewProj;
	vec4 rect;
	vec4 multiplier;
	vec4 quaternion;
	vec4 quaternion2;
	uint latitudes;
	uint longitudes;
	float radius;
	float sideview;
	vec4 debugColour;
	vec3 debugViewDir;
	int slices;
	vec2 texcOffset;
};
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/quaternion.sl"
vec4 quat_conj(vec4 q)
{
return vec4(-q.x,-q.y,-q.z,q.w);
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/quaternion.sl"
vec4 quat_mult(vec4 q1, vec4 q2)
{
vec4 qr;
qr.w=(q1.w*q2.w)-(q1.x*q2.x)-(q1.y*q2.y)-(q1.z*q2.z);
qr.x=(q1.w*q2.x)+(q1.x*q2.w)+(q1.y*q2.z)-(q1.z*q2.y);
qr.y=(q1.w*q2.y)-(q1.x*q2.z)+(q1.y*q2.w)+(q1.z*q2.x);
qr.z=(q1.w*q2.z)+(q1.x*q2.y)-(q1.y*q2.x)+(q1.z*q2.w);
return qr;
}
#line 53 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/quaternion.sl"
vec4 quat_vec(vec4 q, vec3 v)
{
vec4 qr;
qr.w=-(q.x*v.x)-(q.y*v.y)-(q.z*v.z);
qr.x=(q.w*v.x)+(q.y*v.z)-(q.z*v.y);
qr.y=(q.w*v.y)+(q.z*v.x)-(q.x*v.z);
qr.z=(q.w*v.z)+(q.x*v.y)-(q.y*v.x);
return qr;
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/quaternion.sl"
vec3 rotate_by_quaternion(vec4 quat, vec3 position)
{
vec4 qr_conj=quat_conj(quat);
vec4 q_tmp=quat_vec(quat,position);
vec4 qr=quat_mult(q_tmp,qr_conj);
return qr.xyz;
}
layout(location = 0) out Block
{
posTexVertexOutput BlockData;
} ioblock;
void main()
{
idOnly IN;
IN.vertex_id=gl_VertexID;
#line 14 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_edit.sfx"
posTexVertexOutput OUT;
vec3 poss[4];
poss[0]=vec3(1.0,-1.0,1.0);
poss[1]=vec3(1.0,1.0,1.0);
poss[3]=vec3(-1.0,1.0,1.0);
poss[2]=vec3(-1.0,-1.0,1.0);
vec3 pos;
uint vert=typed_mod(IN.vertex_id,4);

{
pos=poss[vert];
OUT.texCoords=pos.xy*0.5+vec2(0.5,0.5);
pos.xy*=sideview;
pos.z=1.0;
pos=normalize(pos);
}

pos=radius*rotate_by_quaternion(quaternion,pos);
OUT.hPosition=mul(debugWorldViewProj,vec4(pos.xyz,1.0));
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}