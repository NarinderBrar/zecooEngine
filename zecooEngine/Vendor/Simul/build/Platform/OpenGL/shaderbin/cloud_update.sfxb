#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/cloud_update_CS_AccelerationMip1_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};

layout(rgba8, binding = 0) uniform image3D outputTexture3d;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t cloudDensity[24];
};
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
layout(local_size_x=4, local_size_y=4, local_size_z=1) in;
void main()
{
uvec3 p = gl_GlobalInvocationID;
#line 703 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
ivec3 pos=ivec3(p)*ivec3(amortizationScale)+ivec3(amortizationOffset.xyz);
if(pos.x>=exclusionRange.x&&pos.y>=exclusionRange.y&&pos.x<exclusionRange.z&&pos.y<exclusionRange.w)return ;
pos.xy+=ivec2(gridCentreTexel);
pos.xy+=ivec2(windowGrid.xy+windowGrid.xy/2);
pos.xy=typed_mod(pos.xy,ivec2(windowGrid.xy));
ivec3 grid2=ivec3(windowGrid)*2;
ivec3 pos2=pos*2;
vec3 texc=vec3(pos)/vec3(targetTextureSize.xxy);
vec3 offset_texc=vec3(1.f,1.f,1.f)/vec3(targetTextureSize.xxy);
vec4 res=vec4(0,0,0,0);
for(int i=-1;i<3;i++)
{
for(int j=-1;j<3;j++)
{
for(int k=-1;k<3;k++)
{
ivec3 pos4=pos2+ivec3(i,j,k);
pos4=ivec3(typed_mod((pos4.xy+grid2.xy),grid2.xy),min(max(0,pos4.z),grid2.z-1));
res=max(res,texelFetch(sampler3D(cloudDensity[0]),ivec3(ivec4(pos4,0)).xyz,int(ivec4(pos4,0).w)).zzzz);
}

}

}

imageStore(outputTexture3d,ivec3(pos),vec4(res));
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/cloud_update_CS_AccelerationMip_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};

layout(rgba8, binding = 0) uniform image3D outputTexture3d;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t cloudDensity[24];
};
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
layout(local_size_x=4, local_size_y=4, local_size_z=1) in;
void main()
{
uvec3 p = gl_GlobalInvocationID;
#line 733 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
ivec3 pos=ivec3(p)*ivec3(amortizationScale)+ivec3(amortizationOffset.xyz);
if(pos.x>=exclusionRange.x&&pos.y>=exclusionRange.y&&pos.x<exclusionRange.z&&pos.y<exclusionRange.w)return ;
pos.xy+=ivec2(gridCentreTexel);
pos.xy+=ivec2(windowGrid.xy+windowGrid.xy/2);
pos.xy=typed_mod(pos.xy,ivec2(windowGrid.xy));
ivec3 grid2=ivec3(windowGrid)*2;
ivec3 pos2=pos*2;
vec3 texc=vec3(pos)/vec3(targetTextureSize.xxy);
vec3 offset_texc=vec3(1.f,1.f,1.f)/vec3(targetTextureSize.xxy);
vec4 res=vec4(0,0,0,0);
for(int i=0;i<2;i++)
{
for(int j=0;j<2;j++)
{
for(int k=0;k<2;k++)
{
ivec3 pos4=pos2+ivec3(i,j,k);
res=max(res,texelFetch(sampler3D(cloudDensity[0]),ivec3(ivec4(pos4,0)).xyz,int(ivec4(pos4,0).w)).zzzz);
}

}

}

imageStore(outputTexture3d,ivec3(pos),vec4(res));
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/cloud_update_CS_CloudMip_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};

layout(rgba8, binding = 0) uniform image3D outputTexture3d;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t cloudDensity[24];
};
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
layout(local_size_x=4, local_size_y=4, local_size_z=1) in;
void main()
{
uvec3 p = gl_GlobalInvocationID;
#line 762 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
ivec3 pos=ivec3(p)*ivec3(amortizationScale)+ivec3(amortizationOffset.xyz);
if(pos.x>=exclusionRange.x&&pos.y>=exclusionRange.y&&pos.x<exclusionRange.z&&pos.y<exclusionRange.w)return ;
pos.xy+=ivec2(gridCentreTexel);
pos.xy+=ivec2(windowGrid.xy+windowGrid.xy/2);
pos.xy=typed_mod(pos.xy,ivec2(windowGrid.xy));
uvec3 pos2=pos*2;
vec3 texc=vec3(pos)/vec3(targetTextureSize.xxy);
vec3 offset_texc=vec3(1.f,1.f,1.f)/vec3(targetTextureSize.xxy);
vec4 res;

{
vec4 c1=textureLod(sampler3D(cloudDensity[1 + 12]),texc,0);
vec4 c2=textureLod(sampler3D(cloudDensity[1 + 12]),texc+vec3(offset_texc.x,0,0),0);
vec4 c3=textureLod(sampler3D(cloudDensity[1 + 12]),texc+vec3(-offset_texc.x,0,0),0);
vec4 c4=textureLod(sampler3D(cloudDensity[1 + 12]),texc+vec3(0,offset_texc.y,0),0);
vec4 c5=textureLod(sampler3D(cloudDensity[1 + 12]),texc+vec3(0,-offset_texc.y,0),0);
vec4 c6=textureLod(sampler3D(cloudDensity[1 + 12]),texc+vec3(0,0,offset_texc.z),0);
vec4 c7=textureLod(sampler3D(cloudDensity[1 + 12]),texc+vec3(0,0,-offset_texc.z),0);
res=c1;
res.xyw*=0.5;
}

imageStore(outputTexture3d,ivec3(pos),vec4(res));
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/cloud_update_CS_IncrementalLighting_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
layout(std140, binding = 8) uniform GpuCloudConstants
{
	mat4 transformMatrix;
	vec4 yRange;
	vec3 noiseScale;
	float sourceNoiseScaleKm;
	vec2 extinctions;
	float stepLength;
	float cloudBaseKm;
	uvec3 threadOffset;
	int octaves;
	float time;
	float persistence;
	float humidity;
	float numWorleyOctaves;
	float zPixel;
	int numVolumes;
	float baseLayer;
	float transition;
	float upperDensity;
	float diffusivity;
	float baseMixingRatio;
	float maskThickness;
	vec2 maskCentre;
	float maskRadius;
	float maskFeather;
	vec3 cloudScalesKm;
	float time_step;
	vec3 lightDir;
	float alpha;
	float invBeta;
	int wrap;
	float viscousCoefficient;
	float seaLevelTemperatureK;
	vec3 cloudOriginKm;
	float vorticityConfinement;
	float worleyNoiseStrength;
	float worleyNoiseScale;
	float noisePeriod;
	int numAffectors;
	float localNoiseStrength;
	float localCellNoiseStrength;
	float baseNoiseFactor;
	float max_density_gm3;
	ivec3 gridEdge;
	float edgeSharpness;
	ivec3 idxOffset;
	float cloudLayerThicknessKm;
};

layout(rgba32f, binding = 2) uniform image3D vec4OutputTexture3d;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t cloudDensity[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 529 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
void IncrementalLighting(uvec3 p, bool init)
{
#line 619 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
ivec2 xyOffset=(idxOffset.xy+ivec2(1,1))/2;
ivec2 xyStart=4*(ivec2(1,1)-idxOffset.xy);
ivec3 idx=ivec3(xyStart-p.xy*idxOffset.xy,p.z)*ivec3(amortizationScale)+ivec3(amortizationOffset.xyz);
if(idx.x>=exclusionRange.x&&idx.y>=exclusionRange.y&&idx.x<exclusionRange.z&&idx.y<exclusionRange.w)return ;
idx.xy+=gridCentreTexel;
vec3 texc=vec3(idx-ivec3(gridCentreTexel+windowGrid.xy/2,0))*scale+offset;
idx.xy+=ivec2(windowGrid.xy+windowGrid.xy/2);
idx.xy=typed_mod(idx.xy,ivec2(windowGrid.xy));
vec3 texc_o=vec3(idx)/vec3(windowGrid);
vec3 wpos=texc*VolumeScaleKm;
int i=0;
float stepLengthKm=1.0/inverseScalesKm.x/float(windowGrid.x);
float s=0.5*stepLengthKm;
float max_h_km=1.0/inverseScalesKm.z;
vec4 current=imageLoad(vec4OutputTexture3d,ivec3(idx).xyz);
uint store_idx=p.y*5+p.x;
vec4 illum_prev=vec4(1.0,1.0,1.0,1.0);
float density=0;
vec3 z_local=normalize(vec3(wpos.xy/6378.0,1.0));
float lightDotz=dot(z_local,directionToSun);
vec3 dir_to_light=normalize(vec3(directionToSun.xy,lightDotz));
vec3 light_dot=dir_to_light*dir_to_light;
if(!init)if(idx.z<windowGrid.z-1)
{
ivec3 idx_x=ivec3((typed_mod((idx.x+idxOffset.x+windowGrid.x),windowGrid.x)),idx.yz);
ivec3 idx_y=ivec3(idx.x,(typed_mod((idx.y+idxOffset.y+windowGrid.y),windowGrid.y)),idx.z);
ivec3 idx_z=ivec3(idx.xy,idx.z+idxOffset.z);
vec4 illum_x=imageLoad(vec4OutputTexture3d,ivec3(idx_x).xyz);
vec4 illum_y=imageLoad(vec4OutputTexture3d,ivec3(idx_y).xyz);
vec4 illum_z=imageLoad(vec4OutputTexture3d,ivec3(idx_z).xyz);
float dens_x=texelFetch(sampler3D(cloudDensity[0]),ivec3(idx_x).xyz,0).z;
float dens_y=texelFetch(sampler3D(cloudDensity[0]),ivec3(idx_y).xyz,0).z;
float dens_z=texelFetch(sampler3D(cloudDensity[0]),ivec3(idx_z).xyz,0).z;
illum_prev=illum_x*light_dot.x+illum_y*light_dot.y+illum_z*light_dot.z;
density=smoothstep(0.0,1.0,saturate((dens_x*light_dot.x+dens_y*light_dot.y+dens_z*light_dot.z)));
}

float thicknessKm=stepLengthKm*density;
vec4 illum;
illum=illum_prev;
illum.x*=max(.01,exp(-extinctionPerKm*thicknessKm/12.0));
illum.y*=exp(-extinctionPerKm*thicknessKm);
illum.w=texelFetch(sampler3D(cloudDensity[0]),ivec3(idx).xyz,0).x;
const float v=127.0/255.0;
imageStore(vec4OutputTexture3d,ivec3(idx),vec4(illum));
}
layout(local_size_x=5, local_size_y=5, local_size_z=1) in;
void main()
{
uvec3 p = gl_GlobalInvocationID;
#line 692 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
IncrementalLighting(p,false);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/cloud_update_CS_IncrementalLightingInit_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
layout(std140, binding = 8) uniform GpuCloudConstants
{
	mat4 transformMatrix;
	vec4 yRange;
	vec3 noiseScale;
	float sourceNoiseScaleKm;
	vec2 extinctions;
	float stepLength;
	float cloudBaseKm;
	uvec3 threadOffset;
	int octaves;
	float time;
	float persistence;
	float humidity;
	float numWorleyOctaves;
	float zPixel;
	int numVolumes;
	float baseLayer;
	float transition;
	float upperDensity;
	float diffusivity;
	float baseMixingRatio;
	float maskThickness;
	vec2 maskCentre;
	float maskRadius;
	float maskFeather;
	vec3 cloudScalesKm;
	float time_step;
	vec3 lightDir;
	float alpha;
	float invBeta;
	int wrap;
	float viscousCoefficient;
	float seaLevelTemperatureK;
	vec3 cloudOriginKm;
	float vorticityConfinement;
	float worleyNoiseStrength;
	float worleyNoiseScale;
	float noisePeriod;
	int numAffectors;
	float localNoiseStrength;
	float localCellNoiseStrength;
	float baseNoiseFactor;
	float max_density_gm3;
	ivec3 gridEdge;
	float edgeSharpness;
	ivec3 idxOffset;
	float cloudLayerThicknessKm;
};

layout(rgba32f, binding = 2) uniform image3D vec4OutputTexture3d;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t cloudDensity[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 529 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
void IncrementalLighting(uvec3 p, bool init)
{
#line 619 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
ivec2 xyOffset=(idxOffset.xy+ivec2(1,1))/2;
ivec2 xyStart=4*(ivec2(1,1)-idxOffset.xy);
ivec3 idx=ivec3(xyStart-p.xy*idxOffset.xy,p.z)*ivec3(amortizationScale)+ivec3(amortizationOffset.xyz);
if(idx.x>=exclusionRange.x&&idx.y>=exclusionRange.y&&idx.x<exclusionRange.z&&idx.y<exclusionRange.w)return ;
idx.xy+=gridCentreTexel;
vec3 texc=vec3(idx-ivec3(gridCentreTexel+windowGrid.xy/2,0))*scale+offset;
idx.xy+=ivec2(windowGrid.xy+windowGrid.xy/2);
idx.xy=typed_mod(idx.xy,ivec2(windowGrid.xy));
vec3 texc_o=vec3(idx)/vec3(windowGrid);
vec3 wpos=texc*VolumeScaleKm;
int i=0;
float stepLengthKm=1.0/inverseScalesKm.x/float(windowGrid.x);
float s=0.5*stepLengthKm;
float max_h_km=1.0/inverseScalesKm.z;
vec4 current=imageLoad(vec4OutputTexture3d,ivec3(idx).xyz);
uint store_idx=p.y*5+p.x;
vec4 illum_prev=vec4(1.0,1.0,1.0,1.0);
float density=0;
vec3 z_local=normalize(vec3(wpos.xy/6378.0,1.0));
float lightDotz=dot(z_local,directionToSun);
vec3 dir_to_light=normalize(vec3(directionToSun.xy,lightDotz));
vec3 light_dot=dir_to_light*dir_to_light;
if(!init)if(idx.z<windowGrid.z-1)
{
ivec3 idx_x=ivec3((typed_mod((idx.x+idxOffset.x+windowGrid.x),windowGrid.x)),idx.yz);
ivec3 idx_y=ivec3(idx.x,(typed_mod((idx.y+idxOffset.y+windowGrid.y),windowGrid.y)),idx.z);
ivec3 idx_z=ivec3(idx.xy,idx.z+idxOffset.z);
vec4 illum_x=imageLoad(vec4OutputTexture3d,ivec3(idx_x).xyz);
vec4 illum_y=imageLoad(vec4OutputTexture3d,ivec3(idx_y).xyz);
vec4 illum_z=imageLoad(vec4OutputTexture3d,ivec3(idx_z).xyz);
float dens_x=texelFetch(sampler3D(cloudDensity[0]),ivec3(idx_x).xyz,0).z;
float dens_y=texelFetch(sampler3D(cloudDensity[0]),ivec3(idx_y).xyz,0).z;
float dens_z=texelFetch(sampler3D(cloudDensity[0]),ivec3(idx_z).xyz,0).z;
illum_prev=illum_x*light_dot.x+illum_y*light_dot.y+illum_z*light_dot.z;
density=smoothstep(0.0,1.0,saturate((dens_x*light_dot.x+dens_y*light_dot.y+dens_z*light_dot.z)));
}

float thicknessKm=stepLengthKm*density;
vec4 illum;
illum=illum_prev;
illum.x*=max(.01,exp(-extinctionPerKm*thicknessKm/12.0));
illum.y*=exp(-extinctionPerKm*thicknessKm);
illum.w=texelFetch(sampler3D(cloudDensity[0]),ivec3(idx).xyz,0).x;
const float v=127.0/255.0;
imageStore(vec4OutputTexture3d,ivec3(idx),vec4(illum));
}
layout(local_size_x=5, local_size_y=5, local_size_z=1) in;
void main()
{
uvec3 p = gl_GlobalInvocationID;
#line 698 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
IncrementalLighting(p,true);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/cloud_update_CS_InterpolateDensity_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)


layout(rgba8, binding = 1) uniform image3D packedOutputTexture3d;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
};
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 UnpackUintToVec4(vec4 a)
{
return a;
}
#line 138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 PackVec4ToUint(vec4 a)
{
return a;
}
layout(local_size_x=4, local_size_y=4, local_size_z=4) in;
void main()
{
uvec3 pos = gl_GlobalInvocationID;
#line 38 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
vec4 res=texelFetch(sampler3D(cloudDensity[0]),ivec3(pos).xyz,0);
vec4 current=UnpackUintToVec4(texelFetch(sampler3D(cloudDensity2[0]),ivec3(pos).xyz,0));
res=current*0.8+res*0.2;
imageStore(packedOutputTexture3d,ivec3(pos),vec4(PackVec4ToUint(res)));
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/cloud_update_CS_InterpolateLight_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)


layout(rgba32f, binding = 2) uniform image3D vec4OutputTexture3d;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
};
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 UnpackUintToVec4(vec4 a)
{
return a;
}
layout(local_size_x=4, local_size_y=4, local_size_z=4) in;
void main()
{
uvec3 pos = gl_GlobalInvocationID;
#line 46 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
vec4 res=texelFetch(sampler3D(cloudDensity[0]),ivec3(pos).xyz,0);
vec4 current=UnpackUintToVec4(texelFetch(sampler3D(cloudDensity2[0]),ivec3(pos).xyz,0));
res=current*0.95+res*0.05;
imageStore(vec4OutputTexture3d,ivec3(pos),vec4(res));
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/cloud_update_CS_InterpolateMips_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
layout(std140, binding = 8) uniform GpuCloudConstants
{
	mat4 transformMatrix;
	vec4 yRange;
	vec3 noiseScale;
	float sourceNoiseScaleKm;
	vec2 extinctions;
	float stepLength;
	float cloudBaseKm;
	uvec3 threadOffset;
	int octaves;
	float time;
	float persistence;
	float humidity;
	float numWorleyOctaves;
	float zPixel;
	int numVolumes;
	float baseLayer;
	float transition;
	float upperDensity;
	float diffusivity;
	float baseMixingRatio;
	float maskThickness;
	vec2 maskCentre;
	float maskRadius;
	float maskFeather;
	vec3 cloudScalesKm;
	float time_step;
	vec3 lightDir;
	float alpha;
	float invBeta;
	int wrap;
	float viscousCoefficient;
	float seaLevelTemperatureK;
	vec3 cloudOriginKm;
	float vorticityConfinement;
	float worleyNoiseStrength;
	float worleyNoiseScale;
	float noisePeriod;
	int numAffectors;
	float localNoiseStrength;
	float localCellNoiseStrength;
	float baseNoiseFactor;
	float max_density_gm3;
	ivec3 gridEdge;
	float edgeSharpness;
	ivec3 idxOffset;
	float cloudLayerThicknessKm;
};


layout(rgba8, binding = 1) uniform image3D packedOutputTexture3d;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
};
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 UnpackUintToVec4(vec4 a)
{
return a;
}
#line 138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 PackVec4ToUint(vec4 a)
{
return a;
}
layout(local_size_x=8, local_size_y=8, local_size_z=1) in;
void main()
{
uvec3 idx = gl_GlobalInvocationID;
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
uvec3 pos=idx+uvec3(idxOffset);
vec4 res=texelFetch(sampler3D(cloudDensity[0]),ivec3(pos).xyz,0);
vec4 current=UnpackUintToVec4(texelFetch(sampler3D(cloudDensity2[0]),ivec3(pos).xyz,0));
res=max(current,res);
imageStore(packedOutputTexture3d,ivec3(pos),vec4(PackVec4ToUint(res)));
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/cloud_update_CS_LightMip_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};

layout(rgba8, binding = 0) uniform image3D outputTexture3d;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t cloudDensity[24];
};
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
layout(local_size_x=4, local_size_y=4, local_size_z=1) in;
void main()
{
uvec3 p = gl_GlobalInvocationID;
#line 793 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
ivec3 pos=ivec3(p)*ivec3(amortizationScale)+ivec3(amortizationOffset.xyz);
if(pos.x>=exclusionRange.x&&pos.y>=exclusionRange.y&&pos.x<exclusionRange.z&&pos.y<exclusionRange.w)return ;
pos.xy+=gridCentreTexel;
pos.xy+=ivec2(windowGrid.xy+windowGrid.xy/2);
pos.xy=typed_mod(pos.xy,ivec2(windowGrid.xy));
uvec3 pos2=pos*2;
vec3 texc=vec3(pos)/vec3(targetTextureSize.xxy);
vec3 offset_texc=vec3(1.f,1.f,1.f)/vec3(targetTextureSize.xxy);
vec4 res;

{
vec4 c1=textureLod(sampler3D(cloudDensity[1 + 12]),texc,0);
vec4 c2=textureLod(sampler3D(cloudDensity[1 + 12]),texc+vec3(offset_texc.x,0,0),0);
vec4 c3=textureLod(sampler3D(cloudDensity[1 + 12]),texc+vec3(-offset_texc.x,0,0),0);
vec4 c4=textureLod(sampler3D(cloudDensity[1 + 12]),texc+vec3(0,offset_texc.y,0),0);
vec4 c5=textureLod(sampler3D(cloudDensity[1 + 12]),texc+vec3(0,-offset_texc.y,0),0);
vec4 c6=textureLod(sampler3D(cloudDensity[1 + 12]),texc+vec3(0,0,offset_texc.z),0);
vec4 c7=textureLod(sampler3D(cloudDensity[1 + 12]),texc+vec3(0,0,-offset_texc.z),0);
res=(c1+c2+c3+c4+c5+c6+c7)/7.0;
}

imageStore(outputTexture3d,ivec3(pos),vec4(res));
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/cloud_update_CS_MapToWindow_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
layout(std140, binding = 8) uniform GpuCloudConstants
{
	mat4 transformMatrix;
	vec4 yRange;
	vec3 noiseScale;
	float sourceNoiseScaleKm;
	vec2 extinctions;
	float stepLength;
	float cloudBaseKm;
	uvec3 threadOffset;
	int octaves;
	float time;
	float persistence;
	float humidity;
	float numWorleyOctaves;
	float zPixel;
	int numVolumes;
	float baseLayer;
	float transition;
	float upperDensity;
	float diffusivity;
	float baseMixingRatio;
	float maskThickness;
	vec2 maskCentre;
	float maskRadius;
	float maskFeather;
	vec3 cloudScalesKm;
	float time_step;
	vec3 lightDir;
	float alpha;
	float invBeta;
	int wrap;
	float viscousCoefficient;
	float seaLevelTemperatureK;
	vec3 cloudOriginKm;
	float vorticityConfinement;
	float worleyNoiseStrength;
	float worleyNoiseScale;
	float noisePeriod;
	int numAffectors;
	float localNoiseStrength;
	float localCellNoiseStrength;
	float baseNoiseFactor;
	float max_density_gm3;
	ivec3 gridEdge;
	float edgeSharpness;
	ivec3 idxOffset;
	float cloudLayerThicknessKm;
};



layout(rgba8, binding = 1) uniform image3D packedOutputTexture3d;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
	uint64_t cloudMaskTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/noise.sl"
float rand3(vec3 co)
{
return fract(sin(dot(co.xyz,vec3(12.9898,78.233,42.1897)))*43758.5453);
}
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 UnpackUintToVec4(vec4 a)
{
return a;
}
#line 138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 PackVec4ToUint(vec4 a)
{
return a;
}
#line 444 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
void MapToWindow(uvec3 p, bool clears)
{
ivec3 idx=ivec3(p)*ivec3(amortizationScale)+ivec3(amortizationOffset.xyz);
if(idx.x>=exclusionRange.x&&idx.y>=exclusionRange.y&&idx.x<exclusionRange.z&&idx.y<exclusionRange.w)return ;
vec3 texc1=vec3(idx)/vec3(windowGrid);
texc1.z+=1.0/float(windowGrid.z);
texc1.y=1.0-texc1.y;
texc1.xy-=vec2(0.5,0.5);
texc1=texc1*mapScale+mapOffset;
float sine=sin(azimuth);
float cosine=cos(azimuth);
texc1.xy=vec2(texc1.x*cosine-texc1.y*sine,texc1.y*cosine+texc1.x*sine);
texc1.xy+=vec2(0.5,0.5);
idx.xy+=gridCentreTexel;
vec3 texc=texc1;
texc.z-=mapOffset.z;
texc*=scale/mapScale*vec3(windowGrid);
texc.z+=offset.z;
idx.xy+=ivec2(windowGrid.xy+windowGrid.xy/2);
idx.xy=typed_mod(idx.xy,ivec2(windowGrid.xy));
float zPixel1=1.0/float(windowGrid.z);
float layer_saturate=saturate(texc.z/zPixel1-0.5)*saturate((1.0-0.5*zPixel1-texc.z)/zPixel1);
vec4 res=vec4(0.0,0.0,0.0,0.0);
vec4 current=vec4(0,0,0,1.0);
if(!clears)
{
current=UnpackUintToVec4(imageLoad(packedOutputTexture3d,ivec3(idx).xyz));
}

if(texc1.x>0.0&&texc1.y>=0.0&&texc1.x<=1.0&&texc1.y<=1.0)
{
for(int i=-2;i<3;i++)
{
vec3 tc=texc;
tc.z+=zPixel*i;
vec4 c1=textureLod(sampler3D(cloudDensity[1 + 7]),tc,0);
vec4 c2=textureLod(sampler3D(cloudDensity2[1 + 7]),tc,0);
res+=mix(c1,c2,cloud_interp).zyxw/5.0;
}

vec4 map_lookup=textureLod(sampler2D(cloudMaskTexture[1 + 9]),texc1.xy,0);
res.z*=map_lookup.z;
res.z=saturate((res.z-0.25)/diffusivity+0.25);
res.z*=1.0/0.5*layer_saturate;
res.w=edgeSharpness;
float noise_factor=mix(baseNoiseFactor,1.0,saturate(texc.z));
noise_factor*=mix(0.05,1.0,rand3(vec3(idx)).x);
res.x=saturate(localNoiseStrength/MaxNoiseAmplitudeKm*noise_factor);
res.y=localCellNoiseStrength*noise_factor;
}

res.xyw=mix(current.xyw,res.xyw,layer_saturate);
res.z=max(res.z*max_density_gm3,current.z);
imageStore(packedOutputTexture3d,ivec3(idx),vec4(PackVec4ToUint(res)));
;
}
layout(local_size_x=4, local_size_y=4, local_size_z=4) in;
void main()
{
uvec3 idx = gl_GlobalInvocationID;
#line 511 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
MapToWindow(idx,false);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/cloud_update_CS_MapToWindowInit_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
layout(std140, binding = 8) uniform GpuCloudConstants
{
	mat4 transformMatrix;
	vec4 yRange;
	vec3 noiseScale;
	float sourceNoiseScaleKm;
	vec2 extinctions;
	float stepLength;
	float cloudBaseKm;
	uvec3 threadOffset;
	int octaves;
	float time;
	float persistence;
	float humidity;
	float numWorleyOctaves;
	float zPixel;
	int numVolumes;
	float baseLayer;
	float transition;
	float upperDensity;
	float diffusivity;
	float baseMixingRatio;
	float maskThickness;
	vec2 maskCentre;
	float maskRadius;
	float maskFeather;
	vec3 cloudScalesKm;
	float time_step;
	vec3 lightDir;
	float alpha;
	float invBeta;
	int wrap;
	float viscousCoefficient;
	float seaLevelTemperatureK;
	vec3 cloudOriginKm;
	float vorticityConfinement;
	float worleyNoiseStrength;
	float worleyNoiseScale;
	float noisePeriod;
	int numAffectors;
	float localNoiseStrength;
	float localCellNoiseStrength;
	float baseNoiseFactor;
	float max_density_gm3;
	ivec3 gridEdge;
	float edgeSharpness;
	ivec3 idxOffset;
	float cloudLayerThicknessKm;
};



layout(rgba8, binding = 1) uniform image3D packedOutputTexture3d;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
	uint64_t cloudMaskTexture[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/noise.sl"
float rand3(vec3 co)
{
return fract(sin(dot(co.xyz,vec3(12.9898,78.233,42.1897)))*43758.5453);
}
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 UnpackUintToVec4(vec4 a)
{
return a;
}
#line 138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 PackVec4ToUint(vec4 a)
{
return a;
}
#line 444 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
void MapToWindow(uvec3 p, bool clears)
{
ivec3 idx=ivec3(p)*ivec3(amortizationScale)+ivec3(amortizationOffset.xyz);
if(idx.x>=exclusionRange.x&&idx.y>=exclusionRange.y&&idx.x<exclusionRange.z&&idx.y<exclusionRange.w)return ;
vec3 texc1=vec3(idx)/vec3(windowGrid);
texc1.z+=1.0/float(windowGrid.z);
texc1.y=1.0-texc1.y;
texc1.xy-=vec2(0.5,0.5);
texc1=texc1*mapScale+mapOffset;
float sine=sin(azimuth);
float cosine=cos(azimuth);
texc1.xy=vec2(texc1.x*cosine-texc1.y*sine,texc1.y*cosine+texc1.x*sine);
texc1.xy+=vec2(0.5,0.5);
idx.xy+=gridCentreTexel;
vec3 texc=texc1;
texc.z-=mapOffset.z;
texc*=scale/mapScale*vec3(windowGrid);
texc.z+=offset.z;
idx.xy+=ivec2(windowGrid.xy+windowGrid.xy/2);
idx.xy=typed_mod(idx.xy,ivec2(windowGrid.xy));
float zPixel1=1.0/float(windowGrid.z);
float layer_saturate=saturate(texc.z/zPixel1-0.5)*saturate((1.0-0.5*zPixel1-texc.z)/zPixel1);
vec4 res=vec4(0.0,0.0,0.0,0.0);
vec4 current=vec4(0,0,0,1.0);
if(!clears)
{
current=UnpackUintToVec4(imageLoad(packedOutputTexture3d,ivec3(idx).xyz));
}

if(texc1.x>0.0&&texc1.y>=0.0&&texc1.x<=1.0&&texc1.y<=1.0)
{
for(int i=-2;i<3;i++)
{
vec3 tc=texc;
tc.z+=zPixel*i;
vec4 c1=textureLod(sampler3D(cloudDensity[1 + 7]),tc,0);
vec4 c2=textureLod(sampler3D(cloudDensity2[1 + 7]),tc,0);
res+=mix(c1,c2,cloud_interp).zyxw/5.0;
}

vec4 map_lookup=textureLod(sampler2D(cloudMaskTexture[1 + 9]),texc1.xy,0);
res.z*=map_lookup.z;
res.z=saturate((res.z-0.25)/diffusivity+0.25);
res.z*=1.0/0.5*layer_saturate;
res.w=edgeSharpness;
float noise_factor=mix(baseNoiseFactor,1.0,saturate(texc.z));
noise_factor*=mix(0.05,1.0,rand3(vec3(idx)).x);
res.x=saturate(localNoiseStrength/MaxNoiseAmplitudeKm*noise_factor);
res.y=localCellNoiseStrength*noise_factor;
}

res.xyw=mix(current.xyw,res.xyw,layer_saturate);
res.z=max(res.z*max_density_gm3,current.z);
imageStore(packedOutputTexture3d,ivec3(idx),vec4(PackVec4ToUint(res)));
;
}
layout(local_size_x=4, local_size_y=4, local_size_z=4) in;
void main()
{
uvec3 idx = gl_GlobalInvocationID;
#line 517 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
MapToWindow(idx,true);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/cloud_update_CS_MixCellNoise_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
layout(std140, binding = 8) uniform GpuCloudConstants
{
	mat4 transformMatrix;
	vec4 yRange;
	vec3 noiseScale;
	float sourceNoiseScaleKm;
	vec2 extinctions;
	float stepLength;
	float cloudBaseKm;
	uvec3 threadOffset;
	int octaves;
	float time;
	float persistence;
	float humidity;
	float numWorleyOctaves;
	float zPixel;
	int numVolumes;
	float baseLayer;
	float transition;
	float upperDensity;
	float diffusivity;
	float baseMixingRatio;
	float maskThickness;
	vec2 maskCentre;
	float maskRadius;
	float maskFeather;
	vec3 cloudScalesKm;
	float time_step;
	vec3 lightDir;
	float alpha;
	float invBeta;
	int wrap;
	float viscousCoefficient;
	float seaLevelTemperatureK;
	vec3 cloudOriginKm;
	float vorticityConfinement;
	float worleyNoiseStrength;
	float worleyNoiseScale;
	float noisePeriod;
	int numAffectors;
	float localNoiseStrength;
	float localCellNoiseStrength;
	float baseNoiseFactor;
	float max_density_gm3;
	ivec3 gridEdge;
	float edgeSharpness;
	ivec3 idxOffset;
	float cloudLayerThicknessKm;
};
#line 81 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
struct CloudVolume_densityspace
{
	mat4 transformMatrix;
	vec4 lower;
	vec4 upper;
	vec2 rake;
	flat int cloudVolumeType;
	float padcvds;
};
layout(std430, binding = 3) buffer cloudVolumes_ssbo
{
	CloudVolume_densityspace cloudVolumes[]; 
};
layout(rgba8, binding = 1) uniform image3D packedOutputTexture3d;
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/noise.sl"
float rand3(vec3 co)
{
return fract(sin(dot(co.xyz,vec3(12.9898,78.233,42.1897)))*43758.5453);
}
#line 42 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/noise.sl"
vec3 SphericalRandom(vec3 co)
{
float r=1.f-pow(rand3(co),4.0);
float az=rand3(43.1138*co)*2*3.1415926536;
float sine_el=rand3(17.981*co)*2.0-1.0;
float el=asin(sine_el);
float cos_el=cos(el);
vec3 v;
v.x=r*sin(az)*cos_el;
v.y=r*cos(az)*cos_el;
v.z=r*sine_el;
return v;
}
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 UnpackUintToVec4(vec4 a)
{
return a;
}
#line 138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 PackVec4ToUint(vec4 a)
{
return a;
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
float GetVolumeMultiplier(vec3 wind_texc)
{
float volume_multiplier=initialVolumeMultiplier;
for(int j=0;j<10;j++)
{
if(j>=numVolumes)break;
CloudVolume_densityspace v=cloudVolumes[j];
vec3 texc=mul(v.transformMatrix,vec4(wind_texc,1.0)).xyz;
float rad=length(texc.xy);
float h=(texc.z);
vec2 boundary=mix(v.lower.xy,v.upper.xy,h);
float m=saturate((boundary.x-rad)/boundary.y);
volume_multiplier=max(volume_multiplier,float(m));
}

return volume_multiplier;
}
#line 144 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
float WorleyShapeFn(vec3 texc, int grid, int seed, float zmax)
{
vec3 pos=float(grid)*texc;
vec3 fractional,intpart;
fractional=modf(pos,intpart);
ivec3 ip=ivec3(intpart);
vec3 loc=fractional-vec3(0.5,0.5,0.5);
float g=float(grid);
float n=g;
for(int i=-1;i<2;++i)
{
for(int j=-1;j<2;++j)
{
for(int k=-1;k<2;++k)
{
ivec3 I=ivec3(i,j,k);
vec3 c=vec3(I);
ivec3 u=(ip+I);
ivec3 v=ivec3((u+ivec3(grid,grid,grid)));
vec3 random=SphericalRandom(vec3(v)*float(seed));
c+=.5*random.xyz;
vec3 diff=loc-c;
float dist=length(diff);
float top=(ip.z+c.z+1.0)/g;
float bot=(ip.z+c.z-1.0)/g;
if(top<zmax)n=min(n,dist);
}

}

}

float p=saturate(1.0-n/1.0);
return p;
}
#line 237 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
void MixCellNoise(ivec3 p, bool clears)
{
ivec3 idx=p*ivec3(amortizationScale)+ivec3(amortizationOffset.xyz);
if(idx.x>=exclusionRange.x&&idx.y>=exclusionRange.y&&idx.x<exclusionRange.z&&idx.y<exclusionRange.w)return ;
idx.xy+=gridCentreTexel;
vec3 gridf=vec3(vec2(windowGrid.xy),0);
vec3 wind_texc=vec3(ivec3(typed_mod((idx.xy-gridCentreTexel.xy),windowGrid.xy)-windowGrid.xy/2,idx.z));
vec3 texc=mul(volumeToLayerMatrix,vec4(wind_texc,1.0)).xyz;
idx.xy+=ivec2(windowGrid.xy+windowGrid.xy/2);
idx.xy=typed_mod(idx.xy,ivec2(windowGrid.xy));
vec4 res=vec4(0.0,0.0,0.0,0.0);
float zPixel1=1.0/float(windowGrid.z);
float layer_saturate=saturate(texc.z/zPixel1+1.0)*saturate((1.0+zPixel1-texc.z)/zPixel1);
float volume_multiplier=GetVolumeMultiplier(wind_texc);
if((texc.z>=-2.0*zPixel1&&texc.z<=1.0+2.0*zPixel1))
{
vec3 cell_texc=vec3(texc.xy,texc.z*scale.x/scale.z);
float cellnoise=humidity*sqrt(WorleyShapeFn(cell_texc,5,7,125.0)*WorleyShapeFn(cell_texc,15,15,125.0));
res.z=cellnoise;
res.w=edgeSharpness;
float noise_factor=mix(baseNoiseFactor,1.0,saturate(texc.z));
noise_factor*=(0.5+rand3(vec3(idx)).x);
res.x=saturate(localNoiseStrength/MaxNoiseAmplitudeKm*noise_factor);
res.y=saturate(localCellNoiseStrength*noise_factor);
}

vec4 current=res;
if(!clears)
{
current=UnpackUintToVec4(imageLoad(packedOutputTexture3d,ivec3(idx).xyz));
}

res.xyw=mix(current.xyw,res.xyw,layer_saturate*res.z);
res.z=max(res.z*max_density_gm3,current.z);

{
imageStore(packedOutputTexture3d,ivec3(idx),vec4(PackVec4ToUint(res)));
;
}

}
layout(local_size_x=4, local_size_y=4, local_size_z=4) in;
void main()
{
uvec3 idx = gl_GlobalInvocationID;
#line 428 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
MixCellNoise(ivec3(idx),false);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/cloud_update_CS_MixCellNoiseInit_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
layout(std140, binding = 8) uniform GpuCloudConstants
{
	mat4 transformMatrix;
	vec4 yRange;
	vec3 noiseScale;
	float sourceNoiseScaleKm;
	vec2 extinctions;
	float stepLength;
	float cloudBaseKm;
	uvec3 threadOffset;
	int octaves;
	float time;
	float persistence;
	float humidity;
	float numWorleyOctaves;
	float zPixel;
	int numVolumes;
	float baseLayer;
	float transition;
	float upperDensity;
	float diffusivity;
	float baseMixingRatio;
	float maskThickness;
	vec2 maskCentre;
	float maskRadius;
	float maskFeather;
	vec3 cloudScalesKm;
	float time_step;
	vec3 lightDir;
	float alpha;
	float invBeta;
	int wrap;
	float viscousCoefficient;
	float seaLevelTemperatureK;
	vec3 cloudOriginKm;
	float vorticityConfinement;
	float worleyNoiseStrength;
	float worleyNoiseScale;
	float noisePeriod;
	int numAffectors;
	float localNoiseStrength;
	float localCellNoiseStrength;
	float baseNoiseFactor;
	float max_density_gm3;
	ivec3 gridEdge;
	float edgeSharpness;
	ivec3 idxOffset;
	float cloudLayerThicknessKm;
};
#line 81 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
struct CloudVolume_densityspace
{
	mat4 transformMatrix;
	vec4 lower;
	vec4 upper;
	vec2 rake;
	flat int cloudVolumeType;
	float padcvds;
};
layout(std430, binding = 3) buffer cloudVolumes_ssbo
{
	CloudVolume_densityspace cloudVolumes[]; 
};
layout(rgba8, binding = 1) uniform image3D packedOutputTexture3d;
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/noise.sl"
float rand3(vec3 co)
{
return fract(sin(dot(co.xyz,vec3(12.9898,78.233,42.1897)))*43758.5453);
}
#line 42 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/noise.sl"
vec3 SphericalRandom(vec3 co)
{
float r=1.f-pow(rand3(co),4.0);
float az=rand3(43.1138*co)*2*3.1415926536;
float sine_el=rand3(17.981*co)*2.0-1.0;
float el=asin(sine_el);
float cos_el=cos(el);
vec3 v;
v.x=r*sin(az)*cos_el;
v.y=r*cos(az)*cos_el;
v.z=r*sine_el;
return v;
}
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 UnpackUintToVec4(vec4 a)
{
return a;
}
#line 138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 PackVec4ToUint(vec4 a)
{
return a;
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
float GetVolumeMultiplier(vec3 wind_texc)
{
float volume_multiplier=initialVolumeMultiplier;
for(int j=0;j<10;j++)
{
if(j>=numVolumes)break;
CloudVolume_densityspace v=cloudVolumes[j];
vec3 texc=mul(v.transformMatrix,vec4(wind_texc,1.0)).xyz;
float rad=length(texc.xy);
float h=(texc.z);
vec2 boundary=mix(v.lower.xy,v.upper.xy,h);
float m=saturate((boundary.x-rad)/boundary.y);
volume_multiplier=max(volume_multiplier,float(m));
}

return volume_multiplier;
}
#line 144 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
float WorleyShapeFn(vec3 texc, int grid, int seed, float zmax)
{
vec3 pos=float(grid)*texc;
vec3 fractional,intpart;
fractional=modf(pos,intpart);
ivec3 ip=ivec3(intpart);
vec3 loc=fractional-vec3(0.5,0.5,0.5);
float g=float(grid);
float n=g;
for(int i=-1;i<2;++i)
{
for(int j=-1;j<2;++j)
{
for(int k=-1;k<2;++k)
{
ivec3 I=ivec3(i,j,k);
vec3 c=vec3(I);
ivec3 u=(ip+I);
ivec3 v=ivec3((u+ivec3(grid,grid,grid)));
vec3 random=SphericalRandom(vec3(v)*float(seed));
c+=.5*random.xyz;
vec3 diff=loc-c;
float dist=length(diff);
float top=(ip.z+c.z+1.0)/g;
float bot=(ip.z+c.z-1.0)/g;
if(top<zmax)n=min(n,dist);
}

}

}

float p=saturate(1.0-n/1.0);
return p;
}
#line 237 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
void MixCellNoise(ivec3 p, bool clears)
{
ivec3 idx=p*ivec3(amortizationScale)+ivec3(amortizationOffset.xyz);
if(idx.x>=exclusionRange.x&&idx.y>=exclusionRange.y&&idx.x<exclusionRange.z&&idx.y<exclusionRange.w)return ;
idx.xy+=gridCentreTexel;
vec3 gridf=vec3(vec2(windowGrid.xy),0);
vec3 wind_texc=vec3(ivec3(typed_mod((idx.xy-gridCentreTexel.xy),windowGrid.xy)-windowGrid.xy/2,idx.z));
vec3 texc=mul(volumeToLayerMatrix,vec4(wind_texc,1.0)).xyz;
idx.xy+=ivec2(windowGrid.xy+windowGrid.xy/2);
idx.xy=typed_mod(idx.xy,ivec2(windowGrid.xy));
vec4 res=vec4(0.0,0.0,0.0,0.0);
float zPixel1=1.0/float(windowGrid.z);
float layer_saturate=saturate(texc.z/zPixel1+1.0)*saturate((1.0+zPixel1-texc.z)/zPixel1);
float volume_multiplier=GetVolumeMultiplier(wind_texc);
if((texc.z>=-2.0*zPixel1&&texc.z<=1.0+2.0*zPixel1))
{
vec3 cell_texc=vec3(texc.xy,texc.z*scale.x/scale.z);
float cellnoise=humidity*sqrt(WorleyShapeFn(cell_texc,5,7,125.0)*WorleyShapeFn(cell_texc,15,15,125.0));
res.z=cellnoise;
res.w=edgeSharpness;
float noise_factor=mix(baseNoiseFactor,1.0,saturate(texc.z));
noise_factor*=(0.5+rand3(vec3(idx)).x);
res.x=saturate(localNoiseStrength/MaxNoiseAmplitudeKm*noise_factor);
res.y=saturate(localCellNoiseStrength*noise_factor);
}

vec4 current=res;
if(!clears)
{
current=UnpackUintToVec4(imageLoad(packedOutputTexture3d,ivec3(idx).xyz));
}

res.xyw=mix(current.xyw,res.xyw,layer_saturate*res.z);
res.z=max(res.z*max_density_gm3,current.z);

{
imageStore(packedOutputTexture3d,ivec3(idx),vec4(PackVec4ToUint(res)));
;
}

}
layout(local_size_x=4, local_size_y=4, local_size_z=4) in;
void main()
{
uvec3 idx = gl_GlobalInvocationID;
#line 422 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
MixCellNoise(ivec3(idx),true);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/cloud_update_CS_MixCirrus_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
layout(std140, binding = 8) uniform GpuCloudConstants
{
	mat4 transformMatrix;
	vec4 yRange;
	vec3 noiseScale;
	float sourceNoiseScaleKm;
	vec2 extinctions;
	float stepLength;
	float cloudBaseKm;
	uvec3 threadOffset;
	int octaves;
	float time;
	float persistence;
	float humidity;
	float numWorleyOctaves;
	float zPixel;
	int numVolumes;
	float baseLayer;
	float transition;
	float upperDensity;
	float diffusivity;
	float baseMixingRatio;
	float maskThickness;
	vec2 maskCentre;
	float maskRadius;
	float maskFeather;
	vec3 cloudScalesKm;
	float time_step;
	vec3 lightDir;
	float alpha;
	float invBeta;
	int wrap;
	float viscousCoefficient;
	float seaLevelTemperatureK;
	vec3 cloudOriginKm;
	float vorticityConfinement;
	float worleyNoiseStrength;
	float worleyNoiseScale;
	float noisePeriod;
	int numAffectors;
	float localNoiseStrength;
	float localCellNoiseStrength;
	float baseNoiseFactor;
	float max_density_gm3;
	ivec3 gridEdge;
	float edgeSharpness;
	ivec3 idxOffset;
	float cloudLayerThicknessKm;
};
#line 81 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
struct CloudVolume_densityspace
{
	mat4 transformMatrix;
	vec4 lower;
	vec4 upper;
	vec2 rake;
	flat int cloudVolumeType;
	float padcvds;
};


layout(std430, binding = 3) buffer cloudVolumes_ssbo
{
	CloudVolume_densityspace cloudVolumes[]; 
};
layout(rgba8, binding = 1) uniform image3D packedOutputTexture3d;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/noise.sl"
float rand3(vec3 co)
{
return fract(sin(dot(co.xyz,vec3(12.9898,78.233,42.1897)))*43758.5453);
}
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 UnpackUintToVec4(vec4 a)
{
return a;
}
#line 138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 PackVec4ToUint(vec4 a)
{
return a;
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
float GetVolumeMultiplier(vec3 wind_texc)
{
float volume_multiplier=initialVolumeMultiplier;
for(int j=0;j<10;j++)
{
if(j>=numVolumes)break;
CloudVolume_densityspace v=cloudVolumes[j];
vec3 texc=mul(v.transformMatrix,vec4(wind_texc,1.0)).xyz;
float rad=length(texc.xy);
float h=(texc.z);
vec2 boundary=mix(v.lower.xy,v.upper.xy,h);
float m=saturate((boundary.x-rad)/boundary.y);
volume_multiplier=max(volume_multiplier,float(m));
}

return volume_multiplier;
}
#line 330 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
void MixInCirrus(uvec3 ii, bool clears)
{
ivec3 idx=ivec3(ii)*ivec3(amortizationScale)+ivec3(amortizationOffset.xyz);
if(idx.x>=exclusionRange.x&&idx.y>=exclusionRange.y&&idx.x<exclusionRange.z&&idx.y<exclusionRange.w)return ;
idx.xy+=gridCentreTexel;
vec3 gridf=vec3(vec2(windowGrid.xy),0);
vec3 wind_texc=vec3(ivec3(typed_mod((idx.xy-gridCentreTexel.xy),windowGrid.xy)-windowGrid.xy/2,idx.z));
vec3 texc=mul(volumeToLayerMatrix,vec4(wind_texc,1.0)).xyz;
idx.xy+=ivec2(windowGrid.xy+windowGrid.xy/2);
idx.xy=typed_mod(idx.xy,ivec2(windowGrid.xy));
float fall_amount=saturate(1.0-texc.z);
texc.xy+=cirrusWindVector.xy*pow(fall_amount,2.0);
vec4 res=vec4(0.0,0.0,0.0,0.0);
for(int i=-2;i<3;i++)
{
vec3 tc=texc;
tc.z+=zPixel*i;
vec4 c1=textureLod(sampler3D(cloudDensity[1 + 6]),tc,0);
vec4 c2=textureLod(sampler3D(cloudDensity2[1 + 6]),tc,0);
res+=mix(c1,c2,cloud_interp).zyxw/5.0;
}

float zPixel1=1.0/float(windowGrid.z);
res.z=saturate((res.z-0.5)/diffusivity);
float layer_saturate=saturate(texc.z/zPixel1-0.5)*saturate((1.0-0.5*zPixel1-texc.z)/zPixel1);
float volume_multiplier=GetVolumeMultiplier(wind_texc);
res.z*=(layer_saturate*volume_multiplier);
vec4 current=vec4(0,0,0,0.0);
if(clears)current=vec4(res.xy,res.z*max_density_gm3,res.w);else
current=UnpackUintToVec4(imageLoad(packedOutputTexture3d,ivec3(idx).xyz));

{
float noise_factor=mix(baseNoiseFactor,1.0,saturate(texc.z));
noise_factor*=(0.05+rand3(vec3(idx)).x);
res.x=saturate(localNoiseStrength/MaxNoiseAmplitudeKm*noise_factor);
res.y=localCellNoiseStrength*noise_factor;
res.w=0;
res.xyw=mix(current.xyw,res.xyw,layer_saturate*res.z);
res.z=max(res.z*max_density_gm3,current.z);
imageStore(packedOutputTexture3d,ivec3(idx),vec4(PackVec4ToUint(res)));
;
}

}
layout(local_size_x=4, local_size_y=4, local_size_z=4) in;
void main()
{
uvec3 idx = gl_GlobalInvocationID;
#line 404 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
MixInCirrus(idx,false);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/cloud_update_CS_MixCirrusInit_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
layout(std140, binding = 8) uniform GpuCloudConstants
{
	mat4 transformMatrix;
	vec4 yRange;
	vec3 noiseScale;
	float sourceNoiseScaleKm;
	vec2 extinctions;
	float stepLength;
	float cloudBaseKm;
	uvec3 threadOffset;
	int octaves;
	float time;
	float persistence;
	float humidity;
	float numWorleyOctaves;
	float zPixel;
	int numVolumes;
	float baseLayer;
	float transition;
	float upperDensity;
	float diffusivity;
	float baseMixingRatio;
	float maskThickness;
	vec2 maskCentre;
	float maskRadius;
	float maskFeather;
	vec3 cloudScalesKm;
	float time_step;
	vec3 lightDir;
	float alpha;
	float invBeta;
	int wrap;
	float viscousCoefficient;
	float seaLevelTemperatureK;
	vec3 cloudOriginKm;
	float vorticityConfinement;
	float worleyNoiseStrength;
	float worleyNoiseScale;
	float noisePeriod;
	int numAffectors;
	float localNoiseStrength;
	float localCellNoiseStrength;
	float baseNoiseFactor;
	float max_density_gm3;
	ivec3 gridEdge;
	float edgeSharpness;
	ivec3 idxOffset;
	float cloudLayerThicknessKm;
};
#line 81 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
struct CloudVolume_densityspace
{
	mat4 transformMatrix;
	vec4 lower;
	vec4 upper;
	vec2 rake;
	flat int cloudVolumeType;
	float padcvds;
};


layout(std430, binding = 3) buffer cloudVolumes_ssbo
{
	CloudVolume_densityspace cloudVolumes[]; 
};
layout(rgba8, binding = 1) uniform image3D packedOutputTexture3d;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/noise.sl"
float rand3(vec3 co)
{
return fract(sin(dot(co.xyz,vec3(12.9898,78.233,42.1897)))*43758.5453);
}
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 UnpackUintToVec4(vec4 a)
{
return a;
}
#line 138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 PackVec4ToUint(vec4 a)
{
return a;
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
float GetVolumeMultiplier(vec3 wind_texc)
{
float volume_multiplier=initialVolumeMultiplier;
for(int j=0;j<10;j++)
{
if(j>=numVolumes)break;
CloudVolume_densityspace v=cloudVolumes[j];
vec3 texc=mul(v.transformMatrix,vec4(wind_texc,1.0)).xyz;
float rad=length(texc.xy);
float h=(texc.z);
vec2 boundary=mix(v.lower.xy,v.upper.xy,h);
float m=saturate((boundary.x-rad)/boundary.y);
volume_multiplier=max(volume_multiplier,float(m));
}

return volume_multiplier;
}
#line 330 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
void MixInCirrus(uvec3 ii, bool clears)
{
ivec3 idx=ivec3(ii)*ivec3(amortizationScale)+ivec3(amortizationOffset.xyz);
if(idx.x>=exclusionRange.x&&idx.y>=exclusionRange.y&&idx.x<exclusionRange.z&&idx.y<exclusionRange.w)return ;
idx.xy+=gridCentreTexel;
vec3 gridf=vec3(vec2(windowGrid.xy),0);
vec3 wind_texc=vec3(ivec3(typed_mod((idx.xy-gridCentreTexel.xy),windowGrid.xy)-windowGrid.xy/2,idx.z));
vec3 texc=mul(volumeToLayerMatrix,vec4(wind_texc,1.0)).xyz;
idx.xy+=ivec2(windowGrid.xy+windowGrid.xy/2);
idx.xy=typed_mod(idx.xy,ivec2(windowGrid.xy));
float fall_amount=saturate(1.0-texc.z);
texc.xy+=cirrusWindVector.xy*pow(fall_amount,2.0);
vec4 res=vec4(0.0,0.0,0.0,0.0);
for(int i=-2;i<3;i++)
{
vec3 tc=texc;
tc.z+=zPixel*i;
vec4 c1=textureLod(sampler3D(cloudDensity[1 + 6]),tc,0);
vec4 c2=textureLod(sampler3D(cloudDensity2[1 + 6]),tc,0);
res+=mix(c1,c2,cloud_interp).zyxw/5.0;
}

float zPixel1=1.0/float(windowGrid.z);
res.z=saturate((res.z-0.5)/diffusivity);
float layer_saturate=saturate(texc.z/zPixel1-0.5)*saturate((1.0-0.5*zPixel1-texc.z)/zPixel1);
float volume_multiplier=GetVolumeMultiplier(wind_texc);
res.z*=(layer_saturate*volume_multiplier);
vec4 current=vec4(0,0,0,0.0);
if(clears)current=vec4(res.xy,res.z*max_density_gm3,res.w);else
current=UnpackUintToVec4(imageLoad(packedOutputTexture3d,ivec3(idx).xyz));

{
float noise_factor=mix(baseNoiseFactor,1.0,saturate(texc.z));
noise_factor*=(0.05+rand3(vec3(idx)).x);
res.x=saturate(localNoiseStrength/MaxNoiseAmplitudeKm*noise_factor);
res.y=localCellNoiseStrength*noise_factor;
res.w=0;
res.xyw=mix(current.xyw,res.xyw,layer_saturate*res.z);
res.z=max(res.z*max_density_gm3,current.z);
imageStore(packedOutputTexture3d,ivec3(idx),vec4(PackVec4ToUint(res)));
;
}

}
layout(local_size_x=4, local_size_y=4, local_size_z=4) in;
void main()
{
uvec3 idx = gl_GlobalInvocationID;
#line 398 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
MixInCirrus(idx,true);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/cloud_update_CS_Mix_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
layout(std140, binding = 8) uniform GpuCloudConstants
{
	mat4 transformMatrix;
	vec4 yRange;
	vec3 noiseScale;
	float sourceNoiseScaleKm;
	vec2 extinctions;
	float stepLength;
	float cloudBaseKm;
	uvec3 threadOffset;
	int octaves;
	float time;
	float persistence;
	float humidity;
	float numWorleyOctaves;
	float zPixel;
	int numVolumes;
	float baseLayer;
	float transition;
	float upperDensity;
	float diffusivity;
	float baseMixingRatio;
	float maskThickness;
	vec2 maskCentre;
	float maskRadius;
	float maskFeather;
	vec3 cloudScalesKm;
	float time_step;
	vec3 lightDir;
	float alpha;
	float invBeta;
	int wrap;
	float viscousCoefficient;
	float seaLevelTemperatureK;
	vec3 cloudOriginKm;
	float vorticityConfinement;
	float worleyNoiseStrength;
	float worleyNoiseScale;
	float noisePeriod;
	int numAffectors;
	float localNoiseStrength;
	float localCellNoiseStrength;
	float baseNoiseFactor;
	float max_density_gm3;
	ivec3 gridEdge;
	float edgeSharpness;
	ivec3 idxOffset;
	float cloudLayerThicknessKm;
};
#line 81 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
struct CloudVolume_densityspace
{
	mat4 transformMatrix;
	vec4 lower;
	vec4 upper;
	vec2 rake;
	flat int cloudVolumeType;
	float padcvds;
};


layout(std430, binding = 3) buffer cloudVolumes_ssbo
{
	CloudVolume_densityspace cloudVolumes[]; 
};
layout(rgba8, binding = 1) uniform image3D packedOutputTexture3d;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/noise.sl"
float rand3(vec3 co)
{
return fract(sin(dot(co.xyz,vec3(12.9898,78.233,42.1897)))*43758.5453);
}
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 UnpackUintToVec4(vec4 a)
{
return a;
}
#line 138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 PackVec4ToUint(vec4 a)
{
return a;
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
float GetVolumeMultiplier(vec3 wind_texc)
{
float volume_multiplier=initialVolumeMultiplier;
for(int j=0;j<10;j++)
{
if(j>=numVolumes)break;
CloudVolume_densityspace v=cloudVolumes[j];
vec3 texc=mul(v.transformMatrix,vec4(wind_texc,1.0)).xyz;
float rad=length(texc.xy);
float h=(texc.z);
vec2 boundary=mix(v.lower.xy,v.upper.xy,h);
float m=saturate((boundary.x-rad)/boundary.y);
volume_multiplier=max(volume_multiplier,float(m));
}

return volume_multiplier;
}
#line 83 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
void MixInLayer(ivec3 p, bool clears)
{
ivec3 idx=p*ivec3(amortizationScale)+ivec3(amortizationOffset.xyz);
if(idx.x>=exclusionRange.x&&idx.y>=exclusionRange.y&&idx.x<exclusionRange.z&&idx.y<exclusionRange.w)return ;
idx.xy+=gridCentreTexel;
vec3 gridf=vec3(vec2(windowGrid.xy),0);
vec3 wind_texc=vec3(ivec3(typed_mod((idx.xy-gridCentreTexel.xy),windowGrid.xy)-windowGrid.xy/2,idx.z));
vec3 texc=mul(volumeToLayerMatrix,vec4(wind_texc,1.0)).xyz;
idx.xy+=ivec2(windowGrid.xy+windowGrid.xy/2);
idx.xy=typed_mod(idx.xy,ivec2(windowGrid.xy));
vec4 res=vec4(0.0,0.0,0.0,0.0);
float zPixel1=1.0/float(windowGrid.z);
float layer_saturate=saturate(texc.z/zPixel1+1.0)*saturate((1.0+zPixel1-texc.z)/zPixel1);
float volume_multiplier=GetVolumeMultiplier(wind_texc);
if((texc.z>=-2.0*zPixel1&&texc.z<=1.0+2.0*zPixel1))
{
for(int i=0;i<1;i++)
{
vec3 tc=texc;
tc.z+=zPixel1*i*.5;
vec4 c1=textureLod(sampler3D(cloudDensity[1 + 7]),tc,0);
vec4 c2=textureLod(sampler3D(cloudDensity2[1 + 7]),tc,0);
res+=mix(c1,c2,cloud_interp).zyxw/1.0;
}

res.z=saturate(2.0*volume_multiplier*layer_saturate*((res.z-0.15)/diffusivity+0.15));
res.w=edgeSharpness;
float noise_factor=mix(baseNoiseFactor,1.0,saturate(texc.z));
noise_factor*=(0.5+rand3(vec3(idx)).x);
res.x=saturate(localNoiseStrength/MaxNoiseAmplitudeKm*noise_factor);
res.y=saturate(localCellNoiseStrength*noise_factor);
}

vec4 current=res;
if(!clears)
{
current=UnpackUintToVec4(imageLoad(packedOutputTexture3d,ivec3(idx).xyz));
}

res.xyw=mix(current.xyw,res.xyw,layer_saturate*smoothstep(0.0,0.01,volume_multiplier));
res.z=max(res.z*max_density_gm3,current.z);

{
imageStore(packedOutputTexture3d,ivec3(idx),vec4(PackVec4ToUint(res)));
;
}

}
layout(local_size_x=4, local_size_y=4, local_size_z=4) in;
void main()
{
uvec3 idx = gl_GlobalInvocationID;
#line 392 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
MixInLayer(ivec3(idx),false);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/cloud_update_CS_MixCumulonimbus_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
layout(std140, binding = 8) uniform GpuCloudConstants
{
	mat4 transformMatrix;
	vec4 yRange;
	vec3 noiseScale;
	float sourceNoiseScaleKm;
	vec2 extinctions;
	float stepLength;
	float cloudBaseKm;
	uvec3 threadOffset;
	int octaves;
	float time;
	float persistence;
	float humidity;
	float numWorleyOctaves;
	float zPixel;
	int numVolumes;
	float baseLayer;
	float transition;
	float upperDensity;
	float diffusivity;
	float baseMixingRatio;
	float maskThickness;
	vec2 maskCentre;
	float maskRadius;
	float maskFeather;
	vec3 cloudScalesKm;
	float time_step;
	vec3 lightDir;
	float alpha;
	float invBeta;
	int wrap;
	float viscousCoefficient;
	float seaLevelTemperatureK;
	vec3 cloudOriginKm;
	float vorticityConfinement;
	float worleyNoiseStrength;
	float worleyNoiseScale;
	float noisePeriod;
	int numAffectors;
	float localNoiseStrength;
	float localCellNoiseStrength;
	float baseNoiseFactor;
	float max_density_gm3;
	ivec3 gridEdge;
	float edgeSharpness;
	ivec3 idxOffset;
	float cloudLayerThicknessKm;
};
#line 81 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
struct CloudVolume_densityspace
{
	mat4 transformMatrix;
	vec4 lower;
	vec4 upper;
	vec2 rake;
	flat int cloudVolumeType;
	float padcvds;
};
layout(std430, binding = 3) buffer cloudVolumes_ssbo
{
	CloudVolume_densityspace cloudVolumes[]; 
};
layout(rgba8, binding = 1) uniform image3D packedOutputTexture3d;
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 UnpackUintToVec4(vec4 a)
{
return a;
}
#line 138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 PackVec4ToUint(vec4 a)
{
return a;
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
float GetVolumeMultiplier(vec3 wind_texc)
{
float volume_multiplier=initialVolumeMultiplier;
for(int j=0;j<10;j++)
{
if(j>=numVolumes)break;
CloudVolume_densityspace v=cloudVolumes[j];
vec3 texc=mul(v.transformMatrix,vec4(wind_texc,1.0)).xyz;
float rad=length(texc.xy);
float h=(texc.z);
vec2 boundary=mix(v.lower.xy,v.upper.xy,h);
float m=saturate((boundary.x-rad)/boundary.y);
volume_multiplier=max(volume_multiplier,float(m));
}

return volume_multiplier;
}
#line 288 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
void MixInCumulonimbus(ivec3 p, bool clears)
{
ivec3 idx=p*ivec3(amortizationScale)+ivec3(amortizationOffset.xyz);
if(idx.x>=exclusionRange.x&&idx.y>=exclusionRange.y&&idx.x<exclusionRange.z&&idx.y<exclusionRange.w)return ;
idx.xy+=gridCentreTexel;
vec3 gridf=vec3(vec2(windowGrid.xy),0);
vec3 wind_texc=vec3(ivec3(typed_mod((idx.xy-gridCentreTexel.xy),windowGrid.xy)-windowGrid.xy/2,idx.z));
vec3 texc=mul(volumeToLayerMatrix,vec4(wind_texc,1.0)).xyz;
idx.xy+=ivec2(windowGrid.xy+windowGrid.xy/2);
idx.xy=typed_mod(idx.xy,ivec2(windowGrid.xy));
vec4 res=vec4(0.0,0.0,0.0,0.0);
float zPixel1=1.0/float(windowGrid.z);
float layer_saturate=saturate(texc.z/zPixel1+1.0)*saturate((1.0+zPixel1-texc.z)/zPixel1);
float volume_multiplier=GetVolumeMultiplier(wind_texc);
if((texc.z>=-2.0*zPixel1&&texc.z<=1.0+2.0*zPixel1))
{
res.x=0;
res.y=0;
res.z=volume_multiplier;
res.w=0;
}

vec4 current=res;
if(!clears)
{
current=UnpackUintToVec4(imageLoad(packedOutputTexture3d,ivec3(idx).xyz));
}

res.xyw=mix(current.xyw,res.xyw,layer_saturate*res.z);
res.z=max(res.z*max_density_gm3,current.z);

{
imageStore(packedOutputTexture3d,ivec3(idx),vec4(PackVec4ToUint(res)));
;
}

}
layout(local_size_x=4, local_size_y=4, local_size_z=4) in;
void main()
{
uvec3 idx = gl_GlobalInvocationID;
#line 440 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
MixInCumulonimbus(ivec3(idx),false);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/cloud_update_CS_MixCumulonimbusInit_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
layout(std140, binding = 8) uniform GpuCloudConstants
{
	mat4 transformMatrix;
	vec4 yRange;
	vec3 noiseScale;
	float sourceNoiseScaleKm;
	vec2 extinctions;
	float stepLength;
	float cloudBaseKm;
	uvec3 threadOffset;
	int octaves;
	float time;
	float persistence;
	float humidity;
	float numWorleyOctaves;
	float zPixel;
	int numVolumes;
	float baseLayer;
	float transition;
	float upperDensity;
	float diffusivity;
	float baseMixingRatio;
	float maskThickness;
	vec2 maskCentre;
	float maskRadius;
	float maskFeather;
	vec3 cloudScalesKm;
	float time_step;
	vec3 lightDir;
	float alpha;
	float invBeta;
	int wrap;
	float viscousCoefficient;
	float seaLevelTemperatureK;
	vec3 cloudOriginKm;
	float vorticityConfinement;
	float worleyNoiseStrength;
	float worleyNoiseScale;
	float noisePeriod;
	int numAffectors;
	float localNoiseStrength;
	float localCellNoiseStrength;
	float baseNoiseFactor;
	float max_density_gm3;
	ivec3 gridEdge;
	float edgeSharpness;
	ivec3 idxOffset;
	float cloudLayerThicknessKm;
};
#line 81 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
struct CloudVolume_densityspace
{
	mat4 transformMatrix;
	vec4 lower;
	vec4 upper;
	vec2 rake;
	flat int cloudVolumeType;
	float padcvds;
};
layout(std430, binding = 3) buffer cloudVolumes_ssbo
{
	CloudVolume_densityspace cloudVolumes[]; 
};
layout(rgba8, binding = 1) uniform image3D packedOutputTexture3d;
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 UnpackUintToVec4(vec4 a)
{
return a;
}
#line 138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 PackVec4ToUint(vec4 a)
{
return a;
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
float GetVolumeMultiplier(vec3 wind_texc)
{
float volume_multiplier=initialVolumeMultiplier;
for(int j=0;j<10;j++)
{
if(j>=numVolumes)break;
CloudVolume_densityspace v=cloudVolumes[j];
vec3 texc=mul(v.transformMatrix,vec4(wind_texc,1.0)).xyz;
float rad=length(texc.xy);
float h=(texc.z);
vec2 boundary=mix(v.lower.xy,v.upper.xy,h);
float m=saturate((boundary.x-rad)/boundary.y);
volume_multiplier=max(volume_multiplier,float(m));
}

return volume_multiplier;
}
#line 288 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
void MixInCumulonimbus(ivec3 p, bool clears)
{
ivec3 idx=p*ivec3(amortizationScale)+ivec3(amortizationOffset.xyz);
if(idx.x>=exclusionRange.x&&idx.y>=exclusionRange.y&&idx.x<exclusionRange.z&&idx.y<exclusionRange.w)return ;
idx.xy+=gridCentreTexel;
vec3 gridf=vec3(vec2(windowGrid.xy),0);
vec3 wind_texc=vec3(ivec3(typed_mod((idx.xy-gridCentreTexel.xy),windowGrid.xy)-windowGrid.xy/2,idx.z));
vec3 texc=mul(volumeToLayerMatrix,vec4(wind_texc,1.0)).xyz;
idx.xy+=ivec2(windowGrid.xy+windowGrid.xy/2);
idx.xy=typed_mod(idx.xy,ivec2(windowGrid.xy));
vec4 res=vec4(0.0,0.0,0.0,0.0);
float zPixel1=1.0/float(windowGrid.z);
float layer_saturate=saturate(texc.z/zPixel1+1.0)*saturate((1.0+zPixel1-texc.z)/zPixel1);
float volume_multiplier=GetVolumeMultiplier(wind_texc);
if((texc.z>=-2.0*zPixel1&&texc.z<=1.0+2.0*zPixel1))
{
res.x=0;
res.y=0;
res.z=volume_multiplier;
res.w=0;
}

vec4 current=res;
if(!clears)
{
current=UnpackUintToVec4(imageLoad(packedOutputTexture3d,ivec3(idx).xyz));
}

res.xyw=mix(current.xyw,res.xyw,layer_saturate*res.z);
res.z=max(res.z*max_density_gm3,current.z);

{
imageStore(packedOutputTexture3d,ivec3(idx),vec4(PackVec4ToUint(res)));
;
}

}
layout(local_size_x=4, local_size_y=4, local_size_z=4) in;
void main()
{
uvec3 idx = gl_GlobalInvocationID;
#line 434 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
MixInCumulonimbus(ivec3(idx),true);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/cloud_update_CS_MixCumulus_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
layout(std140, binding = 8) uniform GpuCloudConstants
{
	mat4 transformMatrix;
	vec4 yRange;
	vec3 noiseScale;
	float sourceNoiseScaleKm;
	vec2 extinctions;
	float stepLength;
	float cloudBaseKm;
	uvec3 threadOffset;
	int octaves;
	float time;
	float persistence;
	float humidity;
	float numWorleyOctaves;
	float zPixel;
	int numVolumes;
	float baseLayer;
	float transition;
	float upperDensity;
	float diffusivity;
	float baseMixingRatio;
	float maskThickness;
	vec2 maskCentre;
	float maskRadius;
	float maskFeather;
	vec3 cloudScalesKm;
	float time_step;
	vec3 lightDir;
	float alpha;
	float invBeta;
	int wrap;
	float viscousCoefficient;
	float seaLevelTemperatureK;
	vec3 cloudOriginKm;
	float vorticityConfinement;
	float worleyNoiseStrength;
	float worleyNoiseScale;
	float noisePeriod;
	int numAffectors;
	float localNoiseStrength;
	float localCellNoiseStrength;
	float baseNoiseFactor;
	float max_density_gm3;
	ivec3 gridEdge;
	float edgeSharpness;
	ivec3 idxOffset;
	float cloudLayerThicknessKm;
};
#line 81 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
struct CloudVolume_densityspace
{
	mat4 transformMatrix;
	vec4 lower;
	vec4 upper;
	vec2 rake;
	flat int cloudVolumeType;
	float padcvds;
};


layout(std430, binding = 3) buffer cloudVolumes_ssbo
{
	CloudVolume_densityspace cloudVolumes[]; 
};
layout(rgba8, binding = 1) uniform image3D packedOutputTexture3d;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/noise.sl"
float rand3(vec3 co)
{
return fract(sin(dot(co.xyz,vec3(12.9898,78.233,42.1897)))*43758.5453);
}
#line 42 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/noise.sl"
vec3 SphericalRandom(vec3 co)
{
float r=1.f-pow(rand3(co),4.0);
float az=rand3(43.1138*co)*2*3.1415926536;
float sine_el=rand3(17.981*co)*2.0-1.0;
float el=asin(sine_el);
float cos_el=cos(el);
vec3 v;
v.x=r*sin(az)*cos_el;
v.y=r*cos(az)*cos_el;
v.z=r*sine_el;
return v;
}
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 UnpackUintToVec4(vec4 a)
{
return a;
}
#line 138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 PackVec4ToUint(vec4 a)
{
return a;
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
float GetVolumeMultiplier(vec3 wind_texc)
{
float volume_multiplier=initialVolumeMultiplier;
for(int j=0;j<10;j++)
{
if(j>=numVolumes)break;
CloudVolume_densityspace v=cloudVolumes[j];
vec3 texc=mul(v.transformMatrix,vec4(wind_texc,1.0)).xyz;
float rad=length(texc.xy);
float h=(texc.z);
vec2 boundary=mix(v.lower.xy,v.upper.xy,h);
float m=saturate((boundary.x-rad)/boundary.y);
volume_multiplier=max(volume_multiplier,float(m));
}

return volume_multiplier;
}
#line 144 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
float WorleyShapeFn(vec3 texc, int grid, int seed, float zmax)
{
vec3 pos=float(grid)*texc;
vec3 fractional,intpart;
fractional=modf(pos,intpart);
ivec3 ip=ivec3(intpart);
vec3 loc=fractional-vec3(0.5,0.5,0.5);
float g=float(grid);
float n=g;
for(int i=-1;i<2;++i)
{
for(int j=-1;j<2;++j)
{
for(int k=-1;k<2;++k)
{
ivec3 I=ivec3(i,j,k);
vec3 c=vec3(I);
ivec3 u=(ip+I);
ivec3 v=ivec3((u+ivec3(grid,grid,grid)));
vec3 random=SphericalRandom(vec3(v)*float(seed));
c+=.5*random.xyz;
vec3 diff=loc-c;
float dist=length(diff);
float top=(ip.z+c.z+1.0)/g;
float bot=(ip.z+c.z-1.0)/g;
if(top<zmax)n=min(n,dist);
}

}

}

float p=saturate(1.0-n/1.0);
return p;
}
#line 180 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
void MixInCumulus(ivec3 p, bool clears)
{
ivec3 idx=p*ivec3(amortizationScale)+ivec3(amortizationOffset.xyz);
if(idx.x>=exclusionRange.x&&idx.y>=exclusionRange.y&&idx.x<exclusionRange.z&&idx.y<exclusionRange.w)return ;
idx.xy+=gridCentreTexel;
vec3 gridf=vec3(vec2(windowGrid.xy),0);
vec3 wind_texc=vec3(ivec3(typed_mod((idx.xy-gridCentreTexel.xy),windowGrid.xy)-windowGrid.xy/2,idx.z));
vec3 texc=mul(volumeToLayerMatrix,vec4(wind_texc,1.0)).xyz;
idx.xy+=ivec2(windowGrid.xy+windowGrid.xy/2);
idx.xy=typed_mod(idx.xy,ivec2(windowGrid.xy));
vec4 res=vec4(0.0,0.0,0.0,0.0);
float zPixel1=1.0/float(windowGrid.z);
float layer_saturate=1.0;
float volume_multiplier=GetVolumeMultiplier(wind_texc);
if((texc.z>=-2.0*zPixel1&&texc.z<=1.0+2.0*zPixel1))
{
vec3 cell_texc=vec3(texc.xy,texc.z*scale.x/scale.z);
float cellnoise=(WorleyShapeFn(cell_texc,25,15,25.0)-.8);
vec4 c1=textureLod(sampler3D(cloudDensity[1 + 7]),texc,0);
vec4 c2=textureLod(sampler3D(cloudDensity2[1 + 7]),texc,0);
c1.z=1.0;
c2.z=1.0;
res+=mix(c1,c2,cloud_interp).zyxw/1.0;
res.z=smoothstep(0.5-diffusivity,0.5+diffusivity,res.z*volume_multiplier);
res.w=edgeSharpness;
float noise_factor=mix(baseNoiseFactor,1.0,saturate(texc.z));
noise_factor*=(0.5+rand3(vec3(idx)).x);
res.x=saturate(localNoiseStrength/MaxNoiseAmplitudeKm*noise_factor);
res.y=saturate(localCellNoiseStrength*noise_factor);
}

vec4 current=res;
if(!clears)
{
current=UnpackUintToVec4(imageLoad(packedOutputTexture3d,ivec3(idx).xyz));
}

res.xyw=mix(current.xyw,res.xyw,layer_saturate*res.z);
res.z=max(res.z*max_density_gm3,current.z);

{
imageStore(packedOutputTexture3d,ivec3(idx),vec4(PackVec4ToUint(res)));
;
}

}
layout(local_size_x=4, local_size_y=4, local_size_z=4) in;
void main()
{
uvec3 idx = gl_GlobalInvocationID;
#line 416 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
MixInCumulus(ivec3(idx),false);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/cloud_update_CS_MixCumulusInit_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
layout(std140, binding = 8) uniform GpuCloudConstants
{
	mat4 transformMatrix;
	vec4 yRange;
	vec3 noiseScale;
	float sourceNoiseScaleKm;
	vec2 extinctions;
	float stepLength;
	float cloudBaseKm;
	uvec3 threadOffset;
	int octaves;
	float time;
	float persistence;
	float humidity;
	float numWorleyOctaves;
	float zPixel;
	int numVolumes;
	float baseLayer;
	float transition;
	float upperDensity;
	float diffusivity;
	float baseMixingRatio;
	float maskThickness;
	vec2 maskCentre;
	float maskRadius;
	float maskFeather;
	vec3 cloudScalesKm;
	float time_step;
	vec3 lightDir;
	float alpha;
	float invBeta;
	int wrap;
	float viscousCoefficient;
	float seaLevelTemperatureK;
	vec3 cloudOriginKm;
	float vorticityConfinement;
	float worleyNoiseStrength;
	float worleyNoiseScale;
	float noisePeriod;
	int numAffectors;
	float localNoiseStrength;
	float localCellNoiseStrength;
	float baseNoiseFactor;
	float max_density_gm3;
	ivec3 gridEdge;
	float edgeSharpness;
	ivec3 idxOffset;
	float cloudLayerThicknessKm;
};
#line 81 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
struct CloudVolume_densityspace
{
	mat4 transformMatrix;
	vec4 lower;
	vec4 upper;
	vec2 rake;
	flat int cloudVolumeType;
	float padcvds;
};


layout(std430, binding = 3) buffer cloudVolumes_ssbo
{
	CloudVolume_densityspace cloudVolumes[]; 
};
layout(rgba8, binding = 1) uniform image3D packedOutputTexture3d;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/noise.sl"
float rand3(vec3 co)
{
return fract(sin(dot(co.xyz,vec3(12.9898,78.233,42.1897)))*43758.5453);
}
#line 42 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/noise.sl"
vec3 SphericalRandom(vec3 co)
{
float r=1.f-pow(rand3(co),4.0);
float az=rand3(43.1138*co)*2*3.1415926536;
float sine_el=rand3(17.981*co)*2.0-1.0;
float el=asin(sine_el);
float cos_el=cos(el);
vec3 v;
v.x=r*sin(az)*cos_el;
v.y=r*cos(az)*cos_el;
v.z=r*sine_el;
return v;
}
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 UnpackUintToVec4(vec4 a)
{
return a;
}
#line 138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 PackVec4ToUint(vec4 a)
{
return a;
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
float GetVolumeMultiplier(vec3 wind_texc)
{
float volume_multiplier=initialVolumeMultiplier;
for(int j=0;j<10;j++)
{
if(j>=numVolumes)break;
CloudVolume_densityspace v=cloudVolumes[j];
vec3 texc=mul(v.transformMatrix,vec4(wind_texc,1.0)).xyz;
float rad=length(texc.xy);
float h=(texc.z);
vec2 boundary=mix(v.lower.xy,v.upper.xy,h);
float m=saturate((boundary.x-rad)/boundary.y);
volume_multiplier=max(volume_multiplier,float(m));
}

return volume_multiplier;
}
#line 144 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
float WorleyShapeFn(vec3 texc, int grid, int seed, float zmax)
{
vec3 pos=float(grid)*texc;
vec3 fractional,intpart;
fractional=modf(pos,intpart);
ivec3 ip=ivec3(intpart);
vec3 loc=fractional-vec3(0.5,0.5,0.5);
float g=float(grid);
float n=g;
for(int i=-1;i<2;++i)
{
for(int j=-1;j<2;++j)
{
for(int k=-1;k<2;++k)
{
ivec3 I=ivec3(i,j,k);
vec3 c=vec3(I);
ivec3 u=(ip+I);
ivec3 v=ivec3((u+ivec3(grid,grid,grid)));
vec3 random=SphericalRandom(vec3(v)*float(seed));
c+=.5*random.xyz;
vec3 diff=loc-c;
float dist=length(diff);
float top=(ip.z+c.z+1.0)/g;
float bot=(ip.z+c.z-1.0)/g;
if(top<zmax)n=min(n,dist);
}

}

}

float p=saturate(1.0-n/1.0);
return p;
}
#line 180 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
void MixInCumulus(ivec3 p, bool clears)
{
ivec3 idx=p*ivec3(amortizationScale)+ivec3(amortizationOffset.xyz);
if(idx.x>=exclusionRange.x&&idx.y>=exclusionRange.y&&idx.x<exclusionRange.z&&idx.y<exclusionRange.w)return ;
idx.xy+=gridCentreTexel;
vec3 gridf=vec3(vec2(windowGrid.xy),0);
vec3 wind_texc=vec3(ivec3(typed_mod((idx.xy-gridCentreTexel.xy),windowGrid.xy)-windowGrid.xy/2,idx.z));
vec3 texc=mul(volumeToLayerMatrix,vec4(wind_texc,1.0)).xyz;
idx.xy+=ivec2(windowGrid.xy+windowGrid.xy/2);
idx.xy=typed_mod(idx.xy,ivec2(windowGrid.xy));
vec4 res=vec4(0.0,0.0,0.0,0.0);
float zPixel1=1.0/float(windowGrid.z);
float layer_saturate=1.0;
float volume_multiplier=GetVolumeMultiplier(wind_texc);
if((texc.z>=-2.0*zPixel1&&texc.z<=1.0+2.0*zPixel1))
{
vec3 cell_texc=vec3(texc.xy,texc.z*scale.x/scale.z);
float cellnoise=(WorleyShapeFn(cell_texc,25,15,25.0)-.8);
vec4 c1=textureLod(sampler3D(cloudDensity[1 + 7]),texc,0);
vec4 c2=textureLod(sampler3D(cloudDensity2[1 + 7]),texc,0);
c1.z=1.0;
c2.z=1.0;
res+=mix(c1,c2,cloud_interp).zyxw/1.0;
res.z=smoothstep(0.5-diffusivity,0.5+diffusivity,res.z*volume_multiplier);
res.w=edgeSharpness;
float noise_factor=mix(baseNoiseFactor,1.0,saturate(texc.z));
noise_factor*=(0.5+rand3(vec3(idx)).x);
res.x=saturate(localNoiseStrength/MaxNoiseAmplitudeKm*noise_factor);
res.y=saturate(localCellNoiseStrength*noise_factor);
}

vec4 current=res;
if(!clears)
{
current=UnpackUintToVec4(imageLoad(packedOutputTexture3d,ivec3(idx).xyz));
}

res.xyw=mix(current.xyw,res.xyw,layer_saturate*res.z);
res.z=max(res.z*max_density_gm3,current.z);

{
imageStore(packedOutputTexture3d,ivec3(idx),vec4(PackVec4ToUint(res)));
;
}

}
layout(local_size_x=4, local_size_y=4, local_size_z=4) in;
void main()
{
uvec3 idx = gl_GlobalInvocationID;
#line 410 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
MixInCumulus(ivec3(idx),true);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/cloud_update_CS_MixInit_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
layout(std140, binding = 8) uniform GpuCloudConstants
{
	mat4 transformMatrix;
	vec4 yRange;
	vec3 noiseScale;
	float sourceNoiseScaleKm;
	vec2 extinctions;
	float stepLength;
	float cloudBaseKm;
	uvec3 threadOffset;
	int octaves;
	float time;
	float persistence;
	float humidity;
	float numWorleyOctaves;
	float zPixel;
	int numVolumes;
	float baseLayer;
	float transition;
	float upperDensity;
	float diffusivity;
	float baseMixingRatio;
	float maskThickness;
	vec2 maskCentre;
	float maskRadius;
	float maskFeather;
	vec3 cloudScalesKm;
	float time_step;
	vec3 lightDir;
	float alpha;
	float invBeta;
	int wrap;
	float viscousCoefficient;
	float seaLevelTemperatureK;
	vec3 cloudOriginKm;
	float vorticityConfinement;
	float worleyNoiseStrength;
	float worleyNoiseScale;
	float noisePeriod;
	int numAffectors;
	float localNoiseStrength;
	float localCellNoiseStrength;
	float baseNoiseFactor;
	float max_density_gm3;
	ivec3 gridEdge;
	float edgeSharpness;
	ivec3 idxOffset;
	float cloudLayerThicknessKm;
};
#line 81 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
struct CloudVolume_densityspace
{
	mat4 transformMatrix;
	vec4 lower;
	vec4 upper;
	vec2 rake;
	flat int cloudVolumeType;
	float padcvds;
};


layout(std430, binding = 3) buffer cloudVolumes_ssbo
{
	CloudVolume_densityspace cloudVolumes[]; 
};
layout(rgba8, binding = 1) uniform image3D packedOutputTexture3d;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t cloudDensity[24];
	uint64_t cloudDensity2[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 20 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
#line 21 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
#line 26 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/noise.sl"
float rand3(vec3 co)
{
return fract(sin(dot(co.xyz,vec3(12.9898,78.233,42.1897)))*43758.5453);
}
#line 134 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 UnpackUintToVec4(vec4 a)
{
return a;
}
#line 138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 PackVec4ToUint(vec4 a)
{
return a;
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
float GetVolumeMultiplier(vec3 wind_texc)
{
float volume_multiplier=initialVolumeMultiplier;
for(int j=0;j<10;j++)
{
if(j>=numVolumes)break;
CloudVolume_densityspace v=cloudVolumes[j];
vec3 texc=mul(v.transformMatrix,vec4(wind_texc,1.0)).xyz;
float rad=length(texc.xy);
float h=(texc.z);
vec2 boundary=mix(v.lower.xy,v.upper.xy,h);
float m=saturate((boundary.x-rad)/boundary.y);
volume_multiplier=max(volume_multiplier,float(m));
}

return volume_multiplier;
}
#line 83 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
void MixInLayer(ivec3 p, bool clears)
{
ivec3 idx=p*ivec3(amortizationScale)+ivec3(amortizationOffset.xyz);
if(idx.x>=exclusionRange.x&&idx.y>=exclusionRange.y&&idx.x<exclusionRange.z&&idx.y<exclusionRange.w)return ;
idx.xy+=gridCentreTexel;
vec3 gridf=vec3(vec2(windowGrid.xy),0);
vec3 wind_texc=vec3(ivec3(typed_mod((idx.xy-gridCentreTexel.xy),windowGrid.xy)-windowGrid.xy/2,idx.z));
vec3 texc=mul(volumeToLayerMatrix,vec4(wind_texc,1.0)).xyz;
idx.xy+=ivec2(windowGrid.xy+windowGrid.xy/2);
idx.xy=typed_mod(idx.xy,ivec2(windowGrid.xy));
vec4 res=vec4(0.0,0.0,0.0,0.0);
float zPixel1=1.0/float(windowGrid.z);
float layer_saturate=saturate(texc.z/zPixel1+1.0)*saturate((1.0+zPixel1-texc.z)/zPixel1);
float volume_multiplier=GetVolumeMultiplier(wind_texc);
if((texc.z>=-2.0*zPixel1&&texc.z<=1.0+2.0*zPixel1))
{
for(int i=0;i<1;i++)
{
vec3 tc=texc;
tc.z+=zPixel1*i*.5;
vec4 c1=textureLod(sampler3D(cloudDensity[1 + 7]),tc,0);
vec4 c2=textureLod(sampler3D(cloudDensity2[1 + 7]),tc,0);
res+=mix(c1,c2,cloud_interp).zyxw/1.0;
}

res.z=saturate(2.0*volume_multiplier*layer_saturate*((res.z-0.15)/diffusivity+0.15));
res.w=edgeSharpness;
float noise_factor=mix(baseNoiseFactor,1.0,saturate(texc.z));
noise_factor*=(0.5+rand3(vec3(idx)).x);
res.x=saturate(localNoiseStrength/MaxNoiseAmplitudeKm*noise_factor);
res.y=saturate(localCellNoiseStrength*noise_factor);
}

vec4 current=res;
if(!clears)
{
current=UnpackUintToVec4(imageLoad(packedOutputTexture3d,ivec3(idx).xyz));
}

res.xyw=mix(current.xyw,res.xyw,layer_saturate*smoothstep(0.0,0.01,volume_multiplier));
res.z=max(res.z*max_density_gm3,current.z);

{
imageStore(packedOutputTexture3d,ivec3(idx),vec4(PackVec4ToUint(res)));
;
}

}
layout(local_size_x=4, local_size_y=4, local_size_z=4) in;
void main()
{
uvec3 idx = gl_GlobalInvocationID;
#line 386 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
MixInLayer(ivec3(idx),true);
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

#extension GL_ARB_shader_storage_buffer_object : enable
#extension GL_ARB_compute_shader : enable
#extension GL_ARB_shader_image_load_store : enable
#line 9 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/sfx_intermediate/cloud_update_CS_WindowLighting_c.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
#line 87 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 13) uniform CloudPerViewConstants
{
	uvec4 targetRange[6];
	mat4 shadowMatrix;
	mat4 worldToScatteringVolumeMatrix;
	mat4 volumeToLayerMatrix;
	vec4 depthToLinFadeDistParams;
	vec3 scaleOfGridCoordsKm;
	int halfClipSize;
	vec3 gridOriginPosKm;
	int cubemapViewIndex;
	vec3 viewPosKm;
	float sampleHeight;
	float shadowRangeKm;
	int shadowTextureSize;
	int raytraceSteps;
	int cubemapTargetIndex;
	ivec3 amortizationOffset;
	float exposure;
	uvec2 targetTextureSize;
	uvec2 edge;
	uvec3 amortizationScale;
	float maxCloudDistanceKm;
	uvec4 cubemapFaceIndex[6];
	vec3 scale;
	float cloud_interp;
	vec3 offset;
	float azimuth;
	vec3 mapScale;
	int initialSteps;
	vec3 mapOffset;
	uint stepPos;
	ivec2 gridBackCornerTexel;
	ivec2 gridCentreTexel;
	ivec4 exclusionRange;
	vec2 cirrusWindVector;
	int thicknessSteps;
	float initialVolumeMultiplier;
	vec3 cloudTintColour;
	float windowScaleKm_X;
	uvec3 windowGrid;
	int firstInput;
};
#line 174 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/cloud_constants.sl"
layout(std140, binding = 9) uniform CloudConstants
{
	vec3 inverseScalesKm;
	float rainbowIntensity;
	vec3 VolumeScaleKm;
	uint rainbowDirectionOverride;
	vec3 ambientColour;
	int stepCycle;
	vec3 fractalScale;
	float cloudEccentricity;
	vec4 lightResponse;
	vec3 directionToSun;
	float earthshadowMultiplier;
	vec3 cornerPosKm;
	float hazeEccentricity;
	vec3 sunlightColour1;
	int maxMip;
	vec3 sunlightColour2;
	float fadeAltitudeRangeKm;
	vec2 XXXXXXXXXXXXX;
	vec2 rainTangent;
	vec3 mieRayleighRatio;
	float alphaSharpness;
	float rainToSnow;
	float maxFadeDistanceKm;
	float extinctionPerKm;
	float minSunlightAltitudeKm;
	vec3 crossSectionOffset;
	uint precipitationLayerCount;
	vec3 noise3DTexcoordScale;
	float rainEffect;
	vec3 cloudIrRadiance1;
	float yz;
	vec3 cloudIrRadiance2;
	float MaxNoiseAmplitudeKm;
	vec3 directionToMoon;
	float baseNoiseFactorDeprecated;
	vec3 noise3DTexcoordOffset;
	float dropletRadius;
	vec3 worleyTexcoordScale;
	float precipitationThreshold;
	vec3 rainCentreKm;
	float rainRadiusKm;
	vec3 rainNoiseInvScale;
	float rainVerticalTexcoord;
	vec3 worleyOffsetKm;
	float precipitation;
	vec3 noise3DTexcoordOffset2;
	float rainbowDepthPoint;
	vec3 noise3DTexcoordScale2;
	uint allowOccludedRainbows;
	uvec3 precipitationGrid;
	uint allowLunarRainbows;
	vec3 angleRadiansAltitudeKmRange;
	uint cloudRandomSeed;
	float rainEdgeKm;
	float cc_pad1;
	vec2 cc_pad2;
	vec3 windOffsetKm;
	float wo_pad1;
};
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SL/gpu_cloud_constants.sl"
layout(std140, binding = 8) uniform GpuCloudConstants
{
	mat4 transformMatrix;
	vec4 yRange;
	vec3 noiseScale;
	float sourceNoiseScaleKm;
	vec2 extinctions;
	float stepLength;
	float cloudBaseKm;
	uvec3 threadOffset;
	int octaves;
	float time;
	float persistence;
	float humidity;
	float numWorleyOctaves;
	float zPixel;
	int numVolumes;
	float baseLayer;
	float transition;
	float upperDensity;
	float diffusivity;
	float baseMixingRatio;
	float maskThickness;
	vec2 maskCentre;
	float maskRadius;
	float maskFeather;
	vec3 cloudScalesKm;
	float time_step;
	vec3 lightDir;
	float alpha;
	float invBeta;
	int wrap;
	float viscousCoefficient;
	float seaLevelTemperatureK;
	vec3 cloudOriginKm;
	float vorticityConfinement;
	float worleyNoiseStrength;
	float worleyNoiseScale;
	float noisePeriod;
	int numAffectors;
	float localNoiseStrength;
	float localCellNoiseStrength;
	float baseNoiseFactor;
	float max_density_gm3;
	ivec3 gridEdge;
	float edgeSharpness;
	ivec3 idxOffset;
	float cloudLayerThicknessKm;
};

layout(rgba32f, binding = 2) uniform image3D vec4OutputTexture3d;
layout(std140, binding = 0) uniform _TextureHandles_
{
	uint64_t cloudDensity[24];
};
#line 15 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
#line 16 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
#line 17 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
#line 39 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
int typed_mod(int a, int b)
{
return int(mod(a,b));
}
#line 43 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec2 typed_mod(ivec2 a, ivec2 b)
{
return ivec2(mod(a,b));
}
#line 47 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec3 typed_mod(ivec3 a, ivec3 b)
{
return ivec3(mod(a,b));
}
#line 51 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
ivec4 typed_mod(ivec4 a, ivec4 b)
{
return ivec4(mod(a,b));
}
#line 55 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uint typed_mod(uint a, uint b)
{
return uint(mod(a,b));
}
#line 59 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec2 typed_mod(uvec2 a, uvec2 b)
{
return uvec2(mod(a,b));
}
#line 63 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec3 typed_mod(uvec3 a, uvec3 b)
{
return uvec3(mod(a,b));
}
#line 67 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/OpenGL/GLSL/shader_platform.sl"
uvec4 typed_mod(uvec4 a, uvec4 b)
{
return uvec4(mod(a,b));
}
#line 18 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/noise.sl"
float rand3(vec3 co)
{
return fract(sin(dot(co.xyz,vec3(12.9898,78.233,42.1897)))*43758.5453);
}
#line 138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/SL/colour_packing.sl"
vec4 PackVec4ToUint(vec4 a)
{
return a;
}
#line 529 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
float ThicknessKmInDirection(vec3 texc, vec3 inverseScalesKm, vec3 dir, float rand, float max_dist_km)
{
float thicknessKm=0.0;
float stepLengthKm=1.0/inverseScalesKm.x/float(windowGrid.x);
vec3 tx=texc;
vec3 dir_texc=dir*inverseScalesKm;
float s=max_dist_km/80.0;
int i=0;
for(i=0;i<12;i++)
{
if(i>=thicknessSteps)break;
tx+=dir_texc*s;
vec4 lookup=textureLod(sampler3D(cloudDensity[1 + 7]),vec3(tx),0);
float density=lookup.z*step(tx.z,1.0);
density=saturate(0.3+(1.0+1.0*lookup.w*2.0)*(density-0.4));
thicknessKm+=density*s;
s*=1.44;
}

#line 551 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"

return thicknessKm;
}
layout(local_size_x=4, local_size_y=4, local_size_z=4) in;
void main()
{
uvec3 p = gl_GlobalInvocationID;
#line 556 "D:/Jarvis/workspace/Simul/4.3/Simul/Shaders/SFX/cloud_update.sfx"
ivec3 idx=ivec3(p)*ivec3(amortizationScale)+ivec3(amortizationOffset.xyz);
if(idx.x>=exclusionRange.x&&idx.y>=exclusionRange.y&&idx.x<exclusionRange.z&&idx.y<exclusionRange.w)return ;
idx.xy+=gridCentreTexel;
vec3 texc=vec3(idx-ivec3(gridCentreTexel+windowGrid.xy/2,0))*scale+offset;
idx.xy+=ivec2(windowGrid.xy+windowGrid.xy/2);
idx.xy=typed_mod(idx.xy,ivec2(windowGrid.xy));
if(idx.x<0||idx.y<0||idx.x>=windowGrid.x||idx.y>=windowGrid.y)return ;
vec3 texc_o=vec3(idx)/vec3(windowGrid);
vec3 wpos=texc/inverseScalesKm;
float thicknessKm=0.0;
int i=0;
float stepLengthKm=1.0/inverseScalesKm.x/float(windowGrid.x);
float s=0.5*stepLengthKm;
float max_h_km=1.0/inverseScalesKm.z;
vec4 current=vec4(0,0,0,0);

{
current=imageLoad(vec4OutputTexture3d,ivec3(idx).xyz);
}

float randm=rand3(vec3(idx+uvec3(stepCycle,stepCycle,stepCycle)));
float z_from_top_km=max_h_km*float(1+windowGrid.z-idx.z)/float(windowGrid.z);
float extinction_distance_km=max(5.0,min(5.5*max_h_km,z_from_top_km/(abs(lightDir.z)+0.0001)));
thicknessKm=ThicknessKmInDirection(texc_o,inverseScalesKm,lightDir,randm,extinction_distance_km);
float nearest=10000.0;
vec3 nearest_dir=vec3(0,0,0);
float total=0.0;
vec4 illum;
float t=saturate(thicknessKm/extinction_distance_km);
thicknessKm=t*extinction_distance_km;
illum.x=max(.1,exp(-extinctionPerKm*thicknessKm/40.0));
illum.y=max(.1,exp(-extinctionPerKm*thicknessKm));
illum.z=texelFetch(sampler3D(cloudDensity[0]),ivec3(idx).xyz,0).x;
illum.w=texelFetch(sampler3D(cloudDensity[0]),ivec3(idx).xyz,0).y;
const float v=127.0/255.0;
float d=1.0-texelFetch(sampler3D(cloudDensity[0]),ivec3(idx).xyz,0).z;
imageStore(vec4OutputTexture3d,ivec3(idx),vec4(PackVec4ToUint(illum.xyzw)));
;
}