#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/solid_PS_Solid.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
layout(std140, binding = 12) uniform SceneConstants
{
	vec4 depthToLinFadeDistParams;
	vec4 fullResToLowResTransformXYWH;
	int lightCount;
	int reverseDepth;
	float max_roughness_mip;
	int padxxx;
};
layout(std140, binding = 13) uniform SolidConstants
{
	vec4 diffuseOutputScalar;
	vec2 diffuseTexCoordsScalar_R;
	vec2 diffuseTexCoordsScalar_G;
	vec2 diffuseTexCoordsScalar_B;
	vec2 diffuseTexCoordsScalar_A;
	vec4 normalOutputScalar;
	vec2 normalTexCoordsScalar_R;
	vec2 normalTexCoordsScalar_G;
	vec2 normalTexCoordsScalar_B;
	vec2 normalTexCoordsScalar_A;
	vec4 combinedOutputScalarRoughMetalOcclusion;
	vec2 combinedTexCoordsScalar_R;
	vec2 combinedTexCoordsScalar_G;
	vec2 combinedTexCoordsScalar_B;
	vec2 combinedTexCoordsScalar_A;
	vec4 emissiveOutputScalar;
	vec2 emissiveTexCoordsScalar_R;
	vec2 emissiveTexCoordsScalar_G;
	vec2 emissiveTexCoordsScalar_B;
	vec2 emissiveTexCoordsScalar_A;
	vec3 u_SpecularColour;
	float _pad;
	float u_DiffuseTexCoordIndex;
	float u_NormalTexCoordIndex;
	float u_CombinedTexCoordIndex;
	float u_EmissiveTexCoordIndex;
};
struct Light
{
	mat4 lightSpaceTransform;
	vec4 colour;
	vec3 position;
	float power;
	vec3 direction;
	float is_point;
	float is_spot;
	float radius;
	vec2 pad_light1;
};
layout(std140, binding = 1) uniform CameraConstants
{
	mat4 worldViewProj;
	mat4 world;
	mat4 invWorldViewProj;
	mat4 modelView;
	mat4 view;
	mat4 proj;
	mat4 viewProj;
	vec3 viewPosition;
};








layout(std430, binding = 12) buffer lights_ssbo
{
	Light lights[]; 
};
struct vertexOutput
{
	vec4 hPosition;
	vec2 texCoords0;
	vec2 texCoords1;
	vec3 normal;
	vec3 tangent;
	vec3 wpos;
	vec3 view;
	vec4 clip_pos;
};
struct SurfaceState
{
	vec3 F;
	vec3 kS;
	vec3 kD;
	vec3 refl;
	float n_v;
};
struct SurfaceProperties
{
	vec3 albedo;
	vec3 normal;
	vec3 emission;
	vec3 position;
	float roughness;
	float roughness2;
	float metallic;
	float ao;
	float specular;
	float gloss;
	float alpha;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t diffuseTexture[24];
	uint64_t normalTexture[24];
	uint64_t metalTexture[24];
	uint64_t ambientOcclusionTexture[24];
	uint64_t emissiveTexture[24];
	uint64_t diffuseCubemap[24];
	uint64_t specularCubemap[24];
	uint64_t screenspaceShadowTexture[24];
};
//#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
//#line 23 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
//#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
//#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
//#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
//#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
//#line 29 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
//#line 31 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
//#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
//#line 33 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
//#line 983 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
float GetMetallic(vec4 combinedLookup)
{
return combinedLookup.g;
}
//#line 988 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
float GetAO(vec4 combinedLookup)
{
return combinedLookup.b;
}
//#line 1062 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec3 EnvBRDFApprox(vec3 specularColour, float roughness, float n_v)
{
const vec4 c0=vec4(-1,-0.0275,-0.572,0.022);
const vec4 c1=vec4(1,0.0425,1.04,-0.04);
vec4 r=roughness*c0+c1;
float a004=min(r.x*r.x,exp2(-9.28*n_v))*r.x+r.y;
vec2 AB=vec2(-1.04,1.04)*a004+r.zw;
return specularColour*AB.x+AB.y;
}
//#line 1072 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
float VisibilityTerm(float m2, float n_v, float n_l)
{
float visV=n_l*sqrt(n_v*(n_v-n_v*m2)+m2);
float visL=n_v*sqrt(n_l*(n_l-n_l*m2)+m2);
return saturate(0.5/max(visV+visL,0.00001));
}
//#line 1079 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
float DistributionTerm(float m2, float n_h)
{
float d=(n_h*m2-n_h)*n_h+1.0;
return n_h;
}
//#line 1091 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec3 FresnelTerm(vec3 specularColour, float v_h)
{
vec3 fresnel=specularColour+(vec3(1.0,1.0,1.0)-specularColour)*pow((1.0-v_h),5.);
return fresnel;
}
//#line 1097 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
float MipFromRoughness(float roughness, float CubemapMaxMip)
{
const float REFLECTION_CAPTURE_ROUGHEST_MIP=6.0-1.0;
float LevelFrom1x1=REFLECTION_CAPTURE_ROUGHEST_MIP-1.2*log2(roughness);
return (log2(roughness*1.2)+3.0);
}
//#line 1138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
SurfaceState PreprocessSurface(vec3 viewDir, SurfaceProperties surfaceProperties)
{
SurfaceState surfaceState;
vec3 Fdielectric=vec3(0.04,0.04,0.04);
vec3 F0=mix(Fdielectric,surfaceProperties.albedo,surfaceProperties.metallic);
float cosLo=saturate(dot(surfaceProperties.normal,-viewDir));
surfaceState.F=FresnelTerm(F0,cosLo);
surfaceState.kS=surfaceState.F;
surfaceState.kD=mix(vec3(1.0,1.0,1.0)-surfaceState.kS,vec3(0.0,0.0,0.0),surfaceProperties.metallic);
surfaceState.refl=reflect(normalize(viewDir),normalize(surfaceProperties.normal));
surfaceState.n_v=saturate(dot(surfaceProperties.normal,viewDir));
return surfaceState;
}
//#line 1155 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec3 PBRAmbient(SurfaceState surfaceState, vec3 viewDir, SurfaceProperties surfaceProperties)
{
float roughness_mip=MipFromRoughness(surfaceProperties.roughness,max_roughness_mip);
vec3 diffuse_env=textureLod(samplerCube(diffuseCubemap[1 + 4]),surfaceProperties.normal.xyz,0.0).rgb;
vec3 env=textureLod(samplerCube(specularCubemap[1 + 4]),surfaceState.refl.xyz,roughness_mip).rgb;
vec3 envSpecularColour=EnvBRDFApprox(surfaceProperties.albedo,surfaceProperties.roughness2,surfaceState.n_v);
vec3 specular=surfaceState.kS*envSpecularColour*env;
vec3 diffuse=surfaceProperties.albedo*surfaceState.kD*diffuse_env;
diffuse*=surfaceProperties.ao;
vec3 colour=diffuse+specular;
return .2*colour;
}
//#line 1173 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec3 PBRAddLight(SurfaceState surfaceState, vec3 viewDir, SurfaceProperties surfaceProperties, Light light, vec2 screenPos)
{
vec3 diff=light.position-surfaceProperties.position;
float dist_to_light=length(diff);
float d=max(1.0,dist_to_light/light.radius);
vec3 irradiance=light.colour.xyz*mix(1.0,1.0/(d*d),light.is_point);
vec3 dir_from_surface_to_light=mix(-light.direction,normalize(diff),light.is_point);
float roughnessL=max(.01,surfaceProperties.roughness2);
float n_l=saturate(dot(surfaceProperties.normal,dir_from_surface_to_light));
vec3 halfway=normalize(viewDir+dir_from_surface_to_light);
vec3 refl=reflect(viewDir,surfaceProperties.normal);
float n_h=saturate(dot(refl,dir_from_surface_to_light));
float lightD=DistributionTerm(roughnessL,n_h);
float lightV=VisibilityTerm(roughnessL,surfaceState.n_v,n_l);
vec3 diffuse=surfaceState.kD*irradiance*surfaceProperties.albedo*saturate(n_l);
vec3 specular=irradiance*surfaceState.F*(lightD*lightV*3.1415926536);
specular*=surfaceState.kS*saturate(pow(surfaceState.n_v+surfaceProperties.ao,surfaceProperties.roughness2)-1.0+surfaceProperties.ao);
vec3 colour=surfaceProperties.albedo*(diffuse+specular);
float shadow=mix(texture(sampler2D(screenspaceShadowTexture[1 + 9]),screenPos).x,1.0,light.is_point);
return colour*shadow;
}
//#line 1198 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec4 Solid(vertexOutput IN)
{
vec2 screenPos=IN.clip_pos.xy/IN.clip_pos.w*vec2(0.5,-0.5)+vec2(0.5,0.5);
vec3 tangentx=normalize(IN.tangent);
vec3 tangenty=normalize(cross(IN.normal,tangentx));
mat3 TangentMatrix=transpose(mat3(tangentx,tangenty,normalize(IN.normal)));
vec3 normalLookup=textureLod(sampler2D(normalTexture[1 + 6]),IN.texCoords0.xy*normalTexCoordsScalar_R,0).xyz;
normalLookup=2.0*(normalLookup.rgb-vec3(0.5,0.5,0.5));
vec3 normal=normalize(mul(TangentMatrix,normalLookup));
vec3 diffuseColour=texture(sampler2D(diffuseTexture[1 + 6]),IN.texCoords0.xy*diffuseTexCoordsScalar_R).rgb;
diffuseColour=diffuseColour.rgb*diffuseOutputScalar.rgb;
vec3 view=normalize(IN.wpos.xyz-viewPosition);
float metal=texture(sampler2D(metalTexture[1 + 6]),IN.texCoords0.xy*combinedTexCoordsScalar_R).r;
float ao=texture(sampler2D(ambientOcclusionTexture[1 + 6]),IN.texCoords0.xy*combinedTexCoordsScalar_R).r;
vec4 combinedLookup=vec4(1.0,metal,ao,1.0);
vec4 roughMetalOcclusion;
roughMetalOcclusion.rgb=combinedOutputScalarRoughMetalOcclusion.rgb*combinedLookup.rgb;
roughMetalOcclusion.a=(1.0-combinedOutputScalarRoughMetalOcclusion.r)*combinedLookup.a;
SurfaceProperties surfaceProperties;
surfaceProperties.position=IN.wpos;
surfaceProperties.roughness=mix(roughMetalOcclusion.r,1.0-roughMetalOcclusion.a,combinedOutputScalarRoughMetalOcclusion.a);
surfaceProperties.metallic=GetMetallic(roughMetalOcclusion);
surfaceProperties.ao=GetAO(roughMetalOcclusion);
surfaceProperties.normal=normal;
surfaceProperties.albedo=diffuseColour;
surfaceProperties.roughness2=surfaceProperties.roughness*surfaceProperties.roughness;
SurfaceState surfaceState=PreprocessSurface(view,surfaceProperties);
vec3 c=.3*PBRAmbient(surfaceState,view,surfaceProperties);
for(int i=0;i<10;i++)
{
if(i>=lightCount)break;
Light light=lights[i];
c+=PBRAddLight(surfaceState,view,surfaceProperties,light,screenPos);
}

vec3 emissive=texture(sampler2D(emissiveTexture[1 + 6]),IN.texCoords0.xy*emissiveTexCoordsScalar_R).rgb;
emissive*=emissiveOutputScalar.rgb;
vec4 u=vec4(c.rgb+emissive.rgb,1.0);
return u;
}
layout(location = 0) in Block
{
vertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
vertexOutput BlockData=ioblock.BlockData;
//#line 1262 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
{returnObject_vec4=Solid(BlockData);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/solid_PS_Transparent.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
layout(std140, binding = 12) uniform SceneConstants
{
	vec4 depthToLinFadeDistParams;
	vec4 fullResToLowResTransformXYWH;
	int lightCount;
	int reverseDepth;
	float max_roughness_mip;
	int padxxx;
};
layout(std140, binding = 1) uniform CameraConstants
{
	mat4 worldViewProj;
	mat4 world;
	mat4 invWorldViewProj;
	mat4 modelView;
	mat4 view;
	mat4 proj;
	mat4 viewProj;
	vec3 viewPosition;
};
struct DepthInterpretationStruct
{
	vec4 depthToLinFadeDistParams;
	bool reverseDepth;
};




struct vertexOutput
{
	vec4 hPosition;
	vec2 texCoords0;
	vec2 texCoords1;
	vec3 normal;
	vec3 tangent;
	vec3 wpos;
	vec3 view;
	vec4 clip_pos;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t nearFarTextureCube[24];
	uint64_t loss2dTexture[24];
	uint64_t shadowTexture[24];
	uint64_t inscatterVolumeTexture[24];
};
//#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
//#line 23 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
//#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
//#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
//#line 779 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
float depthToLinearDistance(float depth, DepthInterpretationStruct dis)
{
if(dis.reverseDepth)
{
if(depth<=0)return 1.0;
}
else

{
if(depth>=1.0)return 1.0;
}

float linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.x/(depth*dis.depthToLinFadeDistParams.y+dis.depthToLinFadeDistParams.z)+dis.depthToLinFadeDistParams.w*depth);
return linearFadeDistanceZ;
}
//#line 795 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec4 depthToLinearDistance(vec4 depth, DepthInterpretationStruct dis)
{
vec4 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xxxx/(depth*dis.depthToLinFadeDistParams.yyyy+dis.depthToLinFadeDistParams.zzzz)+dis.depthToLinFadeDistParams.wwww*depth);
if(dis.reverseDepth)
{
vec4 st=step(depth,vec4(0.0,0.0,0.0,0.0));
linearFadeDistanceZ*=(vec4(1.0,1.0,1.0,1.0)-st);
linearFadeDistanceZ+=st;
}
else

{
linearFadeDistanceZ=min(vec4(1.0,1.0,1.0,1.0),linearFadeDistanceZ);
}

return linearFadeDistanceZ;
}
//#line 812 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec2 depthToLinearDistance(vec2 depth, DepthInterpretationStruct dis)
{
vec2 linearFadeDistanceZ=saturate(dis.depthToLinFadeDistParams.xx/(depth*dis.depthToLinFadeDistParams.yy+dis.depthToLinFadeDistParams.zz)+dis.depthToLinFadeDistParams.ww*depth);
if(dis.reverseDepth)
{
linearFadeDistanceZ.x=max(linearFadeDistanceZ.x,step(0.0,-depth.x));
linearFadeDistanceZ.y=max(linearFadeDistanceZ.y,step(0.0,-depth.y));
}
else

{
linearFadeDistanceZ.x=max(linearFadeDistanceZ.x,step(1.0,depth.x));
linearFadeDistanceZ.y=max(linearFadeDistanceZ.y,step(1.0,depth.y));
}

return linearFadeDistanceZ;
}
//#line 1317 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
void AtmosphericsAndCloudOcclusion(out vec4 loss, out vec3 add, vec4 clip_pos, vec3 view, uint64_t nearFarTextureCube[24], uint64_t loss2dTexture[24], uint64_t shadowTexture[24], uint64_t inscatterVolumeTexture[24], vec4 depthToLinFadeDistParams)
{
clip_pos/=clip_pos.w;
float sine=normalize(view).z;
vec2 texCoords=0.5*vec2(clip_pos.x+1.0,1.0-clip_pos.y);
vec4 nearFarCloud=textureLod(samplerCube(nearFarTextureCube[1 + 6]),view,0);
DepthInterpretationStruct depthInterpretationStruct;
depthInterpretationStruct.depthToLinFadeDistParams=depthToLinFadeDistParams;
depthInterpretationStruct.reverseDepth=(reverseDepth!=0);
float dist=depthToLinearDistance(clip_pos.z,depthInterpretationStruct);
float dist_rt=pow(dist,0.5);
vec3 worldspaceVolumeTexCoords=vec3(atan(view.x,view.y)/(2.0*3.1415926536),0.5*(1.0+2.0*asin(sine)/3.1415926536),dist_rt);
vec4 insc=textureLod(sampler3D(inscatterVolumeTexture[1 + 2]),worldspaceVolumeTexCoords,0);
vec2 loss_texc=vec2(dist_rt,0.5*(1.f-sine));
float visibility=1.0-saturate((dist-nearFarCloud.w)/0.001);
insc.rgb*=visibility;
loss=vec4(textureLod(sampler2D(loss2dTexture[1 + 9]),loss_texc,0).rgb,visibility);
add=insc.rgb;
}
layout(location = 0) in Block
{
vertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
vertexOutput BlockData=ioblock.BlockData;
//#line 1358 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec3 normal=normalize(BlockData.normal);
vec4 c=vec4(0.5,0.5,0.5,0.5);
vec4 loss;
vec3 add;
AtmosphericsAndCloudOcclusion(loss,add,BlockData.clip_pos,BlockData.view,nearFarTextureCube,loss2dTexture,shadowTexture,inscatterVolumeTexture,depthToLinFadeDistParams);
c.rgba*=loss.rgba;
c.rgb+=add;
{returnObject_vec4=c;}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/solid_VS_Solid_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
layout(std140, binding = 1) uniform CameraConstants
{
	mat4 worldViewProj;
	mat4 world;
	mat4 invWorldViewProj;
	mat4 modelView;
	mat4 view;
	mat4 proj;
	mat4 viewProj;
	vec3 viewPosition;
};
struct vertexInput
{
	vec3 position;
	vec3 normal;
	vec4 tangent;
	vec2 texCoords;
	vec2 texCoords1;
};
struct vertexOutput
{
	vec4 hPosition;
	vec2 texCoords0;
	vec2 texCoords1;
	vec3 normal;
	vec3 tangent;
	vec3 wpos;
	vec3 view;
	vec4 clip_pos;
};
//#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
//#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
//#line 29 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
//#line 31 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
//#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
//#line 33 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
layout(location=0) in vec3 position;
layout(location=1) in vec3 normal;
layout(location=2) in vec4 tangent;
layout(location=3) in vec2 texCoords;
layout(location=4) in vec2 texCoords1;

layout(location = 0) out Block
{
vertexOutput BlockData;
} ioblock;
void main()
{
vertexInput IN;
IN.position=position;
IN.normal=normal;
IN.tangent=tangent;
IN.texCoords=texCoords;
IN.texCoords1=texCoords1;
//#line 1043 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vertexOutput OUT;
vec4 opos=vec4(IN.position.xyz,1.0);
vec4 wpos=mul(opos,world);
OUT.view=normalize(wpos.xyz-viewPosition);
vec4 viewspace_pos=mul(view,vec4(wpos.xyz,1.0));
OUT.clip_pos=mul(proj,vec4(viewspace_pos.xyz,1.0));
OUT.wpos=wpos.xyz;
OUT.texCoords0=IN.texCoords;
OUT.texCoords1=IN.texCoords;
OUT.normal.xyz=mul(IN.normal,mat3(world));
OUT.tangent.xyz=mul(IN.tangent.xyz,mat3(world));
OUT.hPosition=OUT.clip_pos;
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/solid_VS_Solid_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
layout(std140, binding = 1) uniform CameraConstants
{
	mat4 worldViewProj;
	mat4 world;
	mat4 invWorldViewProj;
	mat4 modelView;
	mat4 view;
	mat4 proj;
	mat4 viewProj;
	vec3 viewPosition;
};
struct vertexInput
{
	vec3 position;
	vec3 normal;
	vec4 tangent;
	vec2 texCoords;
	vec2 texCoords1;
};
struct vertexOutput
{
	vec4 hPosition;
	vec2 texCoords0;
	vec2 texCoords1;
	vec3 normal;
	vec3 tangent;
	vec3 wpos;
	vec3 view;
	vec4 clip_pos;
};
//#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
//#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
//#line 29 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
//#line 31 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
//#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
//#line 33 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
layout(location=0) in vec3 position;
layout(location=1) in vec3 normal;
layout(location=2) in vec4 tangent;
layout(location=3) in vec2 texCoords;
layout(location=4) in vec2 texCoords1;

layout(location = 0) out Block
{
vertexOutput BlockData;
} ioblock;
void main()
{
vertexInput IN;
IN.position=position;
IN.normal=normal;
IN.tangent=tangent;
IN.texCoords=texCoords;
IN.texCoords1=texCoords1;
//#line 1043 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vertexOutput OUT;
vec4 opos=vec4(IN.position.xyz,1.0);
vec4 wpos=mul(opos,world);
OUT.view=normalize(wpos.xyz-viewPosition);
vec4 viewspace_pos=mul(view,vec4(wpos.xyz,1.0));
OUT.clip_pos=mul(proj,vec4(viewspace_pos.xyz,1.0));
OUT.wpos=wpos.xyz;
OUT.texCoords0=IN.texCoords;
OUT.texCoords1=IN.texCoords;
OUT.normal.xyz=mul(IN.normal,mat3(world));
OUT.tangent.xyz=mul(IN.tangent.xyz,mat3(world));
OUT.hPosition=OUT.clip_pos;
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/solid_PS_Solid.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
layout(std140, binding = 12) uniform SceneConstants
{
	vec4 depthToLinFadeDistParams;
	vec4 fullResToLowResTransformXYWH;
	int lightCount;
	int reverseDepth;
	float max_roughness_mip;
	int padxxx;
};
layout(std140, binding = 13) uniform SolidConstants
{
	vec4 diffuseOutputScalar;
	vec2 diffuseTexCoordsScalar_R;
	vec2 diffuseTexCoordsScalar_G;
	vec2 diffuseTexCoordsScalar_B;
	vec2 diffuseTexCoordsScalar_A;
	vec4 normalOutputScalar;
	vec2 normalTexCoordsScalar_R;
	vec2 normalTexCoordsScalar_G;
	vec2 normalTexCoordsScalar_B;
	vec2 normalTexCoordsScalar_A;
	vec4 combinedOutputScalarRoughMetalOcclusion;
	vec2 combinedTexCoordsScalar_R;
	vec2 combinedTexCoordsScalar_G;
	vec2 combinedTexCoordsScalar_B;
	vec2 combinedTexCoordsScalar_A;
	vec4 emissiveOutputScalar;
	vec2 emissiveTexCoordsScalar_R;
	vec2 emissiveTexCoordsScalar_G;
	vec2 emissiveTexCoordsScalar_B;
	vec2 emissiveTexCoordsScalar_A;
	vec3 u_SpecularColour;
	float _pad;
	float u_DiffuseTexCoordIndex;
	float u_NormalTexCoordIndex;
	float u_CombinedTexCoordIndex;
	float u_EmissiveTexCoordIndex;
};
struct Light
{
	mat4 lightSpaceTransform;
	vec4 colour;
	vec3 position;
	float power;
	vec3 direction;
	float is_point;
	float is_spot;
	float radius;
	vec2 pad_light1;
};
layout(std140, binding = 1) uniform CameraConstants
{
	mat4 worldViewProj;
	mat4 world;
	mat4 invWorldViewProj;
	mat4 modelView;
	mat4 view;
	mat4 proj;
	mat4 viewProj;
	vec3 viewPosition;
};








layout(std430, binding = 12) buffer lights_ssbo
{
	Light lights[]; 
};
struct vertexOutput
{
	vec4 hPosition;
	vec2 texCoords0;
	vec2 texCoords1;
	vec3 normal;
	vec3 tangent;
	vec3 wpos;
	vec3 view;
	vec4 clip_pos;
};
struct SurfaceState
{
	vec3 F;
	vec3 kS;
	vec3 kD;
	vec3 refl;
	float n_v;
};
struct SurfaceProperties
{
	vec3 albedo;
	vec3 normal;
	vec3 emission;
	vec3 position;
	float roughness;
	float roughness2;
	float metallic;
	float ao;
	float specular;
	float gloss;
	float alpha;
};
layout(std140, binding = 0) uniform _TextureHandles_c
{
	uint64_t diffuseTexture[24];
	uint64_t normalTexture[24];
	uint64_t metalTexture[24];
	uint64_t ambientOcclusionTexture[24];
	uint64_t emissiveTexture[24];
	uint64_t diffuseCubemap[24];
	uint64_t specularCubemap[24];
	uint64_t screenspaceShadowTexture[24];
};
//#line 22 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
float saturate(float value)
{
return clamp(value,0.0,1.0);
}
//#line 23 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec2 saturate(vec2 vvalue)
{
return clamp(vvalue,vec2(0.0,0.0),vec2(1.0,1.0));
}
//#line 24 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec3 saturate(vec3 vvalue)
{
return clamp(vvalue,vec3(0.0,0.0,0.0),vec3(1.0,1.0,1.0));
}
//#line 25 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec4 saturate(vec4 vvalue)
{
return clamp(vvalue,vec4(0.0,0.0,0.0,0.0),vec4(1.0,1.0,1.0,1.0));
}
//#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
//#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
//#line 29 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
//#line 31 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
//#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
//#line 33 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
//#line 983 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
float GetMetallic(vec4 combinedLookup)
{
return combinedLookup.g;
}
//#line 988 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
float GetAO(vec4 combinedLookup)
{
return combinedLookup.b;
}
//#line 1062 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec3 EnvBRDFApprox(vec3 specularColour, float roughness, float n_v)
{
const vec4 c0=vec4(-1,-0.0275,-0.572,0.022);
const vec4 c1=vec4(1,0.0425,1.04,-0.04);
vec4 r=roughness*c0+c1;
float a004=min(r.x*r.x,exp2(-9.28*n_v))*r.x+r.y;
vec2 AB=vec2(-1.04,1.04)*a004+r.zw;
return specularColour*AB.x+AB.y;
}
//#line 1072 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
float VisibilityTerm(float m2, float n_v, float n_l)
{
float visV=n_l*sqrt(n_v*(n_v-n_v*m2)+m2);
float visL=n_v*sqrt(n_l*(n_l-n_l*m2)+m2);
return saturate(0.5/max(visV+visL,0.00001));
}
//#line 1079 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
float DistributionTerm(float m2, float n_h)
{
float d=(n_h*m2-n_h)*n_h+1.0;
return n_h;
}
//#line 1091 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec3 FresnelTerm(vec3 specularColour, float v_h)
{
vec3 fresnel=specularColour+(vec3(1.0,1.0,1.0)-specularColour)*pow((1.0-v_h),5.);
return fresnel;
}
//#line 1097 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
float MipFromRoughness(float roughness, float CubemapMaxMip)
{
const float REFLECTION_CAPTURE_ROUGHEST_MIP=6.0-1.0;
float LevelFrom1x1=REFLECTION_CAPTURE_ROUGHEST_MIP-1.2*log2(roughness);
return (log2(roughness*1.2)+3.0);
}
//#line 1138 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
SurfaceState PreprocessSurface(vec3 viewDir, SurfaceProperties surfaceProperties)
{
SurfaceState surfaceState;
vec3 Fdielectric=vec3(0.04,0.04,0.04);
vec3 F0=mix(Fdielectric,surfaceProperties.albedo,surfaceProperties.metallic);
float cosLo=saturate(dot(surfaceProperties.normal,-viewDir));
surfaceState.F=FresnelTerm(F0,cosLo);
surfaceState.kS=surfaceState.F;
surfaceState.kD=mix(vec3(1.0,1.0,1.0)-surfaceState.kS,vec3(0.0,0.0,0.0),surfaceProperties.metallic);
surfaceState.refl=reflect(normalize(viewDir),normalize(surfaceProperties.normal));
surfaceState.n_v=saturate(dot(surfaceProperties.normal,viewDir));
return surfaceState;
}
//#line 1155 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec3 PBRAmbient(SurfaceState surfaceState, vec3 viewDir, SurfaceProperties surfaceProperties)
{
float roughness_mip=MipFromRoughness(surfaceProperties.roughness,max_roughness_mip);
vec3 diffuse_env=textureLod(samplerCube(diffuseCubemap[1 + 4]),surfaceProperties.normal.xyz,0.0).rgb;
vec3 env=textureLod(samplerCube(specularCubemap[1 + 4]),surfaceState.refl.xyz,roughness_mip).rgb;
vec3 envSpecularColour=EnvBRDFApprox(surfaceProperties.albedo,surfaceProperties.roughness2,surfaceState.n_v);
vec3 specular=surfaceState.kS*envSpecularColour*env;
vec3 diffuse=surfaceProperties.albedo*surfaceState.kD*diffuse_env;
diffuse*=surfaceProperties.ao;
vec3 colour=diffuse+specular;
return .2*colour;
}
//#line 1173 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec3 PBRAddLight(SurfaceState surfaceState, vec3 viewDir, SurfaceProperties surfaceProperties, Light light, vec2 screenPos)
{
vec3 diff=light.position-surfaceProperties.position;
float dist_to_light=length(diff);
float d=max(1.0,dist_to_light/light.radius);
vec3 irradiance=light.colour.xyz*mix(1.0,1.0/(d*d),light.is_point);
vec3 dir_from_surface_to_light=mix(-light.direction,normalize(diff),light.is_point);
float roughnessL=max(.01,surfaceProperties.roughness2);
float n_l=saturate(dot(surfaceProperties.normal,dir_from_surface_to_light));
vec3 halfway=normalize(viewDir+dir_from_surface_to_light);
vec3 refl=reflect(viewDir,surfaceProperties.normal);
float n_h=saturate(dot(refl,dir_from_surface_to_light));
float lightD=DistributionTerm(roughnessL,n_h);
float lightV=VisibilityTerm(roughnessL,surfaceState.n_v,n_l);
vec3 diffuse=surfaceState.kD*irradiance*surfaceProperties.albedo*saturate(n_l);
vec3 specular=irradiance*surfaceState.F*(lightD*lightV*3.1415926536);
specular*=surfaceState.kS*saturate(pow(surfaceState.n_v+surfaceProperties.ao,surfaceProperties.roughness2)-1.0+surfaceProperties.ao);
vec3 colour=surfaceProperties.albedo*(diffuse+specular);
float shadow=mix(texture(sampler2D(screenspaceShadowTexture[1 + 9]),screenPos).x,1.0,light.is_point);
return colour*shadow;
}
//#line 1198 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec4 Solid(vertexOutput IN)
{
vec2 screenPos=IN.clip_pos.xy/IN.clip_pos.w*vec2(0.5,-0.5)+vec2(0.5,0.5);
vec3 tangentx=normalize(IN.tangent);
vec3 tangenty=normalize(cross(IN.normal,tangentx));
mat3 TangentMatrix=transpose(mat3(tangentx,tangenty,normalize(IN.normal)));
vec3 normalLookup=textureLod(sampler2D(normalTexture[1 + 6]),IN.texCoords0.xy*normalTexCoordsScalar_R,0).xyz;
normalLookup=2.0*(normalLookup.rgb-vec3(0.5,0.5,0.5));
vec3 normal=normalize(mul(TangentMatrix,normalLookup));
vec3 diffuseColour=texture(sampler2D(diffuseTexture[1 + 6]),IN.texCoords0.xy*diffuseTexCoordsScalar_R).rgb;
diffuseColour=diffuseColour.rgb*diffuseOutputScalar.rgb;
vec3 view=normalize(IN.wpos.xyz-viewPosition);
float metal=texture(sampler2D(metalTexture[1 + 6]),IN.texCoords0.xy*combinedTexCoordsScalar_R).r;
float ao=texture(sampler2D(ambientOcclusionTexture[1 + 6]),IN.texCoords0.xy*combinedTexCoordsScalar_R).r;
vec4 combinedLookup=vec4(1.0,metal,ao,1.0);
vec4 roughMetalOcclusion;
roughMetalOcclusion.rgb=combinedOutputScalarRoughMetalOcclusion.rgb*combinedLookup.rgb;
roughMetalOcclusion.a=(1.0-combinedOutputScalarRoughMetalOcclusion.r)*combinedLookup.a;
SurfaceProperties surfaceProperties;
surfaceProperties.position=IN.wpos;
surfaceProperties.roughness=mix(roughMetalOcclusion.r,1.0-roughMetalOcclusion.a,combinedOutputScalarRoughMetalOcclusion.a);
surfaceProperties.metallic=GetMetallic(roughMetalOcclusion);
surfaceProperties.ao=GetAO(roughMetalOcclusion);
surfaceProperties.normal=normal;
surfaceProperties.albedo=diffuseColour;
surfaceProperties.roughness2=surfaceProperties.roughness*surfaceProperties.roughness;
SurfaceState surfaceState=PreprocessSurface(view,surfaceProperties);
vec3 c=.3*PBRAmbient(surfaceState,view,surfaceProperties);
for(int i=0;i<10;i++)
{
if(i>=lightCount)break;
Light light=lights[i];
c+=PBRAddLight(surfaceState,view,surfaceProperties,light,screenPos);
}

vec3 emissive=texture(sampler2D(emissiveTexture[1 + 6]),IN.texCoords0.xy*emissiveTexCoordsScalar_R).rgb;
emissive*=emissiveOutputScalar.rgb;
vec4 u=vec4(c.rgb+emissive.rgb,1.0);
return u;
}
layout(location = 0) in Block
{
vertexOutput BlockData;
} ioblock;
layout(location = 0) out vec4 returnObject_vec4;

void main()
{
vertexOutput BlockData=ioblock.BlockData;
//#line 1262 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
{returnObject_vec4=Solid(BlockData);}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/solid_VS_Solid_vv.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
layout(std140, binding = 1) uniform CameraConstants
{
	mat4 worldViewProj;
	mat4 world;
	mat4 invWorldViewProj;
	mat4 modelView;
	mat4 view;
	mat4 proj;
	mat4 viewProj;
	vec3 viewPosition;
};
struct vertexInput
{
	vec3 position;
	vec3 normal;
	vec4 tangent;
	vec2 texCoords;
	vec2 texCoords1;
};
struct vertexOutput
{
	vec4 hPosition;
	vec2 texCoords0;
	vec2 texCoords1;
	vec3 normal;
	vec3 tangent;
	vec3 wpos;
	vec3 view;
	vec4 clip_pos;
};
//#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
//#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
//#line 29 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
//#line 31 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
//#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
//#line 33 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
layout(location=0) in vec3 position;
layout(location=1) in vec3 normal;
layout(location=2) in vec4 tangent;
layout(location=3) in vec2 texCoords;
layout(location=4) in vec2 texCoords1;

layout(location = 0) out Block
{
vertexOutput BlockData;
} ioblock;
void main()
{
vertexInput IN;
IN.position=position;
IN.normal=normal;
IN.tangent=tangent;
IN.texCoords=texCoords;
IN.texCoords1=texCoords1;
//#line 1043 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vertexOutput OUT;
vec4 opos=vec4(IN.position.xyz,1.0);
vec4 wpos=mul(opos,world);
OUT.view=normalize(wpos.xyz-viewPosition);
vec4 viewspace_pos=mul(view,vec4(wpos.xyz,1.0));
OUT.clip_pos=mul(proj,vec4(viewspace_pos.xyz,1.0));
OUT.wpos=wpos.xyz;
OUT.texCoords0=IN.texCoords;
OUT.texCoords1=IN.texCoords;
OUT.normal.xyz=mul(IN.normal,mat3(world));
OUT.tangent.xyz=mul(IN.tangent.xyz,mat3(world));
OUT.hPosition=OUT.clip_pos;
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}#version 450
#extension GL_ARB_gpu_shader5 : enable
#extension GL_ARB_bindless_texture : enable

//#line 6 "D:/Jarvis/workspace/Simul/4.3/Simul/build/Platform/OpenGL/../OpenGL/sfx_intermediate/solid_VS_Solid_ve.glsl"
#define GLSL 1
#define SFX 1
#define SFX_GLSL 1
#define SFX_OPENGL 1
#define SFX_TYPED_UAV_LOADS 1
#define uint64_t uvec2
#pragma warning(disable:1)
layout(std140, binding = 1) uniform CameraConstants
{
	mat4 worldViewProj;
	mat4 world;
	mat4 invWorldViewProj;
	mat4 modelView;
	mat4 view;
	mat4 proj;
	mat4 viewProj;
	vec3 viewPosition;
};
struct vertexInput
{
	vec3 position;
	vec3 normal;
	vec4 tangent;
	vec2 texCoords;
	vec2 texCoords1;
};
struct vertexOutput
{
	vec4 hPosition;
	vec2 texCoords0;
	vec2 texCoords1;
	vec3 normal;
	vec3 tangent;
	vec3 wpos;
	vec3 view;
	vec4 clip_pos;
};
//#line 27 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec4 mul(mat4 mat, vec4 vec)
{
return mat*vec;
}
//#line 28 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec3 mul(mat3 mat, vec3 vec)
{
return mat*vec;
}
//#line 29 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec2 mul(mat2 mat, vec2 vec)
{
return mat*vec;
}
//#line 31 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec4 mul(vec4 vec, mat4 mat)
{
return vec*mat;
}
//#line 32 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec3 mul(vec3 vec, mat3 mat)
{
return vec*mat;
}
//#line 33 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vec2 mul(vec2 vec, mat2 mat)
{
return vec*mat;
}
layout(location=0) in vec3 position;
layout(location=1) in vec3 normal;
layout(location=2) in vec4 tangent;
layout(location=3) in vec2 texCoords;
layout(location=4) in vec2 texCoords1;

layout(location = 0) out Block
{
vertexOutput BlockData;
} ioblock;
void main()
{
vertexInput IN;
IN.position=position;
IN.normal=normal;
IN.tangent=tangent;
IN.texCoords=texCoords;
IN.texCoords1=texCoords1;
//#line 1043 "D:/Jarvis/workspace/Simul/4.3/Simul/Platform/Shaders/Sfx/solid.sfx"
vertexOutput OUT;
vec4 opos=vec4(IN.position.xyz,1.0);
vec4 wpos=mul(opos,world);
OUT.view=normalize(wpos.xyz-viewPosition);
vec4 viewspace_pos=mul(view,vec4(wpos.xyz,1.0));
OUT.clip_pos=mul(proj,vec4(viewspace_pos.xyz,1.0));
OUT.wpos=wpos.xyz;
OUT.texCoords0=IN.texCoords;
OUT.texCoords1=IN.texCoords;
OUT.normal.xyz=mul(IN.normal,mat3(world));
OUT.tangent.xyz=mul(IN.tangent.xyz,mat3(world));
OUT.hPosition=OUT.clip_pos;
{
ioblock.BlockData=OUT;
gl_Position=OUT.hPosition;
}
}